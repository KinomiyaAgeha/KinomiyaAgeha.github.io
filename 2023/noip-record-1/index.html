<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><link rel="icon" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#1749d1"><meta name="author" content="yozora0908"><meta name="keywords" content="OI"><meta name="description" content="树上差分 从抽象代数的角度讲，树上差分可以维护所有群上信息。 换句话说，满足结合律，存在「可减性」。  通过差分我们能将一个高纬问题以常数代价转化为低维问题，而问题低一维往往会简单非常多 —— lxl  太 \(\textit{Trivial}\) 的我们就不提了。 下文成「前缀」为根到节点的路径。 luogu8201 [yLOI2021] 生活在树上（hard versio"><title>「NOIP Record」#20 树论（1）树上差分与树上倍增 - yozora0908&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"yozora0908.github.io",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"always",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#0076FF",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:null,onlypost:!0,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!1,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="yozora0908's blog" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>yozora0908&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn-us.imgs.moe/2023/02/02/63db75d1e0be8.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="「NOIP Record」#20 树论（1）树上差分与树上倍增"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-09-07 06:30" pubdate>2023年9月7日 早上</time></span></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">「NOIP Record」#20 树论（1）树上差分与树上倍增</h1><div class="markdown-body"><h2 id="树上差分">树上差分</h2><p>从抽象代数的角度讲，树上差分可以维护所有群上信息。</p><p>换句话说，满足结合律，存在「可减性」。</p><blockquote><p>通过差分我们能将一个高纬问题以常数代价转化为低维问题，而问题低一维往往会简单非常多</p><p>—— lxl</p></blockquote><p>太 <span class="math inline">\(\textit{Trivial}\)</span> 的我们就不提了。</p><p>下文成「前缀」为根到节点的路径。</p><h3 id="luogu8201-yloi2021-生活在树上hard-version">luogu8201 [yLOI2021] 生活在树上（hard version）</h3><p>考虑这样一个结论。</p><blockquote><p>树上路径 <span class="math inline">\((t,x)\)</span> 与 <span class="math inline">\((t,y)\)</span>，一定是先有一段重合的路径，再与路径 <span class="math inline">\((x,y)\)</span> 交于一点 <span class="math inline">\(z\)</span>，然后分别连向对应的点。</p></blockquote><p>这个有什么用呢？我们可以把 <span class="math inline">\(\text{dis}_{t,a} \oplus \text{dis}_{t,b} = k\)</span> 转化为 <span class="math inline">\(\text{dis}_{a,b} \oplus w_z = k\)</span>， 其中 <span class="math inline">\(z\)</span> 是 <span class="math inline">\(t\)</span> 与路径 <span class="math inline">\((a,b)\)</span> 的交点。</p><p>更进一步地，询问 <span class="math inline">\((a,b,k)\)</span> 等价于查询路径 <span class="math inline">\((a,b)\)</span> 上是否存在点 <span class="math inline">\(z\)</span>，满足 <span class="math inline">\(w_z = k \oplus \text{dis}_{a,b}\)</span>。</p><p>设 <span class="math inline">\(h(x,k)\)</span> 为根到 <span class="math inline">\(x\)</span> 的路径上，点权为 <span class="math inline">\(k\)</span> 的点的个数，<span class="math inline">\(c=\operatorname{LCA}(a,b)\)</span>。</p><p>我们把询问拆成前缀，放到 <span class="math inline">\(a,b,c,fa(c)\)</span> 上，在对应点处打上 <span class="math inline">\(k \oplus \text{dis}_{a,b}\)</span> 的标记。开一个全局桶，一个点的贡献只会在其子树中产生，访问时加入，回溯时撤销即可。然后开个<code>std::unordered_map</code>数组统计在 <span class="math inline">\(x\)</span> 处统计所有标记对应的值，就能在 <span class="math inline">\(O(n)-O(1)\)</span> 的复杂度内解决问题。</p><blockquote><p>把对路径的询问差分成对前缀的询问。</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, w[N], d[N];
<span class="hljs-type">int</span> son[N], dep[N], sz[N], top[N], fa[N];
vector&lt;<span class="hljs-type">int</span>&gt; p[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;
	<span class="hljs-type">int</span> x, y, z, k;
&#125; q[N];
vector&lt;<span class="hljs-type">int</span>&gt; r[N];
unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp, ans[N];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;
	fa[x]=fr;
	dep[x]=dep[fr]+<span class="hljs-number">1</span>;
	sz[x]=<span class="hljs-number">1</span>;
	d[x]=d[fr]^w[x];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;
		<span class="hljs-built_in">dfs1</span>(y,x);
		<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;
		sz[x]+=sz[y];
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;
	top[x]=tp;
	<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;
	<span class="hljs-built_in">dfs2</span>(son[x],tp);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) &#123;
		<span class="hljs-built_in">dfs2</span>(y,y);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;
		<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);
		x=fa[top[x]];
	&#125;
	<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
	<span class="hljs-keyword">return</span> x;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
	++mp[w[x]];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:r[x]) ans[x][y]=mp[y];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;
		<span class="hljs-built_in">dfs3</span>(y);
	&#125;
	--mp[w[x]];
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);
	&#125;
	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
	<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>(), q[i].k=<span class="hljs-built_in">read</span>();
		q[i].z=<span class="hljs-built_in">lca</span>(q[i].x,q[i].y);
		q[i].k=q[i].k^d[q[i].x]^d[q[i].y]^w[q[i].z];
		<span class="hljs-type">int</span> x=q[i].x, y=q[i].y, z=q[i].z, k=q[i].k;
		r[x].<span class="hljs-built_in">pb</span>(k), r[y].<span class="hljs-built_in">pb</span>(k);
		r[z].<span class="hljs-built_in">pb</span>(k), r[fa[z]].<span class="hljs-built_in">pb</span>(k);
	&#125;
	<span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>);
	
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;
		<span class="hljs-type">int</span> x=q[i].x, y=q[i].y, z=q[i].z, k=q[i].k;
		<span class="hljs-type">int</span> cnt=ans[x][k]+ans[y][k]-ans[z][k]-ans[fa[z]][k];
		<span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YeS&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;nO&quot;</span>);
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div><h3 id="luogu1600-noip2016-提高组-天天爱跑步">luogu1600 [NOIP2016 提高组] 天天爱跑步</h3><p><a href="https://yozora0908.github.io/2021/lg1600-solution">link</a></p><blockquote><p>把路径的贡献拆成前缀的贡献，维护子树和。</p></blockquote><h3 id="luogu2680-noip2015-提高组-运输计划">luogu2680 [NOIP2015 提高组] 运输计划</h3><p>首先答案是可以二分的。</p><p>问题转化为：判定是否能通过把一条边的权值置为 <span class="math inline">\(0\)</span>，使得给定的路径中，最长的路径不超过 <span class="math inline">\(mid\)</span>，</p><p>我们考虑所有长度超过 <span class="math inline">\(mid\)</span> 的路径，设其的数量为 <span class="math inline">\(cnt\)</span>。那么 <span class="math inline">\(mid\)</span> 可行当且仅当存在一条被经过 <span class="math inline">\(cnt\)</span> 次，并且其长度大于等于 <span class="math inline">\(\max_{i=1}^m \big\{dis(u_i,v_i) \big\} - mid\)</span>。</p><p>怎么做？把路径差分了再做子树和，求出每条边被覆盖的次数，检查一遍即可。</p><p>但是这题卡常，需要预处理出 <span class="math inline">\(\text{DFS}\)</span> 序再倒着做子树和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2680 [NOIP2015 提高组] 运输计划</span>
<span class="hljs-comment">// Contest: Luogu</span>
<span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2680</span>
<span class="hljs-comment">// Author: yozora0908</span>
<span class="hljs-comment">// Memory Limit: 292 MB</span>
<span class="hljs-comment">// Time Limit: 1000 ms</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Let&#x27;s Daze</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, c[N];
<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];
<span class="hljs-type">int</span> sz[N], fa[N], son[N], dep[N], d[N], top[N];
<span class="hljs-type">int</span> num, dfn[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;
	<span class="hljs-type">int</span> x, y, z, d;
&#125; a[N];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>  </span>&#123;
	to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;
	fa[x]=fr, dep[x]=dep[fr]+<span class="hljs-number">1</span>;
	dfn[++num]=x;
	sz[x]=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;
		<span class="hljs-type">int</span> y=to[i], z=w[i];
		<span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;
		d[y]=d[x]+z;
		<span class="hljs-built_in">dfs1</span>(y,x);
		<span class="hljs-keyword">if</span>(!son[x]||sz[y]&gt;sz[son[x]]) son[x]=y;
		sz[x]+=sz[y];
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;
	top[x]=tp;
	<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;
	<span class="hljs-built_in">dfs2</span>(son[x],tp);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;
		<span class="hljs-type">int</span> y=to[i];
		<span class="hljs-keyword">if</span>(y==fa[x]||y==son[x]) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs2</span>(y,y);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;
		<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);
		x=fa[top[x]];
	&#125;
	<span class="hljs-keyword">return</span> 	dep[x]&lt;dep[y]? x:y;
&#125;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
	<span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>, cnt=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) c[i]=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(a[i].d&gt;x) &#123;
		++c[a[i].x], ++c[a[i].y], c[a[i].z]-=<span class="hljs-number">2</span>;
		mx=<span class="hljs-built_in">max</span>(mx,a[i].d-x);
		++cnt;
	&#125;
	<span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) c[fa[dfn[i]]]+=c[dfn[i]];
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">if</span>(d[i]-d[fa[i]]&gt;=mx&amp;&amp;c[i]&gt;=cnt) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();
		<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);
	&#125;
	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
	<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);
	<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		a[i].x=<span class="hljs-built_in">read</span>(), a[i].y=<span class="hljs-built_in">read</span>();
		a[i].z=<span class="hljs-built_in">lca</span>(a[i].x,a[i].y);
		a[i].d=d[a[i].x]+d[a[i].y]<span class="hljs-number">-2</span>*d[a[i].z];
		R=<span class="hljs-built_in">max</span>(R,a[i].d);
	&#125;
	<span class="hljs-keyword">while</span>(L&lt;R) &#123;
		<span class="hljs-type">int</span> mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) R=mid; <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,L);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div><h3 id="luogu4219-bjoi2014-大融合">luogu4219 [BJOI2014] 大融合</h3><p>对于一个询问 <span class="math inline">\((x,y)\)</span>，答案就是两边连通块大小之积。</p><p>不过显然不能直接做。</p><p>考虑离线，把树定根后建起来。钦定 <span class="math inline">\(\text{dep}(x) \le \text{dep}(y)\)</span>，那么答案就是<strong>此时与 <span class="math inline">\(x\)</span> 连通的子树大小</strong>减去<strong>此时以 <span class="math inline">\(y\)</span> 为根且连通的子树大小</strong>，最后再乘上后者。注意这里的子树就是定根后原树中的。</p><p>这个怎么维护呢？用并查集维护连通块，每个连通块的根是原树种深度最低的那个点。如果连边 <span class="math inline">\((x,y)\)</span>，那么 <span class="math inline">\(y\)</span> 此时所在连通块一定都会贡献到 <span class="math inline">\(x\)</span> 以及其父亲的子树中去。</p><p>也就是说这是个链加，我们直接差分掉。问题转化为链加，单点求子树和，摊到 <span class="math inline">\(\text{DFS}\)</span> 序上即可用树状数组维护。在 <span class="math inline">\(x\)</span> 处产生贡献，同时在 <span class="math inline">\(x\)</span> 所在连通块的根<strong>在原树中的父亲处消去贡献</strong>，这样就能保证只会贡献到当前连通情况下的点上。</p><p>对于每个询问，与 <span class="math inline">\(x\)</span> 连通的子树大小就是此时 <span class="math inline">\(x\)</span> 所在连通块的大小，以 <span class="math inline">\(y\)</span> 为根且连通的子树大小就是 <span class="math inline">\(y\)</span> 的子树和再加上 <span class="math inline">\(1\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, Q, dep[N], tfa[N], tsz[N];
<span class="hljs-type">int</span> num, dfn[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span> &#123;
	<span class="hljs-type">int</span> op, x, y;
&#125; q[N];
vector&lt;<span class="hljs-type">int</span>&gt; p[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;
	<span class="hljs-type">int</span> c[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=y;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		
		<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res; 
		<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];
		<span class="hljs-keyword">return</span> res;
	&#125;
&#125; T, bit;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;
	dep[x]=dep[fr]+<span class="hljs-number">1</span>;
	tfa[x]=fr;
	dfn[x]=++num;
	tsz[x]=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;
		<span class="hljs-built_in">dfs</span>(y,x);
		tsz[x]+=tsz[y];
	&#125;
&#125;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	<span class="hljs-type">int</span> fa[N], sz[N], siz[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, siz[i]=<span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
		<span class="hljs-type">int</span> fx=<span class="hljs-built_in">get</span>(x), fy=<span class="hljs-built_in">get</span>(y);
		<span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;
		fa[y]=fx;
		siz[fx]+=siz[y];
		T.<span class="hljs-built_in">upd</span>(dfn[x],siz[y]);
		T.<span class="hljs-built_in">upd</span>(dfn[tfa[fx]],-siz[y]);
	&#125;
&#125; dsu;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);
&#125;
<span class="hljs-type">char</span> s[<span class="hljs-number">3</span>];
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);
		<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>) q[i].op=<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> q[i].op=<span class="hljs-number">2</span>;
		q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(q[i].x,q[i].y);
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);
	dsu.<span class="hljs-built_in">init</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;
		<span class="hljs-type">int</span> x=q[i].x, y=q[i].y;
		<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;
			dsu.<span class="hljs-built_in">merge</span>(x,y);
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
			<span class="hljs-type">int</span> size=dsu.siz[dsu.<span class="hljs-built_in">get</span>(x)];
			<span class="hljs-type">int</span> szy=T.<span class="hljs-built_in">query</span>(dfn[y]+tsz[y]<span class="hljs-number">-1</span>)-T.<span class="hljs-built_in">query</span>(dfn[y]<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(size-szy)*szy);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div><h3 id="luogu4211-lnoi2014-lca">luogu4211 [LNOI2014] LCA</h3><p>首先把询问差分了，考虑求 $_{i=1}^r ((i,z)) $。</p><p>从贡献的角度，<span class="math inline">\(\text{dep}\Big(\text{LCA}(i,z)\Big)\)</span> 可以被具象化为根到 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(z\)</span> 的路径上交点的个数。</p><p>把询问离线了，询问挂到 <span class="math inline">\(l-1\)</span> 与 <span class="math inline">\(r\)</span> 上。从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 枚举节点 <span class="math inline">\(i\)</span>，并且使根到 <span class="math inline">\(i\)</span> 的路径点权都 <span class="math inline">\(+1\)</span>。</p><p>具体地，对于一个询问 <span class="math inline">\((z,op,id)\)</span>，我们查询此时根到 <span class="math inline">\(z\)</span> 的链和，带上系数 <span class="math inline">\(op\)</span> 累加进 <span class="math inline">\(ans(id)\)</span> 即可。</p><p>树剖套线段树即可维护。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">201314</span>;
<span class="hljs-type">int</span> n, m, ans[N];
vector&lt;<span class="hljs-type">int</span>&gt; p[N];
<span class="hljs-type">int</span> son[N], top[N], dep[N], sz[N], fa[N];
<span class="hljs-type">int</span> num, dfn[N];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;
	fa[x]=fr;
	sz[x]=<span class="hljs-number">1</span>;
	dep[x]=dep[fr]+<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;
		<span class="hljs-built_in">dfs1</span>(y,x);
		<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;
		sz[x]+=sz[y];
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;
	top[x]=tp;
	dfn[x]=++num;
	<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;
	<span class="hljs-built_in">dfs2</span>(son[x],tp);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;
		<span class="hljs-keyword">if</span>(y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);
	&#125; 
&#125;
<span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]; &#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> d)</span> </span>&#123;
	t[x]+=(r-l+<span class="hljs-number">1</span>)*d;
	tag[x]+=d;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-keyword">if</span>(tag[x]) &#123;
		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
		<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid,tag[x]);
		<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,tag[x]);
		tag[x]=<span class="hljs-number">0</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seg_upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;
	<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,l,r,d); <span class="hljs-keyword">return</span>; &#125;
	<span class="hljs-built_in">pushdown</span>(x,l,r);
	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
	<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">Seg_upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);
	<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">Seg_upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);
	<span class="hljs-built_in">pushup</span>(x);
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Seg_query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;
	<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];
	<span class="hljs-built_in">pushdown</span>(x,l,r);
	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, res=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>(L&lt;=mid) (res+=<span class="hljs-built_in">Seg_query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid))%=mod;
	<span class="hljs-keyword">if</span>(R&gt;mid) (res+=<span class="hljs-built_in">Seg_query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r))%=mod;
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span> &#123;
	<span class="hljs-type">int</span> z, op, id;
	<span class="hljs-built_in">Q</span>() &#123;&#125;
	<span class="hljs-built_in">Q</span>(<span class="hljs-type">int</span> _z,<span class="hljs-type">int</span> _op,<span class="hljs-type">int</span> _id) &#123; z=_z, op=_op, id=_id; &#125; 
&#125;;
vector&lt;Q&gt; q[N];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> d)</span> </span>&#123;
	<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;
		<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);
		<span class="hljs-built_in">Seg_upd</span>(dfn[top[x]],dfn[x],<span class="hljs-number">1</span>);
		x=fa[top[x]];
	&#125;
	<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
	<span class="hljs-built_in">Seg_upd</span>(dfn[x],dfn[y],<span class="hljs-number">1</span>);
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;
		<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);
		(res+=<span class="hljs-built_in">Seg_query</span>(dfn[top[x]],dfn[x]))%=mod;
		x=fa[top[x]];
	&#125;
	<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
	(res+=<span class="hljs-built_in">Seg_query</span>(dfn[x],dfn[y]));
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		<span class="hljs-built_in">upd</span>(<span class="hljs-number">1</span>,i,<span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:q[i]) &#123;
			<span class="hljs-type">int</span> z=t.z, op=t.op, id=t.id;
			<span class="hljs-type">int</span> res=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,z);
			ans[id]+=res*op;
			(ans[id]+=mod)%=mod;
		&#125;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;
		p[x].<span class="hljs-built_in">pb</span>(i);
	&#125;
	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
	<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;
		<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, r=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, z=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;
		q[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">Q</span>(z,<span class="hljs-number">1</span>,i));
		<span class="hljs-keyword">if</span>(l<span class="hljs-number">-1</span>&gt;<span class="hljs-number">0</span>) q[l<span class="hljs-number">-1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">Q</span>(z,<span class="hljs-number">-1</span>,i));
	&#125;
	<span class="hljs-built_in">solve</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div><h3 id="luogu4216-scoi2015情报传递">luogu4216 [SCOI2015]情报传递</h3><p>发现操作一挺难搞的。</p><p>考虑第二种操作。<span class="math inline">\(i\)</span> 时刻点权大于 <span class="math inline">\(c\)</span>，等价于开始时间小于 <span class="math inline">\(i-c\)</span>。问题转化为求一条链上小于某个数的个数。</p><p>lxl 课件上说用树剖 + 树状数组可以做到 <span class="math inline">\(O(m \log_2^2 n)\)</span>，但是我不会。</p><p>继续观察。如果我们把操作一看成一个点的点权从 <span class="math inline">\(0\)</span> 变成 <span class="math inline">\(1\)</span>，问题等价于求 <span class="math inline">\(i-c-1\)</span> 时刻 <span class="math inline">\((x,y)\)</span> 的链和。</p><p>把询问差分成前缀和相减，离线后挂到时间上，单点加转化为子树加，树状数组即可维护。</p><p>时间复杂度是 <span class="math inline">\(O(m \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, rt, Q, ans[N];
vector&lt;<span class="hljs-type">int</span>&gt; p[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> &#123;
	<span class="hljs-type">int</span> op, x, y, c;
&#125; q[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;
	<span class="hljs-type">int</span> x, y, id;
&#125;;
vector&lt;node&gt; v[N];
<span class="hljs-type">int</span> son[N], top[N], dep[N], sz[N], fa[N];
<span class="hljs-type">int</span> num, dfn[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;
	<span class="hljs-type">int</span> c[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;
		<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=d;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;
		<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];
		<span class="hljs-keyword">return</span> res;		
	&#125;
&#125; T;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;
	fa[x]=fr;
	sz[x]=<span class="hljs-number">1</span>;
	dep[x]=dep[fr]+<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;
		<span class="hljs-built_in">dfs1</span>(y,x);
		<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;
		sz[x]+=sz[y];
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;
	top[x]=tp;
	dfn[x]=++num;
	<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;
	<span class="hljs-built_in">dfs2</span>(son[x],tp);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;
		<span class="hljs-keyword">if</span>(y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);
	&#125; 
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;
		<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);
		x=fa[top[x]];
	&#125;
	<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
	<span class="hljs-keyword">return</span> x;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);
	<span class="hljs-keyword">return</span> dep[x]+dep[y]-dep[z]-dep[fa[z]];
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);
	<span class="hljs-keyword">return</span> T.<span class="hljs-built_in">query</span>(dfn[x])+T.<span class="hljs-built_in">query</span>(dfn[y])-T.<span class="hljs-built_in">query</span>(dfn[z])-T.<span class="hljs-built_in">query</span>(dfn[fa[z]]);
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>) p[x].<span class="hljs-built_in">pb</span>(i); <span class="hljs-keyword">else</span> rt=i;
	&#125;
	Q=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;
		q[i].op=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;
			q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>(), q[i].c=<span class="hljs-built_in">read</span>();
			<span class="hljs-keyword">if</span>(i-q[i].c<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) v[i-q[i].c<span class="hljs-number">-1</span>].<span class="hljs-built_in">pb</span>((node)&#123;q[i].x,q[i].y,i&#125;);
		&#125; <span class="hljs-keyword">else</span> q[i].x=<span class="hljs-built_in">read</span>();
	&#125;
	
	<span class="hljs-built_in">dfs1</span>(rt,<span class="hljs-number">0</span>);
	<span class="hljs-built_in">dfs2</span>(rt,rt);
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,Q) &#123;
		<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">2</span>) &#123;
			<span class="hljs-type">int</span> x=q[i].x;
			T.<span class="hljs-built_in">upd</span>(dfn[x],<span class="hljs-number">1</span>);
			T.<span class="hljs-built_in">upd</span>(dfn[x]+sz[x],<span class="hljs-number">-1</span>);
		&#125;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v[i]) &#123;
			ans[t.id]=<span class="hljs-built_in">calc</span>(t.x,t.y);
		&#125;
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) <span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,<span class="hljs-built_in">dis</span>(q[i].x,q[i].y),ans[i]);
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div><h2 id="树上倍增">树上倍增</h2><p>没啥技巧，直接上题。</p><h3 id="cf932d-tree">CF932D Tree</h3><p>设 <span class="math inline">\(f(x,i)\)</span> 表示从 <span class="math inline">\(x\)</span> 往上提取一个长度为 <span class="math inline">\(2^i\)</span> 的点权单调不降子序列（不含 <span class="math inline">\(x\)</span>），最后一项的节点编号。</p><p>发现要是能处理出 <span class="math inline">\(f(x,0)\)</span> 就做完了。</p><p>对于一个新加入的 <span class="math inline">\(x\)</span>，如果 <span class="math inline">\(f(x,0) \neq fa(x)\)</span>，那么就从 <span class="math inline">\(fa(x)\)</span> 向上找到最后一个满足 <span class="math inline">\(w_p &lt; w_x\)</span> 的 <span class="math inline">\(p\)</span>，<span class="math inline">\(fa(p)\)</span> 就是 <span class="math inline">\(f(x,0)\)</span>。</p><h3 id="cf519e-a-and-b-and-lecture-rooms">CF519E A and B and Lecture Rooms</h3><p>运用本文第一题的结论。</p><p>一个点分别到 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 的路径，一定是先重合一段，然后路径 <span class="math inline">\((x,y)\)</span> 的一个点上分开。也就是说，到二者的距离相等的点，一定满足这个交点是路径 <span class="math inline">\((x,y)\)</span> 的中点。</p><p>设中点为 <span class="math inline">\(p\)</span>，考虑其与 <span class="math inline">\(z=\text{LCA}(x,y)\)</span> 的关系。</p><p>设 <span class="math inline">\(pre_x(y)\)</span> 为 <span class="math inline">\(x\)</span> 的一个祖先，满足其是 <span class="math inline">\(y\)</span> 的子节点。</p><ul><li><span class="math inline">\(p=z\)</span>，答案就是 <span class="math inline">\(n-pre_x(z)-pre_y(z)\)</span>。</li><li><span class="math inline">\(p\)</span> 在靠近 <span class="math inline">\(x\)</span> 的那一侧，答案是 <span class="math inline">\(sz_{p} - pre_x(p)\)</span>。</li><li><span class="math inline">\(p\)</span> 在靠近 <span class="math inline">\(y\)</span> 的那一侧，答案是 <span class="math inline">\(sz_p - pre_y(p)\)</span>。</li></ul><p><span class="math inline">\(\text{dep}(p)\)</span> 可以根据 <span class="math inline">\((x,y,z)\)</span> 的深度关系得到，然后倍增求出 <span class="math inline">\(q\)</span>。</p><p><span class="math inline">\(pre_x(y)\)</span> 也可以从 <span class="math inline">\(x\)</span> 往上倍增出来。</p><h3 id="luogu8820-csp-s-2022-数据传输">luogu8820 [CSP-S 2022] 数据传输</h3><p><a href="https://yozora0908.github.io/2023/lg8820-solution">link</a></p><h3 id="loj-2955.-noip2018保卫王国">LOJ #2955. 「NOIP2018」保卫王国</h3><p><a href="https://yozora0908.github.io/2023/loj2955-solution">link</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Record/" class="category-chain-item">Record</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%A0%91%E8%AE%BA/" class="print-no-link">#树论</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" class="print-no-link">#树上倍增</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" class="print-no-link">#线段树</a> <a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" class="print-no-link">#树状数组</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/" class="print-no-link">#树上差分</a> <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" class="print-no-link">#树链剖分</a></div></div><div class="license-box my-3"><div class="license-title"><div>「NOIP Record」#20 树论（1）树上差分与树上倍增</div><div>https://yozora0908.github.io/2023/noip-record-1/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>yozora0908</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年9月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/lg6563-solution/" title="luogu6563 [SBCOI2020] 一直在你身旁 题解"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">luogu6563 [SBCOI2020] 一直在你身旁 题解</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/noip-record-19/" title="「NOIP Record」#19 费用提前计算"><span class="hidden-mobile">「NOIP Record」#19 费用提前计算</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"yozora0908/MyGiscus","repo-id":"R_kgDOKLq9Ag","category":"General","category-id":"DIC_kwDOKLq9As4CY38d","theme-light":"light_protanopia","theme-dark":"dark_dimmed","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","loading":"lazy"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light_protanopia';
        var dark = 'dark_dimmed';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.staticfile.org/jquery/3.7.0/jquery.min.js"></script><script src="https://cdn.staticfile.org/bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://cdn.staticfile.org/tocbot/4.21.1/tocbot.min.js",function(){var t,i=jQuery("#toc");0!==i.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<i.find(".toc-list-item").length&&i.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://cdn.staticfile.org/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://cdn.staticfile.org/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>