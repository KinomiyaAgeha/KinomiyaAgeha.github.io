<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><link rel="icon" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#1749d1"><meta name="author" content="yozora0908"><meta name="keywords" content="OI"><meta name="description" content="突破口永远在环上。   找环是常用操作，但是并没有一个合适的模板。 笔者在写这篇文章之前就做过一些基环树的简单题，但是每一次写的找环都不尽相同。仅仅用dfs的回溯模拟一个栈，显然是不够公式化的，且容易出 bug，因此我们需要确定一种可靠的写法。 关于dfn的那套理论再合适不过了。 当然这玩意只能找一个环。 int cnt, num, fa[N], dfn[N], cir[N]; vo"><title>「NOIP Record」#2 基环树 - yozora0908&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"yozora0908.github.io",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"always",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#0076FF",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:null,onlypost:!0,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!1,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="yozora0908's blog" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>yozora0908&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn-us.imgs.moe/2023/02/02/63db75d1e0be8.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="「NOIP Record」#2 基环树"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-05-07 20:46" pubdate>2023年5月7日 晚上</time></span></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">「NOIP Record」#2 基环树</h1><div class="markdown-body"><p>突破口永远在环上。</p><p> </p><p>找环是常用操作，但是并没有一个合适的模板。</p><p>笔者在写这篇文章之前就做过一些基环树的简单题，但是每一次写的找环都不尽相同。仅仅用<code>dfs</code>的回溯模拟一个栈，显然是不够公式化的，且容易出 bug，因此我们需要确定一种可靠的写法。</p><p>关于<code>dfn</code>的那套理论再合适不过了。</p><p>当然这玩意只能找一个环。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt, num, fa[N], dfn[N], cir[N];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_cir</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    dfn[x]=++num;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;
        <span class="hljs-type">int</span> y=to[i];
        <span class="hljs-keyword">if</span>(y==fa[x]) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span>(dfn[y]) &#123;
            <span class="hljs-keyword">if</span>(dfn[y]&lt;dfn[x]) <span class="hljs-keyword">continue</span>;
            cir[++cnt]=y;
            <span class="hljs-keyword">while</span>(y!=x) &#123;
                cir[++cnt]=fa[y];
                y=fa[x];
            &#125;
        &#125; <span class="hljs-keyword">else</span> fa[y]=x, <span class="hljs-built_in">get_cir</span>(y);
    &#125;
&#125;</code></pre></div><p>还可以使用拓扑排序。</p><p>最终没有入队的就是环上节点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 基环树</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort1</span><span class="hljs-params">()</span></span>&#123; 
    queue&lt;<span class="hljs-type">int</span>&gt; q;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(i);
    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;
        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;
            <span class="hljs-type">int</span> y=to[i];
            <span class="hljs-keyword">if</span>(in[y]&gt;<span class="hljs-number">1</span>)&#123;
                <span class="hljs-comment">// do sth.</span>
                <span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(y);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-comment">// 内向树</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort2</span><span class="hljs-params">()</span></span>&#123; 
    queue&lt;<span class="hljs-type">int</span>&gt; q;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);
    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;
        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;
            <span class="hljs-type">int</span> y=to[i];
            <span class="hljs-comment">// do sth.</span>
            <span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);
        &#125;
    &#125;
&#125;</code></pre></div><h3 id="luogu2607-zjoi2008-骑士">luogu2607 [ZJOI2008] 骑士</h3><blockquote><p>基环树森林， <span class="math inline">\(n\)</span> 个点。求带权最大独立集。</p><p><span class="math inline">\(n \le 10^6\)</span></p></blockquote><p>树的情况是平凡的。</p><p>基环树的本质是若干树挂在一个环上，因此对于环上每个节点为根都跑一遍。然后断环为链，钦定一个元素选还是不选，做两遍即可。</p><h3 id="luogu4381-ioi2008-island">luogu4381 [IOI2008] Island</h3><blockquote><p>求 <span class="math inline">\(n\)</span> 个点的基环树直径。</p><p><span class="math inline">\(n \le 10^6\)</span></p></blockquote><p>答案一定是环上两点连接它们子树的直径。</p><p>断环为链，这里采用复制一遍的方法。</p><p>答案就是 <span class="math display">\[ \max_{i \le j} \{d_i + d_j + dis(i,j)\} \]</span> 把 <span class="math inline">\(dis(i,j)\)</span> 拆成前缀和相减的形式，发现对于一个 <span class="math inline">\(j\)</span>，最优策略是前面距离不超过 <span class="math inline">\(n\)</span> 的最大值，单调队列维护。</p><h3 id="cf835f-roads-in-the-kingdom">CF835F Roads in the Kingdom</h3><blockquote><p><span class="math inline">\(n\)</span> 个结点的基环树，边有边权。需要从删去一条边，保证连通且最小化直径。</p></blockquote><p>首先删掉的边一定是环上的，否则不连通。</p><p>断开环上一边 <span class="math inline">\((x,y)\)</span>，此时的直径是环上 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的路径加上二者子树的直径，或者某个子树的直径。</p><p>而删边的影响仅仅是干掉某些环上的路径。</p><p>长度为 <span class="math inline">\(n\)</span> 的那个滑动窗口能够做到“删掉某条边”。</p><p>由于这个单调队列一次能干掉的决策只有一个，所以用<code>std::set</code>即可，但是要注意判断最优决策相等的情况，维护次大值。</p><h3 id="cf711d-directed-roads">CF711D Directed Roads</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <span class="math inline">\(n\)</span> 边的无向图，多少种给边定向的方式，是的新图中无环。</p><p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p></blockquote><p>考虑一个联通块。如果无环，那么每条边任意。否则一定只有 <span class="math inline">\(1\)</span> 个环，减掉保留这个环的方案数即可。</p><p>注意环可能有两种方向。</p><h3 id="cf1454e-number-of-simple-paths">CF1454E Number of Simple Paths</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <span class="math inline">\(n\)</span> 边的无向图，问一共有多少条简单路径。</p><p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p></blockquote><p>如果两个点之间的路径跨越环上某一部分，那么就有两条简单路径，否则只有一条。对环上每棵子树分别考虑即可。</p><h3 id="cf1607f-robot-on-the-board-2">CF1607F Robot on the Board 2</h3><blockquote><p><span class="math inline">\(n \times m\)</span> 的矩阵，每个点都往上下左右某一个位置连一条边，从任意节点出发按照边走，直到走到之前经过的点为止。求能经过的最大节点数量以及相应起点。</p><p><span class="math inline">\(n,m \le 2000\)</span></p></blockquote><p>连边后是一个内向树森林，直接 DP 即可。</p><h3 id="cf1770d-koxia-and-game">CF1770D Koxia and Game</h3><blockquote><p>给定 <span class="math inline">\(n\)</span> 和长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a,b\)</span>，考虑另一个序列 <span class="math inline">\(c\)</span>。</p><p>先手在第 <span class="math inline">\(i\)</span> 次操作，可以拿走可重集 <span class="math inline">\(\{a_i,b_i,c_i\}\)</span> 中的一个元素，后手再二选一拿走一个。</p><p>做完 <span class="math inline">\(n\)</span> 次操作后，如果后手拿走的所有元素是 <span class="math inline">\(1 \sim n\)</span> 的一个排列，那么先手胜，否则先手败。</p><p>求有多少个 <span class="math inline">\(c\)</span>，满足先手能胜利。对 <span class="math inline">\(998244353\)</span> 取模。</p><p><span class="math inline">\(n \le 10^5\)</span>，<span class="math inline">\(a_i,b_i \in [1,n]\)</span></p></blockquote><p>博弈，但并不是传统的博弈论题目。</p><p>正着想很困难，考虑先手能赢的条件。</p><p>对于 <span class="math inline">\(\{a_n,b_n,c_n\}\)</span>，如果不存在两者相同，那么无论先手拿走哪一个，后手都有办法使得先手输掉。所以 <span class="math inline">\(\{a_n,b_n,c_n\}\)</span> 存在两者相同是一个必要条件。</p><p>考虑 <span class="math inline">\(\{a_{n-1},b_{n-1},c_{n-1}\}\)</span>，假设 <span class="math inline">\(\{a_n,b_n,c_n\}\)</span> 满足上述条件，发现 <span class="math inline">\(\{a_{n-1},b_{n-1},c_{n-1}\}\)</span> 满足上述条件依然是必要的。</p><p>由此递归下去，得到对于任意 <span class="math inline">\(i\)</span>，<span class="math inline">\(\{a_i,b_i,c_i\}\)</span> 满足上述条件是充要的。</p><p>问题转化为对于任意 <span class="math inline">\(i\)</span>，要在 <span class="math inline">\((a_i,b_i)\)</span> 中选择一个数，求选出的数构成 <span class="math inline">\([1,n]\)</span> 的一个排列的方案数。对于 <span class="math inline">\(a_i = b_i\)</span> 的情况，对方案的贡献是 <span class="math inline">\(n\)</span>。</p><p>转化为图论问题。将 <span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(b_i\)</span> 视为点，在 <span class="math inline">\((a_i,b_i)\)</span> 间连一条无向边，这样就会得到一些连通块。由数据范围可知最多有 <span class="math inline">\(n\)</span> 个点与 <span class="math inline">\(n\)</span> 条边。</p><p>由于一条边连接的两个点中必然有一个被选择且不允许重复（要构成排列），所以如果一个联通块点数不等于边数，无解。那么有解的连通块一定是一棵基环树。</p><p>容易发现方案只有 <span class="math inline">\(2\)</span> 种，区别在环上选择的方向。环也有可能是自环，就是 <span class="math inline">\(a_i=b_i\)</span> 的情况，方案是 <span class="math inline">\(1\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;
<span class="hljs-type">int</span> T, n, ans, fg, v[N], a[N], b[N];
<span class="hljs-type">int</span> cnt;
vector&lt;<span class="hljs-type">int</span>&gt; p[N];
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	<span class="hljs-type">int</span> fa[N], sz[N], cnte[N];
	<span class="hljs-type">bool</span> slp[N];
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;;
		<span class="hljs-type">int</span> tx=<span class="hljs-built_in">get</span>(x), ty=<span class="hljs-built_in">get</span>(y);
		<span class="hljs-keyword">if</span>(fa[tx]!=ty) fa[tx]=ty, sz[ty]+=sz[tx], cnte[ty]+=cnte[tx];
		++cnte[ty];
		slp[ty]|=slp[tx];
		<span class="hljs-keyword">if</span>(x==y) slp[ty]=<span class="hljs-number">1</span>;
	&#125;
    <span class="hljs-comment">// 经过某道题的教训，终于老老实实写些并查集维护起来相对容易的信息了</span>
&#125; dsu;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>();
	ans=<span class="hljs-number">1</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-number">0</span>, dsu.fa[i]=i, dsu.cnte[i]=dsu.slp[i]=<span class="hljs-number">0</span>, dsu.sz[i]=<span class="hljs-number">1</span>, a[i]=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		b[i]=<span class="hljs-built_in">read</span>();
		<span class="hljs-type">int</span> x=a[i], y=b[i];
		dsu.<span class="hljs-built_in">merge</span>(x,y);
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i==dsu.<span class="hljs-built_in">get</span>(i)) &#123;
		<span class="hljs-keyword">if</span>(dsu.sz[i]!=dsu.cnte[i]) &#123;
			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">if</span>(dsu.slp[i]) (ans*=n)%=mod;
		<span class="hljs-keyword">else</span> (ans*=<span class="hljs-number">2</span>)%=mod;
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	T=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();
&#125;</code></pre></div><p>贴上<code>DFS</code>版本的 std。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;
<span class="hljs-type">int</span> n, a[N], b[N];
vector &lt;<span class="hljs-type">int</span>&gt; G[N];
<span class="hljs-type">bool</span> vis[N];
<span class="hljs-type">int</span> vertex, edge, self_loop;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">return</span> ;
	vis[x] = <span class="hljs-literal">true</span>;
	vertex++;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : G[x]) &#123;
		edge++;
		<span class="hljs-built_in">dfs</span>(y);
		<span class="hljs-keyword">if</span> (y == x) self_loop++;
 	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) G[i].<span class="hljs-built_in">clear</span>();
 
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		G[a[i]].<span class="hljs-built_in">push_back</span>(b[i]);
		G[b[i]].<span class="hljs-built_in">push_back</span>(a[i]);
	&#125;
 
	<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;
 
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span> ;
		vertex = <span class="hljs-number">0</span>;
		edge = <span class="hljs-number">0</span>;
		self_loop = <span class="hljs-number">0</span>;
		<span class="hljs-built_in">dfs</span>(i);
		<span class="hljs-keyword">if</span> (edge != <span class="hljs-number">2</span> * vertex) ans = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self_loop) ans = <span class="hljs-number">1ll</span> * ans * n % P;
 		<span class="hljs-keyword">else</span> ans = ans * <span class="hljs-number">2</span> % P;
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> t;
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);
	<span class="hljs-keyword">while</span> (t--) <span class="hljs-built_in">solve</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div><h3 id="cf512d-fox-and-travelling">CF512D Fox And Travelling</h3><p><del>不知道和基环树有什么关系</del>。</p><p>首先可以发现，环中的节点和链接两个环的链上的节点是不能选的。</p><p>用上文的无向图拓扑排序可以找到所有上述节点，这样的话就会得到一个森林。</p><p>注意选点是有顺序的，考虑一棵树中，一定是从叶子开始自底向上选，且如果一个点没有被选，其一定不会产生任何贡献。</p><p>设 <span class="math inline">\(f_{x,i}\)</span> 为以 <span class="math inline">\(x\)</span> 为根的子树，选择 <span class="math inline">\(i\)</span> 个点，其中 <span class="math inline">\(x\)</span> 必须选择的方案数。 <span class="math display">\[ g_j = \binom{j}{k} \times f_{x,k} \times f_{y,j-k} \]</span> <span class="math inline">\(\binom{j}{k}\)</span> 的含义是从 <span class="math inline">\(j\)</span> 个位置中选择 <span class="math inline">\(k\)</span> 个给当前以 <span class="math inline">\(x\)</span> 为根的子树。</p><p>能发现 <span class="math inline">\(x\)</span> 是最后被选择的。</p><p>对于挂在环上的树，这种选择方式显然是唯一的。</p><p>考虑孤立的树。由于 <span class="math inline">\(n \le 100\)</span>，所以直接以每个点为根做一次树形 DP。设选择 <span class="math inline">\(i\)</span> 个节点，这样只能保证选 <span class="math inline">\(sz_{root}\)</span> 个点时没有重复。</p><p>考虑选出的 <span class="math inline">\(i\)</span> 个节点，这个方案一定在以剩下 <span class="math inline">\(sz_{root}-i\)</span> 个节点为根时都被算过一次，除掉即可。</p><h3 id="luogu5049-noip2018-提高组-旅行-加强版">luogu5049 [NOIP2018 提高组] 旅行 加强版</h3><blockquote><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树或基环树，起点为 <span class="math inline">\(1\)</span>。</p><p>有两种操作</p><ol type="1"><li>到达一个当前点能直接到达的，没有到达过的点。</li><li>沿着到达当前点的边退回这条边的另一个端点。</li></ol><p>要求遍历所有点，最小化节点遍历的字典序。</p><p><span class="math inline">\(n \le 5 \cdot 10^5\)</span></p></blockquote><p>对于一棵树，必须按照子节点编号递增的顺序<code>DFS</code>，所以下文访问顺序指的就是兄弟节点之间的编号顺序。</p><p>对于基环树，多了的操作是「从环上往后退」。</p><p>什么时候可以往后退呢？当且仅当对于环上的父子节点 <span class="math inline">\((x,y)\)</span>，<span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 最后遍历的子节点（这样才能从另一边绕回来），同时回溯到 <span class="math inline">\(y\)</span> 的祖先时，能够到达编号小于 <span class="math inline">\(y\)</span> 的点。</p><p>更进一步地，如果选择了退回，那么不可能再次后退。所以这个编号小于 <span class="math inline">\(y\)</span> 的点，一定是回溯过程中遇到的第一个祖先的儿子，满足它是这个祖先下一个应访问的节点，否则就无法遍历到了。</p><p>因此就变成了树的做法。</p><p>如何实现？对于节点 <span class="math inline">\(x\)</span>，维护最小子节点编号，<code>DFS</code>时记录之，这样一定能找到最优退回的地方。</p><p>顺带一提，优先队列的内存优化优于队列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, num, fg, root, dfn[N], fa[N];
<span class="hljs-type">bool</span> v[N], cir[N];
vector&lt;<span class="hljs-type">int</span>&gt; p[N], ans;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;
	ans.<span class="hljs-built_in">pb</span>(x);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_cir</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    dfn[x]=++num;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;
        <span class="hljs-keyword">if</span>(dfn[y]) &#123;
            <span class="hljs-keyword">if</span>(dfn[y]&lt;dfn[x]) <span class="hljs-keyword">continue</span>;
            cir[y]=<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span>(y!=x) &#123;
            	cir[fa[y]]=<span class="hljs-number">1</span>;
            	y=fa[y];
            &#125;
        &#125; <span class="hljs-keyword">else</span> fa[y]=x, <span class="hljs-built_in">get_cir</span>(y);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> pre)</span> </span>&#123;
	v[x]=<span class="hljs-number">1</span>;
	ans.<span class="hljs-built_in">pb</span>(x);
	priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) q.<span class="hljs-built_in">push</span>(y);
	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;
		<span class="hljs-type">int</span> y=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();
		<span class="hljs-keyword">if</span>(!fg&amp;&amp;q.<span class="hljs-built_in">empty</span>()&amp;&amp;cir[x]&amp;&amp;cir[y]&amp;&amp;pre&lt;y) &#123;
			fg=<span class="hljs-number">1</span>;
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">if</span>(v[y]) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span>(cir[x]&amp;&amp;q.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">DFS</span>(y,q.<span class="hljs-built_in">top</span>());
		<span class="hljs-keyword">else</span> <span class="hljs-built_in">DFS</span>(y,pre);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">sort</span>(p[i].<span class="hljs-built_in">begin</span>(),p[i].<span class="hljs-built_in">end</span>());
	<span class="hljs-keyword">if</span>(m==n<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
	<span class="hljs-keyword">else</span> <span class="hljs-built_in">get_cir</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1e9</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);
	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
&#125;</code></pre></div><ul><li>欲穷千里目，更上一层楼。</li></ul><h3 id="luogu8288-daoi-r1fireworks">luogu8288 「DAOI R1」Fireworks</h3><p>题面较复杂，就不放了。</p><p>本题相当缝合。</p><p>坚持自己的想法，让我得到了无数次 WA。最终也是放弃了自己的框架，参考了 std。</p><p>这么多次写挂，背后的原因，不全是因为此题代码实现相对复杂。经过教练的指导，我也明白了我深层的不足。</p><p>为了不留下遗憾，勇敢面对吧！</p><p>连边 <span class="math inline">\((a_x \rightarrow x)\)</span>，权值 <span class="math inline">\(b_x\)</span>。</p><p>如果没有系列的限制，相当于在外向树森林上做一个简单 DP。</p><p>有了限制，就把同一个系列的点缩成一个，其权值为所有点权之和。</p><p>设 <span class="math inline">\(f_{x,0/1}\)</span> 为以 <span class="math inline">\(x\)</span> 为根的子树，<span class="math inline">\(x\)</span> 选还是不选的最大价值。每个节点的入边最多为 <span class="math inline">\(1\)</span>，因此无入度点一定不会进入环，直接搜。</p><p>如果有环，强制环上一点选或者不选，两次 DP 即可。</p><p>设主节点为 <span class="math inline">\(p\)</span>，对于非主要点 <span class="math inline">\(x\)</span>，如果 <span class="math inline">\(a_x\)</span> 所在系列是 <span class="math inline">\(x\)</span> 所在的系列，让点权减少 <span class="math inline">\(b_x\)</span>；否则如果 <span class="math inline">\(a_x\)</span> 所在的系列和 <span class="math inline">\(a_p\)</span> 所在系列相同，就让边权加上 <span class="math inline">\(b_x\)</span>。</p><p>注意如果 <span class="math inline">\(a_p\)</span> 就是 <span class="math inline">\(p\)</span> 所在系列，优先执行前者。而这对应的就是无入度点。</p><p>如果有点不属于任何一个系列，新建立一个系列，只有这个点。</p><p>主要问题在于实现。</p><p>代码详细解释。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	ll a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, num, cnt, a[N], p[N], bel[N];
ll b[N], v[N], v2[N], ww[N], f[N][<span class="hljs-number">2</span>];
vector&lt;<span class="hljs-type">int</span>&gt; s[N];
vector&lt;pair&lt;<span class="hljs-type">int</span>,ll&gt; &gt; g[N];
pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cir[N];
<span class="hljs-type">bool</span> vis[N];
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	<span class="hljs-type">int</span> fa[N];
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;
&#125; dsu;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> i)</span> </span>&#123;
	f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=v2[x];
    <span class="hljs-comment">// 赋初值避开清空数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;
		<span class="hljs-type">int</span> y=t.first;
		ll z=t.second;
		<span class="hljs-built_in">dfs</span>(y,i);
        <span class="hljs-comment">// 出边可能不止有一条。虽然断开了环上那条边，但cir[i].second也可能到达其他点</span>
        <span class="hljs-comment">// 因此还要往下DFS，这时候就能看出避免连环上这条边的重要性</span>
        <span class="hljs-comment">// 只需要在更新cir[i].second的父节点时候特判</span>
		<span class="hljs-keyword">if</span>(i&amp;&amp;y==cir[i].second) &#123;
			f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-ww[i]);
			f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-ww[i]-z);
            <span class="hljs-comment">// 无论如何必须减掉i这条边的权值</span>
		&#125; <span class="hljs-keyword">else</span> &#123;
			f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);
			f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);
		&#125;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-built_in">read</span>(), a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();
    
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		p[++num]=<span class="hljs-built_in">read</span>(); <span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();
		dsu.fa[num]=num;
		<span class="hljs-keyword">while</span>(k--) &#123;
			<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();
			v2[num]+=v[x], bel[x]=num;
			s[num].<span class="hljs-built_in">pb</span>(x);
		&#125;
        <span class="hljs-comment">// num表示有多少个系列</span>
        <span class="hljs-comment">// 只有系列才是有用的，因此直接重新编号，避免不必要的麻烦</span>
        <span class="hljs-comment">// 笔者在写的时候，没有进行重新编号，而是用DSU进行缩点</span>
        <span class="hljs-comment">// 不重新编号，会带来各种各样的麻烦</span>
        <span class="hljs-comment">// 重新编号则没有什么坏处</span>
        <span class="hljs-comment">// 因为原来的点的编号在预处理完之后就没有任何用处了</span>
	&#125;
    
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!bel[i]) &#123;
		p[++num]=i, bel[i]=num, v2[num]=v[i];
		s[num].<span class="hljs-built_in">pb</span>(i);
		dsu.fa[num]=num;
        <span class="hljs-comment">// 处理不在任何系列中的点</span>
	&#125;
    
    
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,num) &#123;
		<span class="hljs-type">int</span> tp=bel[a[p[i]]];
		ll res=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s[i]) &#123;
			<span class="hljs-type">int</span> tx=bel[a[x]];
			<span class="hljs-keyword">if</span>(tx==i) v2[i]-=b[x];
            <span class="hljs-comment">// 优先执行这个</span>
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tx==tp) res+=b[x];
		&#125;
		<span class="hljs-keyword">if</span>(tp==i) <span class="hljs-keyword">continue</span>;
        <span class="hljs-comment">// 无入度点</span>
		vis[i]=<span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==dsu.<span class="hljs-built_in">get</span>(tp)) &#123;
            <span class="hljs-comment">// DSU判环</span>
            <span class="hljs-comment">// 但注意不要烦笔者这样的错误</span>
            <span class="hljs-comment">// 突然降智，过于依赖DSU的结构，用DSU存每个连通块那一条环上边</span>
            <span class="hljs-comment">// 自找麻烦罢了</span>
			cir[++cnt].first=i, cir[cnt].second=tp, ww[cnt]=res;
            <span class="hljs-comment">// ww[cnt]为这条边的权值</span>
		&#125; <span class="hljs-keyword">else</span> &#123;
			dsu.fa[dsu.<span class="hljs-built_in">get</span>(i)]=dsu.<span class="hljs-built_in">get</span>(tp);
			g[tp].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">make_pair</span>(i,res));
            <span class="hljs-comment">// 成环的时候不连边，保证DFS无环</span>
            <span class="hljs-comment">// 否则就连反边</span>
		&#125;
	&#125;
	ll ans=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,num) <span class="hljs-keyword">if</span>(!vis[i]) &#123;
		<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);
		ans+=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],f[i][<span class="hljs-number">1</span>]);
        <span class="hljs-comment">// 这样的点可以直接搜</span>
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;
		<span class="hljs-type">int</span> x=cir[i].first;
		ll aa=<span class="hljs-number">0</span>;
		<span class="hljs-built_in">dfs</span>(x,i);
        <span class="hljs-comment">// 强制cir[i].first必须选，cir[i].second-&gt;cir[i].first必须考虑</span>
		aa=f[x][<span class="hljs-number">1</span>];
		<span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">0</span>);
		aa=<span class="hljs-built_in">max</span>(aa,f[x][<span class="hljs-number">0</span>]);
        <span class="hljs-comment">// 不选，不考虑cir[i].second-&gt;cir[i].first</span>
		ans+=aa;
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);
&#125;</code></pre></div><ul><li>不要过于依赖提交，认真分析程序。</li><li>思路应该更广阔些，本题应该在发现建图后就是外向树森林，进而分析图的特殊形态而简化实现</li></ul><p>必须要把我的某一版 sb 程序贴出来，以作警示。</p><p>想不到还有 30pts。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, ans, v[N], vv[N], a[N], b[N], p[N], f[N][<span class="hljs-number">2</span>];
<span class="hljs-type">int</span> to[N][<span class="hljs-number">2</span>];
<span class="hljs-type">bool</span> vis[N];
vector&lt;<span class="hljs-type">int</span>&gt; s[N];
vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; g[N];
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	<span class="hljs-type">int</span> fa[N];
	pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cir[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, cir[i].fi=cir[i].se=<span class="hljs-number">0</span>; &#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-type">int</span> dx=<span class="hljs-built_in">get</span>(x), dy=<span class="hljs-built_in">get</span>(y);
		<span class="hljs-keyword">if</span>(dx!=dy) fa[dx]=dy;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=y) cir[dy]=&#123;x,y&#125;;
	&#125;
&#125; dsu, dsu2;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span> </span>&#123;
	vis[x]=<span class="hljs-number">1</span>;
	f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=v[x];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;
		<span class="hljs-type">int</span> y=t.fi, z=t.se;
		<span class="hljs-keyword">if</span>(y==root) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs</span>(y,root);
		f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);
		f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span> </span>&#123;
	f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
	f[x][<span class="hljs-number">1</span>]=v[x];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;
		<span class="hljs-type">int</span> y=t.fi, z=t.se;
		<span class="hljs-keyword">if</span>(y==root) &#123;
			f[x][<span class="hljs-number">1</span>]-=z;
			<span class="hljs-keyword">continue</span>;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs1</span>(y,root);
		f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);
		f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);
	&#125;
	<span class="hljs-comment">// printf(&quot;x=%lld f=%lld %lld\n&quot;,x,f[x][0],f[x][1]);</span>
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">redirect</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;
		<span class="hljs-type">int</span> y=to[i][<span class="hljs-number">0</span>], z=to[i][<span class="hljs-number">1</span>];
		g[y].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">make_pair</span>(i,z));
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;
		dsu2.<span class="hljs-built_in">merge</span>(i,to[i][<span class="hljs-number">0</span>]);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-built_in">read</span>(), a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();
	dsu.<span class="hljs-built_in">init</span>(), dsu2.<span class="hljs-built_in">init</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		p[i]=<span class="hljs-built_in">read</span>();
		<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">while</span>(k--) &#123;
			<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();
			<span class="hljs-keyword">if</span>(x==p[i]) <span class="hljs-keyword">continue</span>;
			v[p[i]]+=v[x];
			s[p[i]].<span class="hljs-built_in">pb</span>(x);
			dsu.<span class="hljs-built_in">merge</span>(x,p[i]);
		&#125;
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;
		to[i][<span class="hljs-number">0</span>]=dsu.<span class="hljs-built_in">get</span>(a[i]), to[i][<span class="hljs-number">1</span>]=b[i];
		<span class="hljs-keyword">if</span>(!s[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s[i]) &#123;
			<span class="hljs-type">int</span> px=dsu.<span class="hljs-built_in">get</span>(a[x]);
			<span class="hljs-keyword">if</span>(px==i) v[i]-=b[x];
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px==to[i][<span class="hljs-number">0</span>]) to[i][<span class="hljs-number">1</span>]+=b[x];
		&#125;
	&#125;
	
	<span class="hljs-built_in">redirect</span>();
	
	<span class="hljs-built_in">rebuild</span>();
	
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;
		<span class="hljs-type">int</span> aa=<span class="hljs-number">0</span>;
		<span class="hljs-type">int</span> root=<span class="hljs-number">0</span>, pi=dsu2.<span class="hljs-built_in">get</span>(i);
		<span class="hljs-keyword">if</span>(dsu2.cir[pi].fi!=<span class="hljs-number">0</span>) root=dsu2.cir[pi].fi;
		<span class="hljs-keyword">else</span> &#123;
			root=pi;
			<span class="hljs-built_in">dfs</span>(root,root);
			ans+=<span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>],f[root][<span class="hljs-number">1</span>]);
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-built_in">dfs</span>(root,root);
		aa=f[root][<span class="hljs-number">0</span>];
		<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);
		<span class="hljs-built_in">dfs1</span>(root,root);
		aa=<span class="hljs-built_in">max</span>(aa,f[root][<span class="hljs-number">1</span>]);
		ans+=aa;
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);
&#125;</code></pre></div><h3 id="luogu6890-ceoi2006-link">luogu6890 [CEOI2006] Link</h3><p>首先执行拓扑排序，将 <span class="math inline">\(1\)</span> 和无入度点加入队列，<span class="math inline">\(1\)</span> 一定会对它们连边。每求出一个 <span class="math inline">\(f_x &gt; k\)</span> 就将其置为 <span class="math inline">\(1\)</span>，再更新别的点。</p><p>把环拎出来，考虑别的点进入环后只能到达环上一个区间，可以用差分维护。这些点肯定不需要连边。对于剩下的点，如果第一个连边的点确定了，那么就直接贪心。</p><p>考虑枚举第一个连边的点，设环长为 <span class="math inline">\(m\)</span>，发现只会跳 <span class="math inline">\(O(\frac{m}{k})\)</span> 次。由于开头 <span class="math inline">\(k\)</span> 个点必然至少有一个连边，所以复杂度就是 <span class="math inline">\(O(m)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, k, ans, cnt, to[N], in[N], f[N], c[N];
<span class="hljs-type">bool</span> v[N];
vector&lt;<span class="hljs-type">int</span>&gt; cir[N];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;
	queue&lt;<span class="hljs-type">int</span>&gt; q;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		<span class="hljs-keyword">if</span>(!in[i]||i==<span class="hljs-number">1</span>) &#123;
			f[i]=i==<span class="hljs-number">1</span>? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>) ++ans;
			q.<span class="hljs-built_in">push</span>(i);
		&#125; <span class="hljs-keyword">else</span> f[i]=k+<span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;
		<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();
		v[x]=<span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span>(f[x]&gt;k) ++ans, f[x]=<span class="hljs-number">1</span>;
		<span class="hljs-type">int</span> y=to[x];
		<span class="hljs-keyword">if</span>(y&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;
		f[y]=<span class="hljs-built_in">min</span>(f[y],f[x]+<span class="hljs-number">1</span>);
		<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcir</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;
		v[i]=<span class="hljs-number">1</span>;
		cir[++cnt].<span class="hljs-built_in">pb</span>(<span class="hljs-number">114514</span>), cir[cnt].<span class="hljs-built_in">pb</span>(i);
		<span class="hljs-type">int</span> x=i;
		<span class="hljs-keyword">while</span>(to[x]!=i) v[to[x]]=<span class="hljs-number">1</span>, cir[cnt].<span class="hljs-built_in">pb</span>(to[x]), x=to[x];
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
	m=cir[x].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
	<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,(m+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		<span class="hljs-keyword">if</span>(f[cir[x][i]]&gt;k) <span class="hljs-keyword">continue</span>;
		<span class="hljs-type">int</span> R=i+k-f[cir[x][i]];
		<span class="hljs-keyword">if</span>(R&lt;=m) ++c[i], --c[R+<span class="hljs-number">1</span>];
		<span class="hljs-keyword">else</span> ++c[i], --c[m+<span class="hljs-number">1</span>], ++c[<span class="hljs-number">1</span>], --c[R+<span class="hljs-number">1</span>-m];
	&#125;
	vector&lt;<span class="hljs-type">int</span>&gt; v; v.<span class="hljs-built_in">pb</span>(<span class="hljs-number">1919810</span>);
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		c[i]+=c[i<span class="hljs-number">-1</span>];
		<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) v.<span class="hljs-built_in">pb</span>(i);
	&#125;
	<span class="hljs-type">int</span> res=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, mm=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mm,k);++i) &#123;
		<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v[i];j&lt;v[i]+m;++j) &#123;
			<span class="hljs-type">int</span> jj=j&gt;m? j-m:j;
			<span class="hljs-keyword">if</span>(c[jj]==<span class="hljs-number">0</span>) ++a, j+=k<span class="hljs-number">-1</span>;
		&#125;
		res=<span class="hljs-built_in">min</span>(res,a);
	&#125;
	ans+=res;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		to[x]=y, ++in[y];
	&#125;
	<span class="hljs-built_in">toposort</span>();
	<span class="hljs-built_in">getcir</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-built_in">solve</span>(i);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);
&#125;</code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Record/" class="category-chain-item">Record</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%9B%BE%E8%AE%BA/" class="print-no-link">#图论</a> <a href="/tags/DP/" class="print-no-link">#DP</a> <a href="/tags/%E8%AE%A1%E6%95%B0/" class="print-no-link">#计数</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="print-no-link">#博弈论</a> <a href="/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/" class="print-no-link">#基环树</a></div></div><div class="license-box my-3"><div class="license-title"><div>「NOIP Record」#2 基环树</div><div>https://yozora0908.github.io/2023/noip-record-2/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>yozora0908</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年5月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/noip-record-3/" title="「NOIP Record」#3 Trie"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">「NOIP Record」#3 Trie</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/noip-record-1/" title="「NOIP Record」#1 树形DP（1）"><span class="hidden-mobile">「NOIP Record」#1 树形DP（1）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"yozora0908/MyGiscus","repo-id":"R_kgDOKLq9Ag","category":"General","category-id":"DIC_kwDOKLq9As4CY38d","theme-light":"light_protanopia","theme-dark":"dark_dimmed","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","loading":"lazy"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light_protanopia';
        var dark = 'dark_dimmed';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.staticfile.org/jquery/3.7.0/jquery.min.js"></script><script src="https://cdn.staticfile.org/bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://cdn.staticfile.org/tocbot/4.21.1/tocbot.min.js",function(){var t,i=jQuery("#toc");0!==i.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<i.find(".toc-list-item").length&&i.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://cdn.staticfile.org/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://cdn.staticfile.org/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>