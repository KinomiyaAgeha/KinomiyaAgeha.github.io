<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><link rel="icon" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#1749d1"><meta name="author" content="yozora0908"><meta name="keywords" content="OI"><meta name="description" content="多项式哈希 把元素看作数字，把哈希对象看作关于 \(P\) 的多项式，得到多项式哈希，亦称为进制哈希。 主要用于有序对象的哈希。 一般使用unsigned long long自然溢出，相当于对 \(2^{64}\) 取模。 关于 \(P\) 的选取，尽量避免常用的大质数。下文统一使用1610612741，其在 \([2^{30},2^{31}]\) 中。 单哈希的话很简单。 vo"><title>「NOIP Record」#4 多项式哈希与异或哈希 - yozora0908&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"yozora0908.github.io",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"always",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#0076FF",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:null,onlypost:!0,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!1,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="yozora0908's blog" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>yozora0908&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn-us.imgs.moe/2023/02/02/63db75d1e0be8.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="「NOIP Record」#4 多项式哈希与异或哈希"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-05-07 20:46" pubdate>2023年5月7日 晚上</time></span></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">「NOIP Record」#4 多项式哈希与异或哈希</h1><div class="markdown-body"><h2 id="多项式哈希">多项式哈希</h2><p>把元素看作数字，把哈希对象看作关于 <span class="math inline">\(P\)</span> 的多项式，得到多项式哈希，亦称为进制哈希。</p><p>主要用于有序对象的哈希。</p><p>一般使用<code>unsigned long long</code>自然溢出，相当于对 <span class="math inline">\(2^{64}\)</span> 取模。</p><p>关于 <span class="math inline">\(P\)</span> 的选取，尽量避免常用的大质数。下文统一使用<code>1610612741</code>，其在 <span class="math inline">\([2^{30},2^{31}]\)</span> 中。</p><p>单哈希的话很简单。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">geth</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;
	n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) h[i]=h[i<span class="hljs-number">-1</span>]*P+S[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;
&#125;</code></pre></div><h3 id="区间哈希">区间哈希</h3><p><span class="math inline">\(h_r\)</span> 为 <span class="math inline">\([1,r]\)</span> 的哈希值。如何得到 <span class="math inline">\([l,r]\)</span> 的哈希值？在 <span class="math inline">\(h_r\)</span> 中，<span class="math inline">\(h_{l-1}\)</span> 乘了 <span class="math inline">\(r-l+1\)</span> 个 <span class="math inline">\(P\)</span> 且与 <span class="math inline">\([l,r]\)</span> 中的元素无关，因此 <span class="math display">\[ h_{l,r} = h_r - h_{l-1} \cdot P^{r-l+1} \]</span> 预处理 <span class="math inline">\(P\)</span> 的幂次即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">uint <span class="hljs-title">getlr</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*PP[r-l+<span class="hljs-number">1</span>];
&#125;</code></pre></div><h3 id="删除操作">删除操作</h3><p>询问 <span class="math inline">\([l,r]\)</span> 中删去位置 <span class="math inline">\(k\)</span> 上的字符后，<span class="math inline">\([l,r]\)</span> 的哈希值。</p><p>删掉 <span class="math inline">\(k\)</span>，那么 <span class="math inline">\([k+1,r]\)</span> 的字符就会向左移动一位。</p><p>考虑两个子串拼凑成的串的哈希值如何由它们二者得到。只要把 <span class="math inline">\([l,k-1]\)</span> 右移到 <span class="math inline">\(r\)</span> 的位置，做加法即可。移动的距离是 <span class="math inline">\(r-1-(k-1)=r-k\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">uint <span class="hljs-title">getdel</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span> </span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">getlr</span>(l,k<span class="hljs-number">-1</span>)*P[r-k]+<span class="hljs-built_in">getlr</span>(k+<span class="hljs-number">1</span>,r);
&#125;</code></pre></div><h3 id="应用">应用</h3><p>这个能干啥呢？</p><p>可以求 <span class="math inline">\(\texttt{palindrome}\)</span>，<span class="math inline">\(\texttt{border}\)</span>，<span class="math inline">\(\texttt{LCP}\)</span> 啥的小东西，复杂度一般接近那些算法，也就是一定程度上代替部分字符串算法。</p><p>但是不展开讲了。</p><h3 id="luogu7469-noi-online-2021-提高组-积木小赛">luogu7469 [NOI Online 2021 提高组] 积木小赛</h3><blockquote><p>给定两个长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(S,T\)</span>，求 <span class="math inline">\(T\)</span> 中一段区间与 <span class="math inline">\(S\)</span> 的任意子序列的匹配数量。两个匹配不同当且仅当字符串本质不同。</p><p><span class="math inline">\(n \le 3000\)</span>。</p></blockquote><p>预处理一个东西，<span class="math inline">\(nxt_{i,j}\)</span> 表示 <span class="math inline">\(S[i+1,n]\)</span> 中最靠左的字符 <span class="math inline">\(j\)</span> 的下标。</p><p>枚举 <span class="math inline">\(T\)</span> 中的区间左端点 <span class="math inline">\(i\)</span>，按照 <span class="math inline">\(nxt_{i,j}\)</span> 扩展右端点即可。如果找不到要匹配的字符，就结束匹配。</p><p>对于去重，使用区间哈希即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3005</span>, P=<span class="hljs-number">1610612741</span>;
<span class="hljs-type">int</span> n, nxt[N][<span class="hljs-number">30</span>];
uint h[N], PP[N];
<span class="hljs-type">char</span> s[N], t[N];
vector&lt;uint&gt; ans;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>; &#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">geth</span><span class="hljs-params">()</span> </span>&#123;
	PP[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) PP[i]=PP[i<span class="hljs-number">-1</span>]*P, h[i]=h[i<span class="hljs-number">-1</span>]*P+<span class="hljs-built_in">id</span>(t[i]);
&#125;
<span class="hljs-function">uint <span class="hljs-title">getlr</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*PP[r-l+<span class="hljs-number">1</span>];
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,s+<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>);
	<span class="hljs-built_in">geth</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) nxt[n][i]=<span class="hljs-number">-1</span>;
	nxt[n][<span class="hljs-built_in">id</span>(s[n])]=n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) &#123;
		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) nxt[i][j]=nxt[i+<span class="hljs-number">1</span>][j];
		nxt[i][<span class="hljs-built_in">id</span>(s[i])]=i;
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;
		<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>, cnt=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;++j) &#123;
			<span class="hljs-keyword">if</span>(nxt[pos][<span class="hljs-built_in">id</span>(t[j])]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;
			pos=nxt[pos][<span class="hljs-built_in">id</span>(t[j])]+<span class="hljs-number">1</span>;
			ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">getlr</span>(i,j));
			++cnt;
			<span class="hljs-keyword">if</span>(pos&gt;n) <span class="hljs-keyword">break</span>;
		&#125;
	&#125;
	<span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;
	<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ans.<span class="hljs-built_in">size</span>();++i) <span class="hljs-keyword">if</span>(ans[i]!=ans[i<span class="hljs-number">-1</span>]) ++cnt;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,cnt);
&#125;</code></pre></div><h3 id="luogu7114-noip2020-字符串匹配">luogu7114 [NOIP2020] 字符串匹配</h3><p>NOIP 多少年来第一道字符串题。<del>也希望是最后一道</del>。</p><p>这里采用哈希做法。</p><p>枚举 <span class="math inline">\(i\)</span>，表示 <span class="math inline">\(AB = S[1,i]\)</span>。然后倍增地找到最大的 <span class="math inline">\(k\)</span>，满足 <span class="math inline">\((AB)^q\)</span> 合法，设 <span class="math inline">\((AB)^q = S[1,p]\)</span>。</p><p>那么 <span class="math inline">\(C\)</span> 一定是 <span class="math inline">\(S[p+1,n]\)</span> 前面有奇数个或偶数个 <span class="math inline">\(AB\)</span>。不难发现有偶数个 <span class="math inline">\(AB\)</span> 时，其 <span class="math inline">\(F\)</span> 值必然相同，因此只需要多考虑奇数个的情况，取 <span class="math inline">\(S[p-i+1,n]\)</span> 即可。</p><p>对于一个 <span class="math inline">\((p,q)\)</span>，放偶数个 <span class="math inline">\(AB\)</span> 的情况有 <span class="math inline">\(c_0=\lceil \frac{q}{2} \rceil\)</span> 种，奇数个有 <span class="math inline">\(c_1=q-c_0\)</span> 种。注意特判 <span class="math inline">\(p=n\)</span> 时，不能放 <span class="math inline">\(0\)</span> 个 <span class="math inline">\(AB\)</span>，所以此时 <span class="math inline">\(c_0\)</span> 减去 <span class="math inline">\(1\)</span>，后缀需要取 <span class="math inline">\(S[p-2i+1]\)</span>。还可能存在 <span class="math inline">\(p-2i+1&lt;i\)</span>，这是不合法的。</p><p>设放偶数个 <span class="math inline">\(AB\)</span> 对应的 <span class="math inline">\(F\)</span> 值为 <span class="math inline">\(p_0\)</span>，奇数个为 <span class="math inline">\(p_1\)</span>。贡献就是 <span class="math display">\[ c_0 \times \sum_{j=1}^{i-1} [F(S[1,j])\le p_0] + c_1 \times \sum_{j=1}^{i-1}[F(S[1,j]) \le p_1] \]</span> 树状数组维护即可。复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><p>比 <span class="math inline">\(z\)</span> 函数做法慢很多，但是好想且不容易写错。另外还存在哈希+调和级数枚举做法，但是笔者把这份倍增代码改为上述做法后，在洛谷上 TLE 了。可能是人傻常数大吧。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1048580</span>;
<span class="hljs-type">const</span> uint P=<span class="hljs-number">1610612741</span>;
<span class="hljs-type">int</span> T, n, ans, c[<span class="hljs-number">30</span>], pre[N], suf[N], pos[N];
uint h[N], PP[N], f[N][<span class="hljs-number">21</span>];
<span class="hljs-type">char</span> s[N];
<span class="hljs-function">uint <span class="hljs-title">getlr</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*PP[r-l+<span class="hljs-number">1</span>];
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;
	<span class="hljs-type">int</span> c[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
		++x;
		<span class="hljs-keyword">for</span>(;x&lt;=n+<span class="hljs-number">1</span>;x+=x&amp;-x) c[x]+=y;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;
		++x;
		<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];
		<span class="hljs-keyword">return</span> y;
	&#125;
&#125; Tr;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">iinit</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>);
	pre[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, ++c[s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];
	h[<span class="hljs-number">1</span>]=s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;
	PP[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, PP[<span class="hljs-number">1</span>]=P;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;
		h[i]=h[i<span class="hljs-number">-1</span>]*P+(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>);
		PP[i]=PP[i<span class="hljs-number">-1</span>]*P;
		<span class="hljs-keyword">if</span>(c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) pre[i]=pre[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;
		<span class="hljs-keyword">else</span> pre[i]=pre[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;
		++c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];
	&#125;
	<span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>);
	suf[n]=<span class="hljs-number">1</span>, ++c[s[n]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) &#123;
		<span class="hljs-keyword">if</span>(c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) suf[i]=suf[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;
		<span class="hljs-keyword">else</span> suf[i]=suf[i+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;
		++c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];
		f[i][<span class="hljs-number">0</span>]=h[i];
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;++j) &#123;
			f[i][j]=f[i][j<span class="hljs-number">-1</span>]*(PP[i*(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))]+<span class="hljs-number">1</span>);
			<span class="hljs-keyword">if</span>(i*(<span class="hljs-number">1</span>&lt;&lt;(j+<span class="hljs-number">1</span>))&gt;n) pos[i]=j;
		&#125;
	&#125;
&#125;
<span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;
	<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>, q=<span class="hljs-number">0</span>, j=pos[i];
	<span class="hljs-keyword">for</span>(;~j;--j) &#123;
		<span class="hljs-type">int</span> t=i*(<span class="hljs-number">1</span>&lt;&lt;j);
		<span class="hljs-keyword">if</span>(p+t&gt;n) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span>(f[i][j]==<span class="hljs-built_in">getlr</span>(p+<span class="hljs-number">1</span>,p+t)) p+=t, q|=<span class="hljs-number">1</span>&lt;&lt;j;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(p,q);
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	ans=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);
	n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);
	<span class="hljs-built_in">memset</span>(Tr.c,<span class="hljs-number">0</span>,(n+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);
	<span class="hljs-built_in">iinit</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n<span class="hljs-number">-1</span>) &#123;
		Tr.<span class="hljs-built_in">insert</span>(pre[i<span class="hljs-number">-1</span>],<span class="hljs-number">1</span>);
		pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; t=<span class="hljs-built_in">calc</span>(i);
		<span class="hljs-type">int</span> p=t.first, q=t.second;
		<span class="hljs-type">int</span> c0=(q+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, c1=q-c0;
		<span class="hljs-type">int</span> p0=suf[p+<span class="hljs-number">1</span>], p1=suf[p-i+<span class="hljs-number">1</span>];
		<span class="hljs-keyword">if</span>(p==n) &#123;
			--c0;
			<span class="hljs-keyword">if</span>(p<span class="hljs-number">-2</span>*i&gt;=i) p0=suf[p<span class="hljs-number">-2</span>*i+<span class="hljs-number">1</span>];
			<span class="hljs-keyword">else</span> p0=<span class="hljs-number">0</span>;
		&#125;
		ans+=c0*Tr.<span class="hljs-built_in">query</span>(p0)+c1*Tr.<span class="hljs-built_in">query</span>(p1);
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	T=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();
&#125;</code></pre></div><h3 id="luogu9399-dboiround-1-人生如树">luogu9399 「DBOI」Round 1 人生如树</h3><p>由于多项式哈希基于多项式，所以它满足多项式运算的性质，且它基于有序结构，能保证元素的顺序。</p><p>对于一个询问，如果我们能把路径上的点的哈希值搞出来，那么就能判断 <span class="math inline">\(H(b) - H(a)\)</span> 与 <span class="math inline">\(H(\{1,2,\ldots \})\)</span> 是否相等，进而回答询问。直接都弄出来是做不了的，可以二分长度。</p><p>考虑到效率问题，我们要用倍增维护树上哈希值。对于一个 <span class="math inline">\(x\)</span>，如果只维护倍增时以它为 <span class="math inline">\(0\)</span> 次项的信息，那么我们很难把到 <span class="math inline">\(\operatorname{LCA}\)</span> 的两条路径接起来，因此要额外维护一个以 <span class="math inline">\(x\)</span> 为最高次项的时候的信息。最高此项可以在倍增合并时往后推。</p><p>有一个问题，如果把起点 <span class="math inline">\(x\)</span> 当作 <span class="math inline">\(0\)</span> 次项，那么在从 <span class="math inline">\(y\)</span> 那一条链上倍增时必须让这条链上的次数从下往上递减，这又会造成 <span class="math inline">\(z=\operatorname{LCA}(x,y)\)</span> 下面那个点的次数比 <span class="math inline">\(z\)</span> 的次数大，从而涉及除法。</p><p>解决方案是把 <span class="math inline">\(x\)</span> 当作最后一项，这样 <span class="math inline">\(z\)</span> 下面那个点的次数一定是 <span class="math inline">\(1\)</span>。</p><p>同时自然数序列的哈希值 <span class="math display">\[ h_n = \sum_{i=1}^n i \times P^{n-i} \]</span> <del>这是个卷积</del>。</p><p>考虑 <span class="math inline">\(h_n\)</span> 的生成函数 <span class="math inline">\(H(n)\)</span>， 能发现 <span class="math display">\[ H(n) = \frac{1}{(1-x)^2} \frac{x}{1-Px} \]</span> 对 <span class="math inline">\(\Big \langle 0,1,P,P^2,P^3 \ldots \Big\rangle\)</span> 做两遍前缀和即可。</p><p>注意到修改只会添加叶子，对询问没有影响，直接离线。</p><p>注意查询的细节。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">const</span> uint BASE=<span class="hljs-number">1610612741</span>;
<span class="hljs-type">int</span> n, m, s, idx, w[N], dep[N], f[N][<span class="hljs-number">20</span>];
<span class="hljs-type">int</span> x1, y11, x2, y2, z1, z2;
vector&lt;<span class="hljs-type">int</span>&gt; p[N];
uint g[<span class="hljs-number">2</span>][N][<span class="hljs-number">20</span>], pw[N], res[N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span> &#123;
	<span class="hljs-type">int</span> x1, y1, x2, y2;
&#125;;
vector&lt;Q&gt; q;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
	pw[<span class="hljs-number">0</span>]=res[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, res[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,s) pw[i]=pw[i<span class="hljs-number">-1</span>]*BASE;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,s) res[i]=res[i<span class="hljs-number">-1</span>]+pw[i<span class="hljs-number">-1</span>];
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,s) res[i]+=res[i<span class="hljs-number">-1</span>];
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;
	f[x][<span class="hljs-number">0</span>]=fa, dep[x]=dep[fa]+<span class="hljs-number">1</span>;
	g[<span class="hljs-number">0</span>][x][<span class="hljs-number">0</span>]=g[<span class="hljs-number">1</span>][x][<span class="hljs-number">0</span>]=w[x];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">18</span>&amp;&amp;f[x][i<span class="hljs-number">-1</span>];++i) &#123;
		f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];
		g[<span class="hljs-number">0</span>][x][i]=g[<span class="hljs-number">0</span>][x][i<span class="hljs-number">-1</span>]*pw[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)]+g[<span class="hljs-number">0</span>][f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];
        <span class="hljs-comment">// x在(2^i-1)次项</span>
		g[<span class="hljs-number">1</span>][x][i]=g[<span class="hljs-number">1</span>][x][i<span class="hljs-number">-1</span>]+g[<span class="hljs-number">1</span>][f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]*pw[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)];
        <span class="hljs-comment">// x在0次项</span>
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;
	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];
	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];
	<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];
&#125;
<span class="hljs-function">uint <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> d)</span> </span>&#123;
	uint ans=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(d&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)&amp;&amp;dep[x]-dep[z]+<span class="hljs-number">1</span>&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;
		ans=g[<span class="hljs-number">0</span>][x][i]+ans*pw[<span class="hljs-number">1</span>&lt;&lt;i];
		d-=(<span class="hljs-number">1</span>&lt;&lt;i), x=f[x][i];
	&#125;
	<span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[y]-dep[z]&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)+d) y=f[y][i];
        <span class="hljs-comment">// 跳到足够高的位置</span>
		vector&lt;PII&gt; v;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(d&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)&amp;&amp;dep[y]-dep[z]&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;
            <span class="hljs-comment">// 这条链的开头是z在y这条链的儿子处</span>
		    d-=(<span class="hljs-number">1</span>&lt;&lt;i);
			v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">MP</span>(g[<span class="hljs-number">1</span>][y][i],<span class="hljs-number">1</span>&lt;&lt;i)), y=f[y][i];
		&#125;
		<span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v) ans=t.fi+ans*pw[t.se];
	&#125;
	<span class="hljs-keyword">return</span> ans;
&#125;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x2,y2,z2,x)-<span class="hljs-built_in">get</span>(x1,y11,z1,x)!=res[x]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=s=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), idx=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);
	&#125;
	<span class="hljs-keyword">while</span>(m--) &#123;
		<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) &#123;
			<span class="hljs-type">int</span> x1=<span class="hljs-built_in">read</span>(), y1=<span class="hljs-built_in">read</span>(), x2=<span class="hljs-built_in">read</span>(), y2=<span class="hljs-built_in">read</span>();
			q.<span class="hljs-built_in">pb</span>((Q)&#123;x1,y1,x2,y2&#125;);
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-type">int</span> u=<span class="hljs-built_in">read</span>(), ww=<span class="hljs-built_in">read</span>();
			++s, w[s]=ww, p[u].<span class="hljs-built_in">pb</span>(s), p[s].<span class="hljs-built_in">pb</span>(u);
		&#125;
	&#125;
	<span class="hljs-built_in">init</span>();
	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:q) &#123;
		x1=t.x1, y11=t.y1, x2=t.x2, y2=t.y2;
		z1=<span class="hljs-built_in">lca</span>(x1,y11), z2=<span class="hljs-built_in">lca</span>(x2,y2);
		<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-built_in">min</span>(dep[x1]+dep[y11]<span class="hljs-number">-2</span>*dep[z1],dep[x2]+dep[y2]<span class="hljs-number">-2</span>*dep[z2])+<span class="hljs-number">1</span>;
		<span class="hljs-keyword">while</span>(l&lt;r) &#123;
			<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;
		&#125;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);
	&#125;
&#125;</code></pre></div><h2 id="异或哈希">异或哈希</h2><p>异或哈希，一种 Trick。</p><p>主要用于无序对象的哈希。</p><p>异或哈希一般使用随机权值，同时用异或运算作为链接不同哈希结构之间的桥梁。</p><p>相比于按位与、按位或运算，异或运算有着如下优势。</p><ol type="1"><li>大规模与运算后 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 的数量比接近 <span class="math inline">\(1 : 3\)</span>，或运算反之。而异或运算接近 <span class="math inline">\(1 : 1\)</span>。</li><li>异或运算的逆运算是异或运算，这意味着容易得到若干子段的信息。</li></ol><p>相比于多项式哈希，它更不容易被卡，且其本身的碰撞概率也相当小。</p><p>异或本身能做关于奇偶的一些东西以及「截取子段操作」，而异或哈希的主要作用是解决<strong>无序</strong>元素的<strong>存在性问题</strong>。</p><h3 id="abc250e-prefix-equality">ABC250E Prefix Equality</h3><blockquote><p>给定长度为 <span class="math inline">\(n\)</span> 的两个序列 <span class="math inline">\(a,b\)</span>，<span class="math inline">\(q\)</span> 个询问。每次询问 <span class="math inline">\(a\)</span> 的前 <span class="math inline">\(x\)</span> 项与 <span class="math inline">\(b\)</span> 的前 <span class="math inline">\(y\)</span> 项，扔进两个不可重集合中后，两个集合是否相同。</p><p><span class="math inline">\(n,q \le 2 \times 10^5\)</span>，<span class="math inline">\(a_i,b_i \in [1,10^9]\)</span>。</p></blockquote><p>给每个元素 <span class="math inline">\(k\)</span> 一个随机权值 <span class="math inline">\(h_k\)</span>。然后对于每个 <span class="math inline">\([1,i]\)</span>，求出 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 中，只出现了一次的数的权值异或和。这样就能 <span class="math inline">\(O(1)\)</span> 回答询问了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, BASE=<span class="hljs-number">13331</span>;
<span class="hljs-type">int</span> n, m, q, cnt, a[N], b[N], t[N&lt;&lt;<span class="hljs-number">1</span>];
<span class="hljs-type">unsigned</span> aa[N], bb[N];
unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p, pa, pb;
<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;
<span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;
	<span class="hljs-keyword">return</span> c;
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		a[i]=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(p[a[i]]==<span class="hljs-number">0</span>) p[a[i]]=<span class="hljs-built_in">rd</span>();
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		b[i]=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(p[b[i]]==<span class="hljs-number">0</span>) p[b[i]]=<span class="hljs-built_in">rd</span>();
	&#125;
	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sa=<span class="hljs-number">0</span>, sb=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;
		<span class="hljs-keyword">if</span>(++pa[a[i]]==<span class="hljs-number">1</span>) pa[a[i]]=<span class="hljs-number">1</span>, sa^=p[a[i]];
		<span class="hljs-keyword">if</span>(++pb[b[i]]==<span class="hljs-number">1</span>) pb[b[i]]=<span class="hljs-number">1</span>, sb^=p[b[i]];
		aa[i]=sa, bb[i]=sb;
	&#125;
	q=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(q--) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		<span class="hljs-built_in">puts</span>(aa[x]==bb[y]? <span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>);
	&#125;
&#125;</code></pre></div><h3 id="某模拟赛题">某模拟赛题</h3><blockquote><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，带边权。对于一个点对 <span class="math inline">\((u,v)\)</span>，可以生成如下游戏：提取二者路径上的所有边权到一个可重集合 <span class="math inline">\(S\)</span>，执行两个步骤。</p><ol type="1"><li><p>先手第一次取走一个数。</p></li><li><p>记上一个人取走的数的值为 <span class="math inline">\(x\)</span>，当前的人需要从 <span class="math inline">\(S\)</span> 中取走一个不大于 <span class="math inline">\(x\)</span> 的数。不能进行操作的人输。</p></li></ol><p>问有多少无序点对满足先手必胜。</p><p><span class="math inline">\(n \le 5 \times 10^5\)</span>。</p></blockquote><p>先手必胜的充要条件是存在一种边权出现了奇数次，容易归纳证明。</p><p>给每个边权一个随机权值，求出根到 <span class="math inline">\(x\)</span> 的路径异或和 <span class="math inline">\(d_x\)</span>，这样就能把两点之间的路径拆成从根出发的两条路径，如果 <span class="math inline">\(d_x \neq d_y\)</span>，那么 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 路径上一定存在出现奇数次的边权。</p><p>直接随机数竟然过不去……</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, BASE=<span class="hljs-number">13331</span>;
<span class="hljs-type">int</span> T, n, cnt;
<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];
<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w[N&lt;&lt;<span class="hljs-number">1</span>], d[N];
unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp, p;
<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z)</span> </span>&#123;
	to[++tot]=y, nxt[tot]=h[x], w[tot]=z, h[x]=tot;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v)</span> </span>&#123;
	d[x]=d[fa]^v;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;
		<span class="hljs-type">int</span> y=to[i];
		<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs</span>(y,x,w[i]);
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>();
	tot=cnt=<span class="hljs-number">0</span>;
	p.<span class="hljs-built_in">clear</span>(), mp.<span class="hljs-built_in">clear</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(z)) z=mp[z];
		<span class="hljs-keyword">else</span> mp[z]=<span class="hljs-built_in">rd</span>()*(z+BASE), z=mp[z];
		<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);
	&#125;
	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ++p[d[i]];
	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans+=n-p[d[i]];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/<span class="hljs-number">2</span>);
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();
&#125;</code></pre></div><h3 id="nc51463-graph-games">NC51463 Graph Games</h3><p>给每个点一个随机权值 <span class="math inline">\(w_x\)</span>，然后就能得到与点 <span class="math inline">\(x\)</span> 相邻的点的异或和 <span class="math inline">\(v_x\)</span>。</p><p>区间改不好搞，考虑分块。设 <span class="math inline">\(d(i,x)\)</span> 为第 <span class="math inline">\(i\)</span> 块内关于 <span class="math inline">\(x\)</span> 的异或和，整块对 <span class="math inline">\(d\)</span> 打 tag，散块改 <span class="math inline">\(v\)</span>，过程是平凡的。</p><p>最终 <span class="math inline">\(x\)</span> 的信息就是 <span class="math inline">\(v_x\)</span> 异或上所有有 tag 的 <span class="math inline">\(d(i,x)\)</span>。</p><p>正确性显然。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned int</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> T, n, m, q, a[M];
<span class="hljs-type">int</span> t, block, pos[M], L[<span class="hljs-number">450</span>], R[<span class="hljs-number">450</span>], tag[<span class="hljs-number">450</span>];
uint v[N], w[N], d[<span class="hljs-number">450</span>][N];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;
	<span class="hljs-type">int</span> x, y;
&#125; e[M];
<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-type">int</span> p=pos[l], q=pos[r];
	<span class="hljs-keyword">if</span>(p==q) &#123;
		<span class="hljs-built_in">rep</span>(i,l,r) &#123;
			<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;
			v[x]^=w[y], v[y]^=w[x];
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-built_in">rep</span>(i,p+<span class="hljs-number">1</span>,q<span class="hljs-number">-1</span>) tag[i]^=<span class="hljs-number">1</span>;
	<span class="hljs-built_in">rep</span>(i,l,R[p]) &#123;
		<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;
		v[x]^=w[y], v[y]^=w[x];
	&#125;
	<span class="hljs-built_in">rep</span>(i,L[q],r) &#123;
		<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;
		v[x]^=w[y], v[y]^=w[x];
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	block=<span class="hljs-built_in">sqrt</span>(m);
	t=m/block;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,t) L[i]=R[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>, R[i]=i*block;
	<span class="hljs-keyword">if</span>(R[t]&lt;m) ++t, L[t]=R[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>, R[t]=m;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,t) &#123;
		tag[i]=<span class="hljs-number">0</span>;
		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) d[i][j]=<span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">rd</span>(), v[i]=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		e[i].x=<span class="hljs-built_in">read</span>(), e[i].y=<span class="hljs-built_in">read</span>();
		<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;
		v[x]^=w[y];
		v[y]^=w[x];
		pos[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;
		d[pos[i]][x]^=w[y];
		d[pos[i]][y]^=w[x];
	&#125; 
	q=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(q--) &#123;
		<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) <span class="hljs-built_in">modify</span>(l,r);
		<span class="hljs-keyword">else</span> &#123;
			<span class="hljs-type">int</span> vx=v[l], vy=v[r];
			<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,t) &#123;
				<span class="hljs-keyword">if</span>(tag[i]) vx^=d[i][l], vy^=d[i][r];
			&#125;
			<span class="hljs-built_in">printf</span>(vx==vy? <span class="hljs-string">&quot;1&quot;</span>:<span class="hljs-string">&quot;0&quot;</span>);
		&#125;
	&#125;
	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
&#125;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	T=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();
&#125;</code></pre></div><h3 id="cf1175f-the-number-of-subpermutations">CF1175F The Number of Subpermutations</h3><blockquote><p>给定一个序列，求这个序列中有多少区间 <span class="math inline">\([l,r]\)</span> 是 <span class="math inline">\(1 \sim r-l+1\)</span> 的一个排列。</p><p><span class="math inline">\(n \le 3 \times 10^5\)</span>。</p></blockquote><p>给每个 <span class="math inline">\(i\)</span> 分配一个随机权值 <span class="math inline">\(h_i\)</span>，得到 <span class="math inline">\(base_i = \bigoplus_{j=1}^i h_i\)</span>，那么 <span class="math inline">\(base_i\)</span> 就是 <span class="math inline">\(1 \sim i\)</span> 的排列的哈希值。</p><p>一个排列中一定包含一个 <span class="math inline">\(1\)</span>。设 <span class="math inline">\(j\)</span> 为从上一个 <span class="math inline">\(1\)</span> 的位置到 <span class="math inline">\(i\)</span> 中的最大值，初始或遇到 <span class="math inline">\(a_i=1\)</span> 时，<span class="math inline">\(j=1\)</span>。如果 <span class="math inline">\(i \ge j\)</span> 并且 <span class="math inline">\(\bigoplus_{k=i-j+1}^i h_{a_k} = base_j\)</span>，那么说明 <span class="math inline">\([i-j+1,i]\)</span> 是一个排列。</p><p>这样只得到了排列的最大值在 <span class="math inline">\(1\)</span> 右边的情况。反过来再枚举一遍即可。</p><p>注意如果 <span class="math inline">\(a_i=1\)</span>，那么 <span class="math inline">\([i,i]\)</span> 也是排列。</p><h3 id="cf1746f-kazaee">CF1746F Kazaee</h3><blockquote><p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，<span class="math inline">\(q\)</span> 个操作。</p><ol type="1"><li>单点修改</li><li>询问区间 <span class="math inline">\([l,r]\)</span> 中每个数出现的次数是否都是 <span class="math inline">\(k\)</span> 的倍数。</li></ol><p><span class="math inline">\(n,q \le 3 \times 10^5\)</span>，<span class="math inline">\(a_i \in [1,10^9]\)</span>。</p></blockquote><p>先把 <span class="math inline">\(a\)</span> 离散化了，然后考虑给 <span class="math inline">\(a_i\)</span> 一个随机权值 <span class="math inline">\(h_{a_i}\)</span>。</p><p>设 <span class="math inline">\(S=\sum_{i=l}^r h_{a_i}\)</span>，那么也有 <span class="math inline">\(S = \sum_{x \in a[l,r]} cnt_x \times h_x\)</span>。根据一点数论知识，能得到 <span class="math inline">\(k \mid S\)</span> 是答案为<code>YES</code>的一个必要条件为什么不充分呢？因为如果存在一个 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(k \mid h_x\)</span>，其他的都是 <span class="math inline">\(k \mid cnt_x\)</span>，那么也能使得 <span class="math inline">\(k \mid S\)</span>。这是由于哈希的不稳定性导致的。</p><p>解决方法是把询问离线了然后多哈希几次。</p><h3 id="cf869e-the-untended-antiquity">CF869E The Untended Antiquity</h3><blockquote><p>给定一个 <span class="math inline">\(n \times m\)</span> 的网格图，有 <span class="math inline">\(q\)</span> 次操作。</p><ol type="1"><li>在左上角为 <span class="math inline">\((x_1,y_1)\)</span>，右下角为 <span class="math inline">\((x_2,y_2)\)</span> 的矩形四边上修建围墙。</li><li>删除左上角为 <span class="math inline">\((x_1,y_1)\)</span>，右下角为 <span class="math inline">\((x_2,y_2)\)</span> 的矩形四边上修建围墙。保证此围墙存在。</li><li>查询从 <span class="math inline">\((x_1,y_1)\)</span> 出发是否存在路径，满足不跨越任何围墙就能到达 <span class="math inline">\((x_2,y_2)\)</span>。</li></ol><p><strong>保证围墙无重合处。</strong></p><p><span class="math inline">\(n,m \le 2500\)</span>，<span class="math inline">\(q \le 10^5\)</span>。</p></blockquote><p>如果能够到达，那么 <span class="math inline">\((x_1,y_1)\)</span> 与 <span class="math inline">\((x_2,y_2)\)</span> 一定在同一个围墙内（把整个网格图外围也看做有围墙），否则一定不能。</p><p>对于一个围墙，给它一个随机权值，用二维差分的方式做区间异或。只要查询 <span class="math inline">\((x_1,y_1)\)</span> 与 <span class="math inline">\((x_2,y_2)\)</span> 的前缀异或值是否相等，就能判断是否有围墙包含了二者其中之一。</p><h3 id="luogu4065-jxoi2017颜色">luogu4065 [JXOI2017]颜色</h3><p>对于一种颜色 <span class="math inline">\(c\)</span>，将所有 <span class="math inline">\(a_i=c\)</span> 的位置 <span class="math inline">\(i\)</span> 都随机映射一个权值，特别地，最靠右的 <span class="math inline">\(i\)</span> 的权值是前面的异或和。</p><p>这样直接扫一遍，记录当前 <span class="math inline">\(i\)</span> 的异或和 <span class="math inline">\(S\)</span>，如果之前也存在异或和为 <span class="math inline">\(S\)</span> 的一个 <span class="math inline">\(j\)</span>，那么 <span class="math inline">\([j+1,i]\)</span> 就是一段异或和为 <span class="math inline">\(0\)</span> 的区间。根据上文的讨论可知，如果异或和为 <span class="math inline">\(0\)</span>，那么这一段中的颜色 <span class="math inline">\(c\)</span> 一定满足不存在 <span class="math inline">\(a_k=c\)</span> 使得 <span class="math inline">\(k\le j\)</span> 或 <span class="math inline">\(k &gt; i\)</span>，是满足条件的。</p><p>维护一个<code>std::unordered_map</code>即可。</p><p>与上题相同，是利用异或差分与异或前缀和来完成类似区间覆盖的操作。</p><h3 id="luogu8819-csp-s-2022-星战">luogu8819 [CSP-S 2022] 星战</h3><blockquote><p>给定一个 <span class="math inline">\(n\)</span> 点 <span class="math inline">\(m\)</span> 边的有向图，有 <span class="math inline">\(q\)</span> 次操作。</p><ol type="1"><li>删掉一条边 <span class="math inline">\((u,v)\)</span>，保证这条边存在。</li><li>删掉 <span class="math inline">\(u\)</span> 所有的入边。</li><li>添加一条边 <span class="math inline">\((u,v)\)</span>，保证这条边是曾经存在且被删掉的。</li><li>添加 <span class="math inline">\(u\)</span> 所有被删掉且此时不存在的入边。</li></ol><p>每次操作后，询问这张图是不是一个内向树森林。</p><p><span class="math inline">\(n,m,q \le 5 \times 10^5\)</span>。</p></blockquote><p>考虑什么时候一张图是内向树森林。</p><p>发现这玩意没啥强力的性质……</p><ol type="1"><li><span class="math inline">\(n\)</span> 点 <span class="math inline">\(n\)</span> 边。</li><li>每个点有且仅有一条出边。</li><li>满足上述两个条件的有向图必然是内向树森林，证明是平凡的。也就是说这两个性质同时成立就充要了，可以考虑从这里下手。</li></ol><p>第一个条件容易维护，考虑第二个。</p><p>直接做会干到 <span class="math inline">\(O(nq)\)</span>。</p><p>深入思考，我们能发现如果满足第二个条件，那么每个点的入点集合 <span class="math inline">\(in_x\)</span> 之并就是 <span class="math inline">\(1 \sim n\)</span> 所有节点。而由于我们维护了第一个条件，所以这个条件只需要判掉一种情况：<span class="math inline">\(n\)</span> 点 <span class="math inline">\(n\)</span> 边，但是有节点没有出边。没有出边，这个点就一定不在 <span class="math inline">\(in_x\)</span> 的并里面。</p><p>如何快速维护这个东西？对每个点随即映射，使用异或哈希即可完成 <span class="math inline">\(O(1)\)</span> 改查。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;
		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;
		c=<span class="hljs-built_in">getchar</span>();
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">return</span> a*f;
&#125;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, q;
uint U, S, base[N], in[N], icnt[N], cui[N], ccnt[N];
<span class="hljs-comment">// base是随机权值，in是入点集合，icnt是入边数量</span>
<span class="hljs-comment">// cui是被摧毁的入点集合，ccnt是其数量</span>
<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) base[i]=(uint)<span class="hljs-built_in">rd</span>()*(i+<span class="hljs-built_in">rd</span>()), U^=base[i];
    <span class="hljs-comment">// U是1~n之并</span>
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;
		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();
		in[y]^=base[x], S^=base[x];
		++icnt[y];
	&#125;
	q=<span class="hljs-built_in">read</span>();
	<span class="hljs-keyword">while</span>(q--) &#123;
		<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>(), u=<span class="hljs-built_in">read</span>();
		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>||op==<span class="hljs-number">3</span>) &#123;
			<span class="hljs-type">int</span> v=<span class="hljs-built_in">read</span>();
			in[v]^=base[u], cui[v]^=base[u], S^=base[u];
			<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) --icnt[v], ++ccnt[v], --m; <span class="hljs-keyword">else</span> ++icnt[v], --ccnt[v], ++m;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) m-=icnt[u], cui[u]^=in[u], ccnt[u]+=icnt[u], S^=in[u], in[u]=<span class="hljs-number">0</span>, icnt[u]=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">else</span> m+=ccnt[u], icnt[u]+=ccnt[u], in[u]^=cui[u], S^=cui[u], cui[u]=<span class="hljs-number">0</span>, ccnt[u]=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span>(m==n&amp;&amp;S==U) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);
	&#125;
&#125;</code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Record/" class="category-chain-item">Record</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%A0%91%E8%AE%BA/" class="print-no-link">#树论</a> <a href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" class="print-no-link">#树上倍增</a> <a href="/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%93%88%E5%B8%8C/" class="print-no-link">#多项式哈希</a> <a href="/tags/%E5%BC%82%E6%88%96%E5%93%88%E5%B8%8C/" class="print-no-link">#异或哈希</a> <a href="/tags/%E5%88%86%E5%9D%97/" class="print-no-link">#分块</a></div></div><div class="license-box my-3"><div class="license-title"><div>「NOIP Record」#4 多项式哈希与异或哈希</div><div>https://yozora0908.github.io/2023/noip-record-4/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>yozora0908</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年5月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/noip-record-5/" title="「NOIP Record」#5 倍增"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">「NOIP Record」#5 倍增</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/noip-record-3/" title="「NOIP Record」#3 Trie"><span class="hidden-mobile">「NOIP Record」#3 Trie</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"yozora0908/MyGiscus","repo-id":"R_kgDOKLq9Ag","category":"General","category-id":"DIC_kwDOKLq9As4CY38d","theme-light":"light_protanopia","theme-dark":"dark_dimmed","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","loading":"lazy"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light_protanopia';
        var dark = 'dark_dimmed';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.staticfile.org/jquery/3.7.0/jquery.min.js"></script><script src="https://cdn.staticfile.org/bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://cdn.staticfile.org/tocbot/4.21.1/tocbot.min.js",function(){var t,i=jQuery("#toc");0!==i.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<i.find(".toc-list-item").length&&i.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://cdn.staticfile.org/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://cdn.staticfile.org/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>