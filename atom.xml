<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yozora0908&#39;s blog</title>
  
  <subtitle>φ(゜▽゜*)♪</subtitle>
  <link href="https://yozora0908.github.io/atom.xml" rel="self"/>
  
  <link href="https://yozora0908.github.io/"/>
  <updated>2023-09-06T22:51:36.566Z</updated>
  <id>https://yozora0908.github.io/</id>
  
  <author>
    <name>yozora0908</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LOJ#2331 某位歌姬的故事 题解</title>
    <link href="https://yozora0908.github.io/2023/loj2331-solution/"/>
    <id>https://yozora0908.github.io/2023/loj2331-solution/</id>
    <published>2023-09-06T22:35:04.000Z</published>
    <updated>2023-09-06T22:51:36.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="solution">Solution</h2><p>对于每个位置 <span class="math inline">\(i\)</span>，我们维护一个<span class="math inline">\(up_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 能填入的上界。这样每个限制 <spanclass="math inline">\((l,r,x)\)</span> 相当于让 <spanclass="math inline">\(i \in [l,r]\)</span> 的 <spanclass="math inline">\(up_i\)</span> 对 <spanclass="math inline">\(x\)</span> 取 <spanclass="math inline">\(\min\)</span>。</p><p>继续分析限制，发现它其实限制了两点：</p><ol type="1"><li><span class="math inline">\(\forall i \in [l,r]\)</span>，<spanclass="math inline">\(a_i \le x\)</span>。</li><li><span class="math inline">\(\exists i \in [l,r]\)</span>，<spanclass="math inline">\(a_i = x\)</span>。</li></ol><p><span class="math inline">\(up_i\)</span>已经保证了第一点，考虑如何满足第二点。</p><p>对于一个限制 <span class="math inline">\((l,r,x)\)</span>，能取到<span class="math inline">\(w\)</span> 的位置 <spanclass="math inline">\(k\)</span> 一定满足 <span class="math inline">\(k\in [l,r]\)</span> 并且 <span class="math inline">\(up_k =x\)</span>。但我们计数的序列要求本质不同，所以不能“钦定一个 <spanclass="math inline">\(a_k\)</span> 取 <spanclass="math inline">\(x\)</span> 然后剩下的随便选”，否则会出现重复。</p><p>仔细思考不难发现，<span class="math inline">\(up_i\)</span>不同的点是相对独立的。所以我们枚举每个 <spanclass="math inline">\(x\)</span>，把所有 <spanclass="math inline">\(up_i=x\)</span>的点提取出来，同时处理满足这些限制的方案数。</p><div class="note note-primary">            <p>注意，本来我们应该对于每个限制单独提取相应的点，但是这样需要维护区间信息，大大增加工作量。</p>          </div><p>把坐标离散化了，设 <span class="math inline">\(f(i,j)\)</span>为考虑了前 <span class="math inline">\(i\)</span> 个位置，其中上一个<span class="math inline">\(x\)</span> 的位置在 <spanclass="math inline">\(j\)</span> 的方案数。转移比较平凡，不再赘述。</p><p>但是本题最难处理的地方在于细节，下面简单列举。</p><ul><li><p>需要处理没有被限制区间覆盖到的点。</p></li><li><p>离散化后，DP前提取的是限制的端点，真正有贡献的则是夹在端点间的点。</p></li><li><p>提取的点之间，就算是被同一个限制覆盖，也可能是不连续的。</p></li><li><p>DP 转移时，如果要 <span class="math inline">\(f(i-1,j)\rightarrow f(i,j)\)</span>，那么必须要求 <spanclass="math inline">\(i-1\)</span> 与 <spanclass="math inline">\(i\)</span> 在同一个限制区间里。</p></li></ul><p>为了更好地处理区间边界问题，使用<strong>左闭右开</strong>。它的好处是离散化后任意两个坐标对应的值相减，都是区间内点的个数。</p><p>具体细节的处理见代码。</p><p>时间复杂度 <span class="math inline">\(\mathcal{O}(Q^3)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353ll</span>;<span class="hljs-type">int</span> T, n, q, A, up[N], L[N];<span class="hljs-type">int</span> cnt, t[N];<span class="hljs-type">int</span> cntx, x[N];<span class="hljs-type">int</span> lim, p[N];ll f[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r, x;&#125; a[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;ll c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=<span class="hljs-number">1ll</span>*a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">ll <span class="hljs-title">DP</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;lim=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-keyword">if</span>(up[i]==k) p[++lim]=i, L[lim]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) <span class="hljs-keyword">if</span>(a[i].x==k) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">lower_bound</span>(p+<span class="hljs-number">1</span>,p+lim+<span class="hljs-number">1</span>,a[i].l)-p;<span class="hljs-type">int</span> r=<span class="hljs-built_in">lower_bound</span>(p+<span class="hljs-number">1</span>,p+lim+<span class="hljs-number">1</span>,a[i].r)-p<span class="hljs-number">-1</span>;L[r]=<span class="hljs-built_in">max</span>(L[r],l);        <span class="hljs-comment">// 维护限制区间内最靠右边的点，对应的最靠右的能覆盖到它的左端点</span>&#125;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1ll</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i) &#123;f[i][i]=<span class="hljs-number">0</span>;ll k1=<span class="hljs-built_in">fp</span>(k,t[p[i]+<span class="hljs-number">1</span>]-t[p[i]]), k2=<span class="hljs-built_in">fp</span>(k<span class="hljs-number">-1</span>,t[p[i]+<span class="hljs-number">1</span>]-t[p[i]]);        <span class="hljs-comment">// 如果端点p[i]被x=k的端点覆盖了，那么[p[i],p[i+1])中的点就一定满足up=k</span>        <span class="hljs-comment">// k2是这一段的值都小于k的方案数</span>        <span class="hljs-comment">// k1是这一段的值都不能超过k的方案数</span>        <span class="hljs-comment">// 二者之差是至少存在一个k，都不能超过k的方案数</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) &#123;f[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L[i]&lt;=j) f[i][j]=f[i<span class="hljs-number">-1</span>][j]*k2%mod;            <span class="hljs-comment">// 如果i到达了某个限制区间最靠右的坐标，那么就必须要在这个限制区间内转移过来</span>            <span class="hljs-comment">// i每次增加1，所以能保证正确性</span>(f[i][i]+=f[i<span class="hljs-number">-1</span>][j]*(k1-k2+mod)%mod)%=mod;&#125;&#125;ll res=<span class="hljs-number">0ll</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i) (res+=f[lim][i])%=mod;<span class="hljs-keyword">return</span> res; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;cnt=cntx=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) &#123;a[i].l=<span class="hljs-built_in">read</span>(), a[i].r=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, a[i].x=<span class="hljs-built_in">read</span>();        <span class="hljs-comment">// 左闭右开</span>t[++cnt]=a[i].l, t[++cnt]=a[i].r;x[++cntx]=a[i].x;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;t[++cnt]=<span class="hljs-number">1</span>, t[++cnt]=n+<span class="hljs-number">1</span>;    <span class="hljs-comment">// 需要加入端点</span><span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>);cnt=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) up[i]=<span class="hljs-number">1e9</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) &#123;a[i].l=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>,a[i].l)-t;a[i].r=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>,a[i].r)-t;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a[i].l;j&lt;a[i].r;++j) up[j]=<span class="hljs-built_in">min</span>(up[j],a[i].x);        <span class="hljs-comment">// 把范围内的端点都覆盖了，注意左闭右开</span>&#125;<span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+cntx+<span class="hljs-number">1</span>);cntx=<span class="hljs-built_in">unique</span>(x+<span class="hljs-number">1</span>,x+cntx+<span class="hljs-number">1</span>)-(x+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">input</span>();<span class="hljs-built_in">lsh</span>();ll ans=<span class="hljs-number">1ll</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cntx;++i) &#123;(ans*=<span class="hljs-built_in">DP</span>(x[i]))%=mod;<span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>(up[i]==<span class="hljs-number">1e9</span>) &#123;        <span class="hljs-comment">// 最后仍然没有被覆盖到的端点</span>        <span class="hljs-comment">// 其实是某些右端点+1后的位置</span>(ans*=<span class="hljs-built_in">fp</span>(A,t[i+<span class="hljs-number">1</span>]-t[i]))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="题外话">题外话</h2><p>有很多细节，很难写。</p><p>但是可以退而求其次，不离散化，用这个做法对付 <spanclass="math inline">\(n \le 500\)</span> 的测试点也是绰绰有余。</p><p>不愧是集训队的题目，真是令人印象深刻啊。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;对于每个位置 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;，我们维护一个
&lt;span class=&quot;math inline&quot;&gt;&#92;(up_i&#92;)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 能填入的上界。这样每个限制 &lt;span class=&quot;math inline&quot;&gt;&#92;((l,r,x)&#92;)&lt;/span&gt; 相当于让 &lt;span class=&quot;math inline&quot;&gt;&#92;(i &#92;in [l,r]&#92;)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;&#92;(up_i&#92;)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 取 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;min&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;继续分析限制，发现它其实限制了两点：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;forall i &#92;in [l,r]&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(a_i &#92;le x&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;exists i &#92;in [l,r]&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(a_i = x&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(up_i&#92;)&lt;/span&gt;
已经保证了第一点，考虑如何满足第二点。&lt;/p&gt;
&lt;p&gt;对于一个限制 &lt;span class=&quot;math inline&quot;&gt;&#92;((l,r,x)&#92;)&lt;/span&gt;，能取到
&lt;span class=&quot;math inline&quot;&gt;&#92;(w&#92;)&lt;/span&gt; 的位置 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 一定满足 &lt;span class=&quot;math inline&quot;&gt;&#92;(k
&#92;in [l,r]&#92;)&lt;/span&gt; 并且 &lt;span class=&quot;math inline&quot;&gt;&#92;(up_k =
x&#92;)&lt;/span&gt;。但我们计数的序列要求本质不同，所以不能“钦定一个 &lt;span class=&quot;math inline&quot;&gt;&#92;(a_k&#92;)&lt;/span&gt; 取 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 然后剩下的随便选”，否则会出现重复。&lt;/p&gt;
&lt;p&gt;仔细思考不难发现，&lt;span class=&quot;math inline&quot;&gt;&#92;(up_i&#92;)&lt;/span&gt;
不同的点是相对独立的。所以我们枚举每个 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;，把所有 &lt;span class=&quot;math inline&quot;&gt;&#92;(up_i=x&#92;)&lt;/span&gt;
的点提取出来，同时处理满足这些限制的方案数。&lt;/p&gt;
&lt;div class=&quot;note note-primary&quot;&gt;
            &lt;p&gt;注意，本来我们应该对于每个限制单独提取相应的点，但是这样需要维护区间信息，大大增加工作量。&lt;/p&gt;
          &lt;/div&gt;
&lt;p&gt;把坐标离散化了，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,j)&#92;)&lt;/span&gt;
为考虑了前 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 个位置，其中上一个
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 的位置在 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt; 的方案数。转移比较平凡，不再赘述。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="计数" scheme="https://yozora0908.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LOJ#3267 Help Yourself 题解</title>
    <link href="https://yozora0908.github.io/2023/loj3267-solution/"/>
    <id>https://yozora0908.github.io/2023/loj3267-solution/</id>
    <published>2023-09-06T22:34:58.000Z</published>
    <updated>2023-09-06T22:48:51.037Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="help-yourself-gold">Help Yourself Gold</h2><p>考虑每条线段的贡献。</p><p>把所有线段按左端点排序，设 <span class="math inline">\(f(i)\)</span>为前 <span class="math inline">\(i\)</span> 条线段所有子集的贡献和。</p><ul><li>不选 <span class="math inline">\(i\)</span>，贡献是 <spanclass="math inline">\(f(i-1)\)</span>。</li><li>选 <span class="math inline">\(i\)</span>。设有 <spanclass="math inline">\(cnt\)</span> 条线段 <spanclass="math inline">\(j\)</span> 满足 <span class="math inline">\(r_j&lt; l_i\)</span>，那么当选出的线段子集是这些线段的子集时，贡献都会增加<span class="math inline">\(1\)</span>，否则不变。因此贡献是 <spanclass="math inline">\(f(i-1)+2^{cnt}\)</span>。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, pw[N], f[<span class="hljs-number">2</span>*N], cnt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a,PII b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.se&lt;b.se; &#125;PII a[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>(), pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod, cnt[a[i].se]=<span class="hljs-number">1</span>;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) cnt[i]+=cnt[i<span class="hljs-number">-1</span>];f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]%mod+pw[cnt[a[i].fi<span class="hljs-number">-1</span>]])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="help-yourself-platinum">Help Yourself Platinum</h3><p>把所有线段按照左端点排序。</p><p>设 <span class="math inline">\(f_{\delta}(i,r)\)</span> 表示考虑了前<span class="math inline">\(i\)</span> 条线段，最右边的端点在 <spanclass="math inline">\(r\)</span>，所有线段子集的<strong>并</strong>的连通块数<span class="math inline">\(\delta\)</span> 次方和。</p><p>形式化地，有 <span class="math display">\[f_{\delta}(i,r) = \sum_{S \subseteq U, \text{endpos}(S)=r}\text{cnt}(S)^{\delta}\]</span> 其中 <span class="math inline">\(\text{cnt}(S)\)</span>为线段<strong>并</strong> <span class="math inline">\(S\)</span>的连通块数量。</p><p>定义变换 <spanclass="math inline">\(\mathcal{T}\Big(f_{\delta}(i,r)\Big)\)</span>表示对状态 <span class="math inline">\(f_{\delta}(i,r)\)</span> 中所有<span class="math inline">\(\text{cnt}(S)\)</span> 进行 <spanclass="math inline">\(+1\)</span> 操作后得到的值。</p><p>对新加入的线段端点进行讨论，可得 <span class="math display">\[f_{\delta}(i,r_i) = \sum_{j=0}^{l_i-1}\mathcal{T}\Big(f_{\delta}(i-1,j)\Big) + \sum_{j=l_i}^{r_i}f_{\delta}(i-1,j)\]</span> 然后对于 <span class="math inline">\(j &gt; r_i\)</span>，有<span class="math display">\[f_{\delta}(i-1,j) \rightarrow f_{\delta}(i,j)\]</span> 然后我们考虑如何实现 <spanclass="math inline">\(\mathcal{T}\)</span>。 <spanclass="math display">\[\mathcal{T}\Big(f_{\delta}(i,j)\Big) = \sum_{S \subseteq U}\Big(\text{cnt}(S)+1\Big)^{\delta} = \sum_{S \subseteq U}\sum_{k=0}^{\delta} \binom{\delta}{k} \text{cnt}(S)^{k} =\sum_{k=0}^{\delta} \binom{\delta}{k} f_{k}(i,j)\]</span></p><p>可以 <span class="math inline">\(O(K)\)</span> 求出。</p><p>所以得到了一个 <span class="math inline">\(O(n^2 K^2)\)</span>的做法，可以得到 <span class="math inline">\(50\text{pts}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, K, pre[N], f[<span class="hljs-number">12</span>][N][<span class="hljs-number">2</span>*N];<span class="hljs-type">int</span> c[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];PII a[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(t,<span class="hljs-number">0</span>,k) &#123;(res+=c[k][t]*f[t][i][j]%mod)%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;f[k][<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>].se]=<span class="hljs-number">1</span>;f[k][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=(k==<span class="hljs-number">0</span>? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> l=a[i].fi, r=a[i].se;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,pre[i]) f[k][i][j]+=f[k][i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">// f[k][i][r]=f[k][i-1][r];</span><span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>) &#123;(f[k][i][r]+=<span class="hljs-built_in">T</span>(k,i<span class="hljs-number">-1</span>,j))%=mod;&#125;<span class="hljs-built_in">rep</span>(j,l,r) &#123;(f[k][i][r]+=f[k][i<span class="hljs-number">-1</span>][j])%=mod;&#125;<span class="hljs-built_in">rep</span>(j,r+<span class="hljs-number">1</span>,pre[i])  &#123;(f[k][i][j]+=f[k][i<span class="hljs-number">-1</span>][j])%=mod;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) pre[i]=<span class="hljs-built_in">max</span>(pre[i<span class="hljs-number">-1</span>],a[i].se);c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=K;++k) <span class="hljs-built_in">calc</span>(k);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,pre[n]) (ans+=f[K][n][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>考虑优化。</p><p>观察 <span class="math inline">\(\mathcal{T}\)</span>，可以发现 <spanclass="math display">\[\sum_{j=0}^{l_i-1} \mathcal{T}\Big(f_{\delta}(i-1,j)\Big) =\mathcal{T}\Big( \sum_{j=0}^{l_i-1} f_{\delta}(i-1,j) \Big)\]</span> 组合意义比较 <spanclass="math inline">\(\text{Trivial}\)</span>。</p><p>套路性的把 <span class="math inline">\(j\)</span>这一维拍到线段树上，每个线段树节点维护 <spanclass="math inline">\(j\)</span> 点上 <span class="math inline">\(\delta\in [0,K]\)</span> 时对应的 <span class="math inline">\(f\)</span>值。</p><p>每加入一条线段 <spanclass="math inline">\([l_i,r_i]\)</span>，做三种操作：</p><ol type="1"><li>对 <span class="math inline">\(r_i\)</span> 单点加 <spanclass="math inline">\(\mathcal{T}\Big( \sum_{j=0}^{l_i-1}f_{\delta}(i-1,j) \Big)\)</span>。</li><li>对 <span class="math inline">\(r_i\)</span> 单点加 <spanclass="math inline">\(\sum_{j=l_i}^{r_i}f_{\delta}(i-1,j)\)</span>。</li><li>对 <span class="math inline">\([r_i+1,2n]\)</span> 区间乘 <spanclass="math inline">\(2\)</span>。</li></ol><p>注意查询操作需要在修改操作之前。</p><p>时间复杂度 <span class="math inline">\(O(n K^2 + n \log_2nK)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, K, c[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];PII a[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> s[<span class="hljs-number">11</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(s,<span class="hljs-number">0</span>); &#125;<span class="hljs-built_in">node</span>() &#123; <span class="hljs-built_in">init</span>(); &#125;node <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> node&amp; o) &#123;node r=*<span class="hljs-keyword">this</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,K) r.s[i]=(s[i]+o.s[i])%mod;<span class="hljs-keyword">return</span> r;&#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a) &#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,K) (s[i]*=a)%=mod;&#125;&#125;;node t[N&lt;&lt;<span class="hljs-number">3</span>];<span class="hljs-type">int</span> tag[N&lt;&lt;<span class="hljs-number">3</span>];<span class="hljs-function">node <span class="hljs-title">T</span><span class="hljs-params">(node a)</span> </span>&#123;node res=<span class="hljs-built_in">node</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;++j) &#123;(res.s[i]+=c[i][j]*a.s[j]%mod)%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;t[x]*=d;(tag[x]*=d)%=mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,tag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,tag[x]);tag[x]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;tag[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l==r) &#123;<span class="hljs-keyword">if</span>(l==<span class="hljs-number">0</span>) t[x].s[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function">node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<span class="hljs-built_in">pushdown</span>(x);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;node res=<span class="hljs-built_in">node</span>();<span class="hljs-keyword">if</span>(L&lt;=mid) res=res+<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) res=res+<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf</span><span class="hljs-params">(<span class="hljs-type">int</span> p,node&amp; d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) &#123;t[x]=t[x]+d;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">pushdown</span>(x);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">mdf</span>(p,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf</span>(p,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;<span class="hljs-built_in">maketag</span>(x,d);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">pushdown</span>(x);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();m=n&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">prework</span>();<span class="hljs-built_in">build</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> l=a[i].fi, r=a[i].se;node d=<span class="hljs-built_in">T</span>(<span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>))+<span class="hljs-built_in">query</span>(l,r);<span class="hljs-built_in">mdf</span>(r,d);<span class="hljs-keyword">if</span>(r+<span class="hljs-number">1</span>&lt;=m) <span class="hljs-built_in">upd</span>(r+<span class="hljs-number">1</span>,m,<span class="hljs-number">2</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t[<span class="hljs-number">1</span>].s[K]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;help-yourself-gold&quot;&gt;Help Yourself Gold&lt;/h2&gt;
&lt;p&gt;考虑每条线段的贡献。&lt;/p&gt;
&lt;p&gt;把所有线段按左端点排序，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i)&#92;)&lt;/span&gt;
为前 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 条线段所有子集的贡献和。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不选 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;，贡献是 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i-1)&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;选 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;。设有 &lt;span class=&quot;math inline&quot;&gt;&#92;(cnt&#92;)&lt;/span&gt; 条线段 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt; 满足 &lt;span class=&quot;math inline&quot;&gt;&#92;(r_j
&amp;lt; l_i&#92;)&lt;/span&gt;，那么当选出的线段子集是这些线段的子集时，贡献都会增加
&lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，否则不变。因此贡献是 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i-1)+2^{cnt}&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; int long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; uint unsigned long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PII pair&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;int,int&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MP make_pair&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; fi first&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; se second&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; pb push_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; eb emplace_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SET(a,b) memset(a,b,sizeof(a))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CPY(a,b) memcpy(a,b,sizeof(b))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; rep(i,j,k) for(int i=(j);i&amp;lt;=(k);++i)&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; per(i,j,k) for(int i=(j);i&amp;gt;=(k);--i)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, f=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(c==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;) f=&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) a=a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+c-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a*f;
&amp;#125;
&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N=&lt;span class=&quot;hljs-number&quot;&gt;1e6&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, mod=&lt;span class=&quot;hljs-number&quot;&gt;1e9&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, pw[N], f[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*N], cnt[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*N];
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(PII a,PII b)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a.se&amp;lt;b.se; &amp;#125;
PII a[N];
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	n=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	pw[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,n) a[i].fi=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), a[i].se=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), pw[i]=pw[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;%mod, cnt[a[i].se]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(a+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,a+n+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*n;++i) cnt[i]+=cnt[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;];
	f[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;++i) &amp;#123;
		f[i]=(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*f[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]%mod+pw[cnt[a[i].fi&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]])%mod;
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%lld&#92;n&amp;quot;&lt;/span&gt;,f[n]);
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;help-yourself-platinum&quot;&gt;Help Yourself Platinum&lt;/h3&gt;
&lt;p&gt;把所有线段按照左端点排序。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f_{&#92;delta}(i,r)&#92;)&lt;/span&gt; 表示考虑了前
&lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 条线段，最右边的端点在 &lt;span class=&quot;math inline&quot;&gt;&#92;(r&#92;)&lt;/span&gt;，所有线段子集的&lt;strong&gt;并&lt;/strong&gt;的连通块数
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;delta&#92;)&lt;/span&gt; 次方和。&lt;/p&gt;
&lt;p&gt;形式化地，有 &lt;span class=&quot;math display&quot;&gt;&#92;[
f_{&#92;delta}(i,r) = &#92;sum_{S &#92;subseteq U, &#92;text{endpos}(S)=r}
&#92;text{cnt}(S)^{&#92;delta}
&#92;]&lt;/span&gt; 其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{cnt}(S)&#92;)&lt;/span&gt;
为线段&lt;strong&gt;并&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;
的连通块数量。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="线段树" scheme="https://yozora0908.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF1707C DFS Trees 题解</title>
    <link href="https://yozora0908.github.io/2023/cf1707c-solution/"/>
    <id>https://yozora0908.github.io/2023/cf1707c-solution/</id>
    <published>2023-09-06T22:34:49.000Z</published>
    <updated>2023-09-06T22:43:15.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>考虑这个算法什么时候会假掉。</p><p>如果这样选出的一条边 <span class="math inline">\((x,y)\)</span> 不在MST 中，那么说明此时 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 已经连通，也就说这条边是 MST上的返祖边。</p><p>直接考虑以每个节点为根，是否会选出 MST上的返祖边并不容易。我们尝试从每条边入手，考虑以哪些节点为根时，这条边会成为返祖边。</p><p>由于边权各不相同，所以 MST 唯一。我们先把 MST 求出来，设其为 <spanclass="math inline">\(T\)</span>，随便定一个根。</p><p>考虑每一条非 MST 边 <span class="math inline">\((x,y)\)</span>，钦定<span class="math inline">\(\text{dep}(x) \ge\text{dep}(y)\)</span>，<span class="math inline">\(z =\text{LCA}(x,y)\)</span>。</p><ul><li>如果 <span class="math inline">\(z \neq y\)</span>，那么只有以 <spanclass="math inline">\(\text{subtree}(x)\)</span> 或 <spanclass="math inline">\(\text{subtree}(y)\)</span>中的节点为根时，才会使得这条边被错误地加入 MST。</li><li>如果 <span class="math inline">\(z = y\)</span>，那么就是 <spanclass="math inline">\(\text{subtree}(x)\)</span> 中的节点，以及 <spanclass="math inline">\(T - \text{subtree}\Big(son_x(y)\Big)\)</span>中的节点。</li></ul><p>其中 <span class="math inline">\(son_x(y)\)</span> 表示 <spanclass="math inline">\(y\)</span> 一个子节点，满足其所在子树包含 <spanclass="math inline">\(x\)</span>。</p><p>那么从 <span class="math inline">\(x\)</span> 执行算法，能求出 MST的充要条件是 <span class="math inline">\(x\)</span>被上述每一条边都统计到一次。</p><p>问题转化为子树加，单点查，再转化一下就是单点加，求树上前缀和。</p><p><span class="math inline">\(son_x(y)\)</span>可以用倍增轻松找到。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, v[N&lt;&lt;<span class="hljs-number">1</span>], f[N][<span class="hljs-number">17</span>], dep[N], c[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, z;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node b) &#123;<span class="hljs-keyword">return</span> z&lt;b.z;&#125;&#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);dsu.<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=dsu.<span class="hljs-built_in">get</span>(e[i].x), y=dsu.<span class="hljs-built_in">get</span>(e[i].y);<span class="hljs-keyword">if</span>(x!=y) &#123;v[i]=<span class="hljs-number">1</span>;dsu.fa[x]=y;<span class="hljs-comment">// if(++cnt==n-1) break;</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(v[i]) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>;f[x][<span class="hljs-number">0</span>]=fa;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">16</span>;++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) <span class="hljs-keyword">if</span> (dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;c[y]+=c[x];<span class="hljs-built_in">dfs2</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;e[i].x=<span class="hljs-built_in">read</span>(), e[i].y=<span class="hljs-built_in">read</span>(), e[i].z=i;&#125;<span class="hljs-built_in">kruskal</span>();<span class="hljs-built_in">build</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">if</span>(z==y) &#123;++c[<span class="hljs-number">1</span>], ++c[x];<span class="hljs-type">int</span> t=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">16</span>;~j;--j) <span class="hljs-keyword">if</span>(dep[f[t][j]]&gt;dep[y]) t=f[t][j];--c[t]; &#125; <span class="hljs-keyword">else</span> ++c[x], ++c[y];&#125;<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(c[i]==m-n+<span class="hljs-number">1</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;考虑这个算法什么时候会假掉。&lt;/p&gt;
&lt;p&gt;如果这样选出的一条边 &lt;span class=&quot;math inline&quot;&gt;&#92;((x,y)&#92;)&lt;/span&gt; 不在
MST 中，那么说明此时 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(y&#92;)&lt;/span&gt; 已经连通，也就说这条边是 MST
上的返祖边。&lt;/p&gt;
&lt;p&gt;直接考虑以每个节点为根，是否会选出 MST
上的返祖边并不容易。我们尝试从每条边入手，考虑以哪些节点为根时，这条边会成为返祖边。&lt;/p&gt;
&lt;p&gt;由于边权各不相同，所以 MST 唯一。我们先把 MST 求出来，设其为 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;，随便定一个根。&lt;/p&gt;
&lt;p&gt;考虑每一条非 MST 边 &lt;span class=&quot;math inline&quot;&gt;&#92;((x,y)&#92;)&lt;/span&gt;，钦定
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{dep}(x) &#92;ge
&#92;text{dep}(y)&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(z =
&#92;text{LCA}(x,y)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(z &#92;neq y&#92;)&lt;/span&gt;，那么只有以 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{subtree}(x)&#92;)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{subtree}(y)&#92;)&lt;/span&gt;
中的节点为根时，才会使得这条边被错误地加入 MST。&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(z = y&#92;)&lt;/span&gt;，那么就是 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{subtree}(x)&#92;)&lt;/span&gt; 中的节点，以及 &lt;span class=&quot;math inline&quot;&gt;&#92;(T - &#92;text{subtree}&#92;Big(son_x(y)&#92;Big)&#92;)&lt;/span&gt;
中的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(son_x(y)&#92;)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;&#92;(y&#92;)&lt;/span&gt; 一个子节点，满足其所在子树包含 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么从 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 执行算法，能求出 MST
的充要条件是 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
被上述每一条边都统计到一次。&lt;/p&gt;
&lt;p&gt;问题转化为子树加，单点查，再转化一下就是单点加，求树上前缀和。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="图论" scheme="https://yozora0908.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="树论" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="树上倍增" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>LOJ#2955 保卫王国 题解</title>
    <link href="https://yozora0908.github.io/2023/loj2955-solution/"/>
    <id>https://yozora0908.github.io/2023/loj2955-solution/</id>
    <published>2023-09-06T22:33:17.000Z</published>
    <updated>2023-09-06T22:46:54.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="部分分">部分分</h2><p>先考虑暴力怎么打。</p><p>规定原树为 <span class="math inline">\(T\)</span>，以 <spanclass="math inline">\(x\)</span> 为根的子树为 <spanclass="math inline">\(T(x)\)</span>。</p><p>设 <span class="math inline">\(f(x,0/1)\)</span> 为考虑 <spanclass="math inline">\(T(x)\)</span>，其中 <spanclass="math inline">\(x\)</span> 选或不选的最小权点覆盖，设 <spanclass="math inline">\(g(x,0/1)\)</span> 为考虑 <spanclass="math inline">\(T-T(x)\)</span>，其中 <spanclass="math inline">\(x\)</span> 选或不选的最小权点覆盖。有转移 <spanclass="math display">\[f(x,0) = \sum_{y \in son(x)} f(y,1)\]</span></p><p><span class="math display">\[f(y,1) = \sum_{y \in son(x)} \min\Big(f(y,0),f(y,1)\Big)\]</span></p><p><span class="math display">\[g(y,0) = g(x,1) + f(x,1) - \min\Big(f(y,0),f(y,1)\Big)\]</span></p><p><span class="math display">\[g(y,1) = \min \Big( g(x,0)+f(x,0)-f(y,1),g(y,0) \Big)\]</span></p><p>预处理 <span class="math inline">\(f\)</span> 与 <spanclass="math inline">\(g\)</span>，复杂度是 <spanclass="math inline">\(O(n)\)</span> 的。</p><p>设 <span class="math inline">\(z =\text{LCA}(x,y)\)</span>，对于每个询问，我们暴力修改 <spanclass="math inline">\(f(x)\)</span> 与 <spanclass="math inline">\(f(y)\)</span>，然后求出 <spanclass="math inline">\(f(z)\)</span> 即可。</p><p>这样可以通过前 <span class="math inline">\(11\)</span> 个测试点。</p><p>对于链的情况，我们直接预处理前缀与后缀最小权点覆盖，然后对 <spanclass="math inline">\([x,y]\)</span> 做矩阵加速的最小权点覆盖即可。</p><p>然后就通过前 <span class="math inline">\(17\)</span> 个点了。</p><h2 id="正解">正解</h2><p>承接上文，我不会动态 DP。</p><p>设 <span class="math inline">\(fa(x,i)\)</span> 为 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(2^i\)</span> 级祖先，<spanclass="math inline">\(h(x,i,a,b)\)</span> 为从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(fa(x,i)\)</span>，其中 <spanclass="math inline">\(x\)</span> 的驻军状态是 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(fa(x,i)\)</span> 的驻军状态是 <spanclass="math inline">\(b\)</span>，这条链的最小代价。</p><p>这个的预处理就比上一题简单不少了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// int h[N][17][2][2]</span><span class="hljs-keyword">auto</span> H=h[y][<span class="hljs-number">0</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">0</span>]-f[y][<span class="hljs-number">1</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=H[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<span class="hljs-comment">// 然后倍增一下</span></code></pre></div><p>根据个人习惯把询问改为 <spanclass="math inline">\((x,a,y,b)\)</span>，表示强制令节点 <spanclass="math inline">\(x\)</span> 的状态为 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(y\)</span>的状态为 <span class="math inline">\(b\)</span>。</p><p>钦定 <span class="math inline">\(\text{dep}(x) \ge\text{dep}(y)\)</span>，<span class="math inline">\(z =\text{LCA}(x,y)\)</span>。</p><p>如果 <span class="math inline">\(z=y\)</span>，那么直接倍增出 <spanclass="math inline">\((x,y)\)</span> 的最小代价，加上 <spanclass="math inline">\(f(x,a)\)</span> 与 <spanclass="math inline">\(g(y,b)\)</span>。</p><p>否则拆成 <span class="math inline">\(\Big(x,pre_x(z)\Big)\)</span> 与<span class="math inline">\(\Big(y,pre_y(z)\Big)\)</span>两条链，分别倍增求出，再拼起来。</p><p>其中 <span class="math inline">\(pre_x(z)\)</span> 表示 <spanclass="math inline">\(x\)</span> 的一个祖先，满足它是 <spanclass="math inline">\(y\)</span> 的一个子节点。</p><p>求 <span class="math inline">\(pre_x(z)\)</span> 的过程可以放进倍增求<span class="math inline">\(\text{LCA}\)</span> 中，很方便。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x0f0f0f0f0f0f0f0f</span>;<span class="hljs-type">int</span> n, m, lim, c[N], dep[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>], g[N][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> fa[N][<span class="hljs-number">17</span>], h[N][<span class="hljs-number">17</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">char</span> s[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span></span><span class="hljs-function"></span>&#123;    dep[x]=dep[fr]+<span class="hljs-number">1</span>;    fa[x][<span class="hljs-number">0</span>]=fr;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];++i) fa[x][i]=fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=c[x];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;        <span class="hljs-built_in">dfs1</span>(y,x);        f[x][<span class="hljs-number">0</span>]+=f[y][<span class="hljs-number">1</span>];        f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;g[y][<span class="hljs-number">0</span>]=g[x][<span class="hljs-number">1</span>]+f[x][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);g[y][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(g[x][<span class="hljs-number">0</span>]+f[x][<span class="hljs-number">0</span>]-f[y][<span class="hljs-number">1</span>],g[y][<span class="hljs-number">0</span>]);<span class="hljs-keyword">auto</span> H=h[y][<span class="hljs-number">0</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">0</span>]-f[y][<span class="hljs-number">1</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=H[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[y];++i) <span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(c,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;h[y][i][a][c]=<span class="hljs-built_in">min</span>(h[y][i][a][c],h[y][i<span class="hljs-number">-1</span>][a][b]+h[fa[y][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>][b][c]);&#125;<span class="hljs-built_in">dfs2</span>(y,x);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;res[a]=<span class="hljs-number">0</span>;res[a^<span class="hljs-number">1</span>]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]&amp;&amp;dep[fa[x][i]]&gt;=dep[y]) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">2</span>,inf)</span></span>;<span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) t[b]=<span class="hljs-built_in">min</span>(t[b],res[a]+h[x][i][a][b]);x=fa[x][i], res=t;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> tx=x, ty=y;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]&amp;&amp;dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];<span class="hljs-keyword">if</span>(x==y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">calc</span>(tx,a,y)[b]+f[tx][a]+g[y][b];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i], y=fa[y][i];<span class="hljs-type">int</span> z=fa[x][<span class="hljs-number">0</span>]; <span class="hljs-keyword">auto</span> F=<span class="hljs-built_in">calc</span>(tx,a,x), G=<span class="hljs-built_in">calc</span>(ty,b,y);<span class="hljs-type">int</span> res0=F[<span class="hljs-number">1</span>]+G[<span class="hljs-number">1</span>]+(f[z][<span class="hljs-number">0</span>]-f[x][<span class="hljs-number">1</span>]-f[y][<span class="hljs-number">1</span>])+g[z][<span class="hljs-number">0</span>];<span class="hljs-type">int</span> res1=<span class="hljs-built_in">min</span>(F[<span class="hljs-number">0</span>],F[<span class="hljs-number">1</span>])+<span class="hljs-built_in">min</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">1</span>])+(f[z][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[x][<span class="hljs-number">0</span>],f[x][<span class="hljs-number">1</span>])-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]))+g[z][<span class="hljs-number">1</span>];    <span class="hljs-comment">// 两种情况为z是否驻军</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(res0,res1)+f[tx][a]+f[ty][b];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;defense.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;defense.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>&lt;&lt;(lim+<span class="hljs-number">1</span>)&lt;=n) ++lim;<span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0x0f</span>);<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), a=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y), <span class="hljs-built_in">swap</span>(a,b);<span class="hljs-keyword">if</span>(!a&amp;&amp;!b&amp;&amp;fa[x][<span class="hljs-number">0</span>]==y) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>(x,a,y,b));&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;部分分&quot;&gt;部分分&lt;/h2&gt;
&lt;p&gt;先考虑暴力怎么打。&lt;/p&gt;
&lt;p&gt;规定原树为 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;，以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树为 &lt;span class=&quot;math inline&quot;&gt;&#92;(T(x)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,0/1)&#92;)&lt;/span&gt; 为考虑 &lt;span class=&quot;math inline&quot;&gt;&#92;(T(x)&#92;)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 选或不选的最小权点覆盖，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(g(x,0/1)&#92;)&lt;/span&gt; 为考虑 &lt;span class=&quot;math inline&quot;&gt;&#92;(T-T(x)&#92;)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 选或不选的最小权点覆盖。有转移 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(x,0) = &#92;sum_{y &#92;in son(x)} f(y,1)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
f(y,1) = &#92;sum_{y &#92;in son(x)} &#92;min&#92;Big(f(y,0),f(y,1)&#92;Big)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
g(y,0) = g(x,1) + f(x,1) - &#92;min&#92;Big(f(y,0),f(y,1)&#92;Big)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
g(y,1) = &#92;min &#92;Big( g(x,0)+f(x,0)-f(y,1),g(y,0) &#92;Big)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预处理 &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(g&#92;)&lt;/span&gt;，复杂度是 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(n)&#92;)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(z =
&#92;text{LCA}(x,y)&#92;)&lt;/span&gt;，对于每个询问，我们暴力修改 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(y)&#92;)&lt;/span&gt;，然后求出 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(z)&#92;)&lt;/span&gt; 即可。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="树论" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="树上倍增" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>luogu8820 数据传输 题解</title>
    <link href="https://yozora0908.github.io/2023/lg8820-solution/"/>
    <id>https://yozora0908.github.io/2023/lg8820-solution/</id>
    <published>2023-09-06T22:32:53.000Z</published>
    <updated>2023-09-06T22:45:54.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>下文用 <span class="math inline">\(step\)</span> 代替题目中的 <spanclass="math inline">\(k\)</span>。</p><h2 id="部分分">部分分</h2><p>先考虑一下暴力怎么打。</p><p><span class="math inline">\(k=1\)</span>的情况等于送的，就不说了。</p><p>对于前 <span class="math inline">\(11\)</span> 个点，可以用 <spanclass="math inline">\(n\)</span> 次 <spanclass="math inline">\(\text{BFS}\)</span>预处理出树上任意两点距离，对能够到达的点连边，跑 <spanclass="math inline">\(n\)</span> 遍 <spanclass="math inline">\(\text{Dijkstra}\)</span> 再回答询问，实测 LOJ可以通过。</p><p>虽然题目没有设置特殊图的部分分，但是这里仍然提一嘴。</p><p>链怎么做？我们能发现在链上通过反复横跳来避免到达某些节点是不优的，所以设<span class="math inline">\(f(i)\)</span> 为到达位置 <spanclass="math inline">\(i\)</span> 的最小点权和，有 <spanclass="math display">\[f(i) = \min_{j=1}^{step} \{ f(i-j) \}\]</span> 可以矩阵加速。</p><p>菊花是送的。</p><h2 id="正解">正解</h2><p>由于本人不会动态 DP，所以只能参考 Dottle 的树上倍增做法。</p><p>我们遇到的最大困难，就是从 <span class="math inline">\(x\)</span> 往<span class="math inline">\(y\)</span> 跳的过程可以不只经过路径 <spanclass="math inline">\((x,y)\)</span>上的点，从而大大增多了要考虑的情况。</p><p>先转化一下图论模型：寻找代价最小的一条从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span>的路径，其中代价定义为路径中的若干节点的点权。可以自己指定哪些点权计入答案，但是不允许出现连续的<span class="math inline">\(step\)</span> 个点不计入答案。</p><p>设二元组 <span class="math inline">\((x,k)\)</span> 表示到达节点<span class="math inline">\(x\)</span>，包括 <spanclass="math inline">\(x\)</span> 在内，最后一段已经有 <spanclass="math inline">\(k\)</span> 个节点没有标记。</p><p>建议新图，连两种边：</p><ol type="1"><li>如果树中有边 <span class="math inline">\((x,y)\)</span>，连边 <spanclass="math inline">\((x,k) \rightarrow (y,0)\)</span>，权值为 <spanclass="math inline">\(v_y\)</span>。</li><li>如果树中有边 <span class="math inline">\((x,y)\)</span>，且 <spanclass="math inline">\(k+1&lt;step\)</span>那么连边 <spanclass="math inline">\((x,k) \rightarrow (y,k+1)\)</span>，权值为 <spanclass="math inline">\(0\)</span>。</li></ol><p>由于 <span class="math inline">\((x,y)\)</span>路径上的点可能不被计入答案，但是一定会以某种方式被经过，可以用倍增来优化。</p><p>设 <span class="math inline">\(f(x,i)\)</span> 表示原树中 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(2^i\)</span> 级祖先， <spanclass="math inline">\(d(x,i,a,b)\)</span> 表示在新图中，从 <spanclass="math inline">\((x,a)\)</span> 到达 <spanclass="math inline">\(\Big( f(x,i),b\Big)\)</span> 的最小边权。</p><p>下面讨论如何求出 <spanclass="math inline">\(d(x,0,a,b)\)</span>，为了方便就不打公式了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// int d[N][18][3][3];</span><span class="hljs-keyword">auto</span> D=d[x][<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(step==<span class="hljs-number">1</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=v[fa];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(step==<span class="hljs-number">2</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=v[fa], D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> &#123;D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=v[fa];D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;D[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=mn[x];    <span class="hljs-comment">// mn[x]表示与x相邻点中的最小点权</span>&#125;<span class="hljs-comment">// D[k][0]与D[k][k+1]的边就是上文叙述的</span><span class="hljs-comment">// 比较特殊的是从x跳到一个中转点，贡献中转点的点权后再到达fa，同时不贡献v[fa]</span><span class="hljs-comment">// 不难发现当step=1和2时，都一定会贡献出v[fa]</span><span class="hljs-comment">// 想要贡献出mn[x]而不是v[fa]，那么D的第二维一定是2</span></code></pre></div><p>然后就是常规倍增，把状态从中间拼起来即可。</p><p>对于一个询问 <span class="math inline">\((x,y)\)</span>，我们求出<span class="math inline">\(z = \text{LCA}(x,y)\)</span>，分别从 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 往 <spanclass="math inline">\(z\)</span> 跳，倍增出关于所有状态的最优解，最后从<span class="math inline">\(z\)</span> 处拼起来即可。</p><p>注意有 corner case。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x0f0f0f0f0f0f0f0f</span>;<span class="hljs-type">int</span> n, Q, lim, step, v[N], mn[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">18</span>], dep[N];<span class="hljs-type">int</span> d[N][<span class="hljs-number">18</span>][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">0</span>]=fa;dep[x]=dep[fa]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">auto</span> D=d[x][<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(step==<span class="hljs-number">1</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=v[fa];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(step==<span class="hljs-number">2</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=v[fa], D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> &#123;D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=v[fa];D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;D[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=mn[x];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];++i) <span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(c,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;d[x][i][a][c]=<span class="hljs-built_in">min</span>(d[x][i][a][c],d[x][i<span class="hljs-number">-1</span>][a][b]+d[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>][b][c]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">3</span>,v[x])</span></span>;    <span class="hljs-comment">// 小技巧，把所有状态的答案扔进一个vector里面</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]&amp;&amp;dep[f[x][i]]&gt;=dep[y]) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">3</span>,inf)</span></span>;<span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) t[b]=<span class="hljs-built_in">min</span>(t[b],res[a]+d[x][i][a][b]);x=f[x][i];res=t;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">auto</span> F=<span class="hljs-built_in">calc</span>(x,z), G=<span class="hljs-built_in">calc</span>(y,z);<span class="hljs-type">int</span> res=inf;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,step<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,step<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(F[i]!=inf&amp;&amp;G[j]!=inf) &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;j==<span class="hljs-number">0</span>) res=<span class="hljs-built_in">min</span>(res,F[i]+G[j]-v[z]); <span class="hljs-comment">// 此时v[z]会被重复计算</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+j&gt;step) res=<span class="hljs-built_in">min</span>(res,F[i]+G[j]+mn[z]); <span class="hljs-comment">// 此时必须找一个落脚点才能拼起来</span><span class="hljs-keyword">else</span> res=<span class="hljs-built_in">min</span>(res,F[i]+G[j]);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;transmit.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;transmit.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>(), step=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=mn[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);mn[x]=<span class="hljs-built_in">min</span>(mn[x],v[y]);mn[y]=<span class="hljs-built_in">min</span>(mn[y],v[x]);&#125;<span class="hljs-keyword">while</span>((<span class="hljs-number">1</span>&lt;&lt;(lim+<span class="hljs-number">1</span>))&lt;=n) ++lim;<span class="hljs-built_in">SET</span>(d,<span class="hljs-number">0x0f</span>);<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>(x,y));&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;下文用 &lt;span class=&quot;math inline&quot;&gt;&#92;(step&#92;)&lt;/span&gt; 代替题目中的 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;部分分&quot;&gt;部分分&lt;/h2&gt;
&lt;p&gt;先考虑一下暴力怎么打。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(k=1&#92;)&lt;/span&gt;
的情况等于送的，就不说了。&lt;/p&gt;
&lt;p&gt;对于前 &lt;span class=&quot;math inline&quot;&gt;&#92;(11&#92;)&lt;/span&gt; 个点，可以用 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 次 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{BFS}&#92;)&lt;/span&gt;
预处理出树上任意两点距离，对能够到达的点连边，跑 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 遍 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Dijkstra}&#92;)&lt;/span&gt; 再回答询问，实测 LOJ
可以通过。&lt;/p&gt;
&lt;p&gt;虽然题目没有设置特殊图的部分分，但是这里仍然提一嘴。&lt;/p&gt;
&lt;p&gt;链怎么做？我们能发现在链上通过反复横跳来避免到达某些节点是不优的，所以设
&lt;span class=&quot;math inline&quot;&gt;&#92;(f(i)&#92;)&lt;/span&gt; 为到达位置 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 的最小点权和，有 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(i) = &#92;min_{j=1}^{step} &#92;{ f(i-j) &#92;}
&#92;]&lt;/span&gt; 可以矩阵加速。&lt;/p&gt;
&lt;p&gt;菊花是送的。&lt;/p&gt;
&lt;h2 id=&quot;正解&quot;&gt;正解&lt;/h2&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="树论" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="树上倍增" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>luogu6563 [SBCOI2020] 一直在你身旁 题解</title>
    <link href="https://yozora0908.github.io/2023/lg6563-solution/"/>
    <id>https://yozora0908.github.io/2023/lg6563-solution/</id>
    <published>2023-09-06T22:32:30.000Z</published>
    <updated>2023-09-06T22:41:11.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="luogu6563-sbcoi2020-一直在你身旁">luogu6563 [SBCOI2020]一直在你身旁</h3><p>不妨称需要的电线为答案电线。</p><p>注意到购买长度为 <span class="math inline">\(k\)</span>的电线本质上是把答案电线的取值范围从 <spanclass="math inline">\([i,j]\)</span> 缩小到了 <spanclass="math inline">\([i,k]\)</span> 或 <spanclass="math inline">\([k+1,j]\)</span>。虽然无法确定到底是在哪一个区间，但是最坏的情况一定是答案电线在二者中代价更大的里面，同时我们完成了对子问题的划分，直接上区间DP。</p><p>我们把拓扑序反过来，使得这个过程符合区间 DP。设 <spanclass="math inline">\(f(i,j)\)</span> 为答案电线的取值范围是 <spanclass="math inline">\([i,j]\)</span>时，最坏情况下找到答案电线还需要的最小代价。</p><p>显然有 <span class="math display">\[f(i,j) = \min_{k \in [i,j-1]} \Big\{ \max \Big(f(i,k),f(k+1,j) \Big) +a_k \Big\}\]</span> 考虑优化。</p><p>打表发现确实有决策单调性，但是是分段单调，不太容易下手。</p><p>从实际意义的角度似乎不是很显然。</p><p>套路地把 <span class="math inline">\(\max\)</span>拆开，考虑会在哪边取到。</p><p>注意到 <span class="math inline">\(\{a_i\}\)</span>单调不降，再感性理解一下，<span class="math inline">\(f(i,k)\)</span>关于 <span class="math inline">\(k\)</span> 单调增，<spanclass="math inline">\(f(k+1,j)\)</span> 关于 <spanclass="math inline">\(k+1\)</span> 单调减，从而 <spanclass="math inline">\(f(i,k)-f(k+1,j)\)</span> 关于 <spanclass="math inline">\(k\)</span> 单调不降，也就是存在临界点。</p><p>可以用二分找到最小的使得 <spanclass="math inline">\(f(i,k)&gt;f(k+1,j)\)</span> 的 <spanclass="math inline">\(k\)</span>，记为 <spanclass="math inline">\(p\)</span>。</p><p>然而有 <span class="math inline">\(f(i,j) \lef(i,j+1)\)</span>，所以在 <span class="math inline">\(i\)</span> 或者<span class="math inline">\(j\)</span> 变化时，<spanclass="math inline">\(p\)</span> 也是单调的，用一个指针维护即可。</p><p>接下来讨论一个决策点 <span class="math inline">\(k\)</span> 与 <spanclass="math inline">\(p\)</span> 的关系。</p><ul><li><span class="math inline">\(k &lt; p\)</span>。此时取到的是 <spanclass="math inline">\(f(k+1,j)+a_k\)</span>，发现这东西和 <spanclass="math inline">\(i\)</span> 无关。在 <spanclass="math inline">\(j\)</span> 固定时可以用单调队列维护。</li><li><span class="math inline">\(k \ge p\)</span>，此时取到的时 <spanclass="math inline">\(f(i,k)+a_k\)</span>，它关于 <spanclass="math inline">\(k\)</span> 单调增，最终取到的一定是 <spanclass="math inline">\(f(i,p)+a_p\)</span>。</li></ul><p>综上所述，在右端点固定，左端点递减时，我们可以做到均摊 <spanclass="math inline">\(O(1)\)</span> 地转移。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">7105</span>;<span class="hljs-type">int</span> T, n, a[N];<span class="hljs-type">int</span> q[N];ll f[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) &#123;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;f[j<span class="hljs-number">-1</span>][j]=a[j<span class="hljs-number">-1</span>];q[++r]=j<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j<span class="hljs-number">-2</span>,k=j;i;--i) &#123;<span class="hljs-keyword">while</span>(k&gt;i&amp;&amp;f[i][k<span class="hljs-number">-1</span>]&gt;f[k][j]) --k;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;=k) ++l;f[i][j]=f[i][k]+a[k];<span class="hljs-keyword">if</span>(l&lt;=r) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[q[l]+<span class="hljs-number">1</span>][j]+a[q[l]]);<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[q[r]+<span class="hljs-number">1</span>][j]+a[q[r]]&gt;=f[i+<span class="hljs-number">1</span>][j]+a[i]) --r;q[++r]=i;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h3 id=&quot;luogu6563-sbcoi2020-一直在你身旁&quot;&gt;luogu6563 [SBCOI2020]
一直在你身旁&lt;/h3&gt;
&lt;p&gt;不妨称需要的电线为答案电线。&lt;/p&gt;
&lt;p&gt;注意到购买长度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt;
的电线本质上是把答案电线的取值范围从 &lt;span class=&quot;math inline&quot;&gt;&#92;([i,j]&#92;)&lt;/span&gt; 缩小到了 &lt;span class=&quot;math inline&quot;&gt;&#92;([i,k]&#92;)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;&#92;([k+1,j]&#92;)&lt;/span&gt;。虽然无法确定到底是在哪一个区间，但是最坏的情况一定是答案电线在二者中代价更大的里面，同时我们完成了对子问题的划分，直接上区间
DP。&lt;/p&gt;
&lt;p&gt;我们把拓扑序反过来，使得这个过程符合区间 DP。设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,j)&#92;)&lt;/span&gt; 为答案电线的取值范围是 &lt;span class=&quot;math inline&quot;&gt;&#92;([i,j]&#92;)&lt;/span&gt;
时，最坏情况下找到答案电线还需要的最小代价。&lt;/p&gt;
&lt;p&gt;显然有 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(i,j) = &#92;min_{k &#92;in [i,j-1]} &#92;Big&#92;{ &#92;max &#92;Big(f(i,k),f(k+1,j) &#92;Big) +
a_k &#92;Big&#92;}
&#92;]&lt;/span&gt; 考虑优化。&lt;/p&gt;
&lt;p&gt;打表发现确实有决策单调性，但是是分段单调，不太容易下手。&lt;/p&gt;
&lt;p&gt;从实际意义的角度似乎不是很显然。&lt;/p&gt;
&lt;p&gt;套路地把 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;max&#92;)&lt;/span&gt;
拆开，考虑会在哪边取到。&lt;/p&gt;
&lt;p&gt;注意到 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{a_i&#92;}&#92;)&lt;/span&gt;
单调不降，再感性理解一下，&lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,k)&#92;)&lt;/span&gt;
关于 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 单调增，&lt;span class=&quot;math inline&quot;&gt;&#92;(f(k+1,j)&#92;)&lt;/span&gt; 关于 &lt;span class=&quot;math inline&quot;&gt;&#92;(k+1&#92;)&lt;/span&gt; 单调减，从而 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,k)-f(k+1,j)&#92;)&lt;/span&gt; 关于 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 单调不降，也就是存在临界点。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="区间DP" scheme="https://yozora0908.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
    <category term="单调队列" scheme="https://yozora0908.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="决策单调性" scheme="https://yozora0908.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#20 树论（1）树上差分与树上倍增</title>
    <link href="https://yozora0908.github.io/2023/noip-record-1/"/>
    <id>https://yozora0908.github.io/2023/noip-record-1/</id>
    <published>2023-09-06T22:30:00.000Z</published>
    <updated>2023-09-06T22:38:52.275Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="树上差分">树上差分</h2><p>从抽象代数的角度讲，树上差分可以维护所有群上信息。</p><p>换句话说，满足结合律，存在「可减性」。</p><blockquote><p>通过差分我们能将一个高纬问题以常数代价转化为低维问题，而问题低一维往往会简单非常多</p><p>—— lxl</p></blockquote><p>太 <span class="math inline">\(\textit{Trivial}\)</span>的我们就不提了。</p><p>下文成「前缀」为根到节点的路径。</p><h3 id="luogu8201-yloi2021-生活在树上hard-version">luogu8201 [yLOI2021]生活在树上（hard version）</h3><p>考虑这样一个结论。</p><blockquote><p>树上路径 <span class="math inline">\((t,x)\)</span> 与 <spanclass="math inline">\((t,y)\)</span>，一定是先有一段重合的路径，再与路径<span class="math inline">\((x,y)\)</span> 交于一点 <spanclass="math inline">\(z\)</span>，然后分别连向对应的点。</p></blockquote><p>这个有什么用呢？我们可以把 <spanclass="math inline">\(\text{dis}_{t,a} \oplus \text{dis}_{t,b} =k\)</span> 转化为 <span class="math inline">\(\text{dis}_{a,b} \oplusw_z = k\)</span>， 其中 <span class="math inline">\(z\)</span> 是 <spanclass="math inline">\(t\)</span> 与路径 <spanclass="math inline">\((a,b)\)</span> 的交点。</p><p>更进一步地，询问 <span class="math inline">\((a,b,k)\)</span>等价于查询路径 <span class="math inline">\((a,b)\)</span> 上是否存在点<span class="math inline">\(z\)</span>，满足 <spanclass="math inline">\(w_z = k \oplus \text{dis}_{a,b}\)</span>。</p><p>设 <span class="math inline">\(h(x,k)\)</span> 为根到 <spanclass="math inline">\(x\)</span> 的路径上，点权为 <spanclass="math inline">\(k\)</span> 的点的个数，<spanclass="math inline">\(c=\operatorname{LCA}(a,b)\)</span>。</p><p>我们把询问拆成前缀，放到 <spanclass="math inline">\(a,b,c,fa(c)\)</span> 上，在对应点处打上 <spanclass="math inline">\(k \oplus \text{dis}_{a,b}\)</span>的标记。开一个全局桶，一个点的贡献只会在其子树中产生，访问时加入，回溯时撤销即可。然后开个<code>std::unordered_map</code>数组统计在<span class="math inline">\(x\)</span> 处统计所有标记对应的值，就能在<span class="math inline">\(O(n)-O(1)\)</span> 的复杂度内解决问题。</p><blockquote><p>把对路径的询问差分成对前缀的询问。</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, w[N], d[N];<span class="hljs-type">int</span> son[N], dep[N], sz[N], top[N], fa[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, z, k;&#125; q[N];vector&lt;<span class="hljs-type">int</span>&gt; r[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp, ans[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr;dep[x]=dep[fr]+<span class="hljs-number">1</span>;sz[x]=<span class="hljs-number">1</span>;d[x]=d[fr]^w[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) &#123;<span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;++mp[w[x]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:r[x]) ans[x][y]=mp[y];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;<span class="hljs-built_in">dfs3</span>(y);&#125;--mp[w[x]];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>(), q[i].k=<span class="hljs-built_in">read</span>();q[i].z=<span class="hljs-built_in">lca</span>(q[i].x,q[i].y);q[i].k=q[i].k^d[q[i].x]^d[q[i].y]^w[q[i].z];<span class="hljs-type">int</span> x=q[i].x, y=q[i].y, z=q[i].z, k=q[i].k;r[x].<span class="hljs-built_in">pb</span>(k), r[y].<span class="hljs-built_in">pb</span>(k);r[z].<span class="hljs-built_in">pb</span>(k), r[fa[z]].<span class="hljs-built_in">pb</span>(k);&#125;<span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=q[i].x, y=q[i].y, z=q[i].z, k=q[i].k;<span class="hljs-type">int</span> cnt=ans[x][k]+ans[y][k]-ans[z][k]-ans[fa[z]][k];<span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YeS&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;nO&quot;</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu1600-noip2016-提高组-天天爱跑步">luogu1600 [NOIP2016提高组] 天天爱跑步</h3><p><ahref="https://yozora0908.github.io/2021/lg1600-solution">link</a></p><blockquote><p>把路径的贡献拆成前缀的贡献，维护子树和。</p></blockquote><h3 id="luogu2680-noip2015-提高组-运输计划">luogu2680 [NOIP2015 提高组]运输计划</h3><p>首先答案是可以二分的。</p><p>问题转化为：判定是否能通过把一条边的权值置为 <spanclass="math inline">\(0\)</span>，使得给定的路径中，最长的路径不超过<span class="math inline">\(mid\)</span>，</p><p>我们考虑所有长度超过 <span class="math inline">\(mid\)</span>的路径，设其的数量为 <span class="math inline">\(cnt\)</span>。那么<span class="math inline">\(mid\)</span> 可行当且仅当存在一条被经过<span class="math inline">\(cnt\)</span> 次，并且其长度大于等于 <spanclass="math inline">\(\max_{i=1}^m \big\{dis(u_i,v_i) \big\} -mid\)</span>。</p><p>怎么做？把路径差分了再做子树和，求出每条边被覆盖的次数，检查一遍即可。</p><p>但是这题卡常，需要预处理出 <spanclass="math inline">\(\text{DFS}\)</span> 序再倒着做子树和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2680 [NOIP2015 提高组] 运输计划</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2680</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 292 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, c[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> sz[N], fa[N], son[N], dep[N], d[N], top[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, z, d;&#125; a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>  </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr, dep[x]=dep[fr]+<span class="hljs-number">1</span>;dfn[++num]=x;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;d[y]=d[x]+z;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(!son[x]||sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa[x]||y==son[x]) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">return</span> dep[x]&lt;dep[y]? x:y;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>, cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) c[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(a[i].d&gt;x) &#123;++c[a[i].x], ++c[a[i].y], c[a[i].z]-=<span class="hljs-number">2</span>;mx=<span class="hljs-built_in">max</span>(mx,a[i].d-x);++cnt;&#125;<span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) c[fa[dfn[i]]]+=c[dfn[i]];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">if</span>(d[i]-d[fa[i]]&gt;=mx&amp;&amp;c[i]&gt;=cnt) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i].x=<span class="hljs-built_in">read</span>(), a[i].y=<span class="hljs-built_in">read</span>();a[i].z=<span class="hljs-built_in">lca</span>(a[i].x,a[i].y);a[i].d=d[a[i].x]+d[a[i].y]<span class="hljs-number">-2</span>*d[a[i].z];R=<span class="hljs-built_in">max</span>(R,a[i].d);&#125;<span class="hljs-keyword">while</span>(L&lt;R) &#123;<span class="hljs-type">int</span> mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) R=mid; <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,L);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4219-bjoi2014-大融合">luogu4219 [BJOI2014] 大融合</h3><p>对于一个询问 <spanclass="math inline">\((x,y)\)</span>，答案就是两边连通块大小之积。</p><p>不过显然不能直接做。</p><p>考虑离线，把树定根后建起来。钦定 <spanclass="math inline">\(\text{dep}(x) \le\text{dep}(y)\)</span>，那么答案就是<strong>此时与 <spanclass="math inline">\(x\)</span>连通的子树大小</strong>减去<strong>此时以 <spanclass="math inline">\(y\)</span>为根且连通的子树大小</strong>，最后再乘上后者。注意这里的子树就是定根后原树中的。</p><p>这个怎么维护呢？用并查集维护连通块，每个连通块的根是原树种深度最低的那个点。如果连边<span class="math inline">\((x,y)\)</span>，那么 <spanclass="math inline">\(y\)</span> 此时所在连通块一定都会贡献到 <spanclass="math inline">\(x\)</span> 以及其父亲的子树中去。</p><p>也就是说这是个链加，我们直接差分掉。问题转化为链加，单点求子树和，摊到<span class="math inline">\(\text{DFS}\)</span>序上即可用树状数组维护。在 <span class="math inline">\(x\)</span>处产生贡献，同时在 <span class="math inline">\(x\)</span>所在连通块的根<strong>在原树中的父亲处消去贡献</strong>，这样就能保证只会贡献到当前连通情况下的点上。</p><p>对于每个询问，与 <span class="math inline">\(x\)</span>连通的子树大小就是此时 <span class="math inline">\(x\)</span>所在连通块的大小，以 <span class="math inline">\(y\)</span>为根且连通的子树大小就是 <span class="math inline">\(y\)</span>的子树和再加上 <span class="math inline">\(1\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, Q, dep[N], tfa[N], tsz[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span> &#123;<span class="hljs-type">int</span> op, x, y;&#125; q[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=y;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res; <span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];<span class="hljs-keyword">return</span> res;&#125;&#125; T, bit;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;dep[x]=dep[fr]+<span class="hljs-number">1</span>;tfa[x]=fr;dfn[x]=++num;tsz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;<span class="hljs-built_in">dfs</span>(y,x);tsz[x]+=tsz[y];&#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N], sz[N], siz[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, siz[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-type">int</span> fx=<span class="hljs-built_in">get</span>(x), fy=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;fa[y]=fx;siz[fx]+=siz[y];T.<span class="hljs-built_in">upd</span>(dfn[x],siz[y]);T.<span class="hljs-built_in">upd</span>(dfn[tfa[fx]],-siz[y]);&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-type">char</span> s[<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>) q[i].op=<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> q[i].op=<span class="hljs-number">2</span>;q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(q[i].x,q[i].y);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);dsu.<span class="hljs-built_in">init</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;<span class="hljs-type">int</span> x=q[i].x, y=q[i].y;<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;dsu.<span class="hljs-built_in">merge</span>(x,y);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-type">int</span> size=dsu.siz[dsu.<span class="hljs-built_in">get</span>(x)];<span class="hljs-type">int</span> szy=T.<span class="hljs-built_in">query</span>(dfn[y]+tsz[y]<span class="hljs-number">-1</span>)-T.<span class="hljs-built_in">query</span>(dfn[y]<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(size-szy)*szy);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4211-lnoi2014-lca">luogu4211 [LNOI2014] LCA</h3><p>首先把询问差分了，考虑求 $_{i=1}^r ((i,z)) $。</p><p>从贡献的角度，<spanclass="math inline">\(\text{dep}\Big(\text{LCA}(i,z)\Big)\)</span>可以被具象化为根到 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(z\)</span> 的路径上交点的个数。</p><p>把询问离线了，询问挂到 <span class="math inline">\(l-1\)</span> 与<span class="math inline">\(r\)</span> 上。从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 枚举节点 <spanclass="math inline">\(i\)</span>，并且使根到 <spanclass="math inline">\(i\)</span> 的路径点权都 <spanclass="math inline">\(+1\)</span>。</p><p>具体地，对于一个询问 <spanclass="math inline">\((z,op,id)\)</span>，我们查询此时根到 <spanclass="math inline">\(z\)</span> 的链和，带上系数 <spanclass="math inline">\(op\)</span> 累加进 <spanclass="math inline">\(ans(id)\)</span> 即可。</p><p>树剖套线段树即可维护。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">201314</span>;<span class="hljs-type">int</span> n, m, ans[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">int</span> son[N], top[N], dep[N], sz[N], fa[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr;sz[x]=<span class="hljs-number">1</span>;dep[x]=dep[fr]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;dfn[x]=++num;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125; &#125;<span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> d)</span> </span>&#123;t[x]+=(r-l+<span class="hljs-number">1</span>)*d;tag[x]+=d;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid,tag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,tag[x]);tag[x]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seg_upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,l,r,d); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">Seg_upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">Seg_upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Seg_query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) (res+=<span class="hljs-built_in">Seg_query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid))%=mod;<span class="hljs-keyword">if</span>(R&gt;mid) (res+=<span class="hljs-built_in">Seg_query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r))%=mod;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span> &#123;<span class="hljs-type">int</span> z, op, id;<span class="hljs-built_in">Q</span>() &#123;&#125;<span class="hljs-built_in">Q</span>(<span class="hljs-type">int</span> _z,<span class="hljs-type">int</span> _op,<span class="hljs-type">int</span> _id) &#123; z=_z, op=_op, id=_id; &#125; &#125;;vector&lt;Q&gt; q[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">Seg_upd</span>(dfn[top[x]],dfn[x],<span class="hljs-number">1</span>);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">Seg_upd</span>(dfn[x],dfn[y],<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);(res+=<span class="hljs-built_in">Seg_query</span>(dfn[top[x]],dfn[x]))%=mod;x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);(res+=<span class="hljs-built_in">Seg_query</span>(dfn[x],dfn[y]));<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">upd</span>(<span class="hljs-number">1</span>,i,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:q[i]) &#123;<span class="hljs-type">int</span> z=t.z, op=t.op, id=t.id;<span class="hljs-type">int</span> res=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,z);ans[id]+=res*op;(ans[id]+=mod)%=mod;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;p[x].<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, r=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, z=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;q[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">Q</span>(z,<span class="hljs-number">1</span>,i));<span class="hljs-keyword">if</span>(l<span class="hljs-number">-1</span>&gt;<span class="hljs-number">0</span>) q[l<span class="hljs-number">-1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">Q</span>(z,<span class="hljs-number">-1</span>,i));&#125;<span class="hljs-built_in">solve</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4216-scoi2015情报传递">luogu4216 [SCOI2015]情报传递</h3><p>发现操作一挺难搞的。</p><p>考虑第二种操作。<span class="math inline">\(i\)</span> 时刻点权大于<span class="math inline">\(c\)</span>，等价于开始时间小于 <spanclass="math inline">\(i-c\)</span>。问题转化为求一条链上小于某个数的个数。</p><p>lxl 课件上说用树剖 + 树状数组可以做到 <span class="math inline">\(O(m\log_2^2 n)\)</span>，但是我不会。</p><p>继续观察。如果我们把操作一看成一个点的点权从 <spanclass="math inline">\(0\)</span> 变成 <spanclass="math inline">\(1\)</span>，问题等价于求 <spanclass="math inline">\(i-c-1\)</span> 时刻 <spanclass="math inline">\((x,y)\)</span> 的链和。</p><p>把询问差分成前缀和相减，离线后挂到时间上，单点加转化为子树加，树状数组即可维护。</p><p>时间复杂度是 <span class="math inline">\(O(m \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, rt, Q, ans[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> &#123;<span class="hljs-type">int</span> op, x, y, c;&#125; q[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, id;&#125;;vector&lt;node&gt; v[N];<span class="hljs-type">int</span> son[N], top[N], dep[N], sz[N], fa[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=d;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];<span class="hljs-keyword">return</span> res;&#125;&#125; T;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr;sz[x]=<span class="hljs-number">1</span>;dep[x]=dep[fr]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;dfn[x]=++num;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">return</span> dep[x]+dep[y]-dep[z]-dep[fa[z]];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">return</span> T.<span class="hljs-built_in">query</span>(dfn[x])+T.<span class="hljs-built_in">query</span>(dfn[y])-T.<span class="hljs-built_in">query</span>(dfn[z])-T.<span class="hljs-built_in">query</span>(dfn[fa[z]]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>) p[x].<span class="hljs-built_in">pb</span>(i); <span class="hljs-keyword">else</span> rt=i;&#125;Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;q[i].op=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>(), q[i].c=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(i-q[i].c<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) v[i-q[i].c<span class="hljs-number">-1</span>].<span class="hljs-built_in">pb</span>((node)&#123;q[i].x,q[i].y,i&#125;);&#125; <span class="hljs-keyword">else</span> q[i].x=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">dfs1</span>(rt,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(rt,rt);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,Q) &#123;<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> x=q[i].x;T.<span class="hljs-built_in">upd</span>(dfn[x],<span class="hljs-number">1</span>);T.<span class="hljs-built_in">upd</span>(dfn[x]+sz[x],<span class="hljs-number">-1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v[i]) &#123;ans[t.id]=<span class="hljs-built_in">calc</span>(t.x,t.y);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) <span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,<span class="hljs-built_in">dis</span>(q[i].x,q[i].y),ans[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="树上倍增">树上倍增</h2><p>没啥技巧，直接上题。</p><h3 id="cf932d-tree">CF932D Tree</h3><p>设 <span class="math inline">\(f(x,i)\)</span> 表示从 <spanclass="math inline">\(x\)</span> 往上提取一个长度为 <spanclass="math inline">\(2^i\)</span> 的点权单调不降子序列（不含 <spanclass="math inline">\(x\)</span>），最后一项的节点编号。</p><p>发现要是能处理出 <span class="math inline">\(f(x,0)\)</span>就做完了。</p><p>对于一个新加入的 <span class="math inline">\(x\)</span>，如果 <spanclass="math inline">\(f(x,0) \neq fa(x)\)</span>，那么就从 <spanclass="math inline">\(fa(x)\)</span> 向上找到最后一个满足 <spanclass="math inline">\(w_p &lt; w_x\)</span> 的 <spanclass="math inline">\(p\)</span>，<spanclass="math inline">\(fa(p)\)</span> 就是 <spanclass="math inline">\(f(x,0)\)</span>。</p><h3 id="cf519e-a-and-b-and-lecture-rooms">CF519E A and B and LectureRooms</h3><p>运用本文第一题的结论。</p><p>一个点分别到 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 的路径，一定是先重合一段，然后路径<span class="math inline">\((x,y)\)</span>的一个点上分开。也就是说，到二者的距离相等的点，一定满足这个交点是路径<span class="math inline">\((x,y)\)</span> 的中点。</p><p>设中点为 <span class="math inline">\(p\)</span>，考虑其与 <spanclass="math inline">\(z=\text{LCA}(x,y)\)</span> 的关系。</p><p>设 <span class="math inline">\(pre_x(y)\)</span> 为 <spanclass="math inline">\(x\)</span> 的一个祖先，满足其是 <spanclass="math inline">\(y\)</span> 的子节点。</p><ul><li><span class="math inline">\(p=z\)</span>，答案就是 <spanclass="math inline">\(n-pre_x(z)-pre_y(z)\)</span>。</li><li><span class="math inline">\(p\)</span> 在靠近 <spanclass="math inline">\(x\)</span> 的那一侧，答案是 <spanclass="math inline">\(sz_{p} - pre_x(p)\)</span>。</li><li><span class="math inline">\(p\)</span> 在靠近 <spanclass="math inline">\(y\)</span> 的那一侧，答案是 <spanclass="math inline">\(sz_p - pre_y(p)\)</span>。</li></ul><p><span class="math inline">\(\text{dep}(p)\)</span> 可以根据 <spanclass="math inline">\((x,y,z)\)</span> 的深度关系得到，然后倍增求出<span class="math inline">\(q\)</span>。</p><p><span class="math inline">\(pre_x(y)\)</span> 也可以从 <spanclass="math inline">\(x\)</span> 往上倍增出来。</p><h3 id="luogu8820-csp-s-2022-数据传输">luogu8820 [CSP-S 2022]数据传输</h3><p><ahref="https://yozora0908.github.io/2023/lg8820-solution">link</a></p><h3 id="loj-2955.-noip2018保卫王国">LOJ #2955. 「NOIP2018」保卫王国</h3><p><ahref="https://yozora0908.github.io/2023/loj2955-solution">link</a></p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;树上差分&quot;&gt;树上差分&lt;/h2&gt;
&lt;p&gt;从抽象代数的角度讲，树上差分可以维护所有群上信息。&lt;/p&gt;
&lt;p&gt;换句话说，满足结合律，存在「可减性」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过差分我们能将一个高纬问题以常数代价转化为低维问题，而问题低一维往往会简单非常多&lt;/p&gt;
&lt;p&gt;—— lxl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;太 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;textit{Trivial}&#92;)&lt;/span&gt;
的我们就不提了。&lt;/p&gt;
&lt;p&gt;下文成「前缀」为根到节点的路径。&lt;/p&gt;
&lt;h3 id=&quot;luogu8201-yloi2021-生活在树上hard-version&quot;&gt;luogu8201 [yLOI2021]
生活在树上（hard version）&lt;/h3&gt;
&lt;p&gt;考虑这样一个结论。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;树上路径 &lt;span class=&quot;math inline&quot;&gt;&#92;((t,x)&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;((t,y)&#92;)&lt;/span&gt;，一定是先有一段重合的路径，再与路径
&lt;span class=&quot;math inline&quot;&gt;&#92;((x,y)&#92;)&lt;/span&gt; 交于一点 &lt;span class=&quot;math inline&quot;&gt;&#92;(z&#92;)&lt;/span&gt;，然后分别连向对应的点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="树论" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="树上倍增" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
    <category term="线段树" scheme="https://yozora0908.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树状数组" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="树上差分" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
    <category term="树链剖分" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#19 费用提前计算</title>
    <link href="https://yozora0908.github.io/2023/noip-record-19/"/>
    <id>https://yozora0908.github.io/2023/noip-record-19/</id>
    <published>2023-09-06T22:29:32.000Z</published>
    <updated>2023-09-06T22:36:46.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>未完待续</p><h3 id="cf1107e-vasya-and-binary-string">CF1107E Vasya and BinaryString</h3><p>设 <span class="math inline">\(f(i,j,t)\)</span> 为删去区间 <spanclass="math inline">\([i,j]\)</span>，其中区间右边还有 <spanclass="math inline">\(t\)</span> 个与 <spanclass="math inline">\(S[j]\)</span> 相同的字符的最大收益。</p><p><span class="math display">\[f(i,j,t) = \max \begin{cases}f(i,j-1,0) + a_{t+1}\\\max _{k=i}^{j-1} \Big\{ f(i,k,t+1) + f(k+1,j-1,0)  \Big\}\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, a[N], f[N][N][N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> t)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">return</span> a[t+<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(f[i][j][t]) <span class="hljs-keyword">return</span> f[i][j][t];<span class="hljs-type">int</span>&amp; res=f[i][j][t];res=<span class="hljs-built_in">dfs</span>(i,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+a[t+<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;++k) <span class="hljs-keyword">if</span>(s[k]==s[j]) &#123;res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+<span class="hljs-built_in">dfs</span>(i,k,t+<span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>));&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;</summary>
      
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="区间DP" scheme="https://yozora0908.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
    <category term="费用提前计算" scheme="https://yozora0908.github.io/tags/%E8%B4%B9%E7%94%A8%E6%8F%90%E5%89%8D%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>luogu9221 「TAOI-1」Pentiment 题解</title>
    <link href="https://yozora0908.github.io/2023/lg9221-solution/"/>
    <id>https://yozora0908.github.io/2023/lg9221-solution/</id>
    <published>2023-08-30T06:33:54.000Z</published>
    <updated>2023-08-30T06:37:13.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>先考虑部分分怎么打。</p><p>根据个人习惯，规定下文中「直角蛇」是从最上面一行到达最下面一行。</p><h3 id="subtask-2">subtask 2</h3><p>不妨这样考虑：到达每一行后，都可以通过左右移动，到达下一行的任意一个位置。到达第一行的位置可以任选；从任意位置到达最后一行后，可以再通过左右移动，在任意位置结束。所以答案就是<span class="math display">\[m^{n+1}\]</span></p><h3 id="subtask-1-and-3">subtask 1 and 3</h3><p>这两个子任务都可以用 <span class="math inline">\(O(nm)\)</span>的做法解决。</p><p>结合 subtask 2，我们对每一行考虑。发现第 <spanclass="math inline">\(i-1\)</span> 行和第 <spanclass="math inline">\(i\)</span> 行本质上是「输送与接收」的关系。</p><p>不妨称不能走的节点为关键点，我们能发现如下性质。</p><ul><li><p>关键点把第 <span class="math inline">\(i-1\)</span> 行和第 <spanclass="math inline">\(i\)</span>行划分成了若干个连续段，只有当两行的连续段有交时，才能完成方案的传递。</p></li><li><p>到达同一个连续段内任意节点的方案数是相等的。这个容易理解，我们到达这一段后可以左右任意走。</p></li></ul><p>这两个性质启发我们这样做：</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为直角蛇到达 <spanclass="math inline">\((i,j)\)</span> 的方案数。对于第 <spanclass="math inline">\(i\)</span> 行，如果 <spanclass="math inline">\((i,j)\)</span> 不是关键点，我们就把 <spanclass="math inline">\(f(i-1,j)\)</span> 的方案下传到 <spanclass="math inline">\(f(i,j)\)</span>。然后对 <spanclass="math inline">\(j\)</span>这一维做前缀和，最后扫一遍，每个点的方案就是其所在连续段的总和。</p><p>使用滚动数组，时间和空间都可以接受。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, q;bitset&lt;10002&gt; v[<span class="hljs-number">10002</span>];bitset&lt;1000002&gt; v1[<span class="hljs-number">3</span>];<span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][<span class="hljs-number">10002</span>], r[<span class="hljs-number">10002</span>], s[<span class="hljs-number">10002</span>];<span class="hljs-keyword">namespace</span> sub3 &#123;    <span class="hljs-comment">// 这是subtask3的代码。</span>    <span class="hljs-comment">// 如果要求解subtask1，那么就交换行和列，用v1做标记即可。</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> lst=m;<span class="hljs-built_in">per</span>(j,m,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(v[i][j]) r[j]=j, lst=j<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span> r[j]=lst;&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;f[i&amp;<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!v[i][j]) &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) s[j]=<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> s[j]=f[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j];s[j]=(<span class="hljs-number">1ll</span>*s[j]+s[j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;R=r[j];<span class="hljs-keyword">if</span>(!v[i][j]) f[i&amp;<span class="hljs-number">1</span>][j]=(s[R]-s[L]+mod)%mod;<span class="hljs-keyword">else</span> L=j, f[i&amp;<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) ans=(<span class="hljs-number">1ll</span>*ans+f[n&amp;<span class="hljs-number">1</span>][i])%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;&#125;;</code></pre></div><h3 id="subtask-6">subtask 6</h3><p>我们发现方案的下传像是在做类似于区间合并的东西。由于本人太菜，不会使用数据结构，所以就对着题解中的离线做法写了，就此学习一下此类问题的处理方法。</p><p>对于连续的不存在关键点的行，其方案数是容易求出的，所以有用的只有不同行的关键点。对此我们可以将所有关键点按照横坐标排序。</p><p>先不考虑连续空行的情况。我们应该先找到一个临界点 <spanclass="math inline">\(i\)</span>，满足 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+1\)</span> 在不同行，再维护一个上一行的末尾位置<spanclass="math inline">\(k\)</span>。这样我们就能得到这一整行的信息了，同时要维护上一行的区间以及区间内每个位置的方案数（每个位置的方案数都相等）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r; ll x;    <span class="hljs-comment">// 区间[l,r]，每个点的方案数都是x</span><span class="hljs-built_in">node</span>() &#123;&#125;;<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _l,<span class="hljs-type">int</span> _r,ll _x) &#123; l=_l, r=_r, x=_x; &#125;&#125; f[N];</code></pre></div><p>考虑如何区间合并。对于当前行的区间，只要上一行的某个区间与其有交，方案就能下传，看起来不很好做。但反过来想，如果当前行被上一行两个区间下传方案了，那么说明一定有关键点把上面那两个区间隔开。也就是说，如果我们把上一行的关键点当作当前行的关键点，这样得到的区间一定会被上一行唯一确定的一个区间下传方案。</p><p>我们先把两行的关键点都存下来，排序后去重。</p><p>对于两个关键点确定的一个区间 <spanclass="math inline">\([L,R]\)</span>，我们找到之前合并完的第一个与这个区间有交的区间，<spanclass="math inline">\([L,R]\)</span> 的方案数就是 <spanclass="math inline">\(R-L+1\)</span> 乘那个区间的方案。注意要把边界<span class="math inline">\(0\)</span> 与 <spanclass="math inline">\(m+1\)</span> 都加入。</p><div class="code-wrapper"><pre><code class="hljs cpp">p.<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>==a[i].fi) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&amp;&amp;a[j].fi==a[k].fi;--j) b[++tot]=a[j].se;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k+<span class="hljs-number">1</span>;j&lt;=i;++j) b[++tot]=a[j].se, p[a[j].se]=<span class="hljs-number">1</span>;b[++tot]=<span class="hljs-number">0</span>, b[++tot]=m+<span class="hljs-number">1</span>;<span class="hljs-built_in">uniq</span>(b,tot);vector&lt;node&gt; v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,pos=<span class="hljs-number">1</span>;j&lt;tot;++j) &#123;<span class="hljs-keyword">if</span>(b[j]&amp;&amp;!p.<span class="hljs-built_in">count</span>(b[j])) v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(b[j],b[j],<span class="hljs-number">0ll</span>));<span class="hljs-type">int</span> L=b[j]+<span class="hljs-number">1</span>, R=b[j+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(L&gt;R) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">while</span>(pos&lt;=cnt&amp;&amp;f[pos].r&lt;L) ++pos;ll sum=f[pos].x*(R-L+<span class="hljs-number">1</span>)%mod;v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(L,R,sum));&#125;</code></pre></div><p>对于合并，只需要将上一行的关键点当作连接区间的桥梁。具体地，我们将通过上述做法得到的区间都存下来，然后把上一行的关键点当作长度为<span class="math inline">\(1\)</span>的区间加进去。合并时，只需要扫一边所有区间，根据端点判断是否可以合并即可，方案数就直接累加。</p><div class="code-wrapper"><pre><code class="hljs cpp">cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> xx:v) &#123;<span class="hljs-keyword">if</span>(!cnt||f[cnt].r!=xx.l<span class="hljs-number">-1</span>) f[++cnt]=xx;<span class="hljs-keyword">else</span> f[cnt].r=xx.r, (f[cnt].x+=xx.x)%=mod;&#125;</code></pre></div><p>对于连续的没有关键点的行，我们只需要先将方案下放并累加，然后乘 <spanclass="math inline">\(m\)</span> 的对应次幂，最后只留下 <spanclass="math inline">\([1,m]\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>!=a[i].fi) &#123;<span class="hljs-type">int</span> dx=a[i].fi-a[k].fi<span class="hljs-number">-2</span>;    ll sum=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) (sum+=f[j].x*(f[j].r-f[j].l+<span class="hljs-number">1</span>)%mod)%=mod;(sum*=<span class="hljs-built_in">fp</span>(m,dx))%=mod;f[<span class="hljs-number">1</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,m,sum);cnt=<span class="hljs-number">1</span>;&#125;</code></pre></div><p>做完之后，最后一定还剩下若干没有关键点的行，照做即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, q, cnt, ans, b[N], t[N];PII a[N];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; p;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r; ll x;<span class="hljs-built_in">node</span>() &#123;&#125;;<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _l,<span class="hljs-type">int</span> _r,ll _x) &#123; l=_l, r=_r, x=_x; &#125;&#125; f[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;ll c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=<span class="hljs-number">1ll</span>*a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uniq</span><span class="hljs-params">(<span class="hljs-type">int</span>* b,<span class="hljs-type">int</span>&amp; tot)</span> </span>&#123;<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+tot+<span class="hljs-number">1</span>);tot=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+tot+<span class="hljs-number">1</span>)-b<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>();    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;f[++cnt]=<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,m,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) <span class="hljs-keyword">if</span>(i==q||a[i].fi!=a[i+<span class="hljs-number">1</span>].fi) &#123;<span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>!=a[i].fi) &#123;<span class="hljs-type">int</span> dx=a[i].fi-a[k].fi<span class="hljs-number">-2</span>; ll sum=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) (sum+=f[j].x*(f[j].r-f[j].l+<span class="hljs-number">1</span>)%mod)%=mod;(sum*=<span class="hljs-built_in">fp</span>(m,dx))%=mod;f[<span class="hljs-number">1</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,m,sum);cnt=<span class="hljs-number">1</span>;&#125;p.<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>==a[i].fi) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&amp;&amp;a[j].fi==a[k].fi;--j) b[++tot]=a[j].se;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k+<span class="hljs-number">1</span>;j&lt;=i;++j) b[++tot]=a[j].se, p[a[j].se]=<span class="hljs-number">1</span>;b[++tot]=<span class="hljs-number">0</span>, b[++tot]=m+<span class="hljs-number">1</span>;<span class="hljs-built_in">uniq</span>(b,tot);vector&lt;node&gt; v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,pos=<span class="hljs-number">1</span>;j&lt;tot;++j) &#123;<span class="hljs-keyword">if</span>(b[j]&amp;&amp;!p.<span class="hljs-built_in">count</span>(b[j])) v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(b[j],b[j],<span class="hljs-number">0ll</span>));<span class="hljs-type">int</span> L=b[j]+<span class="hljs-number">1</span>, R=b[j+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(L&gt;R) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">while</span>(pos&lt;=cnt&amp;&amp;f[pos].r&lt;L) ++pos;ll sum=f[pos].x*(R-L+<span class="hljs-number">1</span>)%mod;v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(L,R,sum));&#125;cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> xx:v) &#123;<span class="hljs-keyword">if</span>(!cnt||f[cnt].r!=xx.l<span class="hljs-number">-1</span>) f[++cnt]=xx;<span class="hljs-keyword">else</span> f[cnt].r=xx.r, (f[cnt].x+=xx.x)%=mod;&#125;k=i;&#125;<span class="hljs-type">int</span> dx=n-a[k].fi;    ll sum=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) (sum+=f[i].x*(f[i].r-f[i].l+<span class="hljs-number">1</span>)%mod)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sum*<span class="hljs-built_in">fp</span>(m,dx)%mod);&#125;</code></pre></div><p>计数部分不难，难在对区间的处理。</p><p>怎么说，在考场上，除非时间很充足并且有很大把握，否则是不会去写这种题的。</p><p>但过一遍这道题也有所收获。</p><p>初看这道题，很容易与某组合典题联系起来，从而想到利用关键点去容斥。尽管正解不是这样做，但最终也需要在关键点上下功夫，算是完善一下科技树并锻炼代码能力了。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;先考虑部分分怎么打。&lt;/p&gt;
&lt;p&gt;根据个人习惯，规定下文中「直角蛇」是从最上面一行到达最下面一行。&lt;/p&gt;
&lt;h3 id=&quot;subtask-2&quot;&gt;subtask 2&lt;/h3&gt;
&lt;p&gt;不妨这样考虑：到达每一行后，都可以通过左右移动，到达下一行的任意一个位置。到达第一行的位置可以任选；从任意位置到达最后一行后，可以再通过左右移动，在任意位置结束。所以答案就是
&lt;span class=&quot;math display&quot;&gt;&#92;[
m^{n+1}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;subtask-1-and-3&quot;&gt;subtask 1 and 3&lt;/h3&gt;
&lt;p&gt;这两个子任务都可以用 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(nm)&#92;)&lt;/span&gt;
的做法解决。&lt;/p&gt;
&lt;p&gt;结合 subtask 2，我们对每一行考虑。发现第 &lt;span class=&quot;math inline&quot;&gt;&#92;(i-1&#92;)&lt;/span&gt; 行和第 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 行本质上是「输送与接收」的关系。&lt;/p&gt;
&lt;p&gt;不妨称不能走的节点为关键点，我们能发现如下性质。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关键点把第 &lt;span class=&quot;math inline&quot;&gt;&#92;(i-1&#92;)&lt;/span&gt; 行和第 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;
行划分成了若干个连续段，只有当两行的连续段有交时，才能完成方案的传递。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;到达同一个连续段内任意节点的方案数是相等的。这个容易理解，我们到达这一段后可以左右任意走。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="计数" scheme="https://yozora0908.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="区间合并" scheme="https://yozora0908.github.io/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#18 区间DP</title>
    <link href="https://yozora0908.github.io/2023/noip-record-18/"/>
    <id>https://yozora0908.github.io/2023/noip-record-18/</id>
    <published>2023-08-30T06:33:43.000Z</published>
    <updated>2023-09-04T02:26:21.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="区间形态的扩展">区间形态的扩展</h2><h3 id="luogu3205-hnoi2010-合唱队">luogu3205 [HNOI2010] 合唱队</h3><p>队列的形成方式是不断往左或往右扩展。</p><p>考虑区间 DP。发现对于一个区间 <spanclass="math inline">\([i,j]\)</span>，最后一个元素的来源会对转移产生影响，所以设<span class="math inline">\(f(i,j,0/1)\)</span> 为考虑区间 <spanclass="math inline">\([i,j]\)</span>，其中最后一个元素是从左边还是右边加入的方案数。</p><p>转移很简单 <span class="math display">\[f(i,j,0) = [a_i &lt; a_{i+1}]f(i+1,j,0) + [a_i &lt; a_j] f(i+1,j,0)\]</span></p><p><span class="math display">\[f(i,j,1) = [a_j &gt; a_{i}] f(i,j-1,0) + [a_j &gt; a_{j-1}] f(i,j-1,1)\]</span></p><p>注意对于 <spanclass="math inline">\([i,i]\)</span>，钦定从一边转移过来即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3205 [HNOI2010] 合唱队</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3205</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">19650827</span>;<span class="hljs-type">int</span> n, a[N], f[N][N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(),  f[i][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(a[i]&lt;a[i+<span class="hljs-number">1</span>]) (f[i][j][<span class="hljs-number">0</span>]+=f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>])%=mod;<span class="hljs-keyword">if</span>(a[i]&lt;a[j]) (f[i][j][<span class="hljs-number">0</span>]+=f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>])%=mod;<span class="hljs-keyword">if</span>(a[j]&gt;a[i]) (f[i][j][<span class="hljs-number">1</span>]+=f[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>])%=mod;<span class="hljs-keyword">if</span>(a[j]&gt;a[j<span class="hljs-number">-1</span>]) (f[i][j][<span class="hljs-number">1</span>]+=f[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>]+f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>])%mod);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="某道题">某道题</h3><blockquote><p>你有 <span class="math inline">\([1,n]\)</span> 中的正整数各 <spanclass="math inline">\(2\)</span> 个，存在 <spanclass="math inline">\(k\)</span> 个限制。</p><p>要求将这 <span class="math inline">\(2n\)</span>个数排成一个序列，满足以下两个条件：</p><ul><li>如果存在一个最大的数所在的的位置 <spanclass="math inline">\(p\)</span>，满足 <spanclass="math inline">\(p&gt;1\)</span>，那么 <spanclass="math inline">\([1,p]\)</span> 中的数单调不降。</li><li>如果存在一个最大的数所在的的位置 <spanclass="math inline">\(p\)</span>，满足 <spanclass="math inline">\(p&lt;n\)</span>，那么 <spanclass="math inline">\([p,n]\)</span> 中的数单调不增。</li></ul><p>每个限制条件形如<code>x op y</code>。</p><p>其中<code>op</code>可能为<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;=</code>，<code>&gt;</code>，表示下标为<span class="math inline">\(x\)</span> 的数与下标为 <spanclass="math inline">\(y\)</span> 的数必须满足的大小关系。</p><p>求方案数，对 <span class="math inline">\(998244353\)</span>取模。</p><p><span class="math inline">\(n \le 1000\)</span>，<spanclass="math inline">\(0 \le k \le 3 \times 10^4\)</span>。</p><p>注意：原题没有取模，<span class="math inline">\(n \le500\)</span>。但是复杂度的瓶颈在于高精度，所以这里加上取模，并且增大数据范围。</p></blockquote><p>先不考虑限制。</p><p>如何生成这样的序列呢？考虑从大到小放。两个 <spanclass="math inline">\(n\)</span>肯定要放到中间，剩下的数要么两边放一个，要么都放在一边。这样就是呈区间形态的扩展方式，考虑区间DP。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为考虑了 <spanclass="math inline">\([k,n]\)</span> 中的数，放完了区间 <spanclass="math inline">\([i,j]\)</span> 的方案。</p><p>仔细思考能发现记录 <span class="math inline">\(k\)</span>根本没有用，只要区间扩展时每次只扩展 <spanclass="math inline">\(2\)</span> 的长度，就一定合法。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为放完了区间 <spanclass="math inline">\([i,j]\)</span> 的方案数。</p><p>如果没有限制的话，能发现答案就是 <spanclass="math inline">\(3^{n-1}\)</span>。</p><p>考虑限制。</p><p>我们讨论三种方法是否会受限制。</p><ol type="1"><li>放的两个位置必须都允许相等。</li><li>这两个位置都必须严格小于其他位置。</li></ol><p>暴力判断就是 <span class="math inline">\(O(n)\)</span> 的。</p><p>利用大小关系的对称性。设 <span class="math inline">\(s(i,j)\)</span>为 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span> 的限制，没有就是 <spanclass="math inline">\(0\)</span>，<code>&lt;</code>是 <spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(\le\)</span> 是 <spanclass="math inline">\(2\)</span>，<code>=</code>是 <spanclass="math inline">\(3\)</span>。对 <spanclass="math inline">\(j\)</span> 这一维求前缀和，就能 <spanclass="math inline">\(O(1)\)</span>判断一个区间对一个位置的限制，加以讨论即可做到 <spanclass="math inline">\(O(n^2)\)</span>。</p><p>下面的代码是带着高精的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;string st;<span class="hljs-type">int</span> n, k, p[N][N], s[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Int</span> &#123;<span class="hljs-type">short</span> a[<span class="hljs-number">245</span>], deg=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(a,<span class="hljs-number">0</span>); deg=<span class="hljs-number">0</span>; &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">zero</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> !deg||(deg==<span class="hljs-number">1</span>&amp;&amp;a[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>); &#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">int</span> x) &#123; deg=<span class="hljs-number">1</span>; a[deg<span class="hljs-number">-1</span>]=x; &#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(Int&amp; x) &#123;deg=<span class="hljs-built_in">max</span>(deg,x.deg);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;deg;++i) &#123;a[i]+=x.a[i];a[i+<span class="hljs-number">1</span>]+=a[i]/<span class="hljs-number">10</span>;a[i]%=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">while</span>(a[deg]) ++deg;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=deg<span class="hljs-number">-1</span>;~i;--i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);&#125;&#125; f[N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>()*<span class="hljs-number">2</span>, k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>();cin&gt;&gt;st;<span class="hljs-type">int</span> r=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;&lt;&quot;</span>) p[l][r]=<span class="hljs-number">1</span>, p[r][l]=<span class="hljs-number">5</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;&lt;=&quot;</span>) p[l][r]=<span class="hljs-number">2</span>, p[r][l]=<span class="hljs-number">4</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;=&quot;</span>) p[l][r]=p[r][l]=<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;&gt;=&quot;</span>) p[l][r]=<span class="hljs-number">4</span>, p[r][l]=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> p[l][r]=<span class="hljs-number">5</span>, p[r][l]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) s[i][j]=s[i][j<span class="hljs-number">-1</span>]+(p[i][j]&gt;<span class="hljs-number">2</span>);f[<span class="hljs-number">1</span>][n]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(!p[i][i+<span class="hljs-number">1</span>]||(p[i][i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">2</span>&amp;&amp;p[i][i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-number">4</span>)) f[i][i+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;l+=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(!f[i][j].<span class="hljs-built_in">zero</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(p[i][i+<span class="hljs-number">1</span>]!=<span class="hljs-number">1</span>&amp;&amp;p[i][i+<span class="hljs-number">1</span>]!=<span class="hljs-number">5</span>&amp;&amp;!f[i+<span class="hljs-number">2</span>][j].<span class="hljs-built_in">zero</span>()) &#123;<span class="hljs-keyword">if</span>(s[i][j]==s[i][i+<span class="hljs-number">1</span>]&amp;&amp;s[i+<span class="hljs-number">1</span>][j]==s[i+<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>]) f[i][j]+=f[i+<span class="hljs-number">2</span>][j];&#125;<span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>][j]!=<span class="hljs-number">1</span>&amp;&amp;p[j<span class="hljs-number">-1</span>][j]!=<span class="hljs-number">5</span>&amp;&amp;!f[i][j<span class="hljs-number">-2</span>].<span class="hljs-built_in">zero</span>()) &#123;<span class="hljs-keyword">if</span>(s[j][j<span class="hljs-number">-2</span>]==s[j][i<span class="hljs-number">-1</span>]&amp;&amp;s[j<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>]==s[j<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>]) f[i][j]+=f[i][j<span class="hljs-number">-2</span>];&#125;<span class="hljs-keyword">if</span>(p[i][j]!=<span class="hljs-number">1</span>&amp;&amp;p[i][j]!=<span class="hljs-number">5</span>&amp;&amp;!f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>].<span class="hljs-built_in">zero</span>()) &#123;<span class="hljs-keyword">if</span>(s[i][j<span class="hljs-number">-1</span>]==s[i][i]&amp;&amp;s[j][j<span class="hljs-number">-1</span>]==s[j][i]) f[i][j]+=f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];&#125;&#125;f[<span class="hljs-number">1</span>][n].<span class="hljs-built_in">print</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu6563-sbcoi2020-一直在你身旁">luogu6563 [SBCOI2020]一直在你身旁</h3><p><ahref="https://yozora0908.github.io/2023/lg6563-solution">link</a></p><h2 id="求出区间信息后贪心划分">求出区间信息后贪心划分</h2><h3 id="uva1437-string-painter">UVA1437 String painter</h3><blockquote><p>我断言一定存在一种最优的方案满足对于任意两次染色：它们的区间要么不交，要么靠后的那次被靠前的那次包含并且不共端点。</p><p>By <a href="https://www.luogu.com.cn/user/174045">FZzzz</a></p></blockquote><p>先考虑空串怎么做。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为完成区间 <spanclass="math inline">\([i,j]\)</span> 的涂色的最小代价。</p><ul><li>如果 <span class="math inline">\(S[i]=S[j]\)</span>，那么 <spanclass="math inline">\(f(i,j) = f(i,j-1)\)</span>。</li><li>否则一定一个断点，满足左右两边的染色区间不相交。枚举断点即可。</li></ul><p>考虑原问题，不难发现最优解一定是若干个不相交区间的 <spanclass="math inline">\(f\)</span> 拼接成的。</p><p>设 <span class="math inline">\(g(i)\)</span> 为完成 <spanclass="math inline">\([1,i]\)</span> 的涂色的最小代价。如果 <spanclass="math inline">\(A[i] = B[i]\)</span>，那么直接继承 <spanclass="math inline">\(g(i-1)\)</span>。否则枚举最后一段的划分点，求<span class="math inline">\(\min_{j=1}^{i-1} \Big\{g(j)+f(j+1,i)\Big\}\)</span></p><h3 id="luogu2470-scoi2007-压缩">luogu2470 [SCOI2007] 压缩</h3><p>和上面那题的套路很像。</p><p>先考虑没有<code>M</code>的情况。</p><p>发现直接做是不行的，比如<code>aaaabaaaab</code>，最短的压缩应该是<code>aRRbR</code>。也就是说，这里有一个子问题的结构。</p><p>设 <span class="math inline">\(g(i,j)\)</span>为不考虑<code>M</code>，区间 <span class="math inline">\([i,j]\)</span>的最小压缩长度。</p><p>仔细思考，发现这个区间能折半的话就折半，否则就只能拖在后面。 <spanclass="math display">\[g(i,j) = \min \begin{cases}g(i,i+mid-1)+1 &amp; \text{if } \; valid(i,j)\\g(i,j-1)+1\end{cases}\]</span> 其中 <span class="math inline">\(valid(i,j)\)</span> 表示<span class="math inline">\([i,j]\)</span>能否从中间划分成两个相同的串。</p><p>然后设 <span class="math inline">\(f(i)\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 的最小划分，有 <spanclass="math display">\[f(i) = \min_{j=0}^{i-1} \Big\{ f(j) + g(j+1,i) \Big\}\]</span> 如果用哈希求 <spanclass="math inline">\(valid(i,j)\)</span>，那么复杂度就是 <spanclass="math inline">\(O(n^2)\)</span>，优于洛谷题解区所有题解。</p><p>但是数据太水，如果用哈希可能因为常数大跑得更慢，所以本人采用了暴力做法，是<span class="math inline">\(O(n^3)\)</span> 的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-type">int</span> n, f[N], g[N][N];string s;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;cin&gt;&gt;s;n=s.<span class="hljs-built_in">size</span>();s=<span class="hljs-string">&quot; &quot;</span>+s;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) g[i][i]=<span class="hljs-number">1</span>, g[i][i+<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> lim=<span class="hljs-number">3</span>;lim&lt;=n;++lim) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+lim<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+lim<span class="hljs-number">-1</span>;<span class="hljs-type">int</span>&amp; res=g[i][j];res=lim;<span class="hljs-keyword">if</span>(lim%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;s.<span class="hljs-built_in">substr</span>(i,lim/<span class="hljs-number">2</span>)==s.<span class="hljs-built_in">substr</span>(i+lim/<span class="hljs-number">2</span>,lim/<span class="hljs-number">2</span>)) res=<span class="hljs-built_in">min</span>(res,g[i][i+lim/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);res=<span class="hljs-built_in">min</span>(res,g[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i]=g[<span class="hljs-number">1</span>][i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) &#123;f[i]=<span class="hljs-built_in">min</span>(f[i],f[j]+g[j+<span class="hljs-number">1</span>][i]+<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>类题还有<ahref="https://yozora0908.github.io/2022/cf1312e-solution/">CF1312E ArrayShrinking</a></p><h2 id="对相交区间的处理">对相交区间的处理</h2><h3 id="luogu5851-usaco19dec-greedy-pie-eaters">luogu5851 [USACO19DEC]Greedy Pie Eaters</h3><p>一个合法的顺序，一定若干个区间不断向外扩展。</p><p>一次收益只需要保证一个元素的存在，可以就此入手。</p><p>区间重叠难以处理，而数据范围较小，可以对区间范围进行限制。</p><p>设 <span class="math inline">\(g(k,i,j)\)</span> 为只考虑被 <spanclass="math inline">\([i,j]\)</span> 完全包含的区间，所有覆盖过 <spanclass="math inline">\(k\)</span> 的区间的最大权值。</p><p>容易在 <span class="math inline">\(O(n^3)\)</span>的时间里处理出来。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为只考虑被 <spanclass="math inline">\([i,j]\)</span>完全包含的区间，能够产生的最大收益。</p><p>枚举最后一个被干掉的元素 <spanclass="math inline">\(k\)</span>，有转移 <span class="math display">\[f(i,j) = \max_{k=i}^j \Big\{ f(i,k-1) + g(k,i,j) + f(k+1,j)  \Big\}\]</span> 对于区间 <spanclass="math inline">\([i,j]\)</span>，一定存在最后一个被干掉的元素。想要这个元素此时依然存在，之前选择的区间就不能包含它，而两边都是子问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P5851 [USACO19DEC] Greedy Pie Eaters P</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P5851</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>;<span class="hljs-type">int</span> n, m, f[N][N], g[N][N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> w=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(k,l,r) g[k][l][r]=<span class="hljs-built_in">max</span>(g[k][l][r],w);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(k,i,j) &#123;g[k][i][j]=<span class="hljs-built_in">max</span>(&#123;g[k][i][j],g[k][i+<span class="hljs-number">1</span>][j],g[k][i][j<span class="hljs-number">-1</span>]&#125;);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][i]=<span class="hljs-built_in">max</span>(f[i][i],g[i][i][i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(k,i,j) &#123;f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][k<span class="hljs-number">-1</span>]+g[k][i][j]+f[k+<span class="hljs-number">1</span>][j]);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj2688.-poi2015洗车">LOJ#2688. 「POI2015」洗车</h3><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为考虑洗车店区间<span class="math inline">\([i,j]\)</span> 和被区间 <spanclass="math inline">\([i,j]\)</span> 完全包含的消费者区间，<spanclass="math inline">\([i,j]\)</span> 的最小值为 <spanclass="math inline">\(k\)</span> 时，能得到的最大收益。</p><p>先将 <span class="math inline">\(c_i\)</span> 离散化了。</p><p>我们把贡献放到点上，求出 <span class="math inline">\(g(p,k)\)</span>表示在当前区间内，覆盖了 <span class="math inline">\(p\)</span> 且 <spanclass="math inline">\(c_i \ge k\)</span> 的区间数量。有转移 <spanclass="math display">\[f(i,j,k) = \max_{p=i}^j \Big\{ f(i,p-1,k) + g(p,k) \times val(k)+  f(p+1,j,k)  \Big\}\]</span> 正确性就比较显然了。</p><p>输出方案只需要记录最优决策点和对应决策值。</p><div class="note note-primary">            <p><ahref="https://www.cnblogs.com/dysyn1314/p/12524538.html">duyi</a>的博客中说这是笛卡尔树DP。</p><p>这个说法我无法否认，因为这就是自底向上重现最值分治的过程。</p><p>但是也完全可以当作区间 DP 来思考。</p>          </div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3592 [POI2015] MYJ</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3592</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>, M=<span class="hljs-number">4005</span>;<span class="hljs-type">int</span> n, m, cnt, a[M], b[M], c[M], t[M];<span class="hljs-type">int</span> f[N][N][M], g[N][M], lst[N][N][M], v[N][N][M], ans[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);cnt=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) c[i]=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>,c[i])-t;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span>;ans[lst[i][j][k]]=t[v[i][j][k]];<span class="hljs-built_in">print</span>(i,lst[i][j][k]<span class="hljs-number">-1</span>,v[i][j][k]);<span class="hljs-built_in">print</span>(lst[i][j][k]+<span class="hljs-number">1</span>,j,v[i][j][k]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>(), c[i]=t[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">lsh</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(i&lt;=a[k]&amp;&amp;b[k]&lt;=j) &#123;<span class="hljs-built_in">rep</span>(p,a[k],b[k]) ++g[p][c[k]];&#125;<span class="hljs-built_in">rep</span>(p,i,j) <span class="hljs-built_in">per</span>(k,cnt,<span class="hljs-number">1</span>) g[p][k]+=g[p][k+<span class="hljs-number">1</span>];lst[i][j][cnt+<span class="hljs-number">1</span>]=i, v[i][j][cnt+<span class="hljs-number">1</span>]=cnt;<span class="hljs-built_in">per</span>(k,cnt,<span class="hljs-number">1</span>) &#123;f[i][j][k]=f[i][j][k+<span class="hljs-number">1</span>];lst[i][j][k]=lst[i][j][k+<span class="hljs-number">1</span>];v[i][j][k]=v[i][j][k+<span class="hljs-number">1</span>];<span class="hljs-built_in">rep</span>(p,i,j) <span class="hljs-keyword">if</span>(f[i][p<span class="hljs-number">-1</span>][k]+f[p+<span class="hljs-number">1</span>][j][k]+g[p][k]*t[k]&gt;f[i][j][k]) &#123;f[i][j][k]=f[i][p<span class="hljs-number">-1</span>][k]+f[p+<span class="hljs-number">1</span>][j][k]+g[p][k]*t[k];lst[i][j][k]=p, v[i][j][k]=k;&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>]);<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>另外有类题<ahref="https://yozora0908.github.io/2022/lg4766-solution/">luogu4766Outer space invaders</a></p><h2 id="区间左右取数">区间左右取数</h2><p>这个就相对固定了。</p><h3 id="abc303g-bags-game">ABC303G Bags Game</h3><p>一类在区间左右选物品的博弈问题。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为只考虑区间 <spanclass="math inline">\([i,j]\)</span>，先手能得到的最大收益。</p><p>第一类操作，转移显然。</p><p>考虑第二三类操作。</p><p>以第二类操作为例，设 <spanclass="math inline">\(\beta=\min(B,len)\)</span>，枚举 <spanclass="math inline">\(x+y=\beta\)</span>，有转移 <spanclass="math display">\[f(i,j) \leftarrow \max_{x=0}^{\beta} \Big\{ \sum_{k=i}^{i+x-1} a_i +\sum_{j-y+1}^{j} a_i  - f (i+x,j-y) \Big\}\]</span> 式子变形一下就是 <span class="math display">\[\max_{x=0}^{\beta} \Bigg\{ sum(i,j) - \Big( f (i+x,j-y) + sum(i+x,j-y)\Big) \Bigg\}\]</span> 考虑优化。</p><p>能发现对于一个固定的 <spanclass="math inline">\(len=j-i+1\)</span>，所有决策区间的长度都是 <spanclass="math inline">\(j-y-(i+x)+1 = len-\beta\)</span>。</p><p>设 <span class="math inline">\(lb=len-\beta\)</span>。</p><p>当从 <span class="math inline">\([i-1,j-1]\)</span> 到 <spanclass="math inline">\([i,j]\)</span> 时，我们只会丢掉决策 <spanclass="math inline">\(f(i-1,i+lb-2)\)</span>，增加决策 <spanclass="math inline">\(f(j-lb+1,j)\)</span> 。</p><p>我们只需要用单调队列维护中间那个东西的最小值就行了。</p><p>实现细节颇多，具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: [ABC303G] Bags Game</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/AT_abc303_g</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 1 MB</span><span class="hljs-comment">// Time Limit: 2500 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3005</span>;<span class="hljs-type">int</span> n, A, B, C, D, a[N], s[N], f[N][N];<span class="hljs-type">int</span> q1[N], q2[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> s[j]-s[i<span class="hljs-number">-1</span>]; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>(), B=<span class="hljs-built_in">read</span>(), C=<span class="hljs-built_in">read</span>(), D=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();s[i]=s[i<span class="hljs-number">-1</span>]+a[i];f[i][i]=a[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;++len) &#123;<span class="hljs-type">int</span> l1=<span class="hljs-number">1</span>, r1=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> l2=<span class="hljs-number">1</span>, r2=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> lb=len-B, ld=len-D;f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(a[<span class="hljs-number">1</span>]-f[<span class="hljs-number">2</span>][len],a[len]-f[<span class="hljs-number">1</span>][len<span class="hljs-number">-1</span>]);<span class="hljs-keyword">if</span>(lb&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+lb<span class="hljs-number">-1</span>&lt;=len;++i) &#123;             <span class="hljs-type">int</span> ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;             <span class="hljs-comment">// 当前加入的区间是[i,i+lb-1]</span><span class="hljs-keyword">while</span>(l1&lt;=r1&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[i][i+lb<span class="hljs-number">-1</span>]+<span class="hljs-built_in">sum</span>(i,i+lb<span class="hljs-number">-1</span>)) &#123;--r1;ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;&#125;q1[++r1]=i;&#125;            <span class="hljs-comment">// 先把[1,len]中所有决策都扔进，注意边界</span><span class="hljs-type">int</span> ll=q1[l1], rr=q1[l1]+lb<span class="hljs-number">-1</span>;f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-A-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125; <span class="hljs-keyword">else</span> f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-A);<span class="hljs-keyword">if</span>(ld&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+ld<span class="hljs-number">-1</span>&lt;=len;++i) &#123;<span class="hljs-type">int</span> ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(l2&lt;=r2&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[i][i+ld<span class="hljs-number">-1</span>]+<span class="hljs-built_in">sum</span>(i,i+ld<span class="hljs-number">-1</span>)) &#123;--r2;ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;&#125;q2[++r2]=i;&#125;<span class="hljs-type">int</span> ll=q2[l2], rr=q2[l2]+ld<span class="hljs-number">-1</span>;f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-C-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125; <span class="hljs-keyword">else</span> f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-C);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i+len<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;f[i][j]=<span class="hljs-built_in">max</span>(a[i]-f[i+<span class="hljs-number">1</span>][j],a[j]-f[i][j<span class="hljs-number">-1</span>]);<span class="hljs-keyword">if</span>(lb&lt;=<span class="hljs-number">0</span>) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-A);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(l1&lt;=r1&amp;&amp;q1[l1]&lt;i) ++l1;<span class="hljs-type">int</span> ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(l1&lt;=r1&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[j-lb+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">sum</span>(j-lb+<span class="hljs-number">1</span>,j)) &#123;--r1;ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;&#125;q1[++r1]=j-lb+<span class="hljs-number">1</span>;ll=q1[l1], rr=q1[l1]+lb<span class="hljs-number">-1</span>;                <span class="hljs-comment">// 注意顺序，我们刚才加入的是当前区间所带来的新决策，所以更新必须放到最后</span>f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-A-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125;<span class="hljs-keyword">if</span>(ld&lt;=<span class="hljs-number">0</span>) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-C);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(l2&lt;=r2&amp;&amp;q2[l2]&lt;i) ++l2;<span class="hljs-type">int</span> ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(l2&lt;=r2&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[j-ld+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">sum</span>(j-ld+<span class="hljs-number">1</span>,j)) &#123;--r2;ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;&#125;q2[++r2]=j-ld+<span class="hljs-number">1</span>;ll=q2[l2], rr=q2[l2]+ld<span class="hljs-number">-1</span>;f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-C-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="杂题">杂题</h2><h3 id="cf149d-coloring-brackets">CF149D Coloring Brackets</h3><p>先用栈求出点 <span class="math inline">\(i\)</span> 的匹配点 <spanclass="math inline">\(\text{match}(i)\)</span>。</p><p>设 <span class="math inline">\(f(i,j,a,b)\)</span> 为考虑区间 <spanclass="math inline">\([i,j]\)</span>，其中左端点的染色情况和为 <spanclass="math inline">\(a\)</span>，右端点的染色情况为 <spanclass="math inline">\(b\)</span> 的方案数。</p><p>分如下情况讨论。</p><ul><li><p><span class="math inline">\(\text{match}(i)=j\)</span>。</p><p>如果 <spanclass="math inline">\(i+1=j\)</span>，那么直接讨论就好了。否则枚举颜色，用<span class="math inline">\(f(i+1,j-1)\)</span> 转移。</p></li><li><p><span class="math inline">\(\text{match}(i) \neqj\)</span>。我们考虑把 <spanclass="math inline">\([i,\text{match}(i)]\)</span> 拼接到 <spanclass="math inline">\([\text{match}(i)+1,j]\)</span>上。枚举颜色讨论即可。</p></li><li><p>注意由于 <span class="math inline">\(\text{match}(i)\)</span>不一定在 <span class="math inline">\(i\)</span> 的右边，所以要判断所有<span class="math inline">\(i&gt;j\)</span> 的情况。</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">705</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, match[N], f[N][N][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<span class="hljs-type">int</span> tp, st[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span>==r) &#123;f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=f[l][r][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=f[l][r][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(match[l]==r) &#123;<span class="hljs-built_in">dfs</span>(l+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(j!=<span class="hljs-number">1</span>) (f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;<span class="hljs-keyword">if</span>(j!=<span class="hljs-number">2</span>) (f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) (f[l][r][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">2</span>) (f[l][r][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">dfs</span>(l,match[l]);<span class="hljs-built_in">dfs</span>(match[l]+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(p,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(q,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(j==p&amp;&amp;j) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(!i||!p) (f[l][r][i][q]+=f[l][match[l]][i][p]*f[match[l]+<span class="hljs-number">1</span>][r][j][q]%mod)%=mod;            <span class="hljs-comment">// 相邻不能相等，匹配的两边不能都染色</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) st[++tp]=i;<span class="hljs-keyword">else</span> &#123;match[i]=st[tp];match[st[tp]]=i;--tp;&#125;&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,n);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)  (ans+=f[<span class="hljs-number">1</span>][n][i][j])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu3147-usaco16open-262144">luogu3147 [USACO16OPEN]262144</h3><p>先考虑 <span class="math inline">\(O(n^3)\)</span> 怎么做。</p><p>这类整个区间合并成一个数的题都有一个套路：只考虑整个区间合并成一个数的情况。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span>能合成的数的最大值，转移枚举断点，再判断两边是否相等即可。</p><p>然后这题正解就和 DP 没关系了。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为从 <spanclass="math inline">\(j\)</span> 开始合并一串数得到 <spanclass="math inline">\(i\)</span>，这串数的个数。 <spanclass="math display">\[f(i,j) = f(i-1,j) + f\Big(i-1,j+f(i-1,j)\Big)\]</span> 类题是 <ahref="https://www.luogu.com.cn/problem/P4805">luogu4805 [CCC2016]合并饭团</a>，不过那题的主要部分是单调性优化，这里就不展开了。</p><h3 id="luogu2890-usaco07open-cheapest-palindrome">luogu2890[USACO07OPEN] Cheapest Palindrome</h3><p>设 <span class="math inline">\(f(i,j)\)</span> 为把区间 <spanclass="math inline">\([i,j]\)</span> 搞成回文的最小代价。</p><p>如果 <span class="math inline">\(S[i]=S[j]\)</span>，那么直接继承<span class="math inline">\(f(i+1,j-1)\)</span>。</p><p>否则就是 <span class="math inline">\(\min\Big(f(i+1,j)+cost_i,f(i,j-1)+cost_j \Big)\)</span></p><p>其中 <span class="math inline">\(cost_i\)</span> 表示增加或删去 <spanclass="math inline">\(S[i]\)</span> 的较小代价。</p><p>对于区间 <span class="math inline">\([i,j]\)</span>，如果 <spanclass="math inline">\(S[i] \neqS[j]\)</span>，那么要想形成回文串，总会拿出 <spanclass="math inline">\(S[i],S[j]\)</span>其中之一，删掉或添加一个一样的在另一边，剩下的部分也要形成回文串，这是一个子问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2890 [USACO07OPEN] Cheapest Palindrome G</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2890</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-type">int</span> n, m, f[N][N], c[<span class="hljs-number">100</span>][<span class="hljs-number">2</span>];<span class="hljs-type">char</span> s[N], o[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,o);c[o[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">read</span>(), c[o[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) f[i][i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=m;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=m;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(s[i]==s[j]) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==j) f[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);&#125;f[i][j]=<span class="hljs-built_in">min</span>(&#123;f[i][j],f[i+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">min</span>(c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>],c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>]),f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">min</span>(c[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>],c[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>])&#125;);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][m]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj2063.-haoi2016字符合并">LOJ#2063. 「HAOI2016」字符合并</h3><p>这里用 <span class="math inline">\(m\)</span> 代替题目中的 <spanclass="math inline">\(k\)</span>。</p><p>注意到任何区间合并后都一定是一个 <spanclass="math inline">\(m\)</span> 位二进制数，而 <spanclass="math inline">\(m\)</span> 很小，可以考虑状压。</p><p>设 <span class="math inline">\(f(i,j,S)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span> 合并为 <spanclass="math inline">\(S\)</span> 的最大收益。</p><p>考虑如何转移。先讨论如何得到 <spanclass="math inline">\(S\)</span>，再讨论合并成什么。</p><p>可以枚举 <span class="math inline">\(S\)</span>的最后一位是哪个区间合并而来，复杂度是 <spanclass="math inline">\(O(\frac{n}{m})\)</span> 的。</p><p>合并只能将整个串合并为 <span class="math inline">\(0\)</span> 或<span class="math inline">\(1\)</span>，不难发现这样做的充要条件是 <spanclass="math inline">\((m-1) \mid (len-1)\)</span>。</p><p>枚举 <span class="math inline">\(S\)</span>，对于转化成 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span> 分别取最大值，最后更新 <spanclass="math inline">\(f(i,j,0/1)\)</span> 即可。</p><p>时间复杂度是 <span class="math inline">\(O(n^22^m\frac{n}{m})\)</span>，勉强通过。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: #2063. 「HAOI2016」字符合并</span><span class="hljs-comment">// Contest: LibreOJ</span><span class="hljs-comment">// URL: https://loj.ac/p/2063</span><span class="hljs-comment">// author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, U, to[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>], w[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>], f[N][N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-0x3f</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][i][s[i]-<span class="hljs-string">&#x27;0&#x27;</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) to[S]=<span class="hljs-built_in">read</span>(), w[S]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j<span class="hljs-number">-1</span>;k&gt;=i;k-=m<span class="hljs-number">-1</span>) &#123;f[i][j][S]=<span class="hljs-built_in">max</span>(f[i][j][S],f[i][k][S&gt;&gt;<span class="hljs-number">1</span>]+f[k+<span class="hljs-number">1</span>][j][S&amp;<span class="hljs-number">1</span>]);                <span class="hljs-comment">// 注意枚举顺序</span>&#125;&#125;<span class="hljs-keyword">if</span>((l<span class="hljs-number">-1</span>)%(m<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> res0=<span class="hljs-number">0</span>, res1=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">if</span>(to[S]==<span class="hljs-number">0</span>) res0=<span class="hljs-built_in">max</span>(res0,f[i][j][S]+w[S]);<span class="hljs-keyword">else</span> res1=<span class="hljs-built_in">max</span>(res1,f[i][j][S]+w[S]);&#125;f[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">0</span>],res0), f[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">1</span>],res1);&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) ans=<span class="hljs-built_in">max</span>(ans,f[<span class="hljs-number">1</span>][n][S]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj2292.-thusc-2016成绩单">LOJ#2292. 「THUSC 2016」成绩单</h3><p>注意到 <span class="math inline">\(n\)</span> 只有 <spanclass="math inline">\(50\)</span>，可以先将 <spanclass="math inline">\(W_i\)</span> 离散化了。</p><p>注意到分发顺序不重要，我们钦定任何区间都是从左往右分发。</p><p>设 <span class="math inline">\(g(i,j,mx,mn)\)</span> 表示把 <spanclass="math inline">\([i,j]\)</span> 取到还剩下一段值域为 <spanclass="math inline">\([mn,mx]\)</span> 的区间的最小代价，<spanclass="math inline">\(f(i,j)\)</span> 表示取完 <spanclass="math inline">\([i,j]\)</span> 的最小代价。</p><p>首先我们可以让 <span class="math inline">\(j\)</span> 加入 <spanclass="math inline">\(g(i,j-1,mx,mn)\)</span>，注意 <spanclass="math inline">\(W_j\)</span> 对 <spanclass="math inline">\(mx\)</span> 与 <spanclass="math inline">\(mn\)</span> 的影响。</p><p>否则我们枚举和 <span class="math inline">\(j\)</span>一起消掉的一段。 <span class="math display">\[g(i,j,mx,mn) = \min_{k=i}^{j-1} \Big\{ g(i,k,mx,mn) + f(k+1,j) \Big\}\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P5336 [THUSC2016] 成绩单</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P5336</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 500 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-type">int</span> n, m, a, b, s[N], f[N][N], g[N][N][N][N], t[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,s[i])-t;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=<span class="hljs-built_in">read</span>(), t[++m]=s[i];<span class="hljs-built_in">lsh</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>), <span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0x3f</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;f[i][i]=a;g[i][i][s[i]][s[i]]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>; <span class="hljs-built_in">rep</span>(mx,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(mn,<span class="hljs-number">1</span>,mx) &#123; <span class="hljs-type">int</span>&amp; x=g[i][j][<span class="hljs-built_in">max</span>(mx,s[j])][<span class="hljs-built_in">min</span>(mn,s[j])]; x=<span class="hljs-built_in">min</span>(x,g[i][j<span class="hljs-number">-1</span>][mx][mn]); <span class="hljs-built_in">rep</span>(k,i,j<span class="hljs-number">-1</span>) g[i][j][mx][mn]=<span class="hljs-built_in">min</span>(g[i][j][mx][mn],g[i][k][mx][mn]+f[k+<span class="hljs-number">1</span>][j]); &#125;<span class="hljs-built_in">rep</span>(mx,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(mn,<span class="hljs-number">1</span>,mx) &#123;f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],g[i][j][mx][mn]+a+b*(t[mx]-t[mn])*(t[mx]-t[mn]));&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj6092.-codeforces-round-418恋爱循环">LOJ#6092. 「CodeforcesRound #418」恋爱循环</h3><p>严格来说算是区间 DP 吗？</p><p>对于每个字符，把所有点提取成连续的，保留各自的下标用作距离。我们断言，最终的修改一定指挥让某一个区间的这个字符连成一片。</p><p>设 <span class="math inline">\(f_{\pi}(i,j)\)</span> 为考虑字符 <spanclass="math inline">\(\pi\)</span>，把区间 <spanclass="math inline">\([i,j]\)</span> 里的 <spanclass="math inline">\(\pi\)</span>，通过修改中间字符的方式搞成连续的所需要的最小代价。</p><p>那么每个询问等价于求一个区间 <spanclass="math inline">\([l,r]\)</span>，满足 <spanclass="math inline">\(f_c(l,r) \le m\)</span> 并且 <spanclass="math inline">\(\min\Big(n,r-l+1+m \Big)\)</span> 最大。</p><p>不难发现对于不断递增的 <span class="math inline">\(r\)</span>，<spanclass="math inline">\(l\)</span> 是有决策单调性的，直接双指针即可。</p><p>然而还是无法通过，考虑预处理答案。</p><p>能发现总复杂度是 <span class="math inline">\(O\Big(\sum_{i=1}^{26}cnt_i^2 + q\Big)\)</span>，其中 <spanclass="math inline">\(cnt_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个字符的数量。</p><p>后面那个东西在所有字符都相同时有上界，可以通过。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1505</span>;<span class="hljs-type">int</span> n, q, a[N], sum[<span class="hljs-number">30</span>][N], ans[<span class="hljs-number">30</span>][N];vector&lt;<span class="hljs-type">int</span>&gt; v[<span class="hljs-number">30</span>];vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; f[<span class="hljs-number">30</span>];<span class="hljs-type">char</span> s[N], cc[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;f[x].<span class="hljs-built_in">resize</span>(v[x].<span class="hljs-built_in">size</span>()+<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v[x].<span class="hljs-built_in">size</span>();++i) f[x][i].<span class="hljs-built_in">resize</span>(v[x].<span class="hljs-built_in">size</span>()+<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v[x].<span class="hljs-built_in">size</span>();++i) f[x][i][i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=v[x].<span class="hljs-built_in">size</span>();++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i+l<span class="hljs-number">-1</span>&lt;v[x].<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;f[x][i][j]=f[x][i][j<span class="hljs-number">-1</span>]+v[x][j]-v[x][j<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(r+<span class="hljs-number">1</span>&lt;v[x].<span class="hljs-built_in">size</span>()&amp;&amp;f[x][l][r+<span class="hljs-number">1</span>]&lt;=i) ++r;ans[x][i]=<span class="hljs-built_in">max</span>(ans[x][i],<span class="hljs-built_in">min</span>(r-l+<span class="hljs-number">1</span>+i,n));<span class="hljs-keyword">for</span>(;r&lt;v[x].<span class="hljs-built_in">size</span>();++r) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[x][l][r]&gt;i) ++l;<span class="hljs-keyword">if</span>(l&lt;=r) ans[x][i]=<span class="hljs-built_in">max</span>(ans[x][i],<span class="hljs-built_in">min</span>(r-l+<span class="hljs-number">1</span>+i,n));&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dp</span>(i);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">solve</span>(i);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;v[a[i]].<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-built_in">prework</span>();q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,cc);<span class="hljs-type">int</span> c=cc[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(v[c].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[c][m]); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,m);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;区间形态的扩展&quot;&gt;区间形态的扩展&lt;/h2&gt;
&lt;h3 id=&quot;luogu3205-hnoi2010-合唱队&quot;&gt;luogu3205 [HNOI2010] 合唱队&lt;/h3&gt;
&lt;p&gt;队列的形成方式是不断往左或往右扩展。&lt;/p&gt;
&lt;p&gt;考虑区间 DP。发现对于一个区间 &lt;span class=&quot;math inline&quot;&gt;&#92;([i,j]&#92;)&lt;/span&gt;，最后一个元素的来源会对转移产生影响，所以设
&lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,j,0/1)&#92;)&lt;/span&gt; 为考虑区间 &lt;span class=&quot;math inline&quot;&gt;&#92;([i,j]&#92;)&lt;/span&gt;，其中最后一个元素是从左边还是右边加入的方案数。&lt;/p&gt;
&lt;p&gt;转移很简单 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(i,j,0) = [a_i &amp;lt; a_{i+1}]f(i+1,j,0) + [a_i &amp;lt; a_j] f(i+1,j,0)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
f(i,j,1) = [a_j &amp;gt; a_{i}] f(i,j-1,0) + [a_j &amp;gt; a_{j-1}] f(i,j-1,1)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意对于 &lt;span class=&quot;math inline&quot;&gt;&#92;([i,i]&#92;)&lt;/span&gt;，钦定从一边转移过来即可。&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Problem: P3205 [HNOI2010] 合唱队&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Contest: Luogu&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// URL: https://www.luogu.com.cn/problem/P3205&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Author: yozora0908&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Memory Limit: 125 MB&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Time Limit: 1000 ms&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// &lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Let&amp;#x27;s Daze&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// &lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Powered by CP Editor (https://cpeditor.org)&lt;/span&gt;

&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; int long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; uint unsigned long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PII pair&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;int,int&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MP make_pair&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; fi first&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; se second&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; pb push_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; eb emplace_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SET(a,b) memset(a,b,sizeof(a))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CPY(a,b) memcpy(a,b,sizeof(b))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; rep(i,j,k) for(int i=(j);i&amp;lt;=(k);++i)&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; per(i,j,k) for(int i=(j);i&amp;gt;=(k);--i)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, f=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(c==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;) f=&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) a=a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+c-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a*f;
&amp;#125;
&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N=&lt;span class=&quot;hljs-number&quot;&gt;1005&lt;/span&gt;, mod=&lt;span class=&quot;hljs-number&quot;&gt;19650827&lt;/span&gt;;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, a[N], f[N][N][&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	n=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,n) a[i]=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(),  f[i][i][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(l,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,n) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i+l&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;&amp;lt;=n;++i) &amp;#123;
		&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=i+l&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(a[i]&amp;lt;a[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) (f[i][j][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]+=f[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;][j][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])%=mod;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(a[i]&amp;lt;a[j]) (f[i][j][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]+=f[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;][j][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])%=mod;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(a[j]&amp;gt;a[i]) (f[i][j][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+=f[i][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])%=mod;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(a[j]&amp;gt;a[j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]) (f[i][j][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+=f[i][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])%=mod;
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%lld&#92;n&amp;quot;&lt;/span&gt;,(f[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;][n][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]+f[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;][n][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])%mod);
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;某道题&quot;&gt;某道题&lt;/h3&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="区间DP" scheme="https://yozora0908.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
    <category term="贪心" scheme="https://yozora0908.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="计数" scheme="https://yozora0908.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="状态压缩" scheme="https://yozora0908.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="双指针" scheme="https://yozora0908.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#17 二分图判定</title>
    <link href="https://yozora0908.github.io/2023/noip-record-17/"/>
    <id>https://yozora0908.github.io/2023/noip-record-17/</id>
    <published>2023-08-24T03:51:05.000Z</published>
    <updated>2023-08-24T03:56:13.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="二分图判定">二分图判定</h2><p>没啥技巧，最难的是把图论模型建起来。</p><h3 id="luogu1330-封锁阳光大学">luogu1330 封锁阳光大学</h3><p>相邻两个点只能封锁一个，但是要覆盖所有边。对应到二分图上就是左部右部点的数量取较小值。</p><p>图可能不连通，取的是每一张二分图的左右边的较小值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, c[N], deg[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">int</span> c1, c2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> col)</span> </span>&#123;c[x]=col;<span class="hljs-keyword">if</span>(col==<span class="hljs-number">1</span>) ++c1; <span class="hljs-keyword">else</span> ++c2;<span class="hljs-type">bool</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(!c[y]) res&amp;=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-col);<span class="hljs-keyword">else</span> res&amp;=(c[y]!=col);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];<span class="hljs-built_in">add</span>(x,y);&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!c[i]) &#123;c1=c2=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;ans+=<span class="hljs-built_in">min</span>(c1,c2);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu1155-noip2008-提高组-双栈排序">luogu1155 [NOIP2008 提高组]双栈排序</h3><p>考虑什么情况下，两个元素不能在用一个栈中。注意不一定是同时，先后进栈也算。</p><p>不难发现 <span class="math inline">\(i,j\)</span>不能在同一个栈中，当且仅当存在 <spanclass="math inline">\((i,j,k)\)</span>，满足 <spanclass="math inline">\(i&lt;j&lt;k\)</span>，<spanclass="math inline">\(a_k &lt;a_i &lt; a_j\)</span>。</p><p>考虑在 <span class="math inline">\(i,j\)</span>之间连边，表示二者不能用同一个栈，那么有解当且仅当这张图是二分图。</p><p>考虑如何构造方案。</p><p>对图黑白染色，编号小的点贪心染白色，同时规定第一个栈是白色栈。</p><p>维护一个全局变量 <span class="math inline">\(now\)</span>表示下一个应该放哪个元素，从 <span class="math inline">\(1\)</span> 到<span class="math inline">\(n\)</span> 扫一遍，对于一个将要加入的 <spanclass="math inline">\(a_i\)</span>，维护它所在颜色的栈中元素单调递增，同时判断栈顶是否是<spanclass="math inline">\(now\)</span>，如果不是就输出另一个栈的栈顶。</p><p>由于白色栈的操作优先级都要高于黑色栈，所以在加入 <spanclass="math inline">\(a_i\)</span> 之前，应该输出白栈的栈顶直到不是<span class="math inline">\(now\)</span>。</p><p>最后输出剩下的元素，贪心白色栈即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-type">int</span> n, now=<span class="hljs-number">1</span>, a[N], suf[N], c[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> col)</span> </span>&#123;c[x]=col;<span class="hljs-type">bool</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(!c[y]) res&amp;=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-col);<span class="hljs-keyword">else</span> res&amp;=(c[y]!=col);<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;stack&lt;<span class="hljs-type">int</span>&gt; s[<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> col)</span> </span>&#123;<span class="hljs-keyword">return</span> s[col].<span class="hljs-built_in">size</span>()&amp;&amp;s[col].<span class="hljs-built_in">top</span>()==now;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">int</span> col)</span> </span>&#123;s[col].<span class="hljs-built_in">pop</span>();++now;<span class="hljs-keyword">if</span>(col==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b &quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d &quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();suf[n]=a[n];<span class="hljs-built_in">per</span>(i,n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) suf[i]=<span class="hljs-built_in">min</span>(suf[i+<span class="hljs-number">1</span>],a[i]);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,i+<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(suf[j+<span class="hljs-number">1</span>]&lt;a[i]&amp;&amp;a[i]&lt;a[j]) <span class="hljs-built_in">add</span>(i,j);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!c[i]) &#123;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">while</span>(s[c[i]].<span class="hljs-built_in">size</span>()&amp;&amp;s[c[i]].<span class="hljs-built_in">top</span>()&lt;=a[i]) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(c[i])) <span class="hljs-built_in">out</span>(c[i]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">out</span>(<span class="hljs-number">3</span>-c[i]);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>)) <span class="hljs-built_in">out</span>(<span class="hljs-number">1</span>);s[c[i]].<span class="hljs-built_in">push</span>(a[i]);<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a &quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c &quot;</span>);&#125;<span class="hljs-keyword">while</span>(s[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()||s[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>)) <span class="hljs-built_in">out</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(<span class="hljs-number">2</span>)) <span class="hljs-built_in">out</span>(<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu1285-队员分组">luogu1285 队员分组</h3><p>老题，从其他 OJ 扒来的换皮题，但是质量意外的高啊。</p><p>预处理出所有不互相认识的人，他们一定不能在同一组。在他们之间连边，发现如果有解当且仅当连出的图是二分图。</p><p>题目要求最小化两组人数之差，但是多个连通块一起考虑显然很难做。这时候可以利用连通块之间相对独立的性质，对每个连通块单独考虑，同时只有单独一个连通块的分组方法是确定的。</p><p>这时候我们能发现，每个连通块有两种颜色，每个颜色的所有点都必须一起选择，但是不同连通块的不同颜色却可以分到同一组。因此问题转化为分组背包。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 个连通块，能否选择 <spanclass="math inline">\(j\)</span> 个点。转移是平凡的，同时记录到达 <spanclass="math inline">\(f(i,j)\)</span>的最后一个决策是选择的哪个颜色。</p><p>设连通块个数为 <span class="math inline">\(m\)</span>。</p><p>分成两组，必然有一组人数不超过 <span class="math inline">\(n /2\)</span>。找到 <span class="math inline">\(f(m,i)\)</span> 中满足<span class="math inline">\(j \le n/2\)</span> 且 <spanclass="math inline">\(f(n,j)=1\)</span> 的极大的 <spanclass="math inline">\(j\)</span>，这就是人数较少那组的人数了。</p><p>此时我们就可以利用记录的决策输出方案了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, a[N][N], col[N];<span class="hljs-type">int</span> cnt;vector&lt;<span class="hljs-type">int</span>&gt; p[N], con[N][<span class="hljs-number">2</span>], ans[<span class="hljs-number">2</span>];<span class="hljs-type">int</span> f[N][N], op[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> j;<span class="hljs-keyword">do</span> &#123;j=<span class="hljs-built_in">read</span>();a[i][j]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">while</span>(j);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i!=j) &#123;<span class="hljs-keyword">if</span>(!a[i][j]||!a[j][i]) <span class="hljs-built_in">add</span>(i,j);&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span> </span>&#123;col[x]=color;con[cnt][col[x]].<span class="hljs-built_in">pb</span>(x);<span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(~col[y]) res&amp;=(col[y]!=col[x]);<span class="hljs-keyword">else</span> res&amp;=<span class="hljs-built_in">dfs</span>(y,col[x]^<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(col,<span class="hljs-number">-1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(col[i]&lt;<span class="hljs-number">0</span>) &#123;++cnt;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No solution&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;&#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> sz(x) con[i][x].size()</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:con[i][op[i][j]]) ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">pb</span>(x);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:con[i][op[i][j]^<span class="hljs-number">1</span>]) ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(x);<span class="hljs-built_in">getans</span>(i<span class="hljs-number">-1</span>,j-<span class="hljs-built_in">sz</span>(op[i][j]));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,n) &#123;<span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-built_in">sz</span>(<span class="hljs-number">0</span>)&amp;&amp;f[i<span class="hljs-number">-1</span>][j-<span class="hljs-built_in">sz</span>(<span class="hljs-number">0</span>)]) f[i][j]=<span class="hljs-number">1</span>, op[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-built_in">sz</span>(<span class="hljs-number">1</span>)&amp;&amp;f[i<span class="hljs-number">-1</span>][j-<span class="hljs-built_in">sz</span>(<span class="hljs-number">1</span>)]) f[i][j]=<span class="hljs-number">1</span>, op[i][j]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 都可以的话0/1随便取一个</span>&#125;<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i;--i) <span class="hljs-keyword">if</span>(f[cnt][i]) &#123; j=i; <span class="hljs-keyword">break</span>; &#125;<span class="hljs-built_in">getans</span>(cnt,j);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(),ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>());<span class="hljs-built_in">sort</span>(ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(),ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 注意输出要排序</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,(<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans[<span class="hljs-number">0</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,x);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,(<span class="hljs-type">int</span>)ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans[<span class="hljs-number">1</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">input</span>();<span class="hljs-built_in">build</span>();<span class="hljs-built_in">getcol</span>();<span class="hljs-built_in">dp</span>();<span class="hljs-built_in">output</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;二分图判定&quot;&gt;二分图判定&lt;/h2&gt;
&lt;p&gt;没啥技巧，最难的是把图论模型建起来。&lt;/p&gt;
&lt;h3 id=&quot;luogu1330-封锁阳光大学&quot;&gt;luogu1330 封锁阳光大学&lt;/h3&gt;
&lt;p&gt;相邻两个点只能封锁一个，但是要覆盖所有边。对应到二分图上就是左部右部点的数量取较小值。&lt;/p&gt;
&lt;p&gt;图可能不连通，取的是每一张二分图的左右边的较小值。&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; int long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; uint unsigned long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PII pair&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;int,int&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MP make_pair&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; fi first&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; se second&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; pb push_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; eb emplace_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SET(a,b) memset(a,b,sizeof(a))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CPY(a,b) memcpy(a,b,sizeof(b))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; rep(i,j,k) for(int i=(j);i&amp;lt;=(k);++i)&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; per(i,j,k) for(int i=(j);i&amp;gt;=(k);--i)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, f=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(c==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;) f=&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) a=a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+c-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a*f;
&amp;#125;
&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N=&lt;span class=&quot;hljs-number&quot;&gt;1e4&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, m, c[N], deg[N];
vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; p[N];
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; c1, c2;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;
	p[x].&lt;span class=&quot;hljs-built_in&quot;&gt;pb&lt;/span&gt;(y), p[y].&lt;span class=&quot;hljs-built_in&quot;&gt;pb&lt;/span&gt;(x);
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col)&lt;/span&gt; &lt;/span&gt;&amp;#123;
	c[x]=col;
	&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(col==&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ++c1; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; ++c2;
	&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; res=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; y:p[x]) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!c[y]) res&amp;amp;=&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(y,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;-col);
		&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; res&amp;amp;=(c[y]!=col);
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	n=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), m=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,m) &amp;#123;
		&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), y=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
		++deg[x], ++deg[y];
		&lt;span class=&quot;hljs-built_in&quot;&gt;add&lt;/span&gt;(x,y);
	&amp;#125;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ans=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,n) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!c[i]) &amp;#123;
		c1=c2=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Impossible&amp;quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &amp;#125;
		ans+=&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(c1,c2);
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%lld&#92;n&amp;quot;&lt;/span&gt;,ans);
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;luogu1155-noip2008-提高组-双栈排序&quot;&gt;luogu1155 [NOIP2008 提高组]
双栈排序&lt;/h3&gt;
&lt;p&gt;考虑什么情况下，两个元素不能在用一个栈中。注意不一定是同时，先后进栈也算。&lt;/p&gt;
&lt;p&gt;不难发现 &lt;span class=&quot;math inline&quot;&gt;&#92;(i,j&#92;)&lt;/span&gt;
不能在同一个栈中，当且仅当存在 &lt;span class=&quot;math inline&quot;&gt;&#92;((i,j,k)&#92;)&lt;/span&gt;，满足 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&amp;lt;j&amp;lt;k&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(a_k &amp;lt;a_i &amp;lt; a_j&#92;)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="图论" scheme="https://yozora0908.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="贪心" scheme="https://yozora0908.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二分图" scheme="https://yozora0908.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#16 欧拉路径与拓扑排序</title>
    <link href="https://yozora0908.github.io/2023/noip-record-16/"/>
    <id>https://yozora0908.github.io/2023/noip-record-16/</id>
    <published>2023-08-24T03:51:01.000Z</published>
    <updated>2023-08-24T03:54:20.388Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="欧拉路径">欧拉路径</h2><h3 id="定义">定义</h3><p>从一个点出发，不重不漏地经过图中每一条边的一条路径，允许重复经过节点。</p><h3 id="无向图">无向图</h3><p>首先必须是连通图，其次是两种情况。</p><ol type="1"><li>所有点的度数是偶数。</li><li>恰好存在两个点的度数是奇数。</li></ol><h3 id="有向图">有向图</h3><p>要求连通。</p><ol type="1"><li>所有点的入度等于出度。</li><li>恰好存在一个节点入度比出度多 <spanclass="math inline">\(1\)</span>，一个节点入度比出度少 <spanclass="math inline">\(1\)</span>。</li></ol><h2 id="欧拉回路">欧拉回路</h2><h3 id="定义-1">定义</h3><p>起点和终点是一个点的欧拉路径。</p><h3 id="无向图-1">无向图</h3><p>连通，所有点的度数都是偶数。</p><h3 id="有向图-1">有向图</h3><p>连通，所有点的入度等于出度。</p><h2 id="hierholzer算法">Hierholzer算法</h2><p>这个 H 姓算法的实现有很多。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(x)     <span class="hljs-function"><span class="hljs-keyword">for</span> each <span class="hljs-title">edge</span> <span class="hljs-params">(x,y)</span> in E</span><span class="hljs-function">         <span class="hljs-keyword">if</span> vis[<span class="hljs-params">(x,y)</span>]</span>=<span class="hljs-number">0</span>             vis[(x,y)]=<span class="hljs-number">1</span>             <span class="hljs-built_in">dfs</span>(y)     push_front y to ans</code></pre></div><p>直接暴力跑是 <span class="math inline">\(O(nm)\)</span> 的。</p><p>使用邻接表存图的话，建完图后访问每个点连出边是有顺序的。</p><p>记录一下访问到了哪条边即可。</p><p>那么下面代码的复杂度就是 <spanclass="math inline">\(O(n+m)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, tot=<span class="hljs-number">1</span>, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">if</span>(!v[i&gt;&gt;<span class="hljs-number">1</span>]) &#123;v[i&gt;&gt;<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(to[i]);&#125;&#125;ans.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());&#125;</code></pre></div><p>另外还有模拟机器递归的实现，不会爆栈。但是我记不住。</p><h2 id="题">题</h2><p>这个算是冷门知识点了，但是大纲里有。</p><p>要么太难要么偏板。</p><h3 id="luogu2731-usaco3.3-骑马修栅栏">luogu2731 [USACO3.3]骑马修栅栏</h3><p>就是板子。</p><p>只不过两点之间可以有多条路径。</p><p>我们走一次干掉一条就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1145</span>;<span class="hljs-type">int</span> n, lim, deg[N], e[N][N];vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=lim;++y) <span class="hljs-keyword">if</span>(e[x][y]) &#123;--e[x][y], --e[y][x];<span class="hljs-built_in">dfs</span>(y);&#125;ans.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++e[x][y], ++e[y][x];++deg[x], ++deg[y];lim=<span class="hljs-built_in">max</span>(&#123;lim,x,y&#125;);&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, st=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,lim) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) &#123;++cnt;<span class="hljs-keyword">if</span>(!st) st=i;&#125;<span class="hljs-keyword">if</span>(!st) &#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,lim) <span class="hljs-keyword">if</span>(deg[i]) &#123; st=i; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">dfs</span>(st);<span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,x);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="uva10129-play-on-words">UVA10129 Play on Words</h3><p>其实问题就是二选一：</p><ol type="1"><li><p>单词为点。结尾为字母 <span class="math inline">\(\pi\)</span>的单词向开头为字母 <span class="math inline">\(\pi\)</span>的单词连边。</p></li><li><p>字母为点。每个单词的首字母向尾字母连边。</p></li></ol><p>很重要的一点是每个字母必须都出现一次且仅一次。</p><p>第一种方式，问题转化哈密顿回路，做不了。</p><p>第二种方式，问题转化为欧拉路径，可以做。</p><h3 id="cf547d-mike-and-fish">CF547D Mike and Fish</h3><p>个人感觉这题的建模方式就不太自然了。</p><p>对每行每列都建一个点，对于节点 <spanclass="math inline">\((x,y)\)</span>，在 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>之间连一条无向边，然后对边定向，使得每个点的入度出度只差不超过 <spanclass="math inline">\(1\)</span>。</p><p>然后连边后是个二分图。可以没用。</p><p>考虑简化版，所有点的度数都是偶数。</p><p>在图上跑欧拉回路，按照路径上经过点的顺序定向，就能得到一组合法解。</p><p>考虑原版。如果能将度数为奇数的点改为偶数，那么就能归约到弱化版了。</p><p>建一个虚点，把度数为奇数的点向虚点连双向边。奇度点一定有偶数个，所以此时包括虚点在内所有点的度数都是偶数，跑欧拉回路即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>, DLT=<span class="hljs-number">2e5</span>;<span class="hljs-type">int</span> n, deg[N], v[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> j=i&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-comment">// i&gt;&gt;1定位到i这条边对应的横坐标点的编号</span><span class="hljs-keyword">if</span>(!v[j]) &#123;v[j]=<span class="hljs-number">1</span>+(x&lt;=DLT);<span class="hljs-built_in">dfs</span>(to[i]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 注意</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y+DLT), <span class="hljs-built_in">add</span>(y+DLT,x);        <span class="hljs-comment">// [1,DLT]是横坐标域，[DLT+1,2*DLT]的是纵坐标域</span>++deg[x], ++deg[y+DLT];&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*DLT) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,i), <span class="hljs-built_in">add</span>(i,<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,DLT) <span class="hljs-built_in">dfs</span>(i);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>[v[i]<span class="hljs-number">-1</span>]);        <span class="hljs-comment">// 只需要考虑前n个横坐标点的连边情况</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="拓扑排序">拓扑排序</h2><p>随便放点题。</p><h3 id="luogu3243-hnoi2015-菜肴制作">luogu3243 [HNOI2015] 菜肴制作</h3><p>在满足限制的情况下，字典序小的数尽可能靠前。</p><p>用小根堆去贪显然是错的。</p><p>考虑较大的数在合法的范围内尽可能靠后是优秀的，所以建反图，用大根堆贪心求出反图的拓扑序，它的逆序就是答案。</p><h3 id="cf-gym104053c-customs-controls-2">CF gym104053C Customs Controls2</h3><p>设 <span class="math inline">\(d(x)\)</span> 为 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 的最长路。那么对于 <spanclass="math inline">\(n\)</span> 和它的入点集合 <spanclass="math inline">\(\{y\}\)</span>，应该满足所有 <spanclass="math inline">\(d(y)\)</span>都相等。归纳得到对于任意节点的入点集合 <spanclass="math inline">\(\{y\}\)</span>，都有所有 <spanclass="math inline">\(d(y)\)</span> 相等。</p><p>用并查集把所有点的入点缩成一个点，再此基础上连边。如果出现环，那么说明存在某个点的点权要求是<spanclass="math inline">\(0\)</span>，从而无解。否则对这张图拓扑排序求出到每个节点的最长路。最后用<strong>一个点所在连通块的最长路</strong>减掉<strong>它的入点集合所在连通块</strong>的最长路就是这个点的点权。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, in[N], f[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N], q[N];vector&lt;PII &gt; e;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y;&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) p[i].<span class="hljs-built_in">clear</span>(), q[i].<span class="hljs-built_in">clear</span>(), in[i]=f[i]=<span class="hljs-number">0</span>;e.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();q[y].<span class="hljs-built_in">pb</span>(x);e.<span class="hljs-built_in">pb</span>(&#123;x,y&#125;);&#125;dsu.<span class="hljs-built_in">init</span>();<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:q[x]) &#123;dsu.<span class="hljs-built_in">merge</span>(y,q[x][<span class="hljs-number">0</span>]);            <span class="hljs-comment">// 这里是与第一个入点合并了</span>&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:e) &#123;<span class="hljs-type">int</span> x=t.fi, y=t.se;x=dsu.<span class="hljs-built_in">get</span>(x), y=dsu.<span class="hljs-built_in">get</span>(y);p[x].<span class="hljs-built_in">pb</span>(y), ++in[y];&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-type">int</span>&gt; qu;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(i==dsu.<span class="hljs-built_in">get</span>(i)) &#123;++cnt;<span class="hljs-keyword">if</span>(!in[i]) f[i]=<span class="hljs-number">1</span>, qu.<span class="hljs-built_in">push</span>(i);&#125;&#125;<span class="hljs-keyword">while</span>(qu.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=qu.<span class="hljs-built_in">front</span>(); qu.<span class="hljs-built_in">pop</span>();--cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) qu.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">if</span>(cnt) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> ans=f[dsu.<span class="hljs-built_in">get</span>(i)];<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) ans-=f[dsu.<span class="hljs-built_in">get</span>(q[i][<span class="hljs-number">0</span>])];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;欧拉路径&quot;&gt;欧拉路径&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;从一个点出发，不重不漏地经过图中每一条边的一条路径，允许重复经过节点。&lt;/p&gt;
&lt;h3 id=&quot;无向图&quot;&gt;无向图&lt;/h3&gt;
&lt;p&gt;首先必须是连通图，其次是两种情况。&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;所有点的度数是偶数。&lt;/li&gt;
&lt;li&gt;恰好存在两个点的度数是奇数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;有向图&quot;&gt;有向图&lt;/h3&gt;
&lt;p&gt;要求连通。&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;所有点的入度等于出度。&lt;/li&gt;
&lt;li&gt;恰好存在一个节点入度比出度多 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，一个节点入度比出度少 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="图论" scheme="https://yozora0908.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="拓扑排序" scheme="https://yozora0908.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
    <category term="欧拉路径" scheme="https://yozora0908.github.io/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#15 数论题目选讲</title>
    <link href="https://yozora0908.github.io/2023/noip-record-15/"/>
    <id>https://yozora0908.github.io/2023/noip-record-15/</id>
    <published>2023-08-24T03:50:56.000Z</published>
    <updated>2023-09-04T02:50:35.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="hankson的趣味题">Hankson的趣味题</h2><p>从质因子的角度考虑。</p><p>把 <span class="math inline">\(a,b,c,d\)</span>都分解了，对于一个质因子 <spanclass="math inline">\(p_i\)</span>，题目给出的条件等价于 <spanclass="math display">\[\min \Big( e_{p_i} (x) ,e_{p_i} (a)\Big) =e_{p_i}(c)\]</span></p><p><span class="math display">\[\max \Big( e_{p_i}(x),e_{p_i}(b) \Big) = e_{p_i}(d)\]</span></p><p>讨论一下就能得到 <span class="math inline">\(e_{p_i}(x)\)</span>的取值范围，或者报告无解。</p><h2 id="cf1114c-trailing-loves-or-loeufs">CF1114C Trailing Loves (orL'oeufs?)</h2><p>把 <span class="math inline">\(k\)</span> 分解为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，设 <spanclass="math inline">\(E_i\)</span> 为 <spanclass="math inline">\(p_i\)</span> 在 <spanclass="math inline">\(N\)</span> 中的幂次。</p><p>则 <span class="math inline">\(N\)</span> 在 <spanclass="math inline">\(k\)</span> 进制下后导 <spanclass="math inline">\(0\)</span> 的个数就是 <spanclass="math inline">\(\min\Big(\Big\lfloor \frac{E_i}{e_i}\Big\rfloor\Big)\)</span>。</p><p>对于每个 <span class="math inline">\(p_i\)</span>，<spanclass="math inline">\(n!\)</span> 中质因子 <spanclass="math inline">\(p_i\)</span> 的个数为 <spanclass="math display">\[\sum_{k=1 \wedge p_i^k \le n} \Big\lfloor \frac{n}{p_i^k} \Big\rfloor\]</span> 解释一下上式。</p><blockquote><p><span class="math inline">\(n!\)</span> 中包含质因子 <spanclass="math inline">\(p_i\)</span> 的指数，等价于 <spanclass="math inline">\([1,n]\)</span> 中每个数中 <spanclass="math inline">\(p_i\)</span> 的指数之和。</p><p>指数至少为 <span class="math inline">\(1\)</span> 的数有 <spanclass="math inline">\(\Big\lfloor \frac{n}{p_i} \Big\rfloor\)</span>个，这里只统计第一个。指数至少为 <span class="math inline">\(2\)</span>的有 <span class="math inline">\(\Big\lfloor \frac{n}{p_i^2}\Big\rfloor\)</span> 个，这里只统计第二个，以此类推。</p></blockquote><h2 id="luogu1445-樱花">luogu1445 樱花</h2><p><span class="math display">\[\begin{aligned}\frac{1}{x} + \frac{1}{y} &amp;= \frac{1}{n!}\\\frac{x+y}{xy} &amp;=\frac{1}{n!}\\xn! + yn! &amp;= xy\\xy - xn! -yn! + (n!)^2 &amp;=  (n!)^2\\(x-n!)(y-n!) &amp;= (n!)^2\end{aligned}\]</span></p><p><span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 一一对应。</p><p>用上面的办法求出 <span class="math inline">\((n!)^2\)</span>的质因子指数，再求 <spanclass="math inline">\(\sigma_0\Big((n!)^2\Big)\)</span> 即可。</p><p><span class="math inline">\(\texttt{Bonus:}\)</span> 求出所有 <spanclass="math inline">\((x+y)\)</span> 的和。</p><p>求出 <span class="math inline">\(\sigma_1\Big((n!)^2\Big)\)</span>即可。</p><h2 id="luogu1069-noip2009-普及组-细胞分裂">luogu1069 [NOIP2009 普及组]细胞分裂</h2><p>先把 <span class="math inline">\(m_1\)</span> 分解了，对于 <spanclass="math inline">\(m_1\)</span> 的一个质因数 <spanclass="math inline">\(p_j\)</span>，如果 <spanclass="math inline">\(s_i\)</span> 中不存在 <spanclass="math inline">\(p_j\)</span> 则无解。</p><p>否则，设 <span class="math inline">\(p_j\)</span> 在 <spanclass="math inline">\(s_i\)</span> 中的指数为 <spanclass="math inline">\(E_j\)</span>，则 <spanclass="math inline">\(x\)</span> 至少为 <spanclass="math inline">\(\Big\lceil \frac{e_j \times m_2}{E_j}\Big\rceil\)</span>。</p><p>取最大值即可。</p><h2 id="cf1325e-ehabs-real-number-theory-problem">CF1325E Ehab's REALNumber Theory Problem</h2><p>每个数的约数个数不超过 <spanclass="math inline">\(7\)</span>，也就是每个数最多有 <spanclass="math inline">\(2\)</span> 个质因数。</p><p>首先我们判一下完全平方数。然后我们就可以不考虑次数为偶数的质因子，所以所有数一共可以分成两类。</p><ol type="1"><li>单个质数 <span class="math inline">\(p\)</span>。</li><li>两个质数 <span class="math inline">\(p,q\)</span> 的乘积 <spanclass="math inline">\(pq\)</span>。</li></ol><p>用这些数的乘积得到完全平方数，那么每一种质数应该都出现偶数次。</p><p>考虑经典的图论建模问题。我们把出现过的质数当作点，能表示为 <spanclass="math inline">\(pq\)</span> 的点，看作 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(q\)</span>之间连一条无向边。另外还要额外建立一个点 <spanclass="math inline">\(1\)</span>，对于单个质数 <spanclass="math inline">\(p\)</span>，在 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(p\)</span> 之间连一条无向边。</p><p>这样，任何合法解都是图中的一个环。问题转化为求这张图的最小环。</p><p>由于边权都为 <span class="math inline">\(1\)</span>，我们直接使用<span class="math inline">\(\text{BFS}\)</span> 找环。</p><p><span class="math inline">\(\text{BFS}\)</span>树上的每一条返祖边都对应着一个环。枚举起点，如果这个点在环里，那么找到的第一条返祖边就是它所在的最小环，并且两个端点到它的距离再加<span class="math inline">\(1\)</span> 就是环长。</p><p>如果一个点不在环里，那么如果有环，以它为起点搜到的环一定比答案更大；否则以它为起点一定不能搜到环。所以这样做不会有问题。</p><p>然而复杂度约是 <span class="math inline">\(O\Big(n \frac{n}{\lnn}\Big)\)</span>，无法通过。</p><p>注意到每条边至少有一个点小于等于 <spanclass="math inline">\(\sqrt{\max\{a_i\}}\)</span>，只枚举这部分点作为起点即可。复杂度 <spanclass="math inline">\(O\Big(n \sqrt{\max \{a_i\}}\Big)\)</span>。</p><h2 id="cf582a-gcd-table">CF582A GCD Table</h2><p>一个重要的性质是 <span class="math inline">\(\gcd(a,b) \le\min(a,b)\)</span>。</p><p>表中最大的数、次大的数一定都是原序列中最大和次大的数，但是其他的就不一定了。</p><p>可以这样做。找到表中最大的数 <spanclass="math inline">\(k\)</span>，它一定是序列元素。然后删掉 <spanclass="math inline">\(k\)</span>，在序列中加入 <spanclass="math inline">\(k\)</span>，然后扫一遍序列中的其他元素 <spanclass="math inline">\(j\)</span>，在表中删掉两个 <spanclass="math inline">\(\gcd(k,j)\)</span>。</p><p>使用<code>std::set</code>可以做到 <span class="math inline">\(O(n^2\log_2 n^2)\)</span>。</p><h2 id="cf1344a-hilberts-hotel">CF1344A Hilbert's Hotel</h2><p>注意到原本位置距离为 <span class="math inline">\(tn, t \in\mathbb{Z}\)</span> 的点，在移动后仍然会距离 <spanclass="math inline">\(tn\)</span>，所以就可以只考虑 <spanclass="math inline">\([0,n-1]\)</span> 的点。</p><p>然后 check 每个 <span class="math inline">\((i+a_i) \bmod n\)</span>是否唯一即可。</p><p>注意要把 <span class="math inline">\(i+a_i\)</span> 可能小于 <spanclass="math inline">\(0\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, a[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> ((x+a[x])%n+n)%n;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) a[i]=<span class="hljs-built_in">read</span>(), ++p[<span class="hljs-built_in">r</span>(i)];<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(p[<span class="hljs-built_in">r</span>(i)]&gt;<span class="hljs-number">1</span>) &#123; fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(fg) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="cf1342c-yet-another-counting-problem">CF1342C Yet AnotherCounting Problem</h2><p>容易看出这个是有循环节的，周期为 <spanclass="math inline">\(\operatorname{lcm}(a,b)\)</span>。</p><p>然后 <span class="math inline">\(a,b\)</span>都很小，可以直接暴力处理每个周期内的信息，最后即可 <spanclass="math inline">\(O(1)\)</span> 回答询问。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> T, a, b, q, c, d;<span class="hljs-type">int</span> s[<span class="hljs-number">50000</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> t=x/c;<span class="hljs-keyword">return</span> t*s[c]+s[x-t*c];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x/__gcd(x,y)*y; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();c=<span class="hljs-built_in">lcm</span>(a,b);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,c) s[i]=s[i<span class="hljs-number">-1</span>]+(i%a%b!=i%b%a);<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,<span class="hljs-built_in">calc</span>(r)-<span class="hljs-built_in">calc</span>(l<span class="hljs-number">-1</span>));&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="luogu1477-noi2008-假面舞会">luogu1477 [NOI2008] 假面舞会</h2><p><ahref="https://yozora0908.github.io/2023/lg1477-solution">link</a></p><h2 id="cf980d-perfect-groups">CF980D Perfect Groups</h2><p>该上那个经典套路了。。</p><p>乘积为完全平方数具有传递性，因此可以轻易划分成若干唯一确定的不相交集合。</p><p>题目要求最小化分组的数量，那么就要保证每个集合都是极大的。</p><p>枚举起点，每考虑一个数都贪心把它加入它所对应的集合，没有就新开一个。</p><p>应该注意的是， <span class="math inline">\(0\)</span>可以放到任何一个集合中，我们钦定所有 <spanclass="math inline">\(0\)</span>都放到第一个集合里。所以，只有以下两种情况才需要新开集合。</p><ol type="1"><li>序列中没有元素。</li><li><span class="math inline">\(a_i \neq 0\)</span>，<spanclass="math inline">\(a_i\)</span>所在集合还没有元素并且当前序列中不是全 <spanclass="math inline">\(0\)</span>。</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, k, a[N], l[N], ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> t=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(x*y);<span class="hljs-keyword">return</span> x*y==t*t;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">per</span>(j,i<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">squ</span>(a[i],a[j])) &#123; l[i]=j; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>, zero=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,i,n) &#123;<span class="hljs-keyword">if</span>(i==j||(a[j]!=<span class="hljs-number">0</span>&amp;&amp;zero&amp;&amp;l[j]&lt;i)) ++k;++ans[k];zero|=a[j]!=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="cf354c-vasya-and-beautiful-arrays">CF354C Vasya and BeautifulArrays</h2><p>考虑直接枚举答案。容易发现一个答案 <spanclass="math inline">\(d\)</span> 是整个序列的公约数，当且仅当 <spanclass="math inline">\({\forall} i \in [1,n], a_i \bmod d \lek\)</span>。</p><p>然而貌似无法优化了。</p><p>注意到答案不会超过 <span class="math inline">\(mn = \min_{i=1}^n\{a_i\}\)</span>。</p><p>如果 <span class="math inline">\(mn \le k+1\)</span>，那么 <spanclass="math inline">\(a_i \bmod mn \le k\)</span>。</p><p>如果 <span class="math inline">\(mn&gt; k+1\)</span>，那么令答案为<span class="math inline">\(k+1\)</span>，显然都可以满足。因此答案区间为<span class="math inline">\([k+1,mn]\)</span>。</p><p>考虑如果一个 <span class="math inline">\(d\)</span> 能成为答案，每个<span class="math inline">\(a_i\)</span> 一定都能写成 <spanclass="math inline">\(tk+r\)</span>，其中 <span class="math inline">\(r\in[0,k]\)</span>。</p><p>注意到值域不大，可以开一个桶，在桶上做前缀和，然后枚举 <spanclass="math inline">\(t\)</span>，对每个区间求和，最后检查是否等于 <spanclass="math inline">\(n\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, lim=<span class="hljs-number">1e6</span>;<span class="hljs-type">int</span> n, k, mx, mn=<span class="hljs-number">1e9</span>, a[N], c[M];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();mx=<span class="hljs-built_in">max</span>(mx,a[i]);mn=<span class="hljs-built_in">min</span>(mn,a[i]);++c[a[i]];&#125;<span class="hljs-keyword">if</span>(mn&lt;=k+<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mn); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mx+k,lim);++i) c[i]+=c[i<span class="hljs-number">-1</span>];<span class="hljs-built_in">per</span>(d,mn,k+<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mx/d;++i) &#123;cnt+=c[<span class="hljs-built_in">min</span>(i*d+k,lim)]-c[i*d<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">if</span>(cnt==n) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="cf1114f-please-another-queries-on-array">CF1114F Please, anotherQueries on Array?</h2><p>不要忘了欧拉函数最原始的式子 <span class="math display">\[\varphi(n) = n \prod_{i=1}^m \frac{1-p_i}{p_i}\]</span> 这个式子的优点在于只和 <span class="math inline">\(n\)</span>以及它的质因子有关，并且是个积式。</p><p>也就是说，对于一个区间 <spanclass="math inline">\([l,r]\)</span>，我们只需要知道区间积以及区间出现过的质因子集合即可。</p><p>而值域小得令人发指，并且对于乘法操作，能增加的质因子也不超过 <spanclass="math inline">\(300\)</span>。也就是说可能出现的质因子只有 <spanclass="math inline">\(62\)</span>个，正好能用<code>long long</code>状压。</p><p>用线段树维护区间乘积和区间质因子集合即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, q, a[N];<span class="hljs-type">int</span> cnt, v[N];<span class="hljs-type">int</span> p[N], inv[N], rev[N];<span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>], s[N&lt;&lt;<span class="hljs-number">2</span>], stag[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">300</span>;++i) &#123;inv[i]=(mod-mod/i)*inv[mod%i]%mod;<span class="hljs-keyword">if</span>(!v[i]) &#123;p[cnt]=i, rev[cnt]=(i<span class="hljs-number">-1</span>)*inv[i]%mod, ++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=<span class="hljs-number">300</span>;j+=i) v[j]=<span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-type">char</span> ss[<span class="hljs-number">14</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]*t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]%mod;s[x]=s[x&lt;&lt;<span class="hljs-number">1</span>]|s[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> s0)</span> </span>&#123;(t[x]*=<span class="hljs-built_in">fp</span>(d,len))%=mod;(tag[x]*=d)%=mod;s[x]|=s0;stag[x]|=s0;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]&gt;<span class="hljs-number">1</span>||stag[x]) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,mid-l+<span class="hljs-number">1</span>,tag[x],stag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,r-mid,tag[x],stag[x]);tag[x]=<span class="hljs-number">1</span>, stag[x]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;tag[x]=t[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l==r)  &#123;t[x]=a[l];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>(a[l]%p[i]==<span class="hljs-number">0</span>) s[x]|=<span class="hljs-number">1ll</span>&lt;&lt;i;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> s0,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,r-l+<span class="hljs-number">1</span>,d,s0); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,s0,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,s0,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function">PII <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">MP</span>(t[x],s[x]);&#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;PII res; res.fi=<span class="hljs-number">1</span>, res.se=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) &#123;PII tmp=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);(res.fi*=tmp.fi)%=mod, res.se|=tmp.se;&#125;<span class="hljs-keyword">if</span>(R&gt;mid) &#123;PII tmp=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);(res.fi*=tmp.fi)%=mod, res.se|=tmp.se;&#125;<span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-built_in">build</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ss);<span class="hljs-keyword">if</span>(ss[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;M&#x27;</span>) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> s0=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>(x%p[i]==<span class="hljs-number">0</span>) s0|=<span class="hljs-number">1ll</span>&lt;&lt;i;<span class="hljs-built_in">upd</span>(l,r,x,s0);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();PII a=<span class="hljs-built_in">query</span>(l,r);<span class="hljs-type">int</span> ans=a.fi, S=a.se;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>((S&gt;&gt;i)&amp;<span class="hljs-number">1</span>) (ans*=rev[i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="cf632b-array-gcd">CF632B Array GCD</h2><p>首先将「整个序列的 <span class="math inline">\(\gcd\)</span>大于一」，转化成「整个序列存在公共质因子」。</p><p>一个重要的观察：任何一组合法解，整个序列的 <spanclass="math inline">\(\gcd\)</span> 一定是 <spanclass="math inline">\(a_1\)</span> 或 <spanclass="math inline">\(a_n\)</span> 的某个质因子的倍数。</p><p>然后 <span class="math inline">\(\omega(a_i)\)</span> 的最大值大概是<span class="math inline">\(10\)</span>的样子，所以可以枚举每个质因子。</p><p>能发现唯一的影响就是删掉的那一段。</p><p>设 <span class="math inline">\(f(i,0/1/2)\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 个数，删掉的段在位置 <spanclass="math inline">\(i\)</span>还没开始、开始了没结束、结束了的最小代价。</p><p>直接做就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">2e18</span>;<span class="hljs-type">int</span> n, ans, A, B, a[N][<span class="hljs-number">3</span>];vector&lt;<span class="hljs-type">int</span>&gt; tmp, v;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;tmp.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) tmp.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">divide</span>(a[<span class="hljs-number">1</span>][i]), <span class="hljs-built_in">divide</span>(a[n][i]);<span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> p=<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>())-tmp.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;++i) v.<span class="hljs-built_in">pb</span>(tmp[i]);&#125;<span class="hljs-type">int</span> f[N][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(i==n+<span class="hljs-number">1</span>) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];f[i][<span class="hljs-number">2</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);f[i][<span class="hljs-number">1</span>]=inf;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(a[i][<span class="hljs-number">1</span>]%x==<span class="hljs-number">0</span>) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+A;f[i][<span class="hljs-number">2</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][<span class="hljs-number">0</span>]%x==<span class="hljs-number">0</span>||a[i][<span class="hljs-number">2</span>]%x==<span class="hljs-number">0</span>) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+B;f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+A;f[i][<span class="hljs-number">2</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])+B;&#125; <span class="hljs-keyword">else</span> &#123;f[i][<span class="hljs-number">0</span>]=inf;f[i][<span class="hljs-number">2</span>]=inf;f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+A;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(f[n+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[n+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>(), B=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>();a[i][<span class="hljs-number">0</span>]=a[i][<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;a[i][<span class="hljs-number">2</span>]=a[i][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">prework</span>();ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) &#123;<span class="hljs-type">int</span> res=<span class="hljs-built_in">solve</span>(x);ans=<span class="hljs-built_in">min</span>(ans,res);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2id="求区间中与给定数互质的数的个数">求区间中与给定数互质的数的个数</h2><p>最后我们关注一个小问题。</p><blockquote><p>给定 <span class="math inline">\(n,L,R\)</span>，求 <spanclass="math inline">\([L,R]\)</span> 中与 <spanclass="math inline">\(n\)</span> 互质的数的个数。</p></blockquote><p>怎么做？</p><p>转化医学，求 <span class="math inline">\([L,R]\)</span>中有多少个数和 <span class="math inline">\(n\)</span>含有相同质因子，先差分成 <span class="math inline">\([1,L-1]\)</span> 和<span class="math inline">\([1,R]\)</span>。</p><p>设当前区间为 <span class="math inline">\([1,R]\)</span>。我们把 <spanclass="math inline">\(n\)</span>分解了，暴力搜索所有质因数的组合方式，设其为 <spanclass="math inline">\(m\)</span>，那么就有 <spanclass="math inline">\(\Big\lfloor \frac{R}{m} \Big\rfloor\)</span>个数含有这个质因子集合。根据熟悉的集合容斥，容易知道集合 <spanclass="math inline">\(S\)</span> 的容斥系数就是 <spanclass="math inline">\((-1)^{|S|}\)</span>。</p><p>设质因子个数为 <spanclass="math inline">\(\omega(n)\)</span>，那么复杂度就是 <spanclass="math inline">\(O(\sqrt{n} + 2^{\omega(n)})\)</span>。</p><p>通过提前筛质数能做到 <span class="math inline">\(O(\log_2 n +2^{\omega(n)})\)</span>，实际上第一项常数较小，第二项小于 <spanclass="math inline">\(O(n)\)</span>。</p><h3 id="cf1750d-count-gcd">CF1750D Count GCD</h3><p>有解一定要有 <span class="math inline">\(a_i \mida_{i-1}\)</span>。</p><p>考虑 <span class="math inline">\(\gcd_{j=1}^{i-1} \{b_j\} =a_{i-1}\)</span>，<span class="math inline">\(\gcd_{j=1}^{i} \{b_j\} =a_{i}\)</span>，也就是说 <span class="math inline">\(b_i\)</span> 不能有<span class="math inline">\(\frac{a_{i-1}}{a_i}\)</span>的任何质因子。</p><p>由于 <span class="math inline">\(a_i \mid b_i\)</span>，所以 <spanclass="math inline">\(\frac{b_i}{a_i} \in [1,\lfloor \frac{m}{a_i}\rfloor]\)</span>。</p><p>求区间中与 <span class="math inline">\(\frac{a_{i-1}}{a_i}\)</span>互质的数的个数即可。</p><p>单次求解的复杂度已经到了 <spanclass="math inline">\(O(2^{\omega(m)})\)</span> 了，而 <spanclass="math inline">\(\omega(m)\)</span> 的上界大概是 <spanclass="math inline">\(10\)</span>。</p><p>注意到那个很重要的条件 <span class="math inline">\(a_i \mida_{i-1}\)</span>，也就是这玩意是 <spanclass="math inline">\(\log\)</span> 级别递减的，所以直接暴力做就行。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// LUOGU_RID: 121128333</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> T, n, m, a[N];vector&lt;<span class="hljs-type">int</span>&gt; p;map&lt;PII,<span class="hljs-type">int</span>&gt; mp;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;p.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;p.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) p.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> lim)</span> </span>&#123;<span class="hljs-keyword">if</span>(i==p.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> lim/k;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -lim/k;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,k,lim)+<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>,k*p[i],lim);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> lim,<span class="hljs-type">int</span> r)</span> </span>&#123;PII t=&#123;lim,r&#125;;<span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(t)) <span class="hljs-keyword">return</span> mp[t];<span class="hljs-built_in">divide</span>(r);<span class="hljs-keyword">return</span> mp[t]=lim-<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,lim);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;a[i<span class="hljs-number">-1</span>]%a[i]) fg=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(fg) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;(ans*=<span class="hljs-built_in">calc</span>(m/a[i],a[i<span class="hljs-number">-1</span>]/a[i]))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;hankson的趣味题&quot;&gt;Hankson的趣味题&lt;/h2&gt;
&lt;p&gt;从质因子的角度考虑。&lt;/p&gt;
&lt;p&gt;把 &lt;span class=&quot;math inline&quot;&gt;&#92;(a,b,c,d&#92;)&lt;/span&gt;
都分解了，对于一个质因子 &lt;span class=&quot;math inline&quot;&gt;&#92;(p_i&#92;)&lt;/span&gt;，题目给出的条件等价于 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;min &#92;Big( e_{p_i} (x) ,e_{p_i} (a)&#92;Big) =e_{p_i}(c)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;max &#92;Big( e_{p_i}(x),e_{p_i}(b) &#92;Big) = e_{p_i}(d)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;讨论一下就能得到 &lt;span class=&quot;math inline&quot;&gt;&#92;(e_{p_i}(x)&#92;)&lt;/span&gt;
的取值范围，或者报告无解。&lt;/p&gt;
&lt;h2 id=&quot;cf1114c-trailing-loves-or-loeufs&quot;&gt;CF1114C Trailing Loves (or
L&#39;oeufs?)&lt;/h2&gt;
&lt;p&gt;把 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 分解为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;prod_{i=1}^m p_i^{e_i}&#92;)&lt;/span&gt;，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(E_i&#92;)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;&#92;(p_i&#92;)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;&#92;(N&#92;)&lt;/span&gt; 中的幂次。&lt;/p&gt;
&lt;p&gt;则 &lt;span class=&quot;math inline&quot;&gt;&#92;(N&#92;)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 进制下后导 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt; 的个数就是 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;min&#92;Big(&#92;Big&#92;lfloor &#92;frac{E_i}{e_i}
&#92;Big&#92;rfloor&#92;Big)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于每个 &lt;span class=&quot;math inline&quot;&gt;&#92;(p_i&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(n!&#92;)&lt;/span&gt; 中质因子 &lt;span class=&quot;math inline&quot;&gt;&#92;(p_i&#92;)&lt;/span&gt; 的个数为 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sum_{k=1 &#92;wedge p_i^k &#92;le n} &#92;Big&#92;lfloor &#92;frac{n}{p_i^k} &#92;Big&#92;rfloor
&#92;]&lt;/span&gt; 解释一下上式。&lt;/p&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="数论" scheme="https://yozora0908.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>luogu1477 假面舞会 题解</title>
    <link href="https://yozora0908.github.io/2023/lg1477-solution/"/>
    <id>https://yozora0908.github.io/2023/lg1477-solution/</id>
    <published>2023-08-24T03:50:05.000Z</published>
    <updated>2023-08-24T03:51:43.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>考虑如果 <span class="math inline">\(a\)</span> 能看见 <spanclass="math inline">\(b\)</span>，那么从 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 连边。</p><p>先从简单的图上开始分析。</p><p>考虑在 DAG 上的情况，发现还是不太容易确定。</p><h3 id="part1">Part1</h3><p>不妨先只考虑有向链，这个很简单，最大就是链长（超过 <spanclass="math inline">\(3\)</span> 的话），最小是 <spanclass="math inline">\(3\)</span>。然而当我们把若干形态的链拼成一张 DAG时，则会出现一个点到达另一个点的路径不止一条，从而导致很诡异的事情，似乎不太容易找到最大值了。然后我们能发现要是不存在这种情况，也就是DAG 是个有向树，那么答案就是最长链。</p><p>可以发现，链这种结构不会使原本合法的 <spanclass="math inline">\(k\)</span> 变小。</p><p>观察这种情况，设较长链长度为 <spanclass="math inline">\(l_1\)</span>，较短链长度为 <spanclass="math inline">\(l_2\)</span>，那么能发现答案就是 <spanclass="math inline">\(l_1-l_2\)</span>，更确切地说，合法环长是 <spanclass="math inline">\(l_1-l_2\)</span>的约数。那么根据上一段的结论，最大值是所有 <spanclass="math inline">\(l_1-l_2\)</span> 的 <spanclass="math inline">\(\gcd\)</span>。</p><p>如何找到这样的情况，是我们亟待解决的第一个问题。</p><h3 id="part2">Part2</h3><p>然后加入对环的讨论。设一个简单环环长为 <spanclass="math inline">\(len\)</span>，那么 <spanclass="math inline">\(len\)</span> 必须是 <spanclass="math inline">\(k\)</span> 的倍数。不难想到 <spanclass="math inline">\(k\)</span> 最大能取所有环长的 <spanclass="math inline">\(\gcd\)</span>。同时对于链来说 <spanclass="math inline">\(k\)</span> 是啥都无所谓，因此此时最大值就是环长<span class="math inline">\(\gcd\)</span>，最小值取 <spanclass="math inline">\(\gcd\)</span> 大于 <spanclass="math inline">\(3\)</span>的约数即可。然而这还是简单环，如何解决有公共边的环，这是我们亟待解决的第二个问题。</p><h3 id="part3">Part3</h3><p>下面不加推导地给出解决两个问题的办法：对于关系 <spanclass="math inline">\((a,b)\)</span>，从 <spanclass="math inline">\(a\)</span> 向 <spanclass="math inline">\(b\)</span> 连权值为 <spanclass="math inline">\(1\)</span> 的边，从 <spanclass="math inline">\(b\)</span> 向 <spanclass="math inline">\(a\)</span> 连权值为 <spanclass="math inline">\(-1\)</span>​ 的边。直接钦定一个连通块中的节点为<spanclass="math inline">\(0\)</span>，然后顺着边权求出每个点的权值。</p><ul><li>每个连通块的最大权值减掉最小权值再加上 <spanclass="math inline">\(1\)</span> 就是最长链长度。</li><li>重复访问到一个节点时，将两个值做差得到环的权值，取 <spanclass="math inline">\(\gcd\)</span> 即可。</li></ul><h3 id="part4">Part4</h3><p>首要明确连完反边之后就成了无向图，图中的每一个环，都对应着上述结构中的一个，即到一个点的两条路径、有或无公共边的环。</p><p>对于第一个问题，在无向图上搜完一圈回来得到的就是 <spanclass="math inline">\(l_1-l_2\)</span>。</p><p>对于第二个问题，取公共部分的末端为起点，公共部分的始端为重点，这就是第一个问题的情况又复合上了一条链，而链是不会对种类数产生限制的。因此，第二个问题规约到了第一个问题上。</p><p>设较长环长度为 <span class="math inline">\(x\)</span>，较短环长度为<span class="math inline">\(y\)</span>，二者公共部分长度为 <spanclass="math inline">\(z\)</span>。那么这个东西所对应的最大值是 <spanclass="math inline">\((x-z)-(y-z) = x-y\)</span>。这个结构的贡献是 <spanclass="math inline">\(\gcd(x,y)\)</span>。</p><p>假设已经搜完了较长环，进入环的时机以及走的路径不同，会导致上述做法得到的较短环的权值也不同。但是塔可以保证这个权值只会是<span class="math inline">\(y\)</span> 或 <spanclass="math inline">\(x-y\)</span>，并且 <spanclass="math inline">\(\gcd(x,y) = \gcd(x,x-y)\)</span>，所以是对的。</p><p>具体证明设计大量分类讨论，此处不予展开。</p><p>比较抽象，可以对着图理解。</p><p><imgsrc="https://cdn-us.imgs.moe/2023/08/19/64e0aacc8995b.png" srcset="/img/loading.gif" lazyload /></p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, t, mx, mn, ans, dis[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-type">int</span> tot, h[N], to[M], w[M], nxt[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(v[x]) &#123;ans=<span class="hljs-built_in">gcd</span>(ans,<span class="hljs-built_in">abs</span>(dis[x]-k));<span class="hljs-keyword">return</span>;&#125;v[x]=<span class="hljs-number">1</span>, dis[x]=k;mx=<span class="hljs-built_in">max</span>(mx,k), mn=<span class="hljs-built_in">min</span>(mn,k);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x,k+z);        <span class="hljs-comment">// 判一下不要往回搜是因为二元环是一种很没用的东西</span>        <span class="hljs-comment">// 搜不搜反正都是和1取gcd</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>);<span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">-1</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;mx=<span class="hljs-number">-1e9</span>, mn=<span class="hljs-number">1e9</span>;<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);t+=mx-mn+<span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!ans) ans=t, ans2=<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> &#123;ans2=<span class="hljs-number">3</span>;<span class="hljs-keyword">while</span>(ans2&lt;ans&amp;&amp;ans%ans2) ++ans2;&#125;<span class="hljs-keyword">if</span>(ans&lt;<span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,ans,ans2);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;考虑如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt; 能看见 &lt;span class=&quot;math inline&quot;&gt;&#92;(b&#92;)&lt;/span&gt;，那么从 &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;&#92;(b&#92;)&lt;/span&gt; 连边。&lt;/p&gt;
&lt;p&gt;先从简单的图上开始分析。&lt;/p&gt;
&lt;p&gt;考虑在 DAG 上的情况，发现还是不太容易确定。&lt;/p&gt;
&lt;h3 id=&quot;part1&quot;&gt;Part1&lt;/h3&gt;
&lt;p&gt;不妨先只考虑有向链，这个很简单，最大就是链长（超过 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt; 的话），最小是 &lt;span class=&quot;math inline&quot;&gt;&#92;(3&#92;)&lt;/span&gt;。然而当我们把若干形态的链拼成一张 DAG
时，则会出现一个点到达另一个点的路径不止一条，从而导致很诡异的事情，似乎不太容易找到最大值了。然后我们能发现要是不存在这种情况，也就是
DAG 是个有向树，那么答案就是最长链。&lt;/p&gt;
&lt;p&gt;可以发现，链这种结构不会使原本合法的 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 变小。&lt;/p&gt;
&lt;p&gt;观察这种情况，设较长链长度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(l_1&#92;)&lt;/span&gt;，较短链长度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(l_2&#92;)&lt;/span&gt;，那么能发现答案就是 &lt;span class=&quot;math inline&quot;&gt;&#92;(l_1-l_2&#92;)&lt;/span&gt;，更确切地说，合法环长是 &lt;span class=&quot;math inline&quot;&gt;&#92;(l_1-l_2&#92;)&lt;/span&gt;
的约数。那么根据上一段的结论，最大值是所有 &lt;span class=&quot;math inline&quot;&gt;&#92;(l_1-l_2&#92;)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;gcd&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如何找到这样的情况，是我们亟待解决的第一个问题。&lt;/p&gt;
&lt;h3 id=&quot;part2&quot;&gt;Part2&lt;/h3&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="图论" scheme="https://yozora0908.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="数论" scheme="https://yozora0908.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#14 基础数论（1）</title>
    <link href="https://yozora0908.github.io/2023/noip-record-14/"/>
    <id>https://yozora0908.github.io/2023/noip-record-14/</id>
    <published>2023-08-12T13:34:56.000Z</published>
    <updated>2023-09-01T11:50:25.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>本文主要放知识点。</p><h2 id="质数筛">质数筛</h2><h3 id="埃氏筛模板">埃氏筛模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prime</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=n;j+=i) v[j]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 优化：从i*i开始枚举</span>&#125;&#125;</code></pre></div><h3 id="线性筛模板">线性筛模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-comment">// p[j]是i*p[j]的最小质因子</span><span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></div><h3 id="区间筛">区间筛</h3><blockquote><p>求 <span class="math inline">\([a,b]\)</span> 中的所有质数。</p><p><span class="math inline">\(a,b \le 10^{12}\)</span>，<spanclass="math inline">\(b-a \le 10^6\)</span>。</p></blockquote><p>由于每个合数 <span class="math inline">\(x\)</span> 存在至少一个<span class="math inline">\(\le \sqrt{x}\)</span> 的质因数，所以先筛出<span class="math inline">\([2,\sqrt{b}]\)</span>中的质数，用这些质数再筛掉 <span class="math inline">\([a,b]\)</span>中的合数。</p><h2 id="约数相关">约数相关</h2><h3 id="质因数分解">质因数分解</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;++i) <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;p[++cnt]=i;<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i, ++e[cnt];&#125;<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) p[++cnt]=n, e[n]=<span class="hljs-number">1</span>;&#125;</code></pre></div><p>时间复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>，常数比较小。</p><p>还有 <span class="math inline">\(O(\log_2 n)\)</span>的做法。先用筛法处理出每个数的最小质因子。分解 <spanclass="math inline">\(n\)</span> 时就可以 <spanclass="math inline">\(O(1)\)</span> 除掉一个质因子了 。</p><h3 id="求约数集合">求约数集合</h3><h4 id="试除法">试除法</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fac</span><span class="hljs-params">()</span> </span>&#123;vector&lt;<span class="hljs-type">int</span>&gt; factor;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;++i)  <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;factor.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">if</span>(i*i!=n) factor.<span class="hljs-built_in">push_back</span>(n/i);&#125;&#125;</code></pre></div><p>求单个数的约数集合，时间复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>。</p><h4 id="倍数法">倍数法</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fac</span><span class="hljs-params">()</span> </span>&#123;vector&lt;<span class="hljs-type">int</span>&gt; factor[N];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*j&lt;=n;++j) &#123;factor[i*j].<span class="hljs-built_in">push_back</span>(i);&#125;&#125;</code></pre></div><p>求 <span class="math inline">\([1,n]\)</span>中所有数的约数集合，时间复杂度 <span class="math inline">\(O(n \lnn)\)</span>。</p><p>从中得到推论：</p><blockquote><p><span class="math display">\[\sum_{i=1}^n \sigma_0 (i) \approx n \ln n\]</span></p></blockquote><h3 id="约数个数函数">约数个数函数</h3><p>设 <span class="math inline">\(n\)</span> 分解后为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，则 <spanclass="math display">\[\sigma_0(n) = \prod_{i=1}^m (e_i+1)\]</span></p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\le\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^2\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^3\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^4\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^5\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^6\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^7\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^8\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^9\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sigma_0(n)\le\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4\)</span></td><td style="text-align: center;"><spanclass="math inline">\(12\)</span></td><td style="text-align: center;"><spanclass="math inline">\(32\)</span></td><td style="text-align: center;"><spanclass="math inline">\(64\)</span></td><td style="text-align: center;"><spanclass="math inline">\(128\)</span></td><td style="text-align: center;"><spanclass="math inline">\(240\)</span></td><td style="text-align: center;"><spanclass="math inline">\(448\)</span></td><td style="text-align: center;"><spanclass="math inline">\(768\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1344\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(n\le\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{10}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{11}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{12}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{13}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{14}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{15}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{16}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{17}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{18}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sigma_0(n)\le\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2304\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4032\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6720\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10752\)</span></td><td style="text-align: center;"><spanclass="math inline">\(17280\)</span></td><td style="text-align: center;"><spanclass="math inline">\(26880\)</span></td><td style="text-align: center;"><spanclass="math inline">\(41472\)</span></td><td style="text-align: center;"><spanclass="math inline">\(64512\)</span></td><td style="text-align: center;"><spanclass="math inline">\(103680\)</span></td></tr></tbody></table><p><imgsrc="http://cdnjson.com/images/2023/08/11/screenshot20230811.png" srcset="/img/loading.gif" lazyload /></p><h3 id="约数和函数">约数和函数</h3><p>设 <span class="math inline">\(n\)</span> 分解后为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，则 <spanclass="math display">\[\begin{aligned}\sigma_1(n) &amp;= \prod_{i=1}^m \sum_{j=0}^{e_i} p_i^j\\&amp;= \prod_{i=1}^m \frac{p_i^{e_i+1}-1}{p_i-1}\end{aligned}\]</span> 然而这个一般要在模意义下进行，<spanclass="math inline">\(p_i-1\)</span>在可能是模数的倍数，否则直接求即可。</p><p>可以用分治法求 <span class="math inline">\(\sum_{j=0}^{e_i}p_i^j\)</span>，设 <span class="math inline">\(sum(a,b) =\sum_{i=0}^ba_i\)</span>。</p><p>若 <span class="math inline">\(b\)</span> 为奇数，记 <spanclass="math inline">\(c=\lfloor\frac{b}{2}\rfloor\)</span> <spanclass="math display">\[\begin{aligned}sum(a,b) &amp;= \sum_{i=0}^{c} a^i + \sum_{i=c+1}^b a^i\\&amp;= \sum_{i=0}^c a_i + a^{c+1} \sum_{i=0}^c a^i\\&amp;= (1+a^{c+1}) \times sum(a,c)\end{aligned}\]</span> 若 <span class="math inline">\(b\)</span> 为偶数，记 <spanclass="math inline">\(c=\frac{b}{2}\)</span> <spanclass="math display">\[\begin{aligned}sum(a,b) &amp;= \sum_{i=0}^{c-1} a^i + \sum_{i=c}^b a^i\\&amp;= \sum_{i=0}^{c-1} a_i + a^{c} \sum_{i=0}^{c-1} a^i + a^b\\&amp;= (1+a^{c}) \times sum(a,c-1) + a^b\end{aligned}\]</span> 这样每次分治后，问题规模都会缩小一半，加上快速幂，复杂度 <spanclass="math inline">\(O(\log b)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>+<span class="hljs-built_in">fp</span>(a,b/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))*<span class="hljs-built_in">sum</span>(a,b/<span class="hljs-number">2</span>)%mod;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> ((<span class="hljs-number">1</span>+<span class="hljs-built_in">fp</span>(a,b/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))*<span class="hljs-built_in">sum</span>(a,b/<span class="hljs-number">2</span><span class="hljs-number">-1</span>)%mod+<span class="hljs-built_in">fp</span>(a,b/<span class="hljs-number">2</span>))%mod;&#125;</code></pre></div><h2 id="gcd与lcm">GCD与LCM</h2><h3 id="定义与基本性质">定义与基本性质</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x/<span class="hljs-built_in">gcd</span>(x,y)*y; &#125;</code></pre></div><p><span class="math display">\[\operatorname{lcm}(x,y) = \frac{xy}{\gcd(x,y)}\]</span></p><p>设长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，所有 <spanclass="math inline">\(a_i\)</span> 分解后的质因数总共有 <spanclass="math inline">\(m\)</span> 个，记为序列 <spanclass="math inline">\(p\)</span>。设 <spanclass="math inline">\(e_{i,j}\)</span> 为 <spanclass="math inline">\(a_j\)</span> 分解后 <spanclass="math inline">\(p_i\)</span> 的指数。</p><p>记 <span class="math display">\[\alpha_i = \min_{j=1}^n \Big\langle e_{i,j} \Big\rangle\]</span></p><p><span class="math display">\[\beta_i = \max_{j=1}^n \Big\langle e_{i,j} \Big\rangle\]</span></p><p>则 <span class="math display">\[\gcd_{i=1}^n (a_i) = \prod_{i=1}^m p_i ^{\alpha_i}\]</span></p><p><span class="math display">\[\operatorname{lcm}_{i=1}^n (a_i) = \prod_{i=1}^m p_i^{\beta_i}\]</span></p><p><span class="math inline">\(\gcd\)</span> 与 <spanclass="math inline">\(\operatorname{lcm}\)</span>满足结合律，可以用区间数据结构维护。</p><h3 id="关于环">关于环</h3><p>还是结合题目吧。</p><h4 id="luogu6187-noi-online-1-提高组-最小环">luogu6187 [NOI Online #1提高组] 最小环</h4><p>考虑这样一个东西，<span class="math inline">\(x\)</span> 在一个下标为<span class="math inline">\([0,n-1]\)</span> 的序列上跳，起点是 <spanclass="math inline">\(0\)</span>，每次从 <spanclass="math inline">\(i\)</span> 跳到 <span class="math inline">\((i+L)\bmod n\)</span>，轨迹是个什么？</p><p>显然一定成环。</p><p>假设跳了 <span class="math inline">\(k\)</span> 次使得 <spanclass="math inline">\(x\)</span> 回到 <spanclass="math inline">\(0\)</span>，那么一定有 <spanclass="math inline">\(kL \bmod n =0\)</span>。</p><p><span class="math inline">\(kL\)</span> 最小是 <spanclass="math inline">\(\operatorname{lcm}(n,L)\)</span>，那么此时 <spanclass="math inline">\(k = \frac{\operatorname{lcm}(n,L)}{L} =\frac{n}{\gcd(n,L)}\)</span>。</p><p>也就是说此时环上节点有 <spanclass="math inline">\(\frac{n}{\gcd(n,L)}\)</span> 个。</p><ul><li><p>从不同的 <span class="math inline">\(n\)</span>个点开始跳，总共形成 <span class="math inline">\(n / k =\gcd(n,L)\)</span> 个不同的环。</p></li><li><p>从 <span class="math inline">\(0\)</span>开始跳，求经过的节点集。问题等价于 <span class="math inline">\(kL \bmodn\)</span> 有几个不同的值。可以转化为 <span class="math inline">\(kL +pn = A\)</span>，对哪些 <span class="math inline">\(A\)</span>有解，其中 <span class="math inline">\(A \in[0,n-1]\)</span>。答案是当且仅当 <span class="math inline">\(\gcd(n,L)\mid A\)</span>，因为只要有解，我们总能把 <spanclass="math inline">\(k\)</span> 调整成为一个正数。</p></li></ul><p>回到本题上。</p><p>我们知道环长为 <spanclass="math inline">\(\frac{n}{\gcd(n,k)}\)</span>，只管上来看，把最大的贪心塞进一个环里贡献最大。</p><p>设一个环内第 <span class="math inline">\(i\)</span> 大的数为 <spanclass="math inline">\(p_i\)</span>，那么最优排列方式是 <spanclass="math inline">\(p_1,p_3,p_5,\ldots\)</span> 与 <spanclass="math inline">\(p_2,p_4 ,\ldots\)</span>各形成两个半环，再将对应端点连接。</p><blockquote><p><span class="math inline">\(\text{Proof by Elegia}\)</span></p><p>我们考虑把乘积看成面积，那么第 <span class="math inline">\(i\)</span>个点就在 <span class="math inline">\((a_i,a_i)\)</span>上，我们要最小化所有走路扫过的以端点形成的正方形面积之和。容易分析得到通过直线<span class="math inline">\(x=a_i\)</span> 和 <spanclass="math inline">\(y=a_j\)</span>切出来的每一个小矩形被经过的次数都达到了下界。</p></blockquote><p>这样单次还是 <span class="math inline">\(O(n)\)</span>的。考虑到不同的环长只有 <spanclass="math inline">\(\sigma_0(n)\)</span> 种，因此记忆化即可。</p><p>复杂度 <span class="math inline">\(O\Big(n\sigma_0(n)\Big)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P6187 [NOI Online #1 提高组] 最小环</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P6187</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans0, a[N], rec[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), ans0+=a[i]*a[i];<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!k) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans0);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> len=n/__gcd(n,k);<span class="hljs-keyword">if</span>(rec[len]) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,rec[len]); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=len) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j+<span class="hljs-number">2</span>&lt;=i+len<span class="hljs-number">-1</span>;j+=<span class="hljs-number">2</span>) ans+=a[j]*a[j+<span class="hljs-number">2</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j+<span class="hljs-number">2</span>&lt;=i+len<span class="hljs-number">-1</span>;j+=<span class="hljs-number">2</span>) ans+=a[j]*a[j+<span class="hljs-number">2</span>];ans+=a[i]*a[i+<span class="hljs-number">1</span>]+a[i+len<span class="hljs-number">-1</span>]*a[i+len<span class="hljs-number">-2</span>];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,rec[len]=ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><h3 id="bézout定理">Bézout定理</h3><p>对于任意不全为 <span class="math inline">\(0\)</span> 的整数 <spanclass="math inline">\(a,b\)</span>，存在无穷多对整数 <spanclass="math inline">\(x,y\)</span>，满足 <span class="math inline">\(ax+ by = \gcd(a,b)\)</span>。</p><p>换言之，<span class="math inline">\(a,b\)</span>的整系数线性组合得到的是所有 <spanclass="math inline">\(\gcd(a,b)\)</span> 的倍数。</p><h3 id="模板">模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);y-=a/b*x;<span class="hljs-keyword">return</span> d;&#125;</code></pre></div><h3 id="求解不定方程与同余方程">求解不定方程与同余方程</h3><p>对于不定方程 <span class="math inline">\(ax+by =c\)</span>，其有整数解的充要条件是 <span class="math inline">\(\gcd(a,b)\mid c\)</span>。</p><p>先用扩展欧几里得算法求出 <spanclass="math inline">\(ax+by=\gcd(a,b)\)</span> 的一组特解 <spanclass="math inline">\((x_0,y_0)\)</span> 和 <spanclass="math inline">\(d = \gcd(a,b)\)</span>。</p><p><span class="math inline">\(ax+by=c\)</span> 的通解可以表示为 <spanclass="math display">\[\large \begin{cases}x= \frac{c}{d} x_0 + k \frac{b}{d}\\y=\frac{c}{d}y_0 - k \frac{a}{d}\end{cases}\]</span> 其中 <span class="math inline">\(k \in\mathbb{Z}\)</span>。</p><p>那么对于线性同余方程 <span class="math display">\[ax \equiv b \pmod{p}\]</span> 可以转化为 <span class="math display">\[ax + py = b\]</span> 这里钦定 <span class="math inline">\(b =\gcd(a,p)\)</span>。</p><p>用上述做法求出特解 <span class="math inline">\(x_0\)</span>之后，所有与 <span class="math inline">\(x_0\)</span> 在模 <spanclass="math inline">\(\frac{p}{\gcd(a,p)}\)</span>意义下同余的数构成的集合，就是这个方程的解集。</p><p>通过这一点可以得到最小正整数解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-type">int</span> x, y;    <span class="hljs-comment">// b=gcd(a,b)</span>    <span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(a,p,x,y);    p/=d;    x=(x%p+p)%p;&#125;</code></pre></div><h2 id="同余相关">同余相关</h2><p><span class="math display">\[a \bmod b = a - \lfloor \frac{a}{b} \rfloor \times b\]</span></p><p> </p><p><span class="math display">\[a \times (b \bmod c) = ab \bmod ac\]</span></p><p><span class="math display">\[x \equiv y \pmod{p} \Longrightarrow xz \equiv yz \pmod{p}\]</span></p><p>  <span class="math display">\[x \equiv y \pmod{p} \iff p \mid (x-y)\]</span></p><p>  <span class="math display">\[ax \equiv ay \pmod{p}\]</span></p><p>令 <span class="math inline">\(d=\gcd(a,p)\)</span>，则 <spanclass="math display">\[x \equiv y \pmod{\frac{p}{d}}\]</span></p><h3 id="费马小定理">费马小定理</h3><p>若 <span class="math inline">\(p\)</span> 为质数，则对于任意整数<span class="math inline">\(a\)</span>，都有 <spanclass="math display">\[a^p \equiv a \pmod{p}\]</span></p><p>或者说，若 <span class="math inline">\(p\)</span> 为质数，<spanclass="math inline">\(a,p\)</span> 互质，那么 <spanclass="math display">\[a^{p-1} \equiv 1 \pmod{p}\]</span></p><h3 id="威尔逊定理">威尔逊定理</h3><p>若 <span class="math inline">\(p\)</span> 为质数，那么 <spanclass="math display">\[(p-1)! \equiv -1 \pmod{p}\]</span></p><h3 id="乘法逆元">乘法逆元</h3><p>对于 <span class="math inline">\(x \in [0,p)\)</span>，如果 <spanclass="math inline">\(x\)</span> 在模 <spanclass="math inline">\(p\)</span>意义下的逆元存在，那么这个逆元唯一。</p><h4 id="费马小定理-1">费马小定理</h4><p>如果 <span class="math inline">\(p\)</span> 是质数，<spanclass="math inline">\(a\)</span> 不是 <spanclass="math inline">\(p\)</span> 的倍数，则 <spanclass="math display">\[a^{p-1} \equiv 1 \pmod{p}\]</span> 从而 <span class="math display">\[a \times a^{p-2} \equiv 1 \pmod{p}\]</span> <span class="math inline">\(a^{p-2}\)</span> 就是 <spanclass="math inline">\(a\)</span> 在模 <spanclass="math inline">\(p\)</span> 意义下的逆元。</p><p>复杂度 <span class="math inline">\(O(\log_2 p)\)</span>。</p><h4 id="扩展欧几里得算法-1">扩展欧几里得算法</h4><p><span class="math display">\[ax \equiv 1 \pmod{p}\]</span></p><p>等价于 <span class="math display">\[{\exists} y, ax + py = 1\]</span> 这个不定方程有解的充要条件是 <spanclass="math inline">\(\gcd(a,p)=1\)</span>，也就是 <spanclass="math inline">\(a \bot p\)</span>。</p><p>求出的 <span class="math inline">\(x_0\)</span> 就是 <spanclass="math inline">\(a\)</span> 在模 <spanclass="math inline">\(p\)</span> 意义下的逆元。</p><p>复杂度 <span class="math inline">\(O(\log_2 p)\)</span>。</p><h4 id="递推逆元">递推逆元</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getinv</span><span class="hljs-params">()</span> </span>&#123;    inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) inv[i]=(p-p/i)*inv[p%i]%p;&#125;</code></pre></div><p>复杂度 <span class="math inline">\(O(n)\)</span>。</p><h4 id="求阶乘逆元">求阶乘逆元</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getinv</span><span class="hljs-params">()</span> </span>&#123;    inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    inv[n]=<span class="hljs-built_in">fp</span>(fac[n],p<span class="hljs-number">-2</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%p;&#125;</code></pre></div><p>复杂度 <span class="math inline">\(O(n+\log_2 p)\)</span></p><h2 id="整除分块">整除分块</h2><p><span class="math display">\[\sum_{i=1}^n \Big \lfloor \frac{n}{i} \Big\rfloor\]</span></p><p>只有 <span class="math inline">\(O(\sqrt{n})\)</span>种不同的值，且每一种值对应的 <span class="math inline">\(i\)</span>连续。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;l&lt;=n;l=r+<span class="hljs-number">1</span>) &#123;        r=n/(n/l);        <span class="hljs-comment">// 值为n/l的区间是[l,r]</span>    &#125;&#125;</code></pre></div><h2 id="欧拉函数">欧拉函数</h2><h3 id="定义">定义</h3><p><span class="math inline">\(\varphi(n)\)</span> 表示 <spanclass="math inline">\([1,n]\)</span> 中与 <spanclass="math inline">\(n\)</span> 互质的数的个数。</p><p>设 <span class="math inline">\(n\)</span> 分解后为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，则 <spanclass="math display">\[\varphi(n) = n \prod_{i=1}^m (1-\frac{1}{p_i})\]</span> 所以可以在分解质因数的过程中计算欧拉函数，复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getphi</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span> </span>&#123;<span class="hljs-type">int</span> phi=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;++i) <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;phi=phi/i*(i<span class="hljs-number">-1</span>);<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i;&#125;<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) phi=phi/n*(n<span class="hljs-number">-1</span>);&#125;</code></pre></div><p>可以用线性筛在 <span class="math inline">\(O(n)\)</span> 的时间里求出<span class="math inline">\([1,n]\)</span> 所有数的欧拉函数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getphi</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) v[i]=<span class="hljs-number">1</span>, p[++cnt]=i, phi[i]=i<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-comment">// p[j]是i*p[j]的最小质因子</span><span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) &#123;                phi[i*p[j]]=phi[i]*p[j];                <span class="hljs-keyword">break</span>;            &#125;            phi[i*p[j]]=phi[i]*phi[p[j]];&#125;&#125;&#125;</code></pre></div><h3 id="性质">性质</h3><p>积性函数。 <span class="math display">\[a \bot b \Longrightarrow \varphi(ab) = \varphi(a)\varphi(b)\]</span></p><p><span class="math display">\[\sum_{d \mid n} \varphi(d) = n\]</span></p><p><span class="math display">\[\sum_{i=1}^n [\gcd(i,n)=1]i = \frac{n \times \varphi(n)}{2}\]</span></p><p>另外线性筛求欧拉函数的过程中用了两个性质。</p><ol type="1"><li>若 <span class="math inline">\(p\)</span> 为质数，<spanclass="math inline">\(p \mid n\)</span>，<span class="math inline">\(p^2\nmid n\)</span>，那么 <spanclass="math inline">\(\varphi(n)=\varphi(n/p) \times\varphi(p)\)</span>。</li><li>若 <span class="math inline">\(p\)</span> 为质数，<spanclass="math inline">\(p \mid n\)</span>，<span class="math inline">\(p^2\nmid n\)</span>，那么 <span class="math inline">\(\varphi(n)=\varphi(n/p) \times p\)</span>。</li></ol><h3 id="欧拉定理">欧拉定理</h3><p>若 <span class="math inline">\(a \bot n\)</span>，则 <spanclass="math display">\[a^{\varphi(n)} \equiv 1 \pmod{n}\]</span></p><p>另外有结论，若 <span class="math inline">\(a \botn\)</span>，那么满足 <span class="math display">\[a^x \equiv 1 \pmod{n}\]</span> 最小的 <span class="math inline">\(x\)</span> 一定是 <spanclass="math inline">\(\varphi(n)\)</span> 的约数。</p><h3 id="扩展欧拉定理">扩展欧拉定理</h3><p>懒得打公式了。</p><p><imgsrc="http://cdnjson.com/images/2023/08/11/2018061415403415.png" srcset="/img/loading.gif" lazyload /></p><h2 id="进制转换">进制转换</h2><p>将 <span class="math inline">\(n\)</span> 位 <spanclass="math inline">\(a\)</span> 进制数转化为 <spanclass="math inline">\(m\)</span> 位 <spanclass="math inline">\(b\)</span> 进制数的做法如下。</p><p>如果这个十进制数存的下的话，</p><ul><li>将给定的 <span class="math inline">\(a\)</span>进制数从高位到低位扫一边，每次将当前结果乘 <spanclass="math inline">\(a\)</span> 再加上当前位的系数，这样就能转化成<span class="math inline">\(10\)</span> 进制。</li><li>从 <span class="math inline">\(10\)</span> 进制转化为 <spanclass="math inline">\(b\)</span>进制。先模再除，取最低位放进去，重复这个过程。</li></ul><p>复杂度是 <span class="math inline">\(O(n)\)</span> 的。</p><h2 id="excrt">exCRT</h2><p>CRT 完全可以被 exCRT 代替。</p><p><ahref="https://yozora0908.github.io/2022/notes-number-theory-1">link</a></p><h2 id="线性筛求常见积性函数">线性筛求常见积性函数</h2><h3 id="莫比乌斯函数">莫比乌斯函数</h3><p><imgsrc="https://cdn-us.imgs.moe/2023/08/11/64d5f860198f1.png" srcset="/img/loading.gif" lazyload /></p><h3 id="欧拉函数-1">欧拉函数</h3><p><imgsrc="https://cdn-us.imgs.moe/2023/08/11/64d5f8605cbef.png" srcset="/img/loading.gif" lazyload /></p><h3 id="约数个数函数-1">约数个数函数</h3><p><imgsrc="https://cdn-us.imgs.moe/2023/08/11/64d5f860541b2.png" srcset="/img/loading.gif" lazyload /></p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;本文主要放知识点。&lt;/p&gt;
&lt;h2 id=&quot;质数筛&quot;&gt;质数筛&lt;/h2&gt;
&lt;h3 id=&quot;埃氏筛模板&quot;&gt;埃氏筛模板&lt;/h3&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;prime&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n;++i) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!v[i]) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=i*i;j&amp;lt;=n;j+=i) v[j]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;hljs-comment&quot;&gt;// 优化：从i*i开始枚举&lt;/span&gt;
	&amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;线性筛模板&quot;&gt;线性筛模板&lt;/h3&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ora&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n;++i) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!v[i]) p[++cnt]=i;
		&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;j&amp;lt;=cnt&amp;amp;&amp;amp;i*p[j]&amp;lt;=n;++j) &amp;#123;
			v[i*p[j]]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
            &lt;span class=&quot;hljs-comment&quot;&gt;// p[j]是i*p[j]的最小质因子&lt;/span&gt;
			&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i%p[j]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;
		&amp;#125;
	&amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;区间筛&quot;&gt;区间筛&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;求 &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt; 中的所有质数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(a,b &#92;le 10^{12}&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(b-a &#92;le 10^6&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于每个合数 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 存在至少一个
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;le &#92;sqrt{x}&#92;)&lt;/span&gt; 的质因数，所以先筛出
&lt;span class=&quot;math inline&quot;&gt;&#92;([2,&#92;sqrt{b}]&#92;)&lt;/span&gt;
中的质数，用这些质数再筛掉 &lt;span class=&quot;math inline&quot;&gt;&#92;([a,b]&#92;)&lt;/span&gt;
中的合数。&lt;/p&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="数论" scheme="https://yozora0908.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>luogu3940 分组 题解</title>
    <link href="https://yozora0908.github.io/2023/lg3940-solution/"/>
    <id>https://yozora0908.github.io/2023/lg3940-solution/</id>
    <published>2023-08-10T01:36:18.000Z</published>
    <updated>2023-08-10T01:52:17.387Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>对于 <span class="math inline">\(K=1\)</span>的情况，每组里面都不能有冲突，所以从后往前尽可能划分，容易证明这样做是对的。</p><p>如何判断冲突？注意到值域不大，可以开一个桶，枚举一个完全平方数 <spanclass="math inline">\(k^2\)</span>，判断 <spanclass="math inline">\(k^2-x\)</span> 是否出现过即可。完全平方数的个数是<span class="math inline">\(O(\sqrt{n})\)</span> 的，所以复杂度为 <spanclass="math inline">\(O(n \sqrt{n})\)</span>。</p><p>对于 <span class="math inline">\(K=2\)</span>的情况，如果我们把有冲突的点连边，那么每一组的点都构成一张二分图。</p><p>可以像经典题「关押罪犯」中一样，用拆点并查集维护。</p><p>记 <span class="math inline">\(v(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 是否出现过，<spanclass="math inline">\(v_2(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 是否出现了超过 <spanclass="math inline">\(1\)</span> 次并且 <spanclass="math inline">\(2x\)</span> 是完全平方数。</p><p>如果 <span class="math inline">\(x\)</span> 没有出现过，<spanclass="math inline">\(v(k^2-x)=1\)</span>，分两种情况。</p><ol type="1"><li>如果 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(k^2-x\)</span>被合并进了同一个集合，并查集产生冲突，那么 <spanclass="math inline">\(x\)</span> 不能加入当前组。</li><li><span class="math inline">\(v_2(k^2-x)=1\)</span>，那么 <spanclass="math inline">\(x\)</span> 不能加入当前组。</li></ol><p>如果 <span class="math inline">\(x\)</span> 出现过，分两种情况。</p><ol type="1"><li>如果 <span class="math inline">\(2x\)</span> 不是完全平方数，由于<span class="math inline">\(x\)</span>与组内其他点能构成二分图，所以加入 <spanclass="math inline">\(x\)</span> 依然能。</li><li>如果 <span class="math inline">\(2x\)</span> 是完全平方数。令 <spanclass="math inline">\(v_2(x)=1\)</span>。枚举 <spanclass="math inline">\(k^2\)</span>，如果 <spanclass="math inline">\(v(k^2-x)=1\)</span> 并且 <spanclass="math inline">\(k^2\neq2x\)</span>，那么说明会产生冲突，<spanclass="math inline">\(x\)</span> 不能加入。注意如果一开始 <spanclass="math inline">\(v_2(x)\)</span> 的值就已经是 <spanclass="math inline">\(1\)</span>，就直接判掉。</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3940 分组</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3940</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">131075</span>, lim=<span class="hljs-number">131072</span>;<span class="hljs-type">int</span> n, m, K, a[N], ans[N], sqr[<span class="hljs-number">2</span>*N];<span class="hljs-type">bool</span> v[N], v2[N];<span class="hljs-keyword">namespace</span> sub1 &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=n;i;) &#123;<span class="hljs-keyword">for</span>(;j;--j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*k-a[j]&lt;N;++k) <span class="hljs-keyword">if</span>(a[j]&lt;=k*k) &#123;<span class="hljs-keyword">if</span>(v[k*k-a[j]]) <span class="hljs-keyword">goto</span> out;&#125;v[a[j]]=<span class="hljs-number">1</span>;&#125;out:;<span class="hljs-keyword">if</span>(!j) <span class="hljs-keyword">break</span>;ans[++m]=j;<span class="hljs-keyword">for</span>(;i&gt;j;--i) v[a[i]]=<span class="hljs-number">0</span>;&#125;&#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> f[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*lim;++i) f[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) f[x]=y;&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> x1=dsu.<span class="hljs-built_in">get</span>(x), x2=dsu.<span class="hljs-built_in">get</span>(x+lim);<span class="hljs-type">int</span> y1=dsu.<span class="hljs-built_in">get</span>(y), y2=dsu.<span class="hljs-built_in">get</span>(y+lim);<span class="hljs-keyword">if</span>(x1==y1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x2==y2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;dsu.<span class="hljs-built_in">merge</span>(x1,y2);dsu.<span class="hljs-built_in">merge</span>(x2,y1);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">namespace</span> sub2 &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;dsu.<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=n;i;) &#123;<span class="hljs-keyword">for</span>(;j;--j) &#123;<span class="hljs-keyword">if</span>(!v[a[j]]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*k-a[j]&lt;N;++k) <span class="hljs-keyword">if</span>(a[j]&lt;=k*k) &#123;<span class="hljs-keyword">if</span>(v[k*k-a[j]]) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(a[j],k*k-a[j])||v2[k*k-a[j]]) <span class="hljs-keyword">goto</span> out;&#125;&#125;v[a[j]]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(sqr[<span class="hljs-number">2</span>*a[j]]) &#123;<span class="hljs-keyword">if</span>(v2[a[j]]) <span class="hljs-keyword">goto</span> out;v2[a[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*k-a[j]&lt;N;++k) <span class="hljs-keyword">if</span>(a[j]&lt;=k*k) &#123;<span class="hljs-keyword">if</span>(v[k*k-a[j]]&amp;&amp;k*k!=<span class="hljs-number">2</span>*a[j])  <span class="hljs-keyword">goto</span> out;&#125;&#125;&#125;&#125;out:;<span class="hljs-keyword">if</span>(!j) <span class="hljs-keyword">break</span>;ans[++m]=j;<span class="hljs-keyword">for</span>(;i&gt;j;--i) v[a[i]]=v2[a[i]]=<span class="hljs-number">0</span>, dsu.f[a[i]]=a[i], dsu.f[a[i]+lim]=a[i]+lim;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">512</span>;++i) sqr[i*i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(K==<span class="hljs-number">1</span>) sub1::<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">else</span> sub2::<span class="hljs-built_in">solve</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,m+<span class="hljs-number">1</span>);<span class="hljs-built_in">per</span>(i,m,<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(K=1&#92;)&lt;/span&gt;
的情况，每组里面都不能有冲突，所以从后往前尽可能划分，容易证明这样做是对的。&lt;/p&gt;
&lt;p&gt;如何判断冲突？注意到值域不大，可以开一个桶，枚举一个完全平方数 &lt;span class=&quot;math inline&quot;&gt;&#92;(k^2&#92;)&lt;/span&gt;，判断 &lt;span class=&quot;math inline&quot;&gt;&#92;(k^2-x&#92;)&lt;/span&gt; 是否出现过即可。完全平方数的个数是
&lt;span class=&quot;math inline&quot;&gt;&#92;(O(&#92;sqrt{n})&#92;)&lt;/span&gt; 的，所以复杂度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(n &#92;sqrt{n})&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(K=2&#92;)&lt;/span&gt;
的情况，如果我们把有冲突的点连边，那么每一组的点都构成一张二分图。&lt;/p&gt;
&lt;p&gt;可以像经典题「关押罪犯」中一样，用拆点并查集维护。&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&quot;math inline&quot;&gt;&#92;(v(x)&#92;)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 是否出现过，&lt;span class=&quot;math inline&quot;&gt;&#92;(v_2(x)&#92;)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 是否出现了超过 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 次并且 &lt;span class=&quot;math inline&quot;&gt;&#92;(2x&#92;)&lt;/span&gt; 是完全平方数。&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 没有出现过，&lt;span class=&quot;math inline&quot;&gt;&#92;(v(k^2-x)=1&#92;)&lt;/span&gt;，分两种情况。&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(k^2-x&#92;)&lt;/span&gt;
被合并进了同一个集合，并查集产生冲突，那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 不能加入当前组。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(v_2(k^2-x)=1&#92;)&lt;/span&gt;，那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 不能加入当前组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 出现过，分两种情况。&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(2x&#92;)&lt;/span&gt; 不是完全平方数，由于
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
与组内其他点能构成二分图，所以加入 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 依然能。&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(2x&#92;)&lt;/span&gt; 是完全平方数。令 &lt;span class=&quot;math inline&quot;&gt;&#92;(v_2(x)=1&#92;)&lt;/span&gt;。枚举 &lt;span class=&quot;math inline&quot;&gt;&#92;(k^2&#92;)&lt;/span&gt;，如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(v(k^2-x)=1&#92;)&lt;/span&gt; 并且 &lt;span class=&quot;math inline&quot;&gt;&#92;(k^2&#92;neq2x&#92;)&lt;/span&gt;，那么说明会产生冲突，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 不能加入。注意如果一开始 &lt;span class=&quot;math inline&quot;&gt;&#92;(v_2(x)&#92;)&lt;/span&gt; 的值就已经是 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，就直接判掉。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="贪心" scheme="https://yozora0908.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="并查集" scheme="https://yozora0908.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="二分图" scheme="https://yozora0908.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#13 树形DP（2）</title>
    <link href="https://yozora0908.github.io/2023/noip-record-13/"/>
    <id>https://yozora0908.github.io/2023/noip-record-13/</id>
    <published>2023-08-09T09:50:21.000Z</published>
    <updated>2023-08-12T13:38:26.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="arc101e-ribbons-on-tree">[ARC101E] Ribbons on Tree</h3><p>对于以 <span class="math inline">\(x\)</span> 为根的子树，如果 <spanclass="math inline">\((x,fa_x)\)</span>的边没有被覆盖，那么说明子树内没有任何一个点与子树外的点匹配。</p><p>把这些没有被覆盖的边看作特殊边，那么整棵树就被若干特殊边划分成了若干连通块。我们要求的是不含任何特殊边的匹配方案。</p><p>考虑容斥。钦定一个边集 <span class="math inline">\(S\)</span>，表示<span class="math inline">\(S\)</span>内的边一定是特殊边。根据<strong>子集反演</strong>，容斥系数为 <spanclass="math inline">\((-1)^{|S|}\)</span>。</p><p>用树形背包维护连通块，设 <spanclass="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，其中特殊边集大小为 <spanclass="math inline">\(j\)</span> 的方案数，容斥系数就是 <spanclass="math inline">\((-1)^j\)</span>。转移就是讨论 <spanclass="math inline">\((x,y)\)</span>这条边要不要加入特殊边集。如果加入，那么以 <spanclass="math inline">\(y\)</span>为根的连通块闭合，在这里可以计算任意两两匹配的方案数。</p><p>然而这样复杂度过高，瓶颈在于 <span class="math inline">\(j\)</span>这一维。一种解决方案只记录 <span class="math inline">\(j\)</span>的奇偶性，不过更好的做法则是把这个容斥系数放进 DP 值里面。具体地，对<span class="math inline">\(j\)</span> 这一维做前缀和，设 <spanclass="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>的方案数。每有一个连通块闭合，就有一条边没有被覆盖，要多乘一个 <spanclass="math inline">\(-1\)</span>，对应到实现就是这部分的方案做减法。</p><p><span class="math inline">\(2n\)</span> 个点两两匹配的方案是 <spanclass="math display">\[\frac{\binom{2n}{n}n!}{2^n}\]</span></p><p>或者说 <span class="math display">\[h_{2n} = h_{2n-2} \times (2n-1)\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, f[N][N], g[N], sz[N], h[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) &#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[y];++j) &#123;(g[i+j]+=f[x][i]*f[y][j]%mod)%=mod;(g[i]-=f[x][i]*f[y][j]%mod*h[j]%mod-mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;h[<span class="hljs-number">2</span>]=h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) h[i]=h[i<span class="hljs-number">-2</span>]*(i<span class="hljs-number">-1</span>)%mod;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) (ans+=f[<span class="hljs-number">1</span>][i]*h[i]%mod)%=mod;    <span class="hljs-comment">// 闭合最后一个连通块</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf-gym104160-e.-graph-completing">CF Gym104160 E. GraphCompleting</h3><p>最终的图是一张边双连通图，也就是不存在割边。</p><p>先把边双缩了，内部点随便连。</p><p>剩下的每一条树边都是割边。考虑容斥，设 <spanclass="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，子树中有 <spanclass="math inline">\(j\)</span> 条割边的方案。</p><p>与上一题相同，转移还是讨论边 <spanclass="math inline">\((x,y)\)</span>的情况。不同的是在连通块闭合时不太容易计算方案数，所以要在 <spanclass="math inline">\((x,y)\)</span> 加入以 <spanclass="math inline">\(x\)</span> 所在连通块时统计。具体地，选取 <spanclass="math inline">\((x,y)\)</span> 为基准点，设 <spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(j\)</span>，<span class="math inline">\(y\)</span>所在连通块大小为 <span class="math inline">\(k\)</span>，那么总共有<span class="math inline">\(j \times k -1\)</span> 条可以连的边能覆盖<span class="math inline">\((x,y)\)</span>，方案数 <spanclass="math inline">\(2^{\max(j \times k-1,0)}\)</span>。注意除了钦定的边集之外，并不需要保证连通块也是边双。</p><p>然后就是把容斥系数塞进 DP 值去。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: E. Graph Completing</span><span class="hljs-comment">// Contest: Codeforces - The 2022 ICPC Asia Shenyang Regional Contest (The 1st Universal Cup, Stage 1: Shenyang)</span><span class="hljs-comment">// URL: https://codeforc.es/gym/104160/problem/E</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-27 07:14:30</span><span class="hljs-comment">// Memory Limit: 512 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, M=<span class="hljs-number">2e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, num, dfn[N], low[N], sz[N], pw[N*N&gt;&gt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> f[N][N], g[N];<span class="hljs-type">int</span> tp, st[N];<span class="hljs-type">int</span> dcc, bel[N], ecnt[N];<span class="hljs-type">bool</span> v[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">G</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[M], nxt[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;&#125; G, T;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> lst)</span> </span>&#123;dfn[x]=low[x]=++num, st[++tp]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i];<span class="hljs-keyword">if</span>(i!=(lst^<span class="hljs-number">1</span>)) &#123;<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y,i);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>; ++dcc;<span class="hljs-keyword">do</span> y=st[tp--], ++sz[dcc], bel[y]=dcc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">suodian</span><span class="hljs-params">()</span> </span>&#123;T.tot=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=G.tot;++i) &#123;<span class="hljs-type">int</span> x=G.to[i^<span class="hljs-number">1</span>], y=G.to[i];<span class="hljs-keyword">if</span>(bel[x]==bel[y]) ++ecnt[bel[x]];<span class="hljs-keyword">if</span>(bel[x]==bel[y]||v[bel[x]][bel[y]]) <span class="hljs-keyword">continue</span>;v[bel[x]][bel[y]]=v[bel[y]][bel[x]]=<span class="hljs-number">1</span>;T.<span class="hljs-built_in">add</span>(bel[x],bel[y]), T.<span class="hljs-built_in">add</span>(bel[y],bel[x]);&#125;pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;++i) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][sz[x]]=pw[sz[x]*(sz[x]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-(ecnt[x]&gt;&gt;<span class="hljs-number">1</span>)];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=T.h[x];i;i=T.nxt[i]) &#123;<span class="hljs-type">int</span> y=T.to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j) &#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=sz[y];++k) &#123;(g[j+k]+=f[x][j]*f[y][k]%mod*pw[<span class="hljs-built_in">max</span>(j*k<span class="hljs-number">-1</span>,<span class="hljs-number">0ll</span>)]%mod)%=mod;(g[j]-=f[x][j]*f[y][k]%mod-mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j) f[x][j]=g[j], g[j]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();G.tot=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();G.<span class="hljs-built_in">add</span>(x,y), G.<span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">suodian</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) (ans+=f[<span class="hljs-number">1</span>][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf-gym103427-l.-perfect-matchings">CF Gym103427 L. PerfectMatchings</h3><p>怎么又是 ICPC shenyang。</p><p>转化一下题意，<span class="math inline">\(2n\)</span>个点完美匹配就是两两匹配，但是有 <spanclass="math inline">\(2n-1\)</span>条构成一棵树的边不允许使用。不妨只考虑树边。</p><p>和第一题很像，但也有不同，所以先子集反演一下。设 <spanclass="math inline">\(f(S)\)</span> 为至少使用了边集 <spanclass="math inline">\(S\)</span> 内的边的完美匹配数量，<spanclass="math inline">\(g(S)\)</span> 为恰好使用了边集 <spanclass="math inline">\(S\)</span> 内的边的完美匹配数量。 <spanclass="math display">\[g(\varnothing) = \sum_{S \in U} (-1)^{|S|} f(S)\]</span> 类比第一题，前者是求至少让边集 <spanclass="math inline">\(S\)</span>内的边没有被经过，从而划分成若干连通块，而后者则是至少让边集 <spanclass="math inline">\(S\)</span>的边被经过。对于「不被经过」，可以直接钦定，把匹配操作放到连通块闭合处进行。而对于「经过」操作，则必须通过匹配完成，因此设<span class="math inline">\(f_{x,i,j,0/1}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，匹配了 <spanclass="math inline">\(i\)</span> 对点，经过了<spanclass="math inline">\(j\)</span> 条边，其中 <spanclass="math inline">\(x\)</span> 有没有匹配的方案数。讨论是否匹配 <spanclass="math inline">\((x,y)\)</span> 即可转移。</p><p>依然是对 <span class="math inline">\(j\)</span>这一维做前缀和，在匹配 <span class="math inline">\((x,y)\)</span>处带上系数即可。</p><p> </p><p>有人可能会说，如果设 <span class="math inline">\(f(S)\)</span>至少为没有经过 <span class="math inline">\(S\)</span> 内的边，<spanclass="math inline">\(g(S)\)</span> 为恰好没有使用 <spanclass="math inline">\(S\)</span>内的树边，那么不就转化成了第一题的形式了吗？不能。因为本题中一条树边<span class="math inline">\((x,y)\)</span> 没有被使用的充要条件是 <spanclass="math inline">\(x\)</span> 没有匹配 <spanclass="math inline">\(y\)</span>，而不是第一题中的子树内没有和外部匹配的点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: L. Perfect Matchings</span><span class="hljs-comment">// Contest: Codeforces - The 2021 ICPC Asia Shenyang Regional Contest</span><span class="hljs-comment">// URL: https://codeforces.com/gym/103427/problem/L</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-28 09:17:48</span><span class="hljs-comment">// Memory Limit: 512 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4005</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, f[N][N/<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], g[N/<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], sz[N], h[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=sz[x]/<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[y]/<span class="hljs-number">2</span>;++j) &#123;(g[i+j][<span class="hljs-number">0</span>]+=f[x][i][<span class="hljs-number">0</span>]*(f[y][j][<span class="hljs-number">0</span>]+f[y][j][<span class="hljs-number">1</span>])%mod)%=mod;(g[i+j][<span class="hljs-number">1</span>]+=f[x][i][<span class="hljs-number">1</span>]*(f[y][j][<span class="hljs-number">0</span>]+f[y][j][<span class="hljs-number">1</span>])%mod)%=mod;(g[i+j+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-=f[x][i][<span class="hljs-number">0</span>]*f[y][j][<span class="hljs-number">0</span>]%mod-mod)%=mod;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=sz[x]/<span class="hljs-number">2</span>;++i) f[x][i][<span class="hljs-number">0</span>]=g[i][<span class="hljs-number">0</span>], f[x][i][<span class="hljs-number">1</span>]=g[i][<span class="hljs-number">1</span>], g[i][<span class="hljs-number">0</span>]=g[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>*n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2</span>*n;i+=<span class="hljs-number">2</span>) h[i]=h[i<span class="hljs-number">-2</span>]*(i<span class="hljs-number">-1</span>)%mod;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (ans+=(f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]+f[<span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>])%mod*h[<span class="hljs-number">2</span>*(n-i)]%mod)%=mod;    <span class="hljs-comment">// 还要乘上其他点任意匹配的方案数，才是子集反演中的f(S)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4099-heoi2013-sao">luogu4099 [HEOI2013] SAO</h3><p>既有外向边，也有内向边，不是很好做。但是只有一种边就很容易了。</p><p>考虑容斥。钦定一个内向边集不满足，剩下的是否满足均可。</p><p><del>其实钦定内向外向都一样</del>。</p><p>设 <span class="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，其中 <spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，钦定了 <spanclass="math inline">\(j\)</span> 条内向边不满足的方案数，同样把 <spanclass="math inline">\(j\)</span> 压了。</p><p>在内向边 <span class="math inline">\((x,y)\)</span>加入连通块时带上容斥系数，统计这条边作为外向边的贡献即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P4099 [HEOI2013] SAO</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P4099</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-28 07:50:08</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, T, sz[N], C[N][N], f[N][N], g[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> fac[N], inv[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[x];++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) &#123;(g[j+k]+=f[x][j]*f[y][k]%mod*C[sz[x]+sz[y]][sz[x]]%mod)%=mod;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[x];++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) &#123;<span class="hljs-type">int</span> d=f[x][j]*f[y][k]%mod*C[sz[x]+sz[y]][sz[x]]%mod;(g[j+k]-=d-mod)%=mod;(g[j]+=d)%=mod;&#125;&#125;sz[x]+=sz[y];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) (f[x][i]*=fac[i<span class="hljs-number">-1</span>]*inv[i]%mod)%=mod;    <span class="hljs-comment">// x必须放在最后</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=sz[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) f[i][j]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;<span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-type">int</span> y=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&lt;&#x27;</span>) <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>); &#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=f[<span class="hljs-number">1</span>][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>) &#123;fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;C[i][<span class="hljs-number">0</span>]=C[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;inv[<span class="hljs-number">1000</span>]=<span class="hljs-built_in">fp</span>(fac[<span class="hljs-number">1000</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,<span class="hljs-number">999</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="loj2117.-hnoi2015实验比较">LOJ#2117. 「HNOI2015」实验比较</h3><p>能发现相等关系具有反身性和传递性，并且这些点必然放到质量序列的连续一段，所以可以先用并查集把相等的图片合并了。</p><p>然后 <span class="math inline">\(x&lt;y\)</span> 说明 <spanclass="math inline">\(x\)</span> 必须放到 <spanclass="math inline">\(y\)</span> 前面，连边 <spanclass="math inline">\((x \rightarrowy)\)</span>，约等于是内向树拓扑序计数，唯一的区别在于没有祖孙关系的两个节点可以通过相等链接。</p><p>为了解决这个问题，我们用状态刻画它。</p><p>设 <span class="math inline">\(f(x,i)\)</span> 表示以 <spanclass="math inline">\(x\)</span> 为根的子树形成的质量序列，其中存在<span class="math inline">\(i-1\)</span> 个小于号把序列划分成 <spanclass="math inline">\(i\)</span> 个相等段的方案数。</p><p>转移合并子树。 <span class="math display">\[g(i) = \sum_{j \le i \wedge  i \le j+k  } f(x,j) f(y,k)\binom{i-1}{j-1}\binom{j-1}{k-(i-j)}\]</span> 下面解释上式的含义。<span class="math inline">\(x\)</span>肯定要放到第一个位置单独一段，所以其实是 <spanclass="math inline">\(j-1\)</span> 段和 <spanclass="math inline">\(k\)</span> 段要放到 <spanclass="math inline">\(i-1\)</span> 段中。第一个二项式系数是给 <spanclass="math inline">\(f(x,j)\)</span> 重标号，然后 <spanclass="math inline">\(f(y,k)\)</span> 中的 <spanclass="math inline">\(k\)</span> 段去补剩下的 <spanclass="math inline">\((i-j)\)</span> 段，最后剩下的 <spanclass="math inline">\(k-(i-j)\)</span> 段则合并进 <spanclass="math inline">\(j-1\)</span>段中。每个段只合并一次，防止重复计数。</p><p>本题还有 <span class="math inline">\(O(n^2)\)</span>做法，先鸽着。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3240 [HNOI2015]实验比较</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3240</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-26 19:56:23</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, in[N], sz[N], f[N][N], c[N][N], g[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];vector&lt;PII &gt; v;<span class="hljs-type">char</span> ch[<span class="hljs-number">3</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> f[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) f[y]=x;&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">// printf(&quot;x=%lld\n&quot;,x);</span>f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs</span>(y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x]+sz[y];++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[x];++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) &#123;<span class="hljs-keyword">if</span>(k+j&lt;i||j&gt;i) <span class="hljs-keyword">continue</span>;(g[i]+=f[x][j]*f[y][k]%mod*c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]%mod*c[j<span class="hljs-number">-1</span>][k-(i-j)]%mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) dsu.f[i]=i;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x, y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%s%lld&quot;</span>,&amp;x,ch,&amp;y);<span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;=&#x27;</span>) dsu.<span class="hljs-built_in">merge</span>(x,y);<span class="hljs-keyword">else</span> v.<span class="hljs-built_in">pb</span>(&#123;x,y&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v) &#123;<span class="hljs-type">int</span> x=dsu.<span class="hljs-built_in">get</span>(t.fi), y=dsu.<span class="hljs-built_in">get</span>(t.se);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">continue</span>;++in[y];p[x].<span class="hljs-built_in">pb</span>(y);&#125;++n;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(dsu.f[i]==i&amp;&amp;!in[i]) p[n].<span class="hljs-built_in">pb</span>(i), fg=<span class="hljs-number">1</span>;<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">if</span>(!fg) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>), <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs</span>(n);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=f[n][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h3 id=&quot;arc101e-ribbons-on-tree&quot;&gt;[ARC101E] Ribbons on Tree&lt;/h3&gt;
&lt;p&gt;对于以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树，如果 &lt;span class=&quot;math inline&quot;&gt;&#92;((x,fa_x)&#92;)&lt;/span&gt;
的边没有被覆盖，那么说明子树内没有任何一个点与子树外的点匹配。&lt;/p&gt;
&lt;p&gt;把这些没有被覆盖的边看作特殊边，那么整棵树就被若干特殊边划分成了若干连通块。我们要求的是不含任何特殊边的匹配方案。&lt;/p&gt;
&lt;p&gt;考虑容斥。钦定一个边集 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;，表示
&lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;
内的边一定是特殊边。根据&lt;strong&gt;子集反演&lt;/strong&gt;，容斥系数为 &lt;span class=&quot;math inline&quot;&gt;&#92;((-1)^{|S|}&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;用树形背包维护连通块，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f_{x,i,j}&#92;)&lt;/span&gt; 为以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树中，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 所在连通块大小为 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;，其中特殊边集大小为 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt; 的方案数，容斥系数就是 &lt;span class=&quot;math inline&quot;&gt;&#92;((-1)^j&#92;)&lt;/span&gt;。转移就是讨论 &lt;span class=&quot;math inline&quot;&gt;&#92;((x,y)&#92;)&lt;/span&gt;
这条边要不要加入特殊边集。如果加入，那么以 &lt;span class=&quot;math inline&quot;&gt;&#92;(y&#92;)&lt;/span&gt;
为根的连通块闭合，在这里可以计算任意两两匹配的方案数。&lt;/p&gt;
&lt;p&gt;然而这样复杂度过高，瓶颈在于 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt;
这一维。一种解决方案只记录 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt;
的奇偶性，不过更好的做法则是把这个容斥系数放进 DP 值里面。具体地，对
&lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt; 这一维做前缀和，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f_{x,i}&#92;)&lt;/span&gt; 为以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 所在连通块大小为 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;
的方案数。每有一个连通块闭合，就有一条边没有被覆盖，要多乘一个 &lt;span class=&quot;math inline&quot;&gt;&#92;(-1&#92;)&lt;/span&gt;，对应到实现就是这部分的方案做减法。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(2n&#92;)&lt;/span&gt; 个点两两匹配的方案是 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;frac{&#92;binom{2n}{n}n!}{2^n}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或者说 &lt;span class=&quot;math display&quot;&gt;&#92;[
h_{2n} = h_{2n-2} &#92;times (2n-1)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; int long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; uint unsigned long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PII pair&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;int,int&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MP make_pair&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; fi first&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; se second&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; pb push_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; eb emplace_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SET(a,b) memset(a,b,sizeof(a))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CPY(a,b) memcpy(a,b,sizeof(b))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; rep(i,j,k) for(int i=(j);i&amp;lt;=(k);++i)&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; per(i,j,k) for(int i=(j);i&amp;gt;=(k);--i)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, f=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(c==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;) f=&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) a=a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+c-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a*f;
&amp;#125;
&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N=&lt;span class=&quot;hljs-number&quot;&gt;5005&lt;/span&gt;, mod=&lt;span class=&quot;hljs-number&quot;&gt;1e9&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, f[N][N], g[N], sz[N], h[N];
vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; p[N];
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; fa)&lt;/span&gt; &lt;/span&gt;&amp;#123;
	f[x][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]=sz[x]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; y:p[x]) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(y!=fa) &amp;#123;
		&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(y,x);
		&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=sz[x];++i) &amp;#123;
			&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; t=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
			&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;j&amp;lt;=sz[y];++j) &amp;#123;
				(g[i+j]+=f[x][i]*f[y][j]%mod)%=mod;
				(g[i]-=f[x][i]*f[y][j]%mod*h[j]%mod-mod)%=mod;
			&amp;#125;
		&amp;#125;
		sz[x]+=sz[y];
		&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=sz[x];++i) f[x][i]=g[i], g[i]=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&amp;#125;
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	n=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,n) &amp;#123;
		&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), y=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
		p[x].&lt;span class=&quot;hljs-built_in&quot;&gt;pb&lt;/span&gt;(y), p[y].&lt;span class=&quot;hljs-built_in&quot;&gt;pb&lt;/span&gt;(x);
	&amp;#125;
	h[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]=h[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;i&amp;lt;=n;i+=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) h[i]=h[i&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;]*(i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)%mod;
	&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ans=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n;i+=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) (ans+=f[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;][i]*h[i]%mod)%=mod;
    &lt;span class=&quot;hljs-comment&quot;&gt;// 闭合最后一个连通块&lt;/span&gt;
	&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%lld&#92;n&amp;quot;&lt;/span&gt;,ans);
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="计数" scheme="https://yozora0908.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="组合数学" scheme="https://yozora0908.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥原理" scheme="https://yozora0908.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
    <category term="子集反演" scheme="https://yozora0908.github.io/tags/%E5%AD%90%E9%9B%86%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#12 并查集</title>
    <link href="https://yozora0908.github.io/2023/noip-record-12/"/>
    <id>https://yozora0908.github.io/2023/noip-record-12/</id>
    <published>2023-08-04T08:15:17.000Z</published>
    <updated>2023-08-22T22:49:01.787Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>并查集是一个森林，每棵树表示一个集合，并且这个集合根据某种具有传递性的关系构建起来。</p><p>普通并查集关心的信息只有 <span class="math inline">\(x\)</span>所在集合的根，<span class="math inline">\(fa_x\)</span>表示的仅仅是一个传递性关系，即 <span class="math inline">\(fa_x\)</span>与 <span class="math inline">\(x\)</span>所在集合的根相同。从任意节点往上跳，都能找到它所在集合的根。</p><p>使用路径压缩优化，在向上访问节点时，把路径上所有节点的 <spanclass="math inline">\(fa\)</span> 都改为根，那么就能做到单次查询均摊<span class="math inline">\(O(\log_2 n)\)</span>。</p><p>使用按秩合并优化，在合并两个连通块时，将较小的连通块合并到较大的连通块中，这样就能做到单次查询均摊<span class="math inline">\(O(\log_2n)\)</span>。为了避免大量修改，在可持久化并查集中，只使用按秩合并的并查集。</p><p>二者同时使用，单次查询均摊 <span class="math inline">\(O\Big(\alpha(n)\Big)\)</span>。</p><h2 id="维护具有传递性的关系">维护具有传递性的关系</h2><h3 id="cf28b-psort">CF28B pSort</h3><p>如果 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 能交换，<spanclass="math inline">\(b\)</span> 与 <spanclass="math inline">\(c\)</span> 能交换，那么 <spanclass="math inline">\(a,b,c\)</span>三者可以任意交换。这个关系具有传递性，用并查集维护。</p><p>最后一一检查需要交换的位置 <spanclass="math inline">\(p_i\)</span>，如果 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(p_i\)</span> 在同一个集合中，那么就可以交换。</p><h3 id="躲避拥挤">躲避拥挤</h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个景点，<spanclass="math inline">\(m\)</span> 条双向道路。每条道路有一个人气值 <spanclass="math inline">\(d\)</span>，表示这条道路的拥挤程度。小明不会经过那些人气值<span class="math inline">\(\ge x\)</span> 的道路，他想知道有多少对景点<span class="math inline">\((a,b)\)</span> 使得从 <spanclass="math inline">\(a\)</span> 出发可以到达 <spanclass="math inline">\(b\)</span> 景点。你需要处理多次询问，每次询问的<span class="math inline">\(x\)</span> 不同。 <spanclass="math inline">\(n, m, q \le 10^5\)</span>。</p></blockquote><p>把询问离线了，倒序加边，用并查集维护连通块大小。</p><p>如果加入了一条边 <span class="math inline">\((x,y)\)</span>第一次连接了两个连通块 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，那么答案增加 <spanclass="math inline">\(sz_A \times sz_B\)</span>。</p><h3 id="luogu1955-程序自动分析">luogu1955 程序自动分析</h3><p>相等具有传递性，不等不具有传递性。</p><p>并查集维护相等关系，最后 check 不等关系即可。</p><h3 id="uva1316-supermarket">UVA1316 Supermarket</h3><p>贪心。将商品按照价格递减排序，然后对于第 <spanclass="math inline">\(i\)</span> 天，维护最大的 <spanclass="math inline">\(rt(i)\)</span>，满足 <spanclass="math inline">\(rt(i) \le i\)</span> 并且第 <spanclass="math inline">\(rt(i)\)</span> 天空闲，不存在就是 <spanclass="math inline">\(0\)</span>。</p><p>对于一个商品 <span class="math inline">\(i\)</span>，查询 <spanclass="math inline">\(d_i\)</span> 所在集合的根 <spanclass="math inline">\(rt(d_i)\)</span> 是否大于 <spanclass="math inline">\(0\)</span>。如果是，那么就占用这一天，合并 <spanclass="math inline">\(rt(d_i)\)</span> 与 <spanclass="math inline">\(rt(d_i)-1\)</span> 即可。</p><h3 id="luogu2391-白雪皑皑">luogu2391 白雪皑皑</h3><p>倒着做。</p><p>用并查集维护每个点之前第一个没有被染色的点。点 <spanclass="math inline">\(i\)</span> 被染色了之后，就把 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(i-1\)</span> 合并。</p><p>对于一个操作 <span class="math inline">\([l,r]\)</span>，从 <spanclass="math inline">\(r\)</span>开始往前跳，这样每个点只会被染色一次，记录每个点被染的颜色就行。</p><h3 id="luogu6185-noi-online-1-提高组-序列">luogu6185 [NOI Online #1提高组] 序列</h3><p>只讲关于并查集的部分。</p><p>把每个点的点权都搞成 <span class="math inline">\(a_i -b_i\)</span>，问题转化为把所有节点权值都搞成 <spanclass="math inline">\(0\)</span>。</p><p>有两种思路。</p><ol type="1"><li><p>用并查集维护 <span class="math inline">\(1\)</span>操作，因为一个连通块内可以同加减。</p></li><li><p>用并查集维护 <span class="math inline">\(2\)</span>操作，因为一个连通块内可以多次使用，所以能让任意节点加<spanclass="math inline">\(1\)</span>，任意节点减 <spanclass="math inline">\(1\)</span>。</p></li></ol><p>虽然前者也具有传递性，但是对问题却没有帮助。</p><p>而后者隐藏着总和不变的信息——只有总和为 <spanclass="math inline">\(0\)</span> 时才有解。</p><p>同时连通块之间的 <span class="math inline">\(1\)</span>操作，就相当于在二者差不变的情况下任意加减。</p><p> </p><p>另外有时候还会用并查集把具有某些关系的点合并到一个等价类中。</p><h2 id="带权并查集">带权并查集</h2><p>有些时候这个带有传递性的关系需要具体的值来度量。</p><p>让 <span class="math inline">\((x,fa_x)\)</span>带上边权，在路径压缩时对路径上的权值求和，通过满足结合律和传递性的运算，得到<span class="math inline">\(x\)</span> 与根的之间的值。</p><h3 id="luogu1196-noi2002-银河英雄传说">luogu1196 [NOI2002]银河英雄传说</h3><p>用并查集维护第 <span class="math inline">\(i\)</span>个战舰所在列的前一个战舰 <spanclass="math inline">\(fa_i\)</span>，一个集合的根就是最前面的战舰。维护<span class="math inline">\(d_i\)</span> 表示 <spanclass="math inline">\((i,fa_i)\)</span> 的权值。</p><p>在合并 <span class="math inline">\(x,y\)</span> 时更新 <spanclass="math inline">\(d_{rt(x)}\)</span> 需要知道 <spanclass="math inline">\(sz_{rt(y)}\)</span>，还需要维护 <spanclass="math inline">\(sz\)</span>。</p><p>在查询 <span class="math inline">\((x,y)\)</span>时，先执行路径压缩并得到 <spanclass="math inline">\(rt(x),rt(y)\)</span>。如果二者相同，那么 <spanclass="math inline">\(|d_x-d_y|-1\)</span> 就是答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P1196 [NOI2002] 银河英雄传说</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P1196</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 128 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">30005</span>;<span class="hljs-type">int</span> T;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N], d[N], sz[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">30000</span>) fa[i]=i, sz[i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==fa[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-type">int</span> rt=<span class="hljs-built_in">get</span>(fa[x]);d[x]+=d[fa[x]];<span class="hljs-keyword">return</span> fa[x]=rt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);fa[x]=y, d[x]=sz[y];sz[y]+=sz[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> d[<span class="hljs-built_in">get</span>(x)];&#125;&#125; dsu;<span class="hljs-type">char</span> s[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;dsu.<span class="hljs-built_in">init</span>();T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;M&#x27;</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();dsu.<span class="hljs-built_in">merge</span>(x,y);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> fx=dsu.<span class="hljs-built_in">get</span>(x), fy=dsu.<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(fx!=fy) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">abs</span>(dsu.d[x]-dsu.d[y])<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="数列询问">数列询问</h3><blockquote><p>有一个长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，值域为 <spanclass="math inline">\([0,P-1]\)</span>。给出 <spanclass="math inline">\(m\)</span> 个条件，每个条件形如 <spanclass="math inline">\((l,r,x)\)</span>，表示 <spanclass="math inline">\(\sum_{i=l}^r a_i = x\)</span>。这 <spanclass="math inline">\(m\)</span> 个条件可能存在自相矛盾的情况。求最大的<span class="math inline">\(k\)</span>，满足前 <spanclass="math inline">\(k\)</span> 个条件自洽。</p><p><span class="math inline">\(n,m \le 10^6\)</span>，<spanclass="math inline">\(P \le 10^9\)</span>。</p></blockquote><p>区间和转化为前缀和的差，令 <span class="math inline">\(S_i =\sum_{j=1}^i a_i\)</span>。</p><p>当一个序列的前缀和序列确定时，这个序列也被确定了。</p><p>用带权并查集维护前缀和的每一项的差，<spanclass="math inline">\(d_i\)</span> 表示 <spanclass="math inline">\(S_{fa_i} + d_i =S_i\)</span>。同时每个集合的代表元素就是编号最小的元素。</p><p>加入一条边 <span class="math inline">\((l,r,x)\)</span> 时，对 <spanclass="math inline">\(l-1\)</span> 与 <spanclass="math inline">\(r\)</span>路径压缩，。如果它们在同一个集合内，那么如果 <spanclass="math inline">\(|d_{l-1} - d_r| \neqx\)</span>，那么说明冲突。</p><p>另外还要解决边权值域的问题。</p><p>有一个结论。</p><blockquote><p>如果 <span class="math inline">\([l,r]\)</span> 的权值和合法，<spanclass="math inline">\([l&#39;,r]\)</span> 的权值和合法，且 <spanclass="math inline">\(l&#39; &gt; l\)</span>，那么 <spanclass="math inline">\([l,l&#39;-1]\)</span> 的权值和也合法。</p></blockquote><blockquote><p>证明： <span class="math display">\[sum(l,r) = S_r - S_{l-1}  \le (r-l+1) \times P\]</span> <span class="math display">\[sum(l&#39;,r) = S_r - S_{l&#39;-1} \le (r-l&#39;+1) \times P\]</span></p><p><span class="math display">\[sum(l,l&#39;-1) = S_{l&#39;-1}-S_{l-1} = (l&#39;-l) \times P\]</span></p><p>证毕。</p></blockquote><p>这样我们只要单独<code>check</code>每条边即可。</p><h2 id="拆点并查集">拆点并查集</h2><p>有时候我们想要维护一些关于变量的信息，通过传递性的关系判断是否出现冲突。</p><p>具体地，把每个变量拆成若干个点，表示它的若干种情况。在合并时，如果两个变量的一些有冲突的组合在同一个集合中，那么就表示信息出现了冲突。否则将存在等价关系的集合合并。</p><h3 id="luogu1525-noip2010-提高组-关押罪犯">luogu1525 [NOIP2010 提高组]关押罪犯</h3><p>将关系按照影响力递减排序，然后维护一张二分图，即有冲突的两个犯人放在同一侧。如果加入一个关系后，图不再是二分图，那么这个关系的影响力就是答案。</p><p>具体地，<span class="math inline">\((x,y)\)</span> 拆成 <spanclass="math inline">\((\{x_1,x_2\},\{y_1,y_2\})\)</span>，分别表示二者在左侧还是右侧。</p><p><span class="math inline">\(x_1\)</span> 等价于 <spanclass="math inline">\(y_2\)</span>，<spanclass="math inline">\(x_2\)</span> 等价于 <spanclass="math inline">\(y_1\)</span>。如果 <spanclass="math inline">\(x_1\)</span> 与 <spanclass="math inline">\(y_1\)</span> 或者 <spanclass="math inline">\(x_2\)</span> 与 <spanclass="math inline">\(y_2\)</span> 在同一个集合，那么产生冲突。</p><h3 id="luogu3940-分组">luogu3940 分组</h3><p><ahref="https://yozora0908.github.io/2023/lg3940-solution">link</a></p><h3 id="luogu2024-noi2001-食物链">luogu2024 [NOI2001] 食物链</h3><p>一个点拆三个点，分别代表同类，捕食，被捕食。</p><p>任何一种关系，都能得到两个点之间三种情况的等价关系，不再展开。</p><h3 id="cf1615d-xor-mas-tree">CF1615D X(or)-mas Tree</h3><p>设 <span class="math inline">\(d_x\)</span> 为根到 <spanclass="math inline">\(x\)</span> 路径上边权异或和的 <spanclass="math inline">\(\operatorname{popcount}\)</span>的奇偶性，那么一个条件 <span class="math inline">\((x,y,z)\)</span>等价于 <span class="math inline">\(d_x\)</span> 是否与 <spanclass="math inline">\(d_y\)</span>相等。把每个点拆成奇偶两个，拆点并查集维护即可。</p><p>如何构造？能发现边权值只需要 <span class="math inline">\(0\)</span>和 <span class="math inline">\(1\)</span> 来调整奇偶。</p><p>这样我们根据 <span class="math inline">\(d_x\)</span> 与 <spanclass="math inline">\(d_y\)</span> 是否相等来确定 <spanclass="math inline">\((x,y)\)</span> 放 <spanclass="math inline">\(0\)</span> 还是 <spanclass="math inline">\(1\)</span>。</p><p>当然这题也可以用带权并查集来做，只不过比较胃疼。</p><h3 id="cf1290c-prefix-enlightenment">CF1290C Prefix Enlightenment</h3><p>任意三个子集的交集为空，说明任意下标至多存在于 <spanclass="math inline">\(2\)</span> 个子集中。</p><p>对于每个下标，求出包含它的子集。</p><ol type="1"><li><p>如果有两个，那么根据当前下标对应元素的值，可以知道它们是只能操作其中一个还是必须同时操作。</p></li><li><p>如果只有一个，那么可以知道它必须被操作或者必须不被操作。</p></li></ol><p>注意到一个子集需要操作，可能使得很多集合也被操作，且具有传递性，代价也有可加性。</p><p>我们把每个元素拆成操作和不操作两个点，一个连通块里的点所代表的信息必须被同时执行，代价就是点权和，然后让操作点的初始点权为<span class="math inline">\(1\)</span>。</p><p>对于第一种情况，我们将对应点合并，合并时累加点权。对于第二种，建一个虚点，从不需要执行的那种操纵往虚点连边，虚点权值为正无穷，表示必须不被选择。</p><p>从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 扫一遍，每次对新加入的点求贡献。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: C. Prefix Enlightenment</span><span class="hljs-comment">// Contest: Codeforces - Codeforces Round 616 (Div. 1)</span><span class="hljs-comment">// URL: https://codeforces.com/problemset/problem/1290/C</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k;<span class="hljs-type">char</span> s[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[<span class="hljs-number">2</span>*N], w[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*k) fa[i]=i;<span class="hljs-built_in">rep</span>(i,k+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*k) w[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// [1,k]对应不操作点</span>        <span class="hljs-comment">// [k+1,2*k]对应操作点</span>        <span class="hljs-comment">// 0是虚点</span>w[<span class="hljs-number">0</span>]=<span class="hljs-number">1e9</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y, w[y]+=w[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(w[<span class="hljs-built_in">get</span>(x)],w[<span class="hljs-built_in">get</span>(x+k)]);        <span class="hljs-comment">// 操作或不操作取较小值</span>&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(cnt--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(i);&#125;&#125;dsu.<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(p[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> x=p[i][<span class="hljs-number">0</span>];ans-=dsu.<span class="hljs-built_in">getmin</span>(x);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) dsu.<span class="hljs-built_in">merge</span>(x+k,<span class="hljs-number">0</span>);<span class="hljs-keyword">else</span> dsu.<span class="hljs-built_in">merge</span>(x,<span class="hljs-number">0</span>);ans+=dsu.<span class="hljs-built_in">getmin</span>(x);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">2</span>)&#123;<span class="hljs-type">int</span> x=p[i][<span class="hljs-number">0</span>], y=p[i][<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(x)!=dsu.<span class="hljs-built_in">get</span>(y)&amp;&amp;dsu.<span class="hljs-built_in">get</span>(x)!=dsu.<span class="hljs-built_in">get</span>(y+k)) &#123;ans-=dsu.<span class="hljs-built_in">getmin</span>(x)+dsu.<span class="hljs-built_in">getmin</span>(y);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) dsu.<span class="hljs-built_in">merge</span>(x,y), dsu.<span class="hljs-built_in">merge</span>(x+k,y+k);<span class="hljs-keyword">else</span> dsu.<span class="hljs-built_in">merge</span>(x,y+k), dsu.<span class="hljs-built_in">merge</span>(x+k,y);ans+=dsu.<span class="hljs-built_in">getmin</span>(x);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="其他应用">其他应用</h2><h3 id="luogu3295-scoi2016-萌萌哒">luogu3295 [SCOI2016] 萌萌哒</h3><p>考虑一个暴力。对于每个限制，用并查集合并对应点，最后看对每一个连通块集体赋值求方案数。</p><p>考虑优化。我们可以用倍增的思路，开若干个并查集，第 <spanclass="math inline">\(k\)</span> 个并查集合并从两个点开始长度为 <spanclass="math inline">\(2^k\)</span> 的一段。对于每个限制，<spanclass="math inline">\(k\)</span> 从大到小尽可能合并一遍。</p><p>最后倒序枚举 <spanclass="math inline">\(k\)</span>，如果当前并查集合并了 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span>，那么就在第 <spanclass="math inline">\(k-1\)</span> 并查集里合并 <spanclass="math inline">\(i,j\)</span> 和 <spanclass="math inline">\(i+2^{k-1},j+2^{k-1}\)</span>。</p><p>最后只考虑 <span class="math inline">\(2^{0}\)</span>对应的并查集就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: #2014. 「SCOI2016」萌萌哒</span><span class="hljs-comment">// Contest: LibreOJ</span><span class="hljs-comment">// URL: https://loj.ac/p/2014</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, lgn;<span class="hljs-type">int</span> f[N][<span class="hljs-number">17</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x][k]? x:f[x][k]=<span class="hljs-built_in">get</span>(f[x][k],k); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> k)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x,k), y=<span class="hljs-built_in">get</span>(y,k);<span class="hljs-keyword">if</span>(x!=y) f[x][k]=y;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();lgn=<span class="hljs-built_in">log2</span>(n);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,lgn) f[i][j]=i;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> l1=<span class="hljs-built_in">read</span>(), r1=<span class="hljs-built_in">read</span>(), l2=<span class="hljs-built_in">read</span>(), r2=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lgn;~i;--i) &#123;<span class="hljs-keyword">if</span>(l1+(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">-1</span>&lt;=r1) &#123;<span class="hljs-built_in">merge</span>(l1,l2,i);l1+=<span class="hljs-number">1</span>&lt;&lt;i, l2+=<span class="hljs-number">1</span>&lt;&lt;i;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=lgn;k;--k) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=<span class="hljs-built_in">get</span>(i,k);<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">merge</span>(i,j,k<span class="hljs-number">-1</span>);<span class="hljs-built_in">merge</span>(i+(<span class="hljs-number">1</span>&lt;&lt;k<span class="hljs-number">-1</span>),j+(<span class="hljs-number">1</span>&lt;&lt;k<span class="hljs-number">-1</span>),k<span class="hljs-number">-1</span>);&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(f[i][<span class="hljs-number">0</span>]==i) &#123;<span class="hljs-keyword">if</span>(ans==<span class="hljs-number">1</span>) (ans*=<span class="hljs-number">9</span>)%=mod;<span class="hljs-keyword">else</span> (ans*=<span class="hljs-number">10</span>)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf1253f-cheap-robot">CF1253F Cheap Robot</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边的图，<spanclass="math inline">\(q\)</span>次询问两点间最短路径上边权的最大值。</p><p><span class="math inline">\(n \le 10^5\)</span>，<spanclass="math inline">\(m, q \le 3 \times 10^5\)</span>。</p></blockquote><p>离线，把询问挂在两个点上，所有边按照边权递增排序，依次加入。</p><p>如果当前边连接了 <span class="math inline">\((x,y)\)</span>，那么回答二者所在连通块较小的那个连通块里的询问。如果询问中的两个点此时连通，那么当前边的权值就是答案，否则就按秩合并进较大连通块。</p><h3 id="a">A</h3><blockquote><p><span class="math inline">\(n\)</span> 个孤立点，<spanclass="math inline">\(m\)</span> 次加边操作。<spanclass="math inline">\(q\)</span>次询问两个点最早在第几次操作后连通。</p></blockquote><p>OI-wiki 上的做法是建立并查集生成树。如果第 <spanclass="math inline">\(i\)</span>此操作的两个点在不同的树中，那么就连接两个点所在的子树，最终得到的一定是一棵树。此时两个点之间的最大边权就是答案。</p><p>其实用上面那种做法也可以。</p><h3 id="b">B</h3><blockquote><p>给定一颗 <span class="math inline">\(n\)</span> 个点的树，有 <spanclass="math inline">\(m\)</span> 次操作，两种类型。</p><ul><li>加边</li><li>询问两个点之间是否有至少两条不相交路径。</li></ul></blockquote><p>询问转化为两个点是否在一个简单环上。</p><p>加边操作转化为，树上两点之间的路径都被覆盖一次。如果两点树上路径都被覆盖过了，那么就一定在至少一个简单环上。</p><p>给树定根，用并查集维护每个点到根的路径上第一条没有被覆盖的边，然后加边时搞出<spanclass="math inline">\(\operatorname{LCA}\)</span>，暴力跳并查集。查询只需要看两个点到根的路径上第一条没有被覆盖的边的深度是否都大于等于<span class="math inline">\(\operatorname{LCA}\)</span> 即可。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;并查集是一个森林，每棵树表示一个集合，并且这个集合根据某种具有传递性的关系构建起来。&lt;/p&gt;
&lt;p&gt;普通并查集关心的信息只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
所在集合的根，&lt;span class=&quot;math inline&quot;&gt;&#92;(fa_x&#92;)&lt;/span&gt;
表示的仅仅是一个传递性关系，即 &lt;span class=&quot;math inline&quot;&gt;&#92;(fa_x&#92;)&lt;/span&gt;
与 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
所在集合的根相同。从任意节点往上跳，都能找到它所在集合的根。&lt;/p&gt;
&lt;p&gt;使用路径压缩优化，在向上访问节点时，把路径上所有节点的 &lt;span class=&quot;math inline&quot;&gt;&#92;(fa&#92;)&lt;/span&gt; 都改为根，那么就能做到单次查询均摊
&lt;span class=&quot;math inline&quot;&gt;&#92;(O(&#92;log_2 n)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;使用按秩合并优化，在合并两个连通块时，将较小的连通块合并到较大的连通块中，这样就能做到单次查询均摊
&lt;span class=&quot;math inline&quot;&gt;&#92;(O(&#92;log_2
n)&#92;)&lt;/span&gt;。为了避免大量修改，在可持久化并查集中，只使用按秩合并的并查集。&lt;/p&gt;
&lt;p&gt;二者同时使用，单次查询均摊 &lt;span class=&quot;math inline&quot;&gt;&#92;(O&#92;Big(&#92;alpha
(n)&#92;Big)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;维护具有传递性的关系&quot;&gt;维护具有传递性的关系&lt;/h2&gt;
&lt;h3 id=&quot;cf28b-psort&quot;&gt;CF28B pSort&lt;/h3&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(a&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(b&#92;)&lt;/span&gt; 能交换，&lt;span class=&quot;math inline&quot;&gt;&#92;(b&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(c&#92;)&lt;/span&gt; 能交换，那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(a,b,c&#92;)&lt;/span&gt;
三者可以任意交换。这个关系具有传递性，用并查集维护。&lt;/p&gt;
&lt;p&gt;最后一一检查需要交换的位置 &lt;span class=&quot;math inline&quot;&gt;&#92;(p_i&#92;)&lt;/span&gt;，如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(p_i&#92;)&lt;/span&gt; 在同一个集合中，那么就可以交换。&lt;/p&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="树论" scheme="https://yozora0908.github.io/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="倍增" scheme="https://yozora0908.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="并查集" scheme="https://yozora0908.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="二分图" scheme="https://yozora0908.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP Record」#11 最短路和最小生成树</title>
    <link href="https://yozora0908.github.io/2023/noip-record-11/"/>
    <id>https://yozora0908.github.io/2023/noip-record-11/</id>
    <published>2023-08-04T08:14:43.000Z</published>
    <updated>2023-09-05T12:14:16.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>图论这一块内容比较多，而且题目涉及的 Trick 也很多，因此分若干篇。</p><p>本文略去所有算法本身性质的证明过程。</p><h2 id="最短路">最短路</h2><h3 id="dijkstra和spfa">Dijkstra和SPFA</h3><p><span class="math inline">\(\text{Dijkstra}\)</span>算法基于一个重要的性质：全局最小值不可能再被任何边更新。这样，在边权为非负数的最短路问题中显然满足，在存在负边时不满足。同时，保证了最多从每个节点处扩展<span class="math inline">\(1\)</span> 次，从而有了稳定的复杂度。</p><p>这也限制了 <span class="math inline">\(\text{Dijkstra}\)</span>在转移 DP 时的应用。</p><p>在某经典问题中，设 <span class="math inline">\(f(x)\)</span> 表示<span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span>的最小点权。全局最小值是可能在更新的过程中变小的，具体方法是绕一圈再经过权值更小的点。</p><p>再来看又一个经典问题。</p><h4 id="luogu4042-ahoi2014jsoi2014-骑士游戏">luogu4042[AHOI2014/JSOI2014] 骑士游戏</h4><p>设 <span class="math inline">\(f(x)\)</span> 为杀死怪物 <spanclass="math inline">\(x\)</span> 以及其他衍生物的最小代价。 <spanclass="math display">\[f(x) = \min \Big\{ K_x, S_x+\sum_{y \in to(x)} f(y) \Big\}\]</span> 这玩意有后效性。</p><p>当前全局最小值也是有可能会随着更新而变小的，因此不能使用 <spanclass="math inline">\(\text{Dijkstra}\)</span> 算法，必须使用SPFA。在更新完 <span class="math inline">\(f(x)\)</span>之后，把所有能生成 <span class="math inline">\(x\)</span>的点都扔到队列里面去更新。复杂度爆炸，但好在是 14年的题，好像做完了。</p><p>然而，真的不满足吗？</p><p>如果一个 <span class="math inline">\(f(x)\)</span>在更新其他点的时候把自己更新成更小的值，那么说明杀死中间那些怪物的代价为负数，这是不合理的，因此本题满足<span class="math inline">\(\text{Dijkstra}\)</span>的贪心性质。这也说明了，当一个点的代价确定时，就一定是其最优解。</p><p>因此本题的正解如下。</p><p>任何一个点的最终代价都依赖于它所生成的那些点，因此建一张反图，把所有点都扔到堆里面，初始值就是用魔法攻击干死的代价。</p><p>有了贪心性质，我们并不需要无脑迭代。对于一个 <spanclass="math inline">\(x\)</span>，当它被 <spanclass="math inline">\(to(x)\)</span> 中的每一个点都更新之后，就能得到<span class="math inline">\(S_x + \sum_{y \in to(x)} f(y)\)</span>，与<span class="math inline">\(K_x\)</span> 取较小值就能得到最小代价。</p><p>这样做的复杂度就是 <span class="math inline">\(O\Big((n+\sum_{i=1}^nR_i) \log_2 (\sum_{i=1}^n R_i )\Big)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P4042 [AHOI2014/JSOI2014] 骑士游戏</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P4042</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, c[N], d[N], to[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;priority_queue&lt;PII &gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) q.<span class="hljs-built_in">push</span>(&#123;-d[i],i&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;c[y]+=d[x];<span class="hljs-keyword">if</span>(--to[y]==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(d[y]&gt;c[y]) &#123;d[y]=c[y];q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) &#123;c[x]=<span class="hljs-built_in">read</span>(), d[x]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(cnt--) &#123;<span class="hljs-type">int</span> y=<span class="hljs-built_in">read</span>();p[y].<span class="hljs-built_in">pb</span>(x);++to[x];&#125;&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="luogu4745-cerc2017-gambling-guide">luogu4745 [CERC2017] GamblingGuide</h4><p>题目中要求最小化期望，指的是在有优劣之分的决策中，选择最优决策。</p><p>设 <span class="math inline">\(f(x)\)</span> 为从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(n\)</span> 的最小期望，有 <spanclass="math display">\[f(x) = 1 + \frac{1}{\operatorname{deg}_x}\sum_{(x,y) \in E}\min\Big(f(x),f(y)\Big)\]</span> 这个取 <span class="math inline">\(\min\)</span>操作很麻烦。考虑 <span class="math inline">\(f(y)\)</span> 对 <spanclass="math inline">\(f(x)\)</span> 有贡献，一定有 <spanclass="math inline">\(f(y) &lt;f(x)\)</span>。因此，考虑按照期望代价确定每个点的答案，第一次只能确定<span class="math inline">\(f(n) = 0\)</span>。</p><p>设满足 <span class="math inline">\(S_x\)</span> 表示 <spanclass="math inline">\(x\)</span>的相邻节点中，已经确定代价的点集，那么就有 <span class="math display">\[f&#39;(x) = 1 + \Big(1-\frac{|S_x|}{\operatorname{deg}_x} \Big) f_x  +\frac{1}{\operatorname{deg}_x} \sum_{y \in S_x} f(y)\]</span></p><p><span class="math display">\[f&#39;(x) = \frac{\operatorname{deg}_x + \sum_{y \in S_x} f(y)}{|S_x|}\]</span></p><p>最终的 <span class="math inline">\(f(x)\)</span> 就是 <spanclass="math inline">\(\min \{ f&#39;(x) \}\)</span>。</p><p>这样就能在图上迭代了，具体做法是取出一个确定了的 <spanclass="math inline">\(f(x)\)</span>，令 <spanclass="math inline">\(|S_y| := |S_y|+1\)</span>，然后那个和式加上 <spanclass="math inline">\(f(x)\)</span>，就能计算出 <spanclass="math inline">\(f&#39;(y)\)</span>。</p><p>考虑一个全局最小的 <span class="math inline">\(f(x)\)</span> 更新了<span class="math inline">\(f(y)\)</span> 得到 <spanclass="math inline">\(f&#39;(y)\)</span>，带入式子中可以有 <spanclass="math inline">\(f(x) &lt; f&#39;(y) &lt;f(y)\)</span>，具体过程略。</p><p>用 <span class="math inline">\(\text{Dijkstra}\)</span> 转移。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P4745 [CERC2017] Gambling Guide</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P4745</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 500 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<span class="hljs-type">int</span> n, m, c[N], v[N];<span class="hljs-type">double</span> f[N], g[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i]=<span class="hljs-number">1e10</span>;priority_queue&lt;pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; &gt; q;f[n]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0.0</span>,n&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) &#123;++c[y];g[y]+=f[x];<span class="hljs-keyword">if</span>(f[y]&gt;(p[y].<span class="hljs-built_in">size</span>()+g[y])/c[y]) &#123;    f[y]=(p[y].<span class="hljs-built_in">size</span>()+g[y])/c[y];    q.<span class="hljs-built_in">push</span>(&#123;-f[y],y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>,f[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>再提供一道关于 <span class="math inline">\(\text{Dijkstra}\)</span>算法的贪心性质的题目。</p><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边的图，边权值域是 <spanclass="math inline">\([0,10^9]\)</span>。求从每个点出发前 <spanclass="math inline">\(k\)</span> 近的点。</p><p><span class="math inline">\(n \le 10^5\)</span>，<spanclass="math inline">\(m \le \min(\frac{n(n-1)}{2},3 \times10^5)\)</span>，<span class="math inline">\(k \le 16\)</span>。</p></blockquote><p>由于 <span class="math inline">\(\text{Dijkstra}\)</span>算法取出的是全局最小值，所以对于每个点，只要取出 <spanclass="math inline">\(k\)</span> 个点扩展即可。而显然从每个点出发最多有<span class="math inline">\(k\)</span>条边有用，所以这样直接做就行了，复杂度 <spanclass="math inline">\(O(nk^2 \log_2 k^2)\)</span>。</p><p>注意清空数组的细节，否则复杂度就假了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-type">bool</span> lst=<span class="hljs-number">0</span>;priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;d[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-comment">//puts(&quot;doit&quot;);</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;++w) &#123;<span class="hljs-keyword">while</span>(v[q.<span class="hljs-built_in">top</span>().second]) q.<span class="hljs-built_in">pop</span>();<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second;v[x]=<span class="hljs-number">1</span>, link[w]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:p[x]) &#123;<span class="hljs-type">int</span> y=i.second, z=i.first;<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;<span class="hljs-keyword">if</span>(w) &#123;<span class="hljs-keyword">if</span>(lst) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);lst=<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,d[x]);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;++w) &#123;v[link[w]]=<span class="hljs-number">0</span>, d[link[w]]=<span class="hljs-number">1e15</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[link[w]]) d[y.second]=<span class="hljs-number">1e15</span>;&#125;&#125;</code></pre></div><h3 id="bfs及其扩展">0-1 BFS及其扩展</h3><p>在边权只有 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 的图上，我们可以用 0-1 BFS 在 <spanclass="math inline">\(O(n+m)\)</span>的时间里求解单源最短路。其原理是在普通队列中，维护队首的元素是全局最小值。可以当作一个退化了的<span class="math inline">\(\text{Dijkstra}\)</span> 算法来理解。</p><p>扩展：边权为 <span class="math inline">\(0,1,2,\cdots, w\)</span>时怎么做？</p><p>依然是维护单调性。开 <span class="math inline">\(w+1\)</span>个队列，当更新完 <span class="math inline">\(dis(y) = dis(x)+ z\)</span>时，将 <span class="math inline">\(dis(y)\)</span> 扔到第 <spanclass="math inline">\(z\)</span> 个队列里。由于每次取出的 <spanclass="math inline">\(dis(x)\)</span>单调不降，所以每个队列内部的大小都是单调的。</p><p>贪心从权值小的队列取点即可。</p><h3 id="最短路树">最短路树</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, pre[y]=i;        <span class="hljs-comment">// pre[y]就是最短路树上x与y之间的边</span>        q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;); &#125;&#125;</code></pre></div><p>性质就像它的名字，源点到每个点的最短路径构成的一棵树。</p><h3 id="次短路">次短路</h3><p>维护两个数组<code>dis1[]</code>和<code>dis2[]</code>。如果用当前点更新了到另一个点的最短路，那么把那个点的最短路和次短路都扔进堆里（因为二者都被更新过了）；如果只更新了另一个点的次短路，那么把次短路扔进堆里。</p><p>一个节点可能会更新和被更新多次，为了避免复杂度退化，要判断当前取出的节点对应的最短路长度，是否是最短路或次短路之一，或者说判断长度是否已经大于了次短路。</p><p>从网上找了份代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(re <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis1[i]=dis2[i]=<span class="hljs-number">1e9</span>;    dis1[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; q.<span class="hljs-built_in">push</span>((node)&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())    &#123;        <span class="hljs-type">int</span> dt,pt;        dt=q.<span class="hljs-built_in">top</span>().d; pt=q.<span class="hljs-built_in">top</span>().p; q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(dt!=dis1[pt]&amp;&amp;dt!=dis2[pt]) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// if(dt&gt;dis2[pt])</span>        <span class="hljs-keyword">for</span>(re <span class="hljs-type">int</span> i=last[pt];i;i=e[i].next)        &#123;            <span class="hljs-type">int</span> v=e[i].to; <span class="hljs-type">int</span> dis=dt+e[i].val;            <span class="hljs-keyword">if</span>(dis&lt;dis1[v])            &#123;                dis2[v]=dis1[v]; dis1[v]=dis;                q.<span class="hljs-built_in">push</span>((node)&#123;dis1[v],v&#125;);                 q.<span class="hljs-built_in">push</span>((node)&#123;dis2[v],v&#125;);            &#125;<span class="hljs-keyword">else</span>            <span class="hljs-keyword">if</span>(dis&gt;dis1[v]&amp;&amp;dis&lt;dis2[v])            &#123;                dis2[v]=dis;                q.<span class="hljs-built_in">push</span>((node)&#123;dis2[v],v&#125;);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="某道题">某道题</h3><blockquote><p>有向图，求从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 必须经过第 <spanclass="math inline">\(i\)</span> 个点的最短路以及必须经过第 <spanclass="math inline">\(j\)</span> 条边的最短路。</p></blockquote><p>以 <span class="math inline">\(1\)</span> 为源点，跑最短路。以 <spanclass="math inline">\(n\)</span> 为源点，在反图上跑最短路。</p><h3 id="luogu5304-gxoigzoi2019-旅行者">luogu5304 [GXOI/GZOI2019]旅行者</h3><p>从超级源点向 <span class="math inline">\(k\)</span> 个关键点都连<span class="math inline">\(0\)</span> 边，求出 <spanclass="math inline">\(dis_0(x)\)</span>，记录到达每个节点距离最小的关键点<span class="math inline">\(c_0(x)\)</span>。然后建反图再跑一次得到<span class="math inline">\(dis_1(x)\)</span> 和 <spanclass="math inline">\(c_1(x)\)</span>。</p><p>这样如果一条边 <span class="math inline">\((x,y,z)\)</span> 满足<span class="math inline">\(c_0(x) \neq c_1(y)\)</span>，那么说明从<span class="math inline">\(c_0(x)\)</span> 到 <spanclass="math inline">\(x\)</span> 的路径与 <spanclass="math inline">\(c_1(y)\)</span> 到 <spanclass="math inline">\(y\)</span> 无交，从而 <spanclass="math inline">\(dis_0(x)+z+dis_1(y)\)</span>可以作为一个决策。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-type">int</span> T, n, m, k, a[N], col[<span class="hljs-number">2</span>][N], dis[<span class="hljs-number">2</span>][N];<span class="hljs-type">int</span> X[M], Y[M], Z[M];<span class="hljs-type">bool</span> v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">G</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[M], nxt[M], w[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=<span class="hljs-number">0</span>;&#125;&#125; G;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span>* d,<span class="hljs-type">int</span>* c)</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=c[i]=<span class="hljs-number">0</span>, d[i]=inf;priority_queue&lt;PII &gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) d[a[i]]=<span class="hljs-number">0</span>, c[a[i]]=a[i], q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,a[i]&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i], z=G.w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;c[y]=c[x];q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;X[i]=<span class="hljs-built_in">read</span>(), Y[i]=<span class="hljs-built_in">read</span>(), Z[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(X[i]!=Y[i]) G.<span class="hljs-built_in">add</span>(X[i],Y[i],Z[i]);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">dijkstra</span>(dis[<span class="hljs-number">0</span>],col[<span class="hljs-number">0</span>]);G.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(X[i]!=Y[i]) G.<span class="hljs-built_in">add</span>(Y[i],X[i],Z[i]);<span class="hljs-built_in">dijkstra</span>(dis[<span class="hljs-number">1</span>],col[<span class="hljs-number">1</span>]);G.<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">1e15</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=X[i], y=Y[i], z=Z[i];<span class="hljs-keyword">if</span>(col[<span class="hljs-number">0</span>][x]&amp;&amp;col[<span class="hljs-number">1</span>][y]&amp;&amp;col[<span class="hljs-number">0</span>][x]!=col[<span class="hljs-number">1</span>][y])ans=<span class="hljs-built_in">min</span>(ans,dis[<span class="hljs-number">0</span>][x]+dis[<span class="hljs-number">1</span>][y]+z);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>不过这样的做法可能不是很好想到，所以有一种更劣但是思路更自然的做法，</p><p>如果我们使用超级源点和超级汇点，那么能够解决两个集合之间两两最短路的最小值，但是无法解决这个问题。如果我们有一种划分关键点的方式，使得划分若干次后任意两个点一定有至少一次不在同一个集合，就能做了。</p><p>考虑二进制分组。考虑二进制的每一位，把这一位是 <spanclass="math inline">\(0\)</span> 的与 <spanclass="math inline">\(S\)</span> 相连，否则与 <spanclass="math inline">\(T\)</span>相连，跑最短路。这样每次划分的两个集合都无交，并且满足任意两个关键点至少出现在一个不同的集合中。</p><p>这 <span class="math inline">\(O(\log_2 2\times 10^9)\)</span>次最短路中，从 <span class="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的最短路的最小值就是答案。</p><h3 id="luogu7473-noi-online-2021-入门组-重力球">luogu7473 [NOI Online2021 入门组] 重力球</h3><p>在经过至少一次操作之后，小球一定贴着墙壁或者障碍，也就是有用的状态数量只有<span class="math inline">\(O(n+m)\)</span>。</p><p>把有用的状态搞出来，建反边 <spanclass="math inline">\(\text{BFS}\)</span> 出 <spanclass="math inline">\(dis(x,y)\)</span> 表示状态 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>的两个小球，到达同一个点的最小步数。</p><p>对于一个询问，枚举第一步的操作，然后取最小值即可。</p><p>貌似代码有点难写。</p><h3 id="某道题-1">某道题</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边一张图，定义一条包含 <spanclass="math inline">\(l\)</span> 条边的路径的长度为 <spanclass="math inline">\(\max_{i=1}^l \{ i \times w_i \}\)</span>，求 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的最短路。</p><p><span class="math inline">\(n,m \le 3 \times 10^5\)</span>。</p></blockquote><p>二分最短路长度 <span class="math inline">\(mid\)</span>，则第 <spanclass="math inline">\(i\)</span> 条经过的边长度不超过 <spanclass="math inline">\(mid / i\)</span>，这样就变成了一个可达性问题，BFS即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, d[N];<span class="hljs-type">int</span> tot, h[N], to[N], nxt[N], w[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> D)</span> </span>&#123;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,(n+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-type">int</span> x=p.first, dd=p.second;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(z*(dd+<span class="hljs-number">1</span>)&lt;=D&amp;&amp;d[y]==<span class="hljs-number">-1</span>) &#123;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(&#123;y,dd+<span class="hljs-number">1</span>&#125;);&#125;&#125;&#125;<span class="hljs-keyword">if</span>(d[n]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z);&#125;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1e13</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">bfs</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div><h3 id="luogu2446-sdoi2010-大陆争霸">luogu2446 [SDOI2010] 大陆争霸</h3><p>设 <span class="math inline">\(dis(x)\)</span> 为到达节点 <spanclass="math inline">\(x\)</span> 的最短时间，<spanclass="math inline">\(des(x)\)</span> 为摧毁 <spanclass="math inline">\(x\)</span> 的最小时间。</p><p>然后 <span class="math inline">\(des(x) = \max_{y \in protect(x)} \{dis(y)\}\)</span>。</p><p>在完成对 <span class="math inline">\(x\)</span> 节点的扩展后去更新被<span class="math inline">\(x\)</span> 保护的节点。一个节点在被求出<span class="math inline">\(des(x)\)</span> 后再次入堆，这样 <spanclass="math inline">\(des(n)\)</span> 即为答案。</p><h3 id="luogu5663-csp-j2019-加工零件">luogu5663 [CSP-J2019]加工零件</h3><p>我们很容易做 <span class="math inline">\(n\)</span> 很小，<spanclass="math inline">\(m\)</span> 很大的问题，并且容易得到方案数。</p><p>然而那个做法和本题没有任何关系。既然本题只关心是否存在，那么不妨做个转化。任何<span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 经过 <spanclass="math inline">\(L\)</span>条边的路径，都能转化成走最短路，然后再一条边上左右横跳的路径。从奇偶性处下手即可证明。</p><p>那么求出从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span>经过奇数条边和偶数条边的最短路就能判断。</p><p>怎么做？一个点拆成奇点和偶点。</p><h3 id="cf938d-buy-a-ticket">CF938D Buy a Ticket</h3><p>建立超级源点 <span class="math inline">\(S\)</span>，从 <spanclass="math inline">\(S\)</span> 往 <spanclass="math inline">\(i\)</span> 连权值为 <spanclass="math inline">\(a_i\)</span> 的有向边，然后把原图中的边权都乘<span class="math inline">\(2\)</span>，这样到达 <spanclass="math inline">\(i\)</span> 点的最短路就是 <spanclass="math inline">\(i\)</span> 点的答案。</p><h3 id="cf1483d-useful-edges">CF1483D Useful Edges</h3><p>必经边。</p><p>记 <span class="math inline">\((u,v,l)\)</span> 为 <spanclass="math inline">\(a(u,v)=l\)</span>。</p><p><span class="math inline">\((x,y,z)\)</span> 满足条件就是看是否存在<span class="math inline">\((i,j)\)</span> 满足 <spanclass="math display">\[dis(i,x)+z+dis(y,j) \le a(i,j)\]</span> 直接做是 <span class="math inline">\(O(n^4)\)</span> 的。</p><p>设 <span class="math inline">\(b(y,i) = \max \{ a(i,j)-dis(y,j)\}\)</span>，于是就是 <span class="math display">\[dis(i,x) + z \le b(y,i)\]</span> 这样就是 <span class="math inline">\(O(n^3)\)</span> 的。</p><h3 id="luogu4366-code4-最短路">luogu4366 [Code+#4] 最短路</h3><p>就一个点。</p><p>事实上我们只需要保留 <span class="math inline">\((i \oplus j) = 2^k,k\in [0,\log_2n]\)</span> 的边。</p><p>把 <span class="math inline">\((i \oplus j)\)</span>拆成若干二进制位上的 <spanclass="math inline">\(1\)</span>，一个一个地走。这样做的权值依然是不变的。</p><h2 id="差分约束系统">差分约束系统</h2><p>分为两种。</p><ol type="1"><li><p>求最大值。</p><p>把式子整理为 <span class="math inline">\(X_i - X_j \lek\)</span>，连边 <span class="math inline">\((j \rightarrowi)\)</span>，权值为 <spanclass="math inline">\(k\)</span>，跑最短路。有负环无解。</p></li><li><p>求最小值。</p><p>把式子整理为 <span class="math inline">\(X_i -X_j \gek\)</span>，连边 <span class="math inline">\((j \rightarrowi)\)</span>，权值为 <spanclass="math inline">\(k\)</span>，跑最长路。有正环无解。</p></li></ol><p>如果关系要求相等，那么就是 <span class="math inline">\(X_i - X_j \lek \wedge X_i - X_j \ge k\)</span>。。</p><p>一般直接连出的图都不连通，所以需要虚拟源点，同时也可以起到各个变量限制初始值的作用。</p><h3 id="某经典题">某经典题。</h3><blockquote><p>现在有 <span class="math inline">\([1,m] \cap \mathbb{Z}\)</span>中的数，有 <span class="math inline">\(n\)</span> 个限制，第 <spanclass="math inline">\(i\)</span> 个限制表示 <spanclass="math inline">\([a_i,b_i]\)</span> 中至少要取 <spanclass="math inline">\(c_i\)</span> 个数。</p><p>求至少需要多少个整数。</p></blockquote><p>限制转化为 <span class="math inline">\([1,b_i]\)</span>中取数的数量至少比 <span class="math inline">\([1,a_i-1]\)</span> 中多<span class="math inline">\(c_i\)</span>，因此 <spanclass="math inline">\(X_{b_i} - X_{a_i -1} \ge c_i\)</span>。</p><p>直接跑差分约束系统也不对，因为还有隐式的限制，<spanclass="math inline">\(X_a \le X_{a+1} \le X_a + 1\)</span>。</p><p>还有一个问题，如果以 <span class="math inline">\(1\)</span>为起点跑，那么因该有 <span class="math inline">\(X_1 =0\)</span>，实际上并不是。因此必须要有一个虚拟点 <spanclass="math inline">\(s\)</span>，满足限制 <span class="math inline">\(0\le X_1 - X_S \le 1\)</span>。</p><h3 id="luogu3275-scoi2011-糖果">luogu3275 [SCOI2011] 糖果</h3><p>关于 SPFA，它死了。</p><p>差分约束建模之后，为了保证连通并且每个变量都是正整数，还要建立超级源点<span class="math inline">\(S\)</span>，满足关系 <spanclass="math inline">\(X_S - X_i \ge 1\)</span>。</p><p>然后 SPFA 就被卡掉了。</p><p>整张图的权值只有 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>。在一个 SCC 里面，如果 <spanclass="math inline">\((x \rightarrow y)\)</span> 权值是 <spanclass="math inline">\(1\)</span>，那么就一定存在一个正环，从而差分约束系统无解。再考虑SCC 的性质，能发现一个 SCC 中的点的取值都是相等的。缩点后求 DAG最长路即可。</p><h2 id="最小生成树">最小生成树</h2><div class="note note-primary">            <p>一张图的一棵最小生成树，也是这张图的一棵瓶颈生成树。</p>          </div><p>说人话就是对于任意点对 <spanclass="math inline">\((x,y)\)</span>，其最小生成树上的路径上的最大边权，就是原图二者所有路径中，最大边权最小的路径所对应的最大边权。</p><div class="note note-primary">            <p>次小生成树（无论严格与否）一定是在最小生成树的基础上更改一条边。</p><p>对于任何不在最小生成树中的边，该边两个端点在最小生成树上的路径的所有边的权值都小于等于该边。</p>          </div><p>所以严格次小生成树怎么做呢？枚举换进去非树边 <spanclass="math inline">\((x,y,z)\)</span>，然后在形成的那个环上找到最大值<span class="math inline">\(z_1\)</span> 和严格次大值 <spanclass="math inline">\(z_2\)</span>。如果 <span class="math inline">\(z_1\neq z\)</span>，那么换掉 <spanclass="math inline">\(z_1\)</span>，否则换掉 <spanclass="math inline">\(z_2\)</span>。</p><p>树上倍增即可。</p><p>不要求严格次小的话，只求最大值即可。</p><h3 id="luogu1991-无线通讯网">luogu1991 无线通讯网</h3><p>不妨先确定 <spanclass="math inline">\(D\)</span>，再选点。能发现只有当 <spanclass="math inline">\(D\)</span> 确定之后，连通块数量不超过 <spanclass="math inline">\(S\)</span> 时才有解。</p><p>问题转化为求出把一张完全图划分成不超过 <spanclass="math inline">\(S\)</span> 个连通块，使得最大边权最小。</p><p>在 <span class="math inline">\(\text{Kruskal}\)</span>的过程中，当整张图被合并为恰好 <span class="math inline">\(S\)</span>个连通块时，最后加入的边权就是最优的 <spanclass="math inline">\(D\)</span>。</p><p>或者说用 <span class="math inline">\(\text{Prim}\)</span>算法，可以做到 <span class="math inline">\(O(n^2)\)</span>，最后对 <spanclass="math inline">\(d\)</span> 数组排序即可。</p><h3 id="cf76a-gift">CF76A Gift</h3><p>先按照 <span class="math inline">\(g_i\)</span> 递增排序，枚举 <spanclass="math inline">\(\max\{g_i\}\)</span>，这样问题就变成了维护只使用<span class="math inline">\([1,i]\)</span> 中的边的生成树。</p><p>我们直接暴力加入这条边，排序后做最小生成树（其实要求出的是瓶颈生成树）最小化<span class="math inline">\(\max\{s_i\}\)</span>。</p><p>这样做的复杂度是 <span class="math inline">\(O(NM\log_2M)\)</span>，有点大。</p><p>不过考虑到每次做完最小生成树后，剩下的边都是有序的，并且新的最小生成树也不会加入上一次没有加入的边，所以可以手动做一次冒泡排序，使得集合内边的<span class="math inline">\(s_i\)</span> 有序，这样做就是 <spanclass="math inline">\(O(NM)\)</span> 了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: A. Gift</span><span class="hljs-comment">// Contest: Codeforces - All-Ukrainian School Olympiad in Informatics</span><span class="hljs-comment">// URL: https://codeforces.com/problemset/problem/76/A</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">50005</span>;<span class="hljs-type">int</span> n, m, G, S, cnt, ans=<span class="hljs-number">5e18</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, y, g, s;&#125; a[M], b[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Edge a,Edge b) &#123;<span class="hljs-keyword">return</span> a.g&lt;b.g;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dsu</span> &#123;<span class="hljs-type">int</span> f[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), G=<span class="hljs-built_in">read</span>(), S=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i].x=<span class="hljs-built_in">read</span>(), a[i].y=<span class="hljs-built_in">read</span>(), a[i].g=<span class="hljs-built_in">read</span>(), a[i].s=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;b[++cnt]=a[i];<span class="hljs-built_in">per</span>(j,cnt,<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(b[j].s&lt;b[j<span class="hljs-number">-1</span>].s) <span class="hljs-built_in">swap</span>(b[j],b[j<span class="hljs-number">-1</span>]);dsu.<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>, maxs=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123;<span class="hljs-type">int</span> x=b[j].x, y=b[j].y;x=dsu.<span class="hljs-built_in">get</span>(x), y=dsu.<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123;dsu.f[x]=y, b[++pos]=b[j];<span class="hljs-keyword">if</span>(pos==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(pos==n<span class="hljs-number">-1</span>) ans=<span class="hljs-built_in">min</span>(ans,G*a[i].g+S*b[pos].s);cnt=pos;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans==<span class="hljs-number">5e18</span>? <span class="hljs-number">-1</span>:ans));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf1468j-road-reform">CF1468J Road Reform</h3><p>先求出最小生成树。</p><p>如果 MST 中的存在权值大于 <span class="math inline">\(k\)</span>的边，那么把这些边调整了一定是最优的。根据上文结论即可证明。</p><p>如果 MST 中的边权值小于 <span class="math inline">\(k\)</span>呢？直接将最大边与 <span class="math inline">\(\min_{(x,y,z) \in G}\{|z_i - k|\}\)</span> 替换一下就好了。</p><h3 id="luogu8074-coci2009-20107-svemir">luogu8074 [COCI2009-2010#7]SVEMIR</h3><p>分别按照每个坐标排序，相邻点连边，那么边数就是 <spanclass="math inline">\(O(3n)\)</span> 的，并且一定不会漏掉 MST。</p><p>直接 <span class="math inline">\(\text{Kruskal}\)</span> 就行。</p><h3 id="cf1245d-shichikuji-and-power-grid">CF1245D Shichikuji and PowerGrid</h3><p>建立超级源点 <span class="math inline">\(S\)</span>，向 <spanclass="math inline">\(i\)</span> 连权值为 <spanclass="math inline">\(c_i\)</span> 的无向边。</p><p>求出 MST 即为答案。</p><p>使用 <span class="math inline">\(\text{Prim}\)</span> 算法更优。</p><h3 id="cf888g-xor-mst">CF888G Xor-MST</h3><p>考虑 <span class="math inline">\(\text{Boruvka}\)</span> 算法。</p><p>简介一下它的流程：</p><blockquote><p>对于每一个连通块，枚举其出边。取其最小出边，合并两个连通块。</p><p>每次做完一轮后连通块数量至少减半，最多重复 <spanclass="math inline">\(O(\log_2 n)\)</span> 次，所以复杂度就是 <spanclass="math inline">\(O\Big((n+m) \log_2 n\Big)\)</span>。</p></blockquote><p>考虑把所有 <span class="math inline">\(a_i\)</span> 都扔到 0-1 Trie中去，这样每个叶子节点就对应这原图中一个点。</p><p>我们一定是贪心连权值小的边,对应的在 Trie 上，一个点集的 <spanclass="math inline">\(\operatorname{LCA}\)</span>深度越大，它们之间的边权越小。根据 <spanclass="math inline">\(\text{B}\)</span>姓算法，我们能知道一定是一棵子树内所有的叶子节点连成一个连通块后，再向外扩展。所以0-1 Trie 就是这张完全图对于 <spanclass="math inline">\(\text{B}\)</span> 姓算法的分治树。</p><p>在Trie 上 <spanclass="math inline">\(\text{DFS}\)</span>，设<code>dfs(x,dep)</code>表示把深度为<span class="math inline">\(dep\)</span> 的节点 <spanclass="math inline">\(x\)</span>子树内，所有叶子节点连成一个连通块的最小代价。</p><p>如果存在 <span class="math inline">\(son_0(x)\)</span> 与 <spanclass="math inline">\(son_1(x)\)</span>，那么就枚举其中一个儿子对应的<spanclass="math inline">\(a_i\)</span>，在另一个儿子得子树内查询最小异或值即可，记这个值为<spanclass="math inline">\(res\)</span>，答案就是它再加上往分别往两个儿子搜的代价。这个枚举的过程可以启发式合并进行优化。不过如果我们按照<span class="math inline">\(a_i\)</span> 递增的顺序插入Trie，那么每个节点对应的 <span class="math inline">\(a_i\)</span>得下标都是连续的区间，这样直接枚举就够了。</p><p>否则就直接继承存在的那个儿子的值即可。</p><p>如果存在两个点权值相同怎么办？在完全图中，它们算是等价类。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: G. Xor-MST</span><span class="hljs-comment">// Contest: Codeforces - Educational Codeforces Round 32</span><span class="hljs-comment">// URL: https://codeforces.com/problemset/problem/888/G</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, a[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> trie[N*<span class="hljs-number">30</span>][<span class="hljs-number">2</span>], l[N*<span class="hljs-number">30</span>], r[N*<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> S,<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">29</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!l[x]) l[x]=id;r[x]=<span class="hljs-built_in">max</span>(r[x],id);<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> S,<span class="hljs-type">int</span> dep)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(dep&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=dep;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) x=trie[x][a^<span class="hljs-number">1</span>], res+=(<span class="hljs-number">1</span>&lt;&lt;i);<span class="hljs-keyword">else</span> x=trie[x][a];&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> dep)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> son0=trie[x][<span class="hljs-number">0</span>], son1=trie[x][<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(son0!=<span class="hljs-number">0</span>&amp;&amp;son1!=<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">1e15</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l[son0];i&lt;=r[son0];++i)ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(son1,a[i],dep<span class="hljs-number">-1</span>)+(<span class="hljs-number">1</span>&lt;&lt;dep));<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(son0,dep<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(son1,dep<span class="hljs-number">-1</span>)+ans;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(son0!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(son0,dep<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(son1!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(son1,dep<span class="hljs-number">-1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125; T;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) T.<span class="hljs-built_in">insert</span>(a[i],i);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,T.<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">29</span>));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf125e-mst-company">CF125E MST Company</h3><p>先对除了 <span class="math inline">\(1\)</span> 之外的 <spanclass="math inline">\(n-1\)</span> 个点做 MST，然后得到 <spanclass="math inline">\(d\)</span> 个连通块。</p><p>如果 <span class="math inline">\(d&gt;k\)</span>，那么无解。</p><p>如果 <span class="math inline">\(d&lt;k\)</span>，先从 <spanclass="math inline">\(1\)</span>往每个连通块连权值最小的那条边，连不完依然无解，然后枚举与 <spanclass="math inline">\(1\)</span>相连的剩下的边。每加入一条新边，就会形成一个环，这条边的代价就是它的权值减去环上的最小权值，注意不考虑<span class="math inline">\(1\)</span> 连出去的那条边。这样取代价前<span class="math inline">\(k-d\)</span> 小的就行。</p><p>找环上最小权值只需要 <span class="math inline">\(\text{DFS}\)</span>一遍。</p><p>复杂度 <span class="math inline">\(O(m \log_2 m + nk)\)</span>。</p><h3 id="cf1253f-cheap-robot">CF1253F Cheap Robot</h3><p>这题很难评价。</p><p>很缝合，但是思路比较自然。</p><p>注意到只有关键点有实际意义。从 <span class="math inline">\(a\)</span>走到 <spanclass="math inline">\(b\)</span>，要么是直接走两个关键点，要么是绕道其他关键点。</p><p>但是有电量的限制，对于边 <spanclass="math inline">\((x,y,z)\)</span>，从任何关键点走过来都需要满足<span class="math inline">\(c \ge dis(x) + dis(y) +z\)</span>，其中<span class="math inline">\(dis(x)\)</span> 表示距离 <spanclass="math inline">\(x\)</span> 最近的关键点，与 <spanclass="math inline">\(x\)</span> 的距离。</p><p>连边 <spanclass="math inline">\(\Big(k_x,k_y,dis(x)+dis(y)+z\Big)\)</span>，其中<span class="math inline">\(k_x\)</span> 是使取到 <spanclass="math inline">\(dis(x)\)</span> 的一个关键点。这样我们只要最小化<span class="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 路径上权值最大的边就行了。考虑 MST的一个性质，任意两点之间路径上的最大边权最小，所以连边之后求出MST，之后用倍增或者树剖做就行了。</p><p>还有一种做法。把询问离线了，枚举每条边的权值当作 <spanclass="math inline">\(c\)</span>，然后加边，用并查集判连通性，在连接两个连通块时回答一个连通块内的询问，启发式合并即可。</p><h3 id="cf1707c-dfs-trees">CF1707C DFS Trees</h3><p><ahref="https://yozora0908.github.io/2023/cf1707c-solution">link</a></p><h3 id="kruskal重构树">Kruskal重构树</h3><p>这个先鸽掉，等到以后有时间再写。</p><p><del>那时候估计已经退役了</del>。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;图论这一块内容比较多，而且题目涉及的 Trick 也很多，因此分若干篇。&lt;/p&gt;
&lt;p&gt;本文略去所有算法本身性质的证明过程。&lt;/p&gt;
&lt;h2 id=&quot;最短路&quot;&gt;最短路&lt;/h2&gt;
&lt;h3 id=&quot;dijkstra和spfa&quot;&gt;Dijkstra和SPFA&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Dijkstra}&#92;)&lt;/span&gt;
算法基于一个重要的性质：全局最小值不可能再被任何边更新。这样，在边权为非负数的最短路问题中显然满足，在存在负边时不满足。同时，保证了最多从每个节点处扩展
&lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 次，从而有了稳定的复杂度。&lt;/p&gt;
&lt;p&gt;这也限制了 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{Dijkstra}&#92;)&lt;/span&gt;
在转移 DP 时的应用。&lt;/p&gt;
&lt;p&gt;在某经典问题中，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt; 表示
&lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
的最小点权。全局最小值是可能在更新的过程中变小的，具体方法是绕一圈再经过权值更小的点。&lt;/p&gt;
&lt;p&gt;再来看又一个经典问题。&lt;/p&gt;
&lt;h4 id=&quot;luogu4042-ahoi2014jsoi2014-骑士游戏&quot;&gt;luogu4042
[AHOI2014/JSOI2014] 骑士游戏&lt;/h4&gt;</summary>
    
    
    
    <category term="Record" scheme="https://yozora0908.github.io/categories/Record/"/>
    
    
    <category term="图论" scheme="https://yozora0908.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="贪心" scheme="https://yozora0908.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="生成树" scheme="https://yozora0908.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="Trie" scheme="https://yozora0908.github.io/tags/Trie/"/>
    
    <category term="最短路" scheme="https://yozora0908.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>luogu2167 [SDOI2009] Bill的挑战 题解</title>
    <link href="https://yozora0908.github.io/2023/lg2167-solution/"/>
    <id>https://yozora0908.github.io/2023/lg2167-solution/</id>
    <published>2023-07-16T01:56:06.000Z</published>
    <updated>2023-08-28T02:47:32.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="状压dp做法">状压DP做法</h2><p>字符串长度不大，考虑刻画 <span class="math inline">\(T\)</span>的每一位。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 表示考虑了 <spanclass="math inline">\(T\)</span> 的前 <spanclass="math inline">\(i\)</span> 位，匹配了 <spanclass="math inline">\(S\)</span> 内的字符串的方案数。</p><p>枚举下一位的字符，然后把能匹配上的字符集合设为 <spanclass="math inline">\(S_0\)</span>，这样就能转移到 <spanclass="math inline">\(f(i+1,S \cap S_0)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>, mod=<span class="hljs-number">1000003</span>;<span class="hljs-type">int</span> T, n, m, k, U, f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>][<span class="hljs-number">55</span>], v[<span class="hljs-number">30</span>];<span class="hljs-type">char</span> s[N][<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ctz</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]);m=<span class="hljs-built_in">strlen</span>(s[<span class="hljs-number">0</span>]);<span class="hljs-keyword">if</span>(n&lt;k) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[U][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=U;S;--S) <span class="hljs-keyword">if</span>(f[S][i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;++j) &#123;<span class="hljs-type">int</span> S0=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k) <span class="hljs-keyword">if</span>(s[k][i]==<span class="hljs-string">&#x27;?&#x27;</span>||s[k][i]-<span class="hljs-string">&#x27;a&#x27;</span>==j) S0|=(<span class="hljs-number">1</span>&lt;&lt;k);(f[S&amp;S0][i+<span class="hljs-number">1</span>]+=f[S][i])%=mod;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ctz</span>(S)==k) (ans+=f[S][m])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="容斥做法">容斥做法</h2><p>考虑二项式反演。设 <span class="math inline">\(f(k)\)</span>为至少匹配了 <span class="math inline">\(k\)</span> 个串的方案数，<spanclass="math inline">\(g(k)\)</span> 为恰好匹配了 <spanclass="math inline">\(k\)</span> 个串的方案数，那么 <spanclass="math display">\[g(k)=\sum_{i=k}^n \binom{i}{k} (-1)^{i-k} f(i)\]</span> 对于 <spanclass="math inline">\(f(i)\)</span>，我们只需要搜索出任意 <spanclass="math inline">\(i\)</span> 个字符串的并，然后乘上 <spanclass="math inline">\(26^{m-i}\)</span> 即可。</p><p>其中 <span class="math inline">\(m\)</span> 是字符串长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>, mod=<span class="hljs-number">1000003</span>;<span class="hljs-type">int</span> T, n, m, k, U, f[N], pw[<span class="hljs-number">55</span>], C[N][N];<span class="hljs-type">int</span> cup, id[<span class="hljs-number">55</span>];<span class="hljs-type">char</span> s[N][<span class="hljs-number">55</span>], Ts[<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> cnt)</span> </span>&#123;<span class="hljs-keyword">if</span>(n-x+<span class="hljs-number">1</span>+cnt&lt;k) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(x&gt;n) &#123;(f[cnt]+=pw[m-cup])%=mod;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,cnt);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">if</span>(Ts[i]&amp;&amp;s[x][i]!=<span class="hljs-string">&#x27;?&#x27;</span>&amp;&amp;Ts[i]!=s[x][i]) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 有冲突，不能并</span>&#125;<span class="hljs-type">int</span> cc=cup;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!Ts[i]&amp;&amp;s[x][i]!=<span class="hljs-string">&#x27;?&#x27;</span>) Ts[i]=s[x][i], id[++cup]=i;<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,cnt+<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(cup&gt;cc) Ts[id[cup--]]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 撤销求并操作</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>), f[i]=f[i+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; m=<span class="hljs-built_in">strlen</span>(s[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(n&lt;k) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>((i-k)&amp;<span class="hljs-number">1</span>) (ans-=C[i][k]*f[i]%mod-mod)%=mod;<span class="hljs-keyword">else</span> (ans+=C[i][k]*f[i]%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">50</span>) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">26</span>%mod;C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">15</span>) &#123;C[i][<span class="hljs-number">0</span>]=C[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;https://cdn.staticfile.org/meting/2.0.1/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;状压dp做法&quot;&gt;状压DP做法&lt;/h2&gt;
&lt;p&gt;字符串长度不大，考虑刻画 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;
的每一位。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,S)&#92;)&lt;/span&gt; 表示考虑了 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt; 的前 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 位，匹配了 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 内的字符串的方案数。&lt;/p&gt;
&lt;p&gt;枚举下一位的字符，然后把能匹配上的字符集合设为 &lt;span class=&quot;math inline&quot;&gt;&#92;(S_0&#92;)&lt;/span&gt;，这样就能转移到 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i+1,S &#92;cap S_0)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; int long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; uint unsigned long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PII pair&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;int,int&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MP make_pair&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; fi first&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; se second&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; pb push_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; eb emplace_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SET(a,b) memset(a,b,sizeof(a))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CPY(a,b) memcpy(a,b,sizeof(b))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; rep(i,j,k) for(int i=(j);i&amp;lt;=(k);++i)&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; per(i,j,k) for(int i=(j);i&amp;gt;=(k);--i)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, f=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(c==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;) f=&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) a=a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+c-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a*f;
&amp;#125;
&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;, mod=&lt;span class=&quot;hljs-number&quot;&gt;1000003&lt;/span&gt;;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; T, n, m, k, U, f[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;], v[&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;];
&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[N][&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;];
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ctz&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cnt=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(x) cnt+=x&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, x&amp;gt;&amp;gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; cnt; 
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	n=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), k=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	U=(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;n)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,n&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;) &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;,s[i]);
	m=&lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);
	&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(n&amp;lt;k) &amp;#123;
		&lt;span class=&quot;hljs-built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt;);
		&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;SET&lt;/span&gt;(f,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);
	f[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=f[U][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;++i) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; S=U;S;--S) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(f[S][i]) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;;++j) &amp;#123;
			&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; S0=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
			&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; k=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;k&amp;lt;n;++k) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(s[k][i]==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;?&amp;#x27;&lt;/span&gt;||s[k][i]-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;==j) S0|=(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;k);
			(f[S&amp;amp;S0][i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+=f[S][i])%=mod;
		&amp;#125;
	&amp;#125;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ans=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; S=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;S&amp;lt;=U;++S) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;ctz&lt;/span&gt;(S)==k) (ans+=f[S][m])%=mod;
	&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%lld&#92;n&amp;quot;&lt;/span&gt;,ans);
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	T=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(T--) &lt;span class=&quot;hljs-built_in&quot;&gt;solve&lt;/span&gt;();
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;容斥做法&quot;&gt;容斥做法&lt;/h2&gt;
&lt;p&gt;考虑二项式反演。设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(k)&#92;)&lt;/span&gt;
为至少匹配了 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 个串的方案数，&lt;span class=&quot;math inline&quot;&gt;&#92;(g(k)&#92;)&lt;/span&gt; 为恰好匹配了 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 个串的方案数，那么 &lt;span class=&quot;math display&quot;&gt;&#92;[
g(k)=&#92;sum_{i=k}^n &#92;binom{i}{k} (-1)^{i-k} f(i)
&#92;]&lt;/span&gt; 对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i)&#92;)&lt;/span&gt;，我们只需要搜索出任意 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 个字符串的并，然后乘上 &lt;span class=&quot;math inline&quot;&gt;&#92;(26^{m-i}&#92;)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;)&lt;/span&gt; 是字符串长度。&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; int long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; uint unsigned long long&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PII pair&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;int,int&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MP make_pair&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; fi first&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; se second&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; pb push_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; eb emplace_back&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SET(a,b) memset(a,b,sizeof(a))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CPY(a,b) memcpy(a,b,sizeof(b))&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; rep(i,j,k) for(int i=(j);i&amp;lt;=(k);++i)&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; per(i,j,k) for(int i=(j);i&amp;gt;=(k);--i)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, f=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(c==&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;) f=&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
		c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isdigit&lt;/span&gt;(c)) a=a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+c-&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, c=&lt;span class=&quot;hljs-built_in&quot;&gt;getchar&lt;/span&gt;();
	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a*f;
&amp;#125;
&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;, mod=&lt;span class=&quot;hljs-number&quot;&gt;1000003&lt;/span&gt;;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; T, n, m, k, U, f[N], pw[&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;], C[N][N];
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cup, id[&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;];
&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[N][&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;], Ts[&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;];
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cnt)&lt;/span&gt; &lt;/span&gt;&amp;#123;
	&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(n-x+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;+cnt&amp;lt;k) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(x&amp;gt;n) &amp;#123;
		(f[cnt]+=pw[m-cup])%=mod;
		&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(x+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,cnt);
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=m;++i) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(Ts[i]&amp;amp;&amp;amp;s[x][i]!=&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;?&amp;#x27;&lt;/span&gt;&amp;amp;&amp;amp;Ts[i]!=s[x][i]) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
        &lt;span class=&quot;hljs-comment&quot;&gt;// 有冲突，不能并&lt;/span&gt;
	&amp;#125;
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cc=cup;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=m;++i) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!Ts[i]&amp;amp;&amp;amp;s[x][i]!=&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;?&amp;#x27;&lt;/span&gt;) Ts[i]=s[x][i], id[++cup]=i;
	&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(x+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,cnt+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(cup&amp;gt;cc) Ts[id[cup--]]=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;hljs-comment&quot;&gt;// 撤销求并操作&lt;/span&gt;
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	n=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;(), k=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	U=(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;n)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,n) &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;,s[i]+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;), f[i]=f[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; 
	m=&lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
	&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(n&amp;lt;k) &amp;#123;
		&lt;span class=&quot;hljs-built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt;);
		&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;dfs&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);
	&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ans=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=k;i&amp;lt;=n;++i) &amp;#123;
		&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;((i-k)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) (ans-=C[i][k]*f[i]%mod-mod)%=mod;
		&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; (ans+=C[i][k]*f[i]%mod)%=mod;
	&amp;#125;
	&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;%lld&#92;n&amp;quot;&lt;/span&gt;,ans);
&amp;#125;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
	T=&lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt;();
	pw[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;) pw[i]=pw[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]*&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;%mod;
	C[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
	&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(i,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;) &amp;#123;
		C[i][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=C[i][i]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
		&lt;span class=&quot;hljs-built_in&quot;&gt;rep&lt;/span&gt;(j,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;) C[i][j]=(C[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][j]+C[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;])%mod;
	&amp;#125;
	&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(T--) &lt;span class=&quot;hljs-built_in&quot;&gt;solve&lt;/span&gt;();
&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.github.io/tags/DP/"/>
    
    <category term="计数" scheme="https://yozora0908.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="搜索" scheme="https://yozora0908.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="状态压缩" scheme="https://yozora0908.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="二项式反演" scheme="https://yozora0908.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
</feed>
