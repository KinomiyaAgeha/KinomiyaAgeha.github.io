<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yozora0908&#39;s blog</title>
  
  <subtitle>φ(゜▽゜*)♪</subtitle>
  <link href="https://yozora0908.top/atom.xml" rel="self"/>
  
  <link href="https://yozora0908.top/"/>
  <updated>2023-10-23T14:53:21.215Z</updated>
  <id>https://yozora0908.top/</id>
  
  <author>
    <name>yozora0908</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LOJ3463「WC2021」表达式求值 题解</title>
    <link href="https://yozora0908.top/2023/loj3463-solution/"/>
    <id>https://yozora0908.top/2023/loj3463-solution/</id>
    <published>2023-10-23T14:49:25.000Z</published>
    <updated>2023-10-23T14:53:21.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>先建立表达式树。</p><p>由于本题的表达式没有优先级之分，所以递归建树是比较方便的。</p><h3 id="subtask-111">Subtask 1~11</h3><p>由于在运算中每个数是相对独立的，所以可以枚举每个数，计算其保留到最后的方案数。</p><p>设 <span class="math inline">\(f(x,0/1/2)\)</span> 为考虑表达式树上以<span class="math inline">\(x\)</span>为根的表达式，运算的结果小于/等于/大于 <spanclass="math inline">\(x\)</span> 的方案数。为了避免重复统计，对于一个值<span class="math inline">\(A_{i,j}\)</span>，我们认为只有 <spanclass="math inline">\(A_{i,j} = A_{x,y}\)</span> 并且 <spanclass="math inline">\(x \le i\)</span> 时才计入 <spanclass="math inline">\(f(x,1)\)</span>。</p><p>然后做子树 <span class="math inline">\(\min\)</span>、<spanclass="math inline">\(\max\)</span> 卷积即可。</p><p>复杂度 <span class="math inline">\(O(nmE)\)</span>。</p><h3 id="subtask-1214">Subtask 12~14</h3><p>此时表达式只有一种结果，<spanclass="math inline">\(\text{DFS}\)</span>时用<code>std::vector</code>暴力合并即可。</p><p> </p><p>下面是这两个部分分拼起来的代码，可以拿到 <spanclass="math inline">\(70 \text{pts}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, M=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, m, len, a[<span class="hljs-number">12</span>][N];<br>string s;<br><span class="hljs-type">int</span> tp, fg, st[M], match[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getmatch</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,len) &#123;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;?&#x27;</span>) fg=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) st[++tp]=i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            match[i]=st[tp];<br>            --tp;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> rt, cnt, ls[M], rs[M], pos[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(!x) x=++cnt;<br>    <span class="hljs-keyword">if</span>(l==r) &#123;<br>        pos[x]=l;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s[r]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>        pos[x]=match[r]<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// printf(&quot;[%lld %lld] pos=%lld\n&quot;,l,r,pos[x]);</span><br>        <span class="hljs-built_in">build</span>(ls[x],l,match[r]<span class="hljs-number">-2</span>);<br>        <span class="hljs-built_in">build</span>(rs[x],match[r]+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pos[x]=r<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// printf(&quot;[%lld %lld] pos=%lld\n&quot;,l,r,pos[x]);</span><br>        <span class="hljs-built_in">build</span>(ls[x],l,r<span class="hljs-number">-2</span>);<br>        <span class="hljs-built_in">build</span>(rs[x],r,r);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> bf &#123;<br>    <span class="hljs-type">int</span> ans, ii, jj, f[M][<span class="hljs-number">3</span>];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!ls[x]) &#123;<br>            <span class="hljs-type">int</span> i=s[pos[x]]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>;        <br>            <span class="hljs-type">int</span> v1=a[i][jj], v2=a[ii][jj];<br>            <span class="hljs-keyword">if</span>(v1&lt;v2) f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v1&gt;v2) f[x][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v1==v2&amp;&amp;i&lt;=ii) f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(ls[x]);<br>        <span class="hljs-built_in">dfs</span>(rs[x]);<br>        <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;&lt;&#x27;</span>||s[pos[x]]==<span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<br>                (f[x][<span class="hljs-built_in">min</span>(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;&gt;&#x27;</span>||s[pos[x]]==<span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<br>                (f[x][<span class="hljs-built_in">max</span>(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) &#123;<br>            ii=i, jj=j;<br>            <span class="hljs-built_in">dfs</span>(rt);<br>            (ans+=f[rt][<span class="hljs-number">1</span>]*a[i][j]%mod)%=mod;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">namespace</span> sub1 &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!ls[x]) &#123;<br>            <span class="hljs-type">int</span> i=s[pos[x]]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) v[j]=a[i][j];<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; v1=<span class="hljs-built_in">dfs</span>(ls[x]), v2=<span class="hljs-built_in">dfs</span>(rs[x]);<br>        <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v1[i]=<span class="hljs-built_in">max</span>(v1[i],v2[i]);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v1[i]=<span class="hljs-built_in">min</span>(v1[i],v2[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> v1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; v=<span class="hljs-built_in">dfs</span>(rt);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=v[i])%=mod;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) &#123;<br>        a[i][j]=<span class="hljs-built_in">read</span>();<br>    &#125;<br>    cin&gt;&gt;s;<br>    len=s.<span class="hljs-built_in">size</span>();<br>    s=<span class="hljs-string">&quot; &quot;</span>+s;<br>    <span class="hljs-built_in">getmatch</span>();<br>    <span class="hljs-built_in">build</span>(rt,<span class="hljs-number">1</span>,len);<br>    <span class="hljs-comment">// sub1::solve();</span><br>    <span class="hljs-keyword">if</span>(fg) bf::<span class="hljs-built_in">solve</span>(); <span class="hljs-keyword">else</span> sub1::<span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="subtask-120">Subtask 1~20</h3><p>考虑一个转化：设结果为 <span class="math inline">\(x\)</span>的方案数为 <span class="math inline">\(G(x)\)</span>，结果 <spanclass="math inline">\(\ge x\)</span> 的方案数为 <spanclass="math inline">\(F(x)\)</span>，那么有 <spanclass="math display">\[G(x) = F(x) - F(x+1)\]</span> 沿用 Subtask 1~11的思路，不过我们要求的时大于等于某个值的方案数，这样似乎还是离不开枚举具体的值，减少不了DP 的次数。考虑 <span class="math inline">\(\min\)</span> 和 <spanclass="math inline">\(\max\)</span>不关心具体的值，而一列元素相对独立并且最多有 <spanclass="math inline">\(2^m\)</span> 种大小关系，我们可以枚举一个集合<span class="math inline">\(S\)</span>，设 <spanclass="math inline">\(f(x,0/1)\)</span> 为考虑以 <spanclass="math inline">\(x\)</span> 为根的表达式，其中最大值不是/是集合<span class="math inline">\(S\)</span> 内元素的方案数。转移类似，最后记<span class="math inline">\(G(S) = f(root,1)\)</span>。</p><p>这样 DP 的复杂度就是 <span class="math inline">\(O(2^mE)\)</span>。</p><p>然后枚举每个元素 <span class="math inline">\(A_{i,j}\)</span>，求出第<span class="math inline">\(j\)</span>列的元素与它的大小关系（大于等于为 <spanclass="math inline">\(1\)</span>，否则为 <spanclass="math inline">\(0\)</span>），记得到的数为 <spanclass="math inline">\(S_{i,j}\)</span>。答案就是 <spanclass="math display">\[\sum_{i=1}^n \sum_{j=1}^m \Big( G(S_{i,j}) - G(S_{i,j} \setminus \{j\})\Big)\]</span> 总复杂度 <span class="math inline">\(O(2^m E +nm^2)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, m, len, a[<span class="hljs-number">12</span>][N];<br>string s;<br><span class="hljs-type">int</span> tp, fg, st[M], match[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getmatch</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,len) &#123;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;?&#x27;</span>) fg=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) st[++tp]=i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            match[i]=st[tp];<br>            --tp;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> rt, cnt, ls[M], rs[M], pos[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(!x) x=++cnt;<br>    <span class="hljs-keyword">if</span>(l==r) &#123;<br>        pos[x]=l;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s[r]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>        pos[x]=match[r]<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// printf(&quot;[%lld %lld] pos=%lld\n&quot;,l,r,pos[x]);</span><br>        <span class="hljs-built_in">build</span>(ls[x],l,match[r]<span class="hljs-number">-2</span>);<br>        <span class="hljs-built_in">build</span>(rs[x],match[r]+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pos[x]=r<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// printf(&quot;[%lld %lld] pos=%lld\n&quot;,l,r,pos[x]);</span><br>        <span class="hljs-built_in">build</span>(ls[x],l,r<span class="hljs-number">-2</span>);<br>        <span class="hljs-built_in">build</span>(rs[x],r,r);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> sol &#123;<br>    <span class="hljs-type">int</span> ans, S, U, f[N][<span class="hljs-number">2</span>], g[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)+<span class="hljs-number">5</span>];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// printf(&quot;x=%lld\n&quot;,x);</span><br>        <span class="hljs-comment">// if(!x) return;</span><br>        f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!ls[x]) &#123;<br>            <span class="hljs-type">int</span> t=(S&gt;&gt;(s[pos[x]]-<span class="hljs-string">&#x27;0&#x27;</span>))&amp;<span class="hljs-number">1</span>;<br>            f[x][t]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(ls[x]);<br>        <span class="hljs-built_in">dfs</span>(rs[x]);<br>        <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<br>                (f[x][<span class="hljs-built_in">min</span>(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<br>                (f[x][<span class="hljs-built_in">max</span>(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[pos[x]]==<span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>            <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<br>                (f[x][<span class="hljs-built_in">max</span>(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;<br>                (f[x][<span class="hljs-built_in">min</span>(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;<br>                <span class="hljs-comment">// (f[x][0]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;</span><br>                <span class="hljs-comment">// if(i||j) (f[x][1]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(;S&lt;=U;++S) &#123;<br>            <span class="hljs-built_in">dfs</span>(rt);<br>            g[S]=f[rt][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// printf(&quot;g[%lld]=%lld\n&quot;,S,g[S]);</span><br>        &#125;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) &#123;<br>            <span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(a[i][j]&lt;a[k][j]||(a[i][j]==a[k][j]&amp;&amp;k&gt;=i)) S|=(<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>));<br>            (ans+=(g[S]-g[S^(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))]+mod)%mod*a[i][j]%mod)%=mod;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) &#123;<br>        a[i][j]=<span class="hljs-built_in">read</span>();<br>    &#125;<br>    cin&gt;&gt;s;<br>    len=s.<span class="hljs-built_in">size</span>();<br>    s=<span class="hljs-string">&quot; &quot;</span>+s;<br>    <span class="hljs-built_in">getmatch</span>();<br>    <span class="hljs-built_in">build</span>(rt,<span class="hljs-number">1</span>,len);<br>    sol::<span class="hljs-built_in">solve</span>();<br>    <span class="hljs-comment">// sub1::solve();</span><br>    <span class="hljs-comment">// if(fg) bf::solve(); else sub1::solve();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;先建立表达式树。&lt;/p&gt;
&lt;p&gt;由于本题的表达式没有优先级之分，所以递归建树是比较方便的。&lt;/p&gt;
&lt;h3 id=&quot;subtask-111&quot;&gt;Subtask 1~11&lt;/h3&gt;
&lt;p&gt;由于在运算中每个数是相对独立的，所以可以枚举每个数，计算其保留到最后的方案数。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,0/1/2)&#92;)&lt;/span&gt; 为考虑表达式树上以
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
为根的表达式，运算的结果小于/等于/大于 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 的方案数。为了避免重复统计，对于一个值
&lt;span class=&quot;math inline&quot;&gt;&#92;(A_{i,j}&#92;)&lt;/span&gt;，我们认为只有 &lt;span class=&quot;math inline&quot;&gt;&#92;(A_{i,j} = A_{x,y}&#92;)&lt;/span&gt; 并且 &lt;span class=&quot;math inline&quot;&gt;&#92;(x &#92;le i&#92;)&lt;/span&gt; 时才计入 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,1)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后做子树 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;min&#92;)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;max&#92;)&lt;/span&gt; 卷积即可。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(nmE)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;subtask-1214&quot;&gt;Subtask 12~14&lt;/h3&gt;
&lt;p&gt;此时表达式只有一种结果，&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{DFS}&#92;)&lt;/span&gt;
时用&lt;code&gt;std::vector&lt;/code&gt;暴力合并即可。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="计数" scheme="https://yozora0908.top/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="表达式树" scheme="https://yozora0908.top/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3212「CSP-S 2019」划分 题解</title>
    <link href="https://yozora0908.top/2023/loj3212-solution/"/>
    <id>https://yozora0908.top/2023/loj3212-solution/</id>
    <published>2023-10-23T14:49:17.000Z</published>
    <updated>2023-10-23T14:50:48.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>容易想到一个暴力 DP。设 <span class="math inline">\(f(i)\)</span>为划分 <span class="math inline">\([1,i]\)</span>的最小代价，记录取到最小值时的决策点 <spanclass="math inline">\(g_i\)</span> 即可转移。</p><p>设 <span class="math inline">\(S_i = \sum_{j=1}^i a_j\)</span>，则<span class="math display">\[f(i) = \min_{j \in [0,i-1] \land \text{valid}(j,i)} \Big\{ f(j)+\Big(S_i - S_j \Big)^2\Big\}\]</span> 其中 <span class="math inline">\(\text{valid}(j,i)=[S_i - S_j\ge S_j - S_{g_j}]\)</span>。</p><p>注意到 <span class="math inline">\((a+b)^2 = a^2 + 2ab +b^2\)</span>，那么尽可能多地划分必然不劣，从而这个 DP 有决策单调性。</p><p>更进一步地，最优决策一定是最大的 <spanclass="math inline">\(j\)</span>，满足 <span class="math inline">\(S_i -S_j \ge S_j -S_{g_j}\)</span>，移项得到 <span class="math inline">\(S_i\ge 2S_j - S_{g_j}\)</span>，不妨设 <span class="math inline">\(h(j) =2S_j - S_{g_j}\)</span>。</p><p>这个值不一定是单调的，但是考虑对于一个 <spanclass="math inline">\(j&#39; &lt; j\)</span>，如果 <spanclass="math inline">\(h(j&#39;) \ge h(j)\)</span>，那么 <spanclass="math inline">\(j&#39;\)</span>就是无用决策。同时决策集合在序列上单调增大，所以用单调队列维护这个二维偏序关系的最优解即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class="note note-info">            <p>下面的代码只能拿到 <span class="math inline">\(\text{88pts}\)</span>。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, type, s[N], f[N], g[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*s[x]-s[g[x]]; &#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), type=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">if</span>(type) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<br>    q[++r]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[l+<span class="hljs-number">1</span>])&lt;=s[i]) ++l;<br>        g[i]=q[l], f[i]=f[g[i]]+<span class="hljs-built_in">squ</span>(s[i]-s[g[i]]);<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[r])&gt;=<span class="hljs-built_in">calc</span>(i)) --r;<br>        q[++r]=i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;容易想到一个暴力 DP。设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i)&#92;)&lt;/span&gt;
为划分 &lt;span class=&quot;math inline&quot;&gt;&#92;([1,i]&#92;)&lt;/span&gt;</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="单调队列" scheme="https://yozora0908.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="决策单调性" scheme="https://yozora0908.top/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>lg9655「GROI-R2」 Beside You</title>
    <link href="https://yozora0908.top/2023/lg9655-solution/"/>
    <id>https://yozora0908.top/2023/lg9655-solution/</id>
    <published>2023-10-23T14:10:48.000Z</published>
    <updated>2023-10-23T14:48:57.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><h3 id="subtask-2">Subtask 2</h3><p>考虑合法括号序列的另一种意义。</p><p>将 <code>(</code>看作 <spanclass="math inline">\(1\)</span>，<code>)</code>看作 <spanclass="math inline">\(-1\)</span>，那么合法括号序列满足：</p><ol type="1"><li>总和为 <span class="math inline">\(0\)</span>。</li><li>任意前缀和不小于 <span class="math inline">\(0\)</span>。</li></ol><p>但是从左往右匹配的过程不是很适合树形结构，所以我们反过来，把<code>)</code>看作 <spanclass="math inline">\(1\)</span>，<code>(</code>看作 <spanclass="math inline">\(-1\)</span>。设 <spanclass="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，自底向上到达 <spanclass="math inline">\(x\)</span> 时，总和为 <spanclass="math inline">\(i\)</span> 的所有路径的点数之和。</p><p>可能会有负数，但它们都是废状态，因此有 <span class="math inline">\(i\ge 0\)</span>。</p><p>求出以 <span class="math inline">\(x\)</span> 为根的最长链 <spanclass="math inline">\(g_x\)</span>，容易得到转移</p><p><span class="math display">\[f_{x,i} = \Big( \sum_{y \in son(x)} f_{y,i+\Delta} \Big) + 1\]</span></p><p>其中当 <span class="math inline">\(x\)</span> 为<code>(</code>时，<span class="math inline">\(\Delta = 1\)</span>，否则<span class="math inline">\(\Delta=-1\)</span>。</p><p>具体实现还有若干细节。</p><ol type="1"><li>只有方程中的和式大于 <span class="math inline">\(0\)</span> 时才会<span class="math inline">\(+1\)</span>。</li><li>特判 <code>)</code>是叶子的情况。</li></ol><p>答案是 <span class="math inline">\(\max\{ f_{x,0} \}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3005</span>;<br><span class="hljs-type">int</span> n, ans, f[N][N], g[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    g[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        g[x]=<span class="hljs-built_in">max</span>(g[x],g[y]+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=g[y];++i) &#123;<br>            <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;)&#x27;</span>) f[x][i+<span class="hljs-number">1</span>]+=f[y][i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) f[x][i<span class="hljs-number">-1</span>]+=f[y][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=g[x];++i) <span class="hljs-keyword">if</span>(f[x][i]&gt;<span class="hljs-number">0</span>) f[x][i]+=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;!f[x][<span class="hljs-number">1</span>]) f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    ans=<span class="hljs-built_in">max</span>(ans,f[x][<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="subtask-6-algo1">Subtask 6 Algo#1</h3><p>由于这个 DP中有用的值不多，并且转移有明显的合并意味，考虑用树上启发式合并优化。</p><p>对每个结点维护一个 <code>std::map</code>，同时用标记 <spanclass="math inline">\(dlt\)</span> 维护下标的偏移量，用标记 <spanclass="math inline">\(val\)</span> 维护值的偏移量。</p><p>具体细节见代码。</p><p>复杂度 <span class="math inline">\(O(n \log^2n)\)</span>，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>, val=<span class="hljs-number">0</span>;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(node&amp; x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">size</span>()&lt;x.p.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-built_in">swap</span>(dlt,x.dlt);<br>            <span class="hljs-built_in">swap</span>(val,x.val);<br>            <span class="hljs-built_in">swap</span>(p,x.p);<br>            <span class="hljs-comment">// 启发式合并</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:x.p) &#123;<br>            <span class="hljs-type">int</span> y=t.fi+x.dlt-dlt, cnt=t.se;<br>            <span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">count</span>(y)) p[y]=-val;<br>            p[y]+=cnt+x.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(p.<span class="hljs-built_in">size</span>()&amp;&amp;p.<span class="hljs-built_in">begin</span>()-&gt;fi+dlt&lt;<span class="hljs-number">0</span>) p.<span class="hljs-built_in">erase</span>(p.<span class="hljs-built_in">begin</span>());<br>        <span class="hljs-comment">// 干掉&lt;0的废状态</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">count</span>(-dlt)) p[-dlt]=-val;<br>        <span class="hljs-comment">// 初始化0状态</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">count</span>(-dlt)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> p[-dlt]+val;<br>        <span class="hljs-comment">// 求f[x][0]</span><br>    &#125;<br>&#125; f[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        f[x].<span class="hljs-built_in">merge</span>(f[y]);<br>    &#125;<br>    f[x].<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;(&#x27;</span>) --f[x].dlt; <span class="hljs-keyword">else</span> ++f[x].dlt;<br>    f[x].<span class="hljs-built_in">reduce</span>();<br>    ++f[x].val;<br>    ans=<span class="hljs-built_in">max</span>(ans,f[x].<span class="hljs-built_in">get</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="subtask-6-algo-2">Subtask 6 Algo #2</h3><p>考虑一个性质：以 <span class="math inline">\(x\)</span>为根的合法连通块，一定可以拆成若干条匹配路径，而与每个点匹配的括号最有只有一个。</p><p>设与右括号 <span class="math inline">\(x\)</span> 匹配的左括号为<span class="math inline">\(\text{match}(x)\)</span>，在 <spanclass="math inline">\(\text{DFS}\)</span>时维护一个栈就不难求出。并且我们能发现由于 <spanclass="math inline">\([\text{match}(x),x]\)</span>是一个合法串，所以中间那些括号只能加入这个区间里的连通块，从而一定能被<span class="math inline">\(\Big(\text{match}(x),x\Big)\)</span>这个连通块代替，因此我们只需要考虑极长括号。</p><p>考虑不断把极长括号加入连通块。初始时每个点各为一个集合，在 <spanclass="math inline">\(\text{DFS}\)</span> 的过程中把 <spanclass="math inline">\(x\)</span> 合并到 <spanclass="math inline">\(\text{match}(x)\)</span>所在集合中，表示这条路径加入了以 <spanclass="math inline">\(\text{match(x)}\)</span>为根的连通块。对于极长括号间的合并，在合并完 <spanclass="math inline">\(x\)</span> 后，尝试把 <spanclass="math inline">\(\text{match}(x)\)</span> 合并到其父亲处即可。</p><p>还有最后一个问题，我们得到的是一个点集，如何确定连通块的大小呢？有一个经典结论：对于一个树上点集<span class="math inline">\(S\)</span>，其导出连通块大小为</p><p><span class="math display">\[\frac{\sum_{x \in \text{cyc}(S)} \text{dis}(x,nxt_x) }{2} + 1\]</span></p><p>其中 <span class="math inline">\(\text{cyc}(S)\)</span> 是将 <spanclass="math inline">\(S\)</span> 中所有点按照 <spanclass="math inline">\(dfn\)</span> 排序后相邻节点形成的环，<spanclass="math inline">\(nxt_x\)</span> 是对环定向后，环上 <spanclass="math inline">\(x\)</span> 的相邻节点。注意当 <spanclass="math inline">\(|S|=1\)</span> 时不合法，不能 <spanclass="math inline">\(+1\)</span>。</p><p>用并查集维护连通块，同时启发式合并，复杂度 <spanclass="math inline">\(O(n \log^2 n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, num, ans, dfn[N], match[N];<br><span class="hljs-type">int</span> tp, st[N];<br><span class="hljs-type">int</span> fa[N], son[N], top[N], dep[N], sz[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>    <span class="hljs-type">int</span> fa[N], sz[N];<br>    vector&lt;<span class="hljs-type">int</span>&gt; s[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, sz[i]=<span class="hljs-number">1</span>, s[i].<span class="hljs-built_in">pb</span>(i); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<br>        x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<br>        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(sz[x]&lt;sz[y]) <span class="hljs-built_in">swap</span>(x,y);<br>        fa[y]=x, sz[x]+=sz[y];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> z:s[y]) s[x].<span class="hljs-built_in">pb</span>(z);<br>    &#125;<br>&#125; dsu;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fat)</span> </span>&#123;<br>    fa[x]=fat;<br>    sz[x]=<span class="hljs-number">1</span>;<br>    dep[x]=dep[fa[x]]+<span class="hljs-number">1</span>;<br>    dfn[x]=++num;<br>    <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;(&#x27;</span>) st[++tp]=x;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(!tp) match[x]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> match[x]=st[tp--];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        sz[x]+=sz[y];<br>        <span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;(&#x27;</span>) --tp; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(match[x]) st[++tp]=match[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> TP)</span> </span>&#123;<br>    top[x]=TP;<br>    <span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[x],TP);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) &#123;<br>        <span class="hljs-built_in">dfs2</span>(y,y);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<br>        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);<br>        x=fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> z=<span class="hljs-built_in">LCA</span>(x,y);<br>    <span class="hljs-keyword">return</span> dep[x]+dep[y]<span class="hljs-number">-2</span>*dep[z];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) <span class="hljs-built_in">dfs3</span>(y);<br>    <span class="hljs-type">int</span> to=match[x];<br>    <span class="hljs-keyword">if</span>(!to) <span class="hljs-keyword">return</span>;<br>    dsu.<span class="hljs-built_in">merge</span>(x,to);<br>    <span class="hljs-keyword">if</span>(match[fa[to]]) dsu.<span class="hljs-built_in">merge</span>(to,fa[to]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> dfn[x]&lt;dfn[y]; &#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    dsu.<span class="hljs-built_in">init</span>();<br>    <span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<br>        <span class="hljs-built_in">sort</span>(dsu.s[i].<span class="hljs-built_in">begin</span>(),dsu.s[i].<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j+<span class="hljs-number">1</span>&lt;dsu.s[i].<span class="hljs-built_in">size</span>();++j) res+=<span class="hljs-built_in">dis</span>(dsu.s[i][j],dsu.s[i][j+<span class="hljs-number">1</span>]);<br>        res+=<span class="hljs-built_in">dis</span>(dsu.s[i][<span class="hljs-number">0</span>],dsu.s[i].<span class="hljs-built_in">back</span>());<br>        res=res/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(res) ++res;<br>        ans=<span class="hljs-built_in">max</span>(ans,res);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;h3 id=&quot;subtask-2&quot;&gt;Subtask 2&lt;/h3&gt;
&lt;p&gt;考虑合法括号序列的另一种意义。&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;(&lt;/code&gt;看作 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，&lt;code&gt;)&lt;/code&gt;看作 &lt;span class=&quot;math inline&quot;&gt;&#92;(-1&#92;)&lt;/span&gt;，那么合法括号序列满足：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;总和为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;任意前缀和不小于 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是从左往右匹配的过程不是很适合树形结构，所以我们反过来，把
&lt;code&gt;)&lt;/code&gt;看作 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，&lt;code&gt;(&lt;/code&gt;看作 &lt;span class=&quot;math inline&quot;&gt;&#92;(-1&#92;)&lt;/span&gt;。设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f_{x,i}&#92;)&lt;/span&gt; 为以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树中，自底向上到达 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 时，总和为 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 的所有路径的点数之和。&lt;/p&gt;
&lt;p&gt;可能会有负数，但它们都是废状态，因此有 &lt;span class=&quot;math inline&quot;&gt;&#92;(i
&#92;ge 0&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;求出以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的最长链 &lt;span class=&quot;math inline&quot;&gt;&#92;(g_x&#92;)&lt;/span&gt;，容易得到转移&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
f_{x,i} = &#92;Big( &#92;sum_{y &#92;in son(x)} f_{y,i+&#92;Delta} &#92;Big) + 1
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中当 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为
&lt;code&gt;(&lt;/code&gt;时，&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Delta = 1&#92;)&lt;/span&gt;，否则
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Delta=-1&#92;)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="树论" scheme="https://yozora0908.top/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="启发式合并" scheme="https://yozora0908.top/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
    <category term="并查集" scheme="https://yozora0908.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="括号序列" scheme="https://yozora0908.top/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>lg9166「联合省选 2023」火车站 题解</title>
    <link href="https://yozora0908.top/2023/lg9166-solution/"/>
    <id>https://yozora0908.top/2023/lg9166-solution/</id>
    <published>2023-10-23T14:10:42.000Z</published>
    <updated>2023-10-23T14:47:38.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>先只考虑往右边开的情况。</p><p>我们先把每个车站被轨道覆盖的次数 <spanclass="math inline">\(c_i\)</span> 差分出来。注意到达 <spanclass="math inline">\(r_i\)</span> 时就停下来了，所以实际的覆盖范围是<span class="math inline">\([l_i,r_i-1]\)</span>。</p><p>然后能到达的车站一定是 <span class="math inline">\(x\)</span>往右连续的一段非 <span class="math inline">\(0\)</span> 位置。</p><p>这样有一个问题，只有到达 <span class="math inline">\(r_i\)</span>才把 <span class="math inline">\(i\)</span> 计入答案，而我们没有覆盖<span class="math inline">\(r_i\)</span>。</p><p>仔细思考不难发现，如果 <span class="math inline">\(r_i\)</span> 在非<span class="math inline">\(0\)</span>段内，那么就一定能被统计到，会漏掉的仅仅是最后一个，特判即可。</p><p>对于往左边，类似处理即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, x, l0, r0, l[N], r[N], tag[N], c[N], d[N];<br><span class="hljs-type">int</span> ans[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>l[i]=<span class="hljs-built_in">read</span>(), r[i]=<span class="hljs-built_in">read</span>();<br>++c[l[i]], --c[r[i]], tag[r[i]]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) c[i]+=c[i<span class="hljs-number">-1</span>];<br>l0=r0=x;<br><span class="hljs-keyword">while</span>(r0&lt;n&amp;&amp;c[r0]) &#123;<br>++r0;<br><span class="hljs-keyword">if</span>(tag[r0]) ans[r0]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) tag[i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>++d[r[i]], --d[l[i]], tag[l[i]]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) d[i]+=d[i+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span>(l0&gt;<span class="hljs-number">1</span>&amp;&amp;d[l0]) &#123;<br>--l0;<br><span class="hljs-keyword">if</span>(tag[l0]) ans[l0]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(ans[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,i);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;先只考虑往右边开的情况。&lt;/p&gt;
&lt;p&gt;我们先把每个车站被轨道覆盖的次数 &lt;span
class=&quot;math inline&quot;&gt;&#92;(c_i&#92;)&lt;/span&gt; 差分出来。注意到达 &lt;span
class=&quot;</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="差分" scheme="https://yozora0908.top/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>luogu8595「KDOI-02」一个网的路 题解</title>
    <link href="https://yozora0908.top/2023/lg8595-solution/"/>
    <id>https://yozora0908.top/2023/lg8595-solution/</id>
    <published>2023-10-23T14:10:35.000Z</published>
    <updated>2023-10-23T14:45:56.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>考虑点 <span class="math inline">\(x\)</span>被炸毁后会发生什么。</p><p>显然是与其子节点形成的链再连成一条链，它不一定是链头。但这个信息是没用的，因为此时怎么连，连成什么样子的代价都相同，并且没有后效性，到<span class="math inline">\(fa(x)\)</span>的边已经没了，再往外连的代价都是 <spanclass="math inline">\(1\)</span>。</p><p>而如果不选择炸毁，则不同的形态是有后效性的。由于到 <spanclass="math inline">\(fa(x)\)</span>的边保留了，所以要么此时子树搞成一条链，要么 <spanclass="math inline">\(x\)</span>是链中的一部分，也就是连了两个儿子的链。后者要想接上就必须干掉到 <spanclass="math inline">\(fa(x)\)</span> 的边。</p><p>对每棵树分别考虑。</p><p>设 <span class="math inline">\(f(x,0/1/2)\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，其中 <spanclass="math inline">\(x\)</span></p><ol start="0" type="1"><li>炸毁。</li><li>不炸毁，<span class="math inline">\(x\)</span> 是链头。</li><li>不炸毁，<span class="math inline">\(x\)</span> 不是链。</li></ol><p>使得整个子树为一条链的最小代价。 <span class="math display">\[f(x,0) = 1 + \sum_{y \in son(x)} \min\Big\{ f(y,0),f(y,1),f(y,2)\Big\} +|son_x|\]</span> 对于 <spanclass="math inline">\(f(x,1)\)</span>，至多有一个儿子没有被炸毁，对于<span class="math inline">\(f(x,2)\)</span>则是两个。同时二者的儿子中不允许出现 <spanclass="math inline">\(f(y,2)\)</span>。</p><p>可以先令二者为 <span class="math display">\[\sum_{y \in son(x)} \Big( f(y,0)+1 \Big)\]</span> 然后维护 <span class="math inline">\(\Delta = f(y,1) - f(y,0)- 1\)</span> 的最小和次小值，如果更优就换出来。</p><p>注意不要求换够相应的数量。</p><p>把每棵树的答案累加，最后加上 <spanclass="math inline">\(n-m-1\)</span> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e15</span>;<br><span class="hljs-type">int</span> n, m, ans, f[N][<span class="hljs-number">3</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-type">bool</span> v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    v[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> w[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// 注意这里是取最大值然后减掉</span><br>    <span class="hljs-comment">// 如果&lt;0那么就不换了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">min</span>(&#123;f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>],f[y][<span class="hljs-number">2</span>]&#125;);<br>        dlt+=f[y][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t=f[y][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>-f[y][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(t&gt;w[<span class="hljs-number">0</span>]) w[<span class="hljs-number">1</span>]=w[<span class="hljs-number">0</span>], w[<span class="hljs-number">0</span>]=t;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;w[<span class="hljs-number">1</span>]) w[<span class="hljs-number">1</span>]=t;<br>    &#125;<br>    f[x][<span class="hljs-number">0</span>]+=p[x].<span class="hljs-built_in">size</span>()-(fa!=<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>;<br>    f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">2</span>]=dlt;<br>    f[x][<span class="hljs-number">1</span>]-=w[<span class="hljs-number">0</span>], f[x][<span class="hljs-number">2</span>]-=w[<span class="hljs-number">0</span>]+w[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;<br>        <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>        ans+=<span class="hljs-built_in">min</span>(&#123;f[i][<span class="hljs-number">0</span>],f[i][<span class="hljs-number">1</span>],f[i][<span class="hljs-number">2</span>]&#125;);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans+n-m<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;考虑点 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
被炸毁后会发生什么。&lt;/p&gt;
&lt;p&gt;显然是与其子节点形成的链再连成一条链，它不一定是链头。但这个信息是没用的，因为此时怎么连，连成什么样子的代价都相同，并且没有后效性，到
&lt;span class=&quot;math inline&quot;&gt;&#92;(fa(x)&#92;)&lt;/span&gt;
的边已经没了，再往外连的代价都是 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;而如果不选择炸毁，则不同的形态是有后效性的。由于到 &lt;span class=&quot;math inline&quot;&gt;&#92;(fa(x)&#92;)&lt;/span&gt;
的边保留了，所以要么此时子树搞成一条链，要么 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
是链中的一部分，也就是连了两个儿子的链。后者要想接上就必须干掉到 &lt;span class=&quot;math inline&quot;&gt;&#92;(fa(x)&#92;)&lt;/span&gt; 的边。&lt;/p&gt;
&lt;p&gt;对每棵树分别考虑。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,0/1/2)&#92;)&lt;/span&gt; 为以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;0&quot; type=&quot;1&quot;&gt;
&lt;li&gt;炸毁。&lt;/li&gt;
&lt;li&gt;不炸毁，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 是链头。&lt;/li&gt;
&lt;li&gt;不炸毁，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 不是链。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使得整个子树为一条链的最小代价。 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(x,0) = 1 + &#92;sum_{y &#92;in son(x)} &#92;min&#92;Big&#92;{ f(y,0),f(y,1),f(y,2)&#92;Big&#92;} +
|son_x|
&#92;]&lt;/span&gt; 对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,1)&#92;)&lt;/span&gt;，至多有一个儿子没有被炸毁，对于
&lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,2)&#92;)&lt;/span&gt;
则是两个。同时二者的儿子中不允许出现 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(y,2)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;可以先令二者为 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sum_{y &#92;in son(x)} &#92;Big( f(y,0)+1 &#92;Big)
&#92;]&lt;/span&gt; 然后维护 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Delta = f(y,1) - f(y,0)
- 1&#92;)&lt;/span&gt; 的最小和次小值，如果更优就换出来。&lt;/p&gt;
&lt;p&gt;注意不要求换够相应的数量。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="贪心" scheme="https://yozora0908.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>luogu8593「KDOI-02」一个弹的投 题解</title>
    <link href="https://yozora0908.top/2023/lg8593-solution/"/>
    <id>https://yozora0908.top/2023/lg8593-solution/</id>
    <published>2023-10-23T14:10:25.000Z</published>
    <updated>2023-10-23T14:45:03.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>我们先求出最后每个炸弹的威力值。</p><p>运用高一物理知识，考虑何时两颗导弹会相撞。</p><p>首先一定满足纵坐标相同，然后我们考虑相撞时间 <spanclass="math inline">\(t\)</span> 的范围，有 <spanclass="math inline">\(0 \le t \le \sqrt{\frac{2y_i}{g}}\)</span>，设其为<spanclass="math inline">\(k_i\)</span>。把纵坐标离散化，相同的点提取出来分别统计。</p><p>考虑 <span class="math inline">\((x_i,y_i)\)</span> 与 <spanclass="math inline">\((x_j,y_i)\)</span>，假设它们能相撞，分两种情况讨论：</p><p><span class="math inline">\(x_i&lt; x_j\)</span>。</p><p>此时的方程是 <span class="math display">\[\begin{aligned}x_j - x_i &amp; \le (v_i - v_j) k_i\\x_j + k_i v_j &amp; \le x_i + k_i v_i\end{aligned}\]</span></p><p><span class="math inline">\(x_i &gt; x_j\)</span>。</p>此时 $$<span class="math display">\[\begin{aligned}x_i - x_j &amp; \le (v_j - v_i)k_i\\x_i + v_ik_i &amp; \le x_j + k_iv_j\end{aligned}\]</span><p>$$</p><p>把 <span class="math inline">\(x_i + v_ik_i\)</span>离散化，把所有点按照 <span class="math inline">\(x_i\)</span>递增排序，树状数组一遍正着插入查后缀，一遍倒着插入查前缀即可。</p><p>做到这里还没完，因为不同纵坐标的炸弹可能有相同落点，代码里偷懒开了个<code>std::unordered_map</code>暴力统计。</p><p>最后因为我们要最小化总和，所以贪心选择能减少威力最多的反制武器即可。</p><p>注意排序后下标会改变，最好把 <span class="math inline">\(a_i\)</span>放到结构体里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> g=<span class="hljs-number">9.8</span>;<br><span class="hljs-type">int</span> n, m, d[N], w[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y, v, d, iv;<br>    <span class="hljs-type">double</span> val;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; b) &#123; <span class="hljs-keyword">return</span> x&lt;b.x; &#125;<br>&#125; a[N];<br><span class="hljs-type">int</span> tot1, t[N];<br><span class="hljs-type">int</span> tot;<br><span class="hljs-type">double</span> tmp[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-type">double</span> k[N];<br><span class="hljs-type">bool</span> v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+tot1+<span class="hljs-number">1</span>);<br>    tot1=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+tot1+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>        a[i].y=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+tot1+<span class="hljs-number">1</span>,a[i].y)-t;<br>        p[a[i].y].<span class="hljs-built_in">pb</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pBIT</span> &#123;<br>    <span class="hljs-type">int</span> lim=<span class="hljs-number">0</span>, c[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i) c[i]=<span class="hljs-number">0</span>; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(;x&lt;=lim;x+=x&amp;-x) c[x]+=d;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; pre;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sBIT</span> &#123;<br>    <span class="hljs-type">int</span> lim=<span class="hljs-number">0</span>, c[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i) c[i]=<span class="hljs-number">0</span>; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) c[x]+=d;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;x&lt;=lim;x+=x&amp;-x) res+=c[x];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; suf;<br>unordered_map&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v,<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    tot=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) &#123;<br>        <span class="hljs-comment">// printf(&quot;x=%lld\n&quot;,x);</span><br>        tmp[++tot]=a[x].val=<span class="hljs-number">1.0</span>*a[x].x+k[i]*a[x].v;<br>        ++mp[a[x].val];<br>        <span class="hljs-comment">// printf(&quot;val[%lld]=%.3lf\n&quot;,x,a[x].val);</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(tmp+<span class="hljs-number">1</span>,tmp+tot+<span class="hljs-number">1</span>);<br>    tot=<span class="hljs-built_in">unique</span>(tmp+<span class="hljs-number">1</span>,tmp+tot+<span class="hljs-number">1</span>)-(tmp+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) &#123;<br>        a[x].iv=<span class="hljs-built_in">lower_bound</span>(tmp+<span class="hljs-number">1</span>,tmp+tot+<span class="hljs-number">1</span>,a[x].val)-tmp;<br>    &#125;<br>    pre.<span class="hljs-built_in">clear</span>();<br>    suf.<span class="hljs-built_in">clear</span>();<br>    pre.lim=suf.lim=tot;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();++i) &#123;<br>        w[v[i]]+=suf.<span class="hljs-built_in">query</span>(a[v[i]].iv);<br>        suf.<span class="hljs-built_in">upd</span>(a[v[i]].iv,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;~i;--i) &#123;<br>        w[v[i]]+=pre.<span class="hljs-built_in">query</span>(a[v[i]].iv);<br>        pre.<span class="hljs-built_in">upd</span>(a[v[i]].iv,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>        a[i].x=<span class="hljs-built_in">read</span>(), a[i].y=<span class="hljs-built_in">read</span>(), a[i].v=<span class="hljs-built_in">read</span>();<br>        t[++tot1]=a[i].y;<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].d=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">lsh</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,tot1) &#123;<br>        k[i]=<span class="hljs-number">1.0</span>*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.0</span>*t[i]/g);<br>        <span class="hljs-built_in">solve</span>(p[i],i);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,tot1) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) --mp[a[x].val];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) w[x]+=mp[a[x].val];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) ++mp[a[x].val];<br>    &#125;<br>    <span class="hljs-comment">// rep(i,1,n) printf(&quot;w[%lld]=%lld\n&quot;,i,w[i]);</span><br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    priority_queue&lt;PII &gt; q;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>        q.<span class="hljs-built_in">push</span>(&#123;w[i]-<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,w[i]-a[i].d),i&#125;);<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()&amp;&amp;cnt&lt;m) &#123;<br>        PII aa=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        v[aa.se]=<span class="hljs-number">1</span>;<br>        ans+=w[aa.se]-aa.fi;<br>        ++cnt;<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) ans+=w[i];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;我们先求出最后每个炸弹的威力值。&lt;/p&gt;
&lt;p&gt;运用高一物理知识，考虑何时两颗导弹会相撞。&lt;/p&gt;
&lt;p&gt;首先一定满足纵坐标相同，然后我们考虑相撞时间 &lt;span class=&quot;math inline&quot;&gt;&#92;(t&#92;)&lt;/span&gt; 的范围，有 &lt;span class=&quot;math inline&quot;&gt;&#92;(0 &#92;le t &#92;le &#92;sqrt{&#92;frac{2y_i}{g}}&#92;)&lt;/span&gt;，设其为
&lt;span class=&quot;math inline&quot;&gt;&#92;(k_i&#92;)&lt;/span&gt;。把纵坐标离散化，相同的点提取出来分别统计。&lt;/p&gt;
&lt;p&gt;考虑 &lt;span class=&quot;math inline&quot;&gt;&#92;((x_i,y_i)&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;((x_j,y_i)&#92;)&lt;/span&gt;，假设它们能相撞，分两种情况讨论：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(x_i&amp;lt; x_j&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此时的方程是 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
x_j - x_i &amp;amp; &#92;le (v_i - v_j) k_i
&#92;&#92;
x_j + k_i v_j &amp;amp; &#92;le x_i + k_i v_i
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(x_i &amp;gt; x_j&#92;)&lt;/span&gt;。&lt;/p&gt;
此时 $$
&lt;span class=&quot;math display&quot;&gt;&#92;[&#92;begin{aligned}
x_i - x_j &amp;amp; &#92;le (v_j - v_i)k_i
&#92;&#92;
x_i + v_ik_i &amp;amp; &#92;le x_j + k_iv_j

&#92;end{aligned}&#92;]&lt;/span&gt;
&lt;p&gt;$$&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="贪心" scheme="https://yozora0908.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二维偏序" scheme="https://yozora0908.top/tags/%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>luogu8476「GLR-R3」惊蛰 题解</title>
    <link href="https://yozora0908.top/2023/lg8476-solution/"/>
    <id>https://yozora0908.top/2023/lg8476-solution/</id>
    <published>2023-10-23T14:09:55.000Z</published>
    <updated>2023-10-23T14:43:29.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>考虑一个朴素的 DP。设 <span class="math inline">\(g(i,j)\)</span>为考虑到第 <span class="math inline">\(i\)</span> 个元素，其中 <spanclass="math inline">\(b_i=j\)</span> 时的最小代价。转移比较显然： <spanclass="math display">\[g(i,j) = \min_{k \ge j} \Big\{ g(i-1,k) \Big\} + f(j,a_i)\]</span> 复杂度 <span class="math inline">\(O(nV)\)</span>。</p><p><span class="math inline">\(f\)</span> 关于 <spanclass="math inline">\(a_i\)</span> 分两段有单调性，所以我们可以把 <spanclass="math inline">\(\{a\}\)</span> 离散化掉，下文 <spanclass="math inline">\(a_i\)</span> 均为离散化后的值，其真实值为 <spanclass="math inline">\(v(a_i)\)</span>。重设 <spanclass="math inline">\(g(i,j)\)</span> 为考虑到第 <spanclass="math inline">\(i\)</span> 个元素，其中 <spanclass="math inline">\(b_j=a_i\)</span> 时的最小代价。复杂度 <spanclass="math inline">\(O(n^2)\)</span>。</p><p>考虑转移的本质：取后缀 <span class="math inline">\(\min\)</span>后加上 <span class="math inline">\(f\)</span>，而 <spanclass="math inline">\(f\)</span> 有很强的单调性。</p><p><span class="math inline">\(i-1\)</span> 阶段取后缀 <spanclass="math inline">\(\min\)</span> 后有 <spanclass="math inline">\(g(i-1,j) \le g(i-1,j+1)\)</span>。对于阶段 <spanclass="math inline">\(i-1\)</span> 转移到阶段 <spanclass="math inline">\(i\)</span> 的过程，<span class="math inline">\(j\in [1,a_i-1]\)</span> 的状态都要加上 <spanclass="math inline">\(C\)</span>，<span class="math inline">\(j \in[a_i+1,m]\)</span> 的状态都要加上 <span class="math inline">\(j -v(a_i)\)</span>。两部分都不会对各自的单调性产生影响，所以只需要考虑<span class="math inline">\(j = a_i\)</span> 这个状态的影响。</p><p>由于 <span class="math inline">\(j \in [1,a_i-1]\)</span>的状态有单调性，所以可以二分找到最小的满足 <spanclass="math inline">\(g&#39;(i-1,j_0) &gt; g(i-1,a_i)\)</span> 的 <spanclass="math inline">\(j_0\)</span>，对那一段赋值即可。</p><p>所以我们需要支持以下操作：</p><ul><li>区间加法。</li><li>区间关于下标的加法。</li><li>区间复制。</li><li>单点查。</li><li>二分。</li></ul><p>把 <span class="math inline">\(j\)</span>这一维拍到线段树上即可维护。</p><p>同时注意为了实现这个线段树上二分，需要维护区间 <spanclass="math inline">\(\max\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, C, a[N], c[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+n+<span class="hljs-number">1</span>);<br>m=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+n+<span class="hljs-number">1</span>)-(c+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>,a[i])-c;<br>&#125;<br><span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> ass=<span class="hljs-number">-1</span>, add=<span class="hljs-number">0</span>, w=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">node</span>() &#123;&#125;;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _ass,<span class="hljs-type">int</span> _add,<span class="hljs-type">int</span> _w) &#123; ass=_ass, add=_add, w=_w; &#125;<br>node <span class="hljs-keyword">operator</span>+(node a) &#123;<br><span class="hljs-keyword">if</span>(~a.ass) <span class="hljs-keyword">return</span> a;<br>node b=*<span class="hljs-keyword">this</span>;<br>b.add=add+a.add, b.w=w+a.w;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br>    <span class="hljs-comment">// 为了方便合并标记与进行操作从而定义结构体</span><br>&#125; tag[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> r,node d)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(d.ass!=<span class="hljs-number">-1</span>) t[x]=d.ass;<br>t[x]+=d.add+c[r]*d.w;<br>tag[x]=tag[x]+d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=<span class="hljs-built_in">max</span>(t[x&lt;&lt;<span class="hljs-number">1</span>],t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tag[x].ass!=<span class="hljs-number">-1</span>||tag[x].add!=<span class="hljs-number">0</span>||tag[x].w!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,mid,tag[x]);<br><span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,r,tag[x]);<br>tag[x].ass=<span class="hljs-number">-1</span>, tag[x].add=tag[x].w=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,node d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,r,d); <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-built_in">pushdown</span>(x,l,r);<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> t[x];<br><span class="hljs-built_in">pushdown</span>(x,l,r);<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;p) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(r&lt;=p&amp;&amp;t[x]&lt;k) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br><span class="hljs-built_in">pushdown</span>(x,l,r);<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> res=<span class="hljs-built_in">binsearch</span>(p,k,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-keyword">if</span>(~res) <span class="hljs-keyword">return</span> res;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">binsearch</span>(p,k,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), C=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=c[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">lsh</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br><span class="hljs-built_in">upd</span>(a[i]+<span class="hljs-number">1</span>,m,<span class="hljs-built_in">node</span>(<span class="hljs-number">-1</span>,-c[a[i]],<span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">upd</span>(<span class="hljs-number">1</span>,a[i]<span class="hljs-number">-1</span>,<span class="hljs-built_in">node</span>(<span class="hljs-number">-1</span>,C,<span class="hljs-number">0</span>));<br><span class="hljs-type">int</span> x=<span class="hljs-built_in">query</span>(a[i]);<br><span class="hljs-type">int</span> pos=<span class="hljs-built_in">binsearch</span>(a[i]<span class="hljs-number">-1</span>,x);<br><span class="hljs-keyword">if</span>(pos!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">upd</span>(pos,a[i]<span class="hljs-number">-1</span>,<span class="hljs-built_in">node</span>(x,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;考虑一个朴素的 DP。设 &lt;span class=&quot;math inline&quot;&gt;&#92;(g(i,j)&#92;)&lt;/span&gt;
为考虑到第 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 个元素，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(b_i=j&#92;)&lt;/span&gt; 时的最小代价。转移比较显然： &lt;span class=&quot;math display&quot;&gt;&#92;[
g(i,j) = &#92;min_{k &#92;ge j} &#92;Big&#92;{ g(i-1,k) &#92;Big&#92;} + f(j,a_i)
&#92;]&lt;/span&gt; 复杂度 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(nV)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; 关于 &lt;span class=&quot;math inline&quot;&gt;&#92;(a_i&#92;)&lt;/span&gt; 分两段有单调性，所以我们可以把 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{a&#92;}&#92;)&lt;/span&gt; 离散化掉，下文 &lt;span class=&quot;math inline&quot;&gt;&#92;(a_i&#92;)&lt;/span&gt; 均为离散化后的值，其真实值为 &lt;span class=&quot;math inline&quot;&gt;&#92;(v(a_i)&#92;)&lt;/span&gt;。重设 &lt;span class=&quot;math inline&quot;&gt;&#92;(g(i,j)&#92;)&lt;/span&gt; 为考虑到第 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 个元素，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(b_j=a_i&#92;)&lt;/span&gt; 时的最小代价。复杂度 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(n^2)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑转移的本质：取后缀 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;min&#92;)&lt;/span&gt;
后加上 &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt;，而 &lt;span class=&quot;math inline&quot;&gt;&#92;(f&#92;)&lt;/span&gt; 有很强的单调性。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(i-1&#92;)&lt;/span&gt; 阶段取后缀 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;min&#92;)&lt;/span&gt; 后有 &lt;span class=&quot;math inline&quot;&gt;&#92;(g(i-1,j) &#92;le g(i-1,j+1)&#92;)&lt;/span&gt;。对于阶段 &lt;span class=&quot;math inline&quot;&gt;&#92;(i-1&#92;)&lt;/span&gt; 转移到阶段 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 的过程，&lt;span class=&quot;math inline&quot;&gt;&#92;(j
&#92;in [1,a_i-1]&#92;)&lt;/span&gt; 的状态都要加上 &lt;span class=&quot;math inline&quot;&gt;&#92;(C&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(j &#92;in
[a_i+1,m]&#92;)&lt;/span&gt; 的状态都要加上 &lt;span class=&quot;math inline&quot;&gt;&#92;(j -
v(a_i)&#92;)&lt;/span&gt;。两部分都不会对各自的单调性产生影响，所以只需要考虑
&lt;span class=&quot;math inline&quot;&gt;&#92;(j = a_i&#92;)&lt;/span&gt; 这个状态的影响。&lt;/p&gt;
&lt;p&gt;由于 &lt;span class=&quot;math inline&quot;&gt;&#92;(j &#92;in [1,a_i-1]&#92;)&lt;/span&gt;
的状态有单调性，所以可以二分找到最小的满足 &lt;span class=&quot;math inline&quot;&gt;&#92;(g&amp;#39;(i-1,j_0) &amp;gt; g(i-1,a_i)&#92;)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;&#92;(j_0&#92;)&lt;/span&gt;，对那一段赋值即可。&lt;/p&gt;
&lt;p&gt;所以我们需要支持以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区间加法。&lt;/li&gt;
&lt;li&gt;区间关于下标的加法。&lt;/li&gt;
&lt;li&gt;区间复制。&lt;/li&gt;
&lt;li&gt;单点查。&lt;/li&gt;
&lt;li&gt;二分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt;
这一维拍到线段树上即可维护。&lt;/p&gt;
&lt;p&gt;同时注意为了实现这个线段树上二分，需要维护区间 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;max&#92;)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="线段树" scheme="https://yozora0908.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="决策单调性" scheme="https://yozora0908.top/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>luogu6419 Kamp 题解</title>
    <link href="https://yozora0908.top/2023/lg6419-solution/"/>
    <id>https://yozora0908.top/2023/lg6419-solution/</id>
    <published>2023-10-23T14:08:45.000Z</published>
    <updated>2023-10-23T14:42:36.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>貌似算是经典问题。</p><p>考虑定点怎么做，不令设它为根。</p><p>发现答案就是到所有关键点边权和的 <spanclass="math inline">\(2\)</span> 倍再减掉最长链。</p><p>维护最长链长度，次长链长度，子树内关键点数量，子树内边权和即可换根。</p><p>当然觉得不放心维护个最长链来源也行。</p><p>复杂度 <span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, k, f[N][<span class="hljs-number">2</span>], g[N], cnt[N], ans[N];<br><span class="hljs-type">bool</span> v[N];<br>vector&lt;PII &gt; p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=g[x]=cnt[x]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(v[x]) cnt[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<br>        <span class="hljs-type">int</span> y=t.fi, z=t.se;<br>        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        <span class="hljs-keyword">if</span>(cnt[y]) &#123;<br>            cnt[x]+=cnt[y];<br>            <span class="hljs-keyword">if</span>(f[y][<span class="hljs-number">0</span>]+z&gt;f[x][<span class="hljs-number">0</span>]) f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">0</span>], f[x][<span class="hljs-number">0</span>]=f[y][<span class="hljs-number">0</span>]+z;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[y][<span class="hljs-number">0</span>]+z&gt;f[x][<span class="hljs-number">1</span>]) f[x][<span class="hljs-number">1</span>]=f[y][<span class="hljs-number">0</span>]+z;<br>            g[x]+=g[y]+<span class="hljs-number">2</span>*z;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    ans[x]=g[x]-f[x][<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> fx0=f[x][<span class="hljs-number">0</span>], fx1=f[x][<span class="hljs-number">1</span>], gx=g[x], cx=cnt[x];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<br>        <span class="hljs-type">int</span> y=t.fi, z=t.se;<br>        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> fy0=f[y][<span class="hljs-number">0</span>], fy1=f[y][<span class="hljs-number">1</span>], gy=g[y], cy=cnt[y];<br>        <span class="hljs-keyword">if</span>(cnt[y]) &#123;<br>            cnt[x]-=cnt[y];<br>            g[x]-=g[y]+<span class="hljs-number">2</span>*z;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt[x]) &#123;<br>            cnt[y]+=cnt[x];<br>            g[y]+=g[x]+<span class="hljs-number">2</span>*z;<br>            <span class="hljs-keyword">if</span>(cnt[x]&amp;&amp;f[x][<span class="hljs-number">0</span>]!=f[y][<span class="hljs-number">0</span>]+z) &#123;<br>                <span class="hljs-keyword">if</span>(f[x][<span class="hljs-number">0</span>]+z&gt;f[y][<span class="hljs-number">0</span>]) f[y][<span class="hljs-number">1</span>]=f[y][<span class="hljs-number">0</span>], f[y][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">0</span>]+z;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[x][<span class="hljs-number">0</span>]+z&gt;f[y][<span class="hljs-number">1</span>]) f[y][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">0</span>]+z;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt[x]) &#123;<br>                <span class="hljs-keyword">if</span>(f[x][<span class="hljs-number">1</span>]+z&gt;f[y][<span class="hljs-number">0</span>]) f[y][<span class="hljs-number">1</span>]=f[y][<span class="hljs-number">0</span>], f[y][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]+z;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[x][<span class="hljs-number">1</span>]+z&gt;f[y][<span class="hljs-number">1</span>]) f[y][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]+z;<br>            &#125;<br>        &#125;<br>        <br><br>        <br>        <br>        <br>        <span class="hljs-built_in">dfs2</span>(y,x);<br><br>        f[x][<span class="hljs-number">0</span>]=fx0, f[x][<span class="hljs-number">1</span>]=fx1, g[x]=gx;<br>        f[y][<span class="hljs-number">0</span>]=fy0, f[y][<span class="hljs-number">1</span>]=fy1, g[y]=gy;<br>        cnt[x]=cx, cnt[y]=cy;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(&#123;y,z&#125;), p[y].<span class="hljs-built_in">pb</span>(&#123;x,z&#125;);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<br>        v[x]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// rep(i,1,n) &#123;</span><br>    <span class="hljs-comment">//     dfs(i,0);</span><br>    <span class="hljs-comment">//     printf(&quot;%lld\n&quot;,g[i]-f[i][0]);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;貌似算是经典问题。&lt;/p&gt;
&lt;p&gt;考虑定点怎么做，不令设它为根。&lt;/p&gt;
&lt;p&gt;发现答案就是到所有关键点边权和的 &lt;span
class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 倍再减掉最</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="换根法" scheme="https://yozora0908.top/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>lg5772「JSOI2016」位运算</title>
    <link href="https://yozora0908.top/2023/lg5772-solution/"/>
    <id>https://yozora0908.top/2023/lg5772-solution/</id>
    <published>2023-10-23T14:08:32.000Z</published>
    <updated>2023-10-23T15:02:24.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>先考虑确定了 <span class="math inline">\(R\)</span> 之后怎么做。</p><p><span class="math inline">\(n\)</span> 个数的异或和为 <spanclass="math inline">\(0\)</span>，常用的套路就是转化为每一位上出现奇数个<span class="math inline">\(1\)</span>。直接 DP 复杂度是 <spanclass="math inline">\(O(nR \log R)\)</span>的，貌似是一个低分暴力，然而我们要求这 <spanclass="math inline">\(n\)</span> 个数两两不同，这个 DP 不能解决。</p><p><del>然后就开题解了</del>。</p><p>由于要求 <span class="math inline">\(n\)</span>个数两两不同，所以钦定 <span class="math inline">\(x_0 &gt; x_1 &gt; x_2&gt; \cdots &gt; x_{n}\)</span>，其中 <span class="math inline">\(x_0 =0\)</span>。</p><p>我们考虑从高位到低位依次确定这 <span class="math inline">\(n\)</span>个数。在只考虑前 <span class="math inline">\(i\)</span> 位时，由于这<span class="math inline">\(n\)</span> 个数的异或和为 <spanclass="math inline">\(0\)</span>，所以它们的前 <spanclass="math inline">\(i\)</span> 位构成的数的异或和也必然为 <spanclass="math inline">\(0\)</span>，这是一个子问题。</p><p>同时可能会出现若干变量相等的情况，这个东西是有后效性的，会对之后的情况产生限制。由于<span class="math inline">\(n\)</span> 很小，所以我们用一个集合 <spanclass="math inline">\(S\)</span>表示状态。它刻画了以下情况：集合含有元素 <spanclass="math inline">\(j\)</span>，其中 <span class="math inline">\(j \in[1,n]\)</span>，那么说明在只考虑当前位的情况下，<spanclass="math inline">\(x_j = x_{j-1}\)</span>。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 为考虑了每个数的前<span class="math inline">\(i\)</span> 位，此时的状态为 <spanclass="math inline">\(S\)</span>的方案数。转移枚举每个数下一位值构成的集合 <spanclass="math inline">\(T\)</span>，只有当 <span class="math inline">\(|T|\bmod 2 = 0\)</span> 才合法，然后检查是否和 <spanclass="math inline">\(S\)</span> 冲突。如果不冲突，那么就能得到新状态<span class="math inline">\(S&#39;\)</span>，刷表即可。</p><p>然后考虑 <span class="math inline">\(k\)</span>。虽然 <spanclass="math inline">\(k\)</span>很大，但是我们能发现每一段都是相同的，DP时都是在做一样的事情，同时转移和具体数位没有关系，考虑矩阵加速。</p><p>没写完。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>, M=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>)+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, m, k, U, f[N][M];<br><span class="hljs-type">int</span> popcount[M];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<br>    <span class="hljs-type">int</span> m[M][M];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(m,<span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=U;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-type">int</span>* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> m[i]; &#125;<br>    Mat <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Mat&amp; b) <span class="hljs-type">const</span> &#123;<br>        Mat c;<br>        c.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=U;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=U;++k)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=U;++j)<br>                    (c.m[i][j]+=m[i][k]*b.m[k][j]%mod)%=mod;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125; base, trans;<br><span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat&amp; a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br>Mat c;<br>c.<span class="hljs-built_in">clear</span>();<br>c.<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<br>    m=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<br>    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,U) popcount[i]=popcount[i&gt;&gt;<span class="hljs-number">1</span>]+(i&amp;<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">rep</span>(ST,<span class="hljs-number">0</span>,U) &#123;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) <span class="hljs-built_in">memset</span>(f[i],<span class="hljs-number">0</span>,(U+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);<br>        f[<span class="hljs-number">0</span>][ST]=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(S0,<span class="hljs-number">0</span>,U) <span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>][S0]) &#123;<br>            <span class="hljs-built_in">rep</span>(T,<span class="hljs-number">0</span>,U) <span class="hljs-keyword">if</span>(popcount[T]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>                v[<span class="hljs-number">0</span>]=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) v[j]=(T&gt;&gt;(j<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>, S=<span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>((S0&gt;&gt;(j<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(v[j]&gt;v[j<span class="hljs-number">-1</span>]) &#123; fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;<br>                    <span class="hljs-keyword">if</span>(v[j]==v[j<span class="hljs-number">-1</span>]) S|=(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(fg) <span class="hljs-keyword">continue</span>;<br>                (f[i][S]+=f[i<span class="hljs-number">-1</span>][S0])%=mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<br>            trans[S][ST]=f[m][S];<br>        &#125;<br>    &#125;<br>    base[U][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <br>    <br>    <br>    base=<span class="hljs-built_in">fp</span>(trans,k)*base; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,base[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;先考虑确定了 &lt;span class=&quot;math inline&quot;&gt;&#92;(R&#92;)&lt;/span&gt; 之后怎么做。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个数的异或和为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;，常用的套路就是转化为每一位上出现奇数个
&lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;。直接 DP 复杂度是 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(nR &#92;log R)&#92;)&lt;/span&gt;
的，貌似是一个低分暴力，然而我们要求这 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个数两两不同，这个 DP 不能解决。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;然后就开题解了&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;由于要求 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;
个数两两不同，所以钦定 &lt;span class=&quot;math inline&quot;&gt;&#92;(x_0 &amp;gt; x_1 &amp;gt; x_2
&amp;gt; &#92;cdots &amp;gt; x_{n}&#92;)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(x_0 =
0&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们考虑从高位到低位依次确定这 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;
个数。在只考虑前 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 位时，由于这
&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个数的异或和为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;，所以它们的前 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 位构成的数的异或和也必然为 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;，这是一个子问题。&lt;/p&gt;
&lt;p&gt;同时可能会出现若干变量相等的情况，这个东西是有后效性的，会对之后的情况产生限制。由于
&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 很小，所以我们用一个集合 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;
表示状态。它刻画了以下情况：集合含有元素 &lt;span class=&quot;math inline&quot;&gt;&#92;(j&#92;)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(j &#92;in
[1,n]&#92;)&lt;/span&gt;，那么说明在只考虑当前位的情况下，&lt;span class=&quot;math inline&quot;&gt;&#92;(x_j = x_{j-1}&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,S)&#92;)&lt;/span&gt; 为考虑了每个数的前
&lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 位，此时的状态为 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;
的方案数。转移枚举每个数下一位值构成的集合 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;，只有当 &lt;span class=&quot;math inline&quot;&gt;&#92;(|T|
&#92;bmod 2 = 0&#92;)&lt;/span&gt; 才合法，然后检查是否和 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 冲突。如果不冲突，那么就能得到新状态
&lt;span class=&quot;math inline&quot;&gt;&#92;(S&amp;#39;&#92;)&lt;/span&gt;，刷表即可。&lt;/p&gt;
&lt;p&gt;然后考虑 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt;。虽然 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt;
很大，但是我们能发现每一段都是相同的，DP
时都是在做一样的事情，同时转移和具体数位没有关系，考虑矩阵加速。&lt;/p&gt;
&lt;p&gt;没写完。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="计数" scheme="https://yozora0908.top/tags/%E8%AE%A1%E6%95%B0/"/>
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="状态压缩" scheme="https://yozora0908.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="组合数学" scheme="https://yozora0908.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="矩阵加速" scheme="https://yozora0908.top/tags/%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3213「CSP-S 2019」树的重心</title>
    <link href="https://yozora0908.top/2023/loj3213-solution/"/>
    <id>https://yozora0908.top/2023/loj3213-solution/</id>
    <published>2023-10-23T14:07:38.000Z</published>
    <updated>2023-10-23T14:39:08.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>大常数做法。</p><p>不妨先钦定 <span class="math inline">\(1\)</span> 为根。</p><p>一棵树最多有两个重心，且如果有两个，那么它们相邻。</p><p>$ $</p><blockquote><p>对于一棵 <span class="math inline">\(n\)</span> 个节点的有根树 <spanclass="math inline">\(T\)</span>，如果节点 <spanclass="math inline">\(x\)</span> 是 <spanclass="math inline">\(T\)</span> 的重心，那么 <spanclass="math inline">\(x\)</span> 在以 <spanclass="math inline">\(\operatorname{root}(T)\)</span>为链头的重链上。</p></blockquote><p><span class="math inline">\(\mathbf{Proof}\)</span></p><blockquote><p>归纳法。</p><p>钦定根的深度为 <spanclass="math inline">\(1\)</span>，考虑从根开始往下寻找重心的过程。</p><p>当 <span class="math inline">\(\operatorname{dep}(x) = 1\)</span>时，显然正确。</p><p>设当前深度为 <span class="math inline">\(d\)</span>，且 <spanclass="math inline">\(\operatorname{dep}(x) &gt;d\)</span>，那么说明深度为 <span class="math inline">\(d\)</span>的这一层中有且仅有一棵大小超过 <span class="math inline">\(\lfloor\frac{n}{2} \rfloor\)</span> 的子树，根据重心的定义，<spanclass="math inline">\(x\)</span>必然在这棵子树中，并且这棵子树的根一定是它的父节点的重儿子，因此必须往下一层的重链移动。</p></blockquote><p>那么通过一遍 <span class="math inline">\(\operatorname{DFS}\)</span>求出子树大小，每个节点的父节点和重儿子。这样我们就能快速找到一个重心<spanclass="math inline">\(x\)</span>，并且如果存在另一个重心，那么一定是<span class="math inline">\(x\)</span> 的父亲或重儿子之一。</p><p>找重心的过程相当于从根不断往下跳重儿子，于是可以用倍增优化。</p><p>考虑如何维护断掉一条边分裂出的两棵树的信息。</p><p>其实就和换根差不多，在 <spanclass="math inline">\(\operatorname{DFS}\)</span>的过程中维护信息，回溯时还原即可。</p><p>具体地，对于一条边 <spanclass="math inline">\((x,y)\)</span>，在搜到它的时候是为把这条边断开，分裂成以<span class="math inline">\(x\)</span> 为根和以 <spanclass="math inline">\(y\)</span>为根两棵子树，同时更新两个节点的信息。前者是一棵「倒」着的树，需要不断<span class="math inline">\(\operatorname{DFS}\)</span>扩展得到最新的信息，后者的信息就是第一次处理出来的，所以用 <spanclass="math inline">\(y\)</span> 和 <spanclass="math inline">\(fa(x)\)</span> 更新 <spanclass="math inline">\(x\)</span> 就行了。</p><p>注意 <span class="math inline">\(y\)</span> 可能在原树中是 <spanclass="math inline">\(x\)</span>的重儿子，所以还要维护原树中次重儿子是哪个节点。</p><p>复杂度 <span class="math inline">\(\mathcal{O}(n \logn)\)</span>，但是常数很大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> T, n, sz[N];<br><span class="hljs-type">int</span> son[N], son2[N], lg[N], f[N][<span class="hljs-number">19</span>];<br>ll ans;<br><span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<br>to[++tot]=y, nxt[tot]=h[x], h[x]=tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>tot=ans=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) son[x]=son2[x]=<span class="hljs-number">0</span>, h[x]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>sz[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<br><span class="hljs-type">int</span> y=to[i];<br><span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(y,x);<br>sz[x]+=sz[y];<br><span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son2[x]=son[x], son[x]=y;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sz[y]&gt;sz[son2[x]]) son2[x]=y;<br>&#125;<br>f[x][<span class="hljs-number">0</span>]=son[x];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lg[n];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> y=x;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lg[n];~i;--i) <span class="hljs-keyword">if</span>(sz[f[y][i]]&gt;sz[x]/<span class="hljs-number">2</span>) y=f[y][i];<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(sz[x]-sz[y]&lt;=sz[x]/<span class="hljs-number">2</span>) res+=y;<br><span class="hljs-keyword">if</span>(sz[x]-sz[f[y][<span class="hljs-number">0</span>]]&lt;=sz[x]/<span class="hljs-number">2</span>) res+=f[y][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br><span class="hljs-type">int</span> szx=sz[x], sonx=son[x];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<br><span class="hljs-type">int</span> y=to[i];<br><span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// cut the edge (x,y)</span><br>son[x]=sonx;<br><span class="hljs-keyword">if</span>(sonx==y) son[x]=son2[x];<br><span class="hljs-keyword">if</span>(sz[fa]&gt;sz[son[x]]) son[x]=fa;<br><br>f[x][<span class="hljs-number">0</span>]=son[x];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=lg[n];++j) f[x][j]=f[f[x][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br><br>sz[x]=n-sz[y];<br>ans+=<span class="hljs-built_in">calc</span>(x);<br>ans+=<span class="hljs-built_in">calc</span>(y);<br><br><span class="hljs-built_in">dfs2</span>(y,x);<br>&#125;<br>sz[x]=szx, f[x][<span class="hljs-number">0</span>]=son[x]=sonx;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=lg[n];++j) f[x][j]=f[f[x][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br><span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);<br>lg[i]=lg[i&gt;&gt;<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br><span class="hljs-built_in">reset</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;centroid.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">// freopen(&quot;centroid.out&quot;,&quot;w&quot;,stdout);</span><br>T=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;大常数做法。&lt;/p&gt;
&lt;p&gt;不妨先钦定 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 为根。&lt;/p&gt;
&lt;p&gt;一棵树最多有两个重心，且如果有两个，那么它们相邻。&lt;/p&gt;
&lt;p&gt;$ $&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一棵 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个节点的有根树 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;，如果节点 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt; 的重心，那么 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 在以 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;operatorname{root}(T)&#92;)&lt;/span&gt;
为链头的重链上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbf{Proof}&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归纳法。&lt;/p&gt;
&lt;p&gt;钦定根的深度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，考虑从根开始往下寻找重心的过程。&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;operatorname{dep}(x) = 1&#92;)&lt;/span&gt;
时，显然正确。&lt;/p&gt;
&lt;p&gt;设当前深度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(d&#92;)&lt;/span&gt;，且 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;operatorname{dep}(x) &amp;gt;
d&#92;)&lt;/span&gt;，那么说明深度为 &lt;span class=&quot;math inline&quot;&gt;&#92;(d&#92;)&lt;/span&gt;
的这一层中有且仅有一棵大小超过 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;lfloor
&#92;frac{n}{2} &#92;rfloor&#92;)&lt;/span&gt; 的子树，根据重心的定义，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
必然在这棵子树中，并且这棵子树的根一定是它的父节点的重儿子，因此必须往下一层的重链移动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么通过一遍 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;operatorname{DFS}&#92;)&lt;/span&gt;
求出子树大小，每个节点的父节点和重儿子。这样我们就能快速找到一个重心
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;，并且如果存在另一个重心，那么一定是
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 的父亲或重儿子之一。&lt;/p&gt;
&lt;p&gt;找重心的过程相当于从根不断往下跳重儿子，于是可以用倍增优化。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="换根法" scheme="https://yozora0908.top/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
    <category term="树论" scheme="https://yozora0908.top/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="树上倍增" scheme="https://yozora0908.top/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>luogu5188 PALACINKE 题解</title>
    <link href="https://yozora0908.top/2023/lg5188-solution/"/>
    <id>https://yozora0908.top/2023/lg5188-solution/</id>
    <published>2023-10-23T14:07:32.000Z</published>
    <updated>2023-10-23T14:36:16.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>注意「采购方式包含了她经过的结点的次序，以及她在每条路上买不买材料，但不计她在哪个商店买了什么」，所以设<span class="math inline">\(f(i,x,S)\)</span> 表示时间 <spanclass="math inline">\(i\)</span> 在点 <spanclass="math inline">\(x\)</span>，取得的材料集合为 <spanclass="math inline">\(S\)</span> 是假的，因为 <spanclass="math inline">\(S\)</span>这一维一定会考虑到在每个店买了什么。</p><p>考虑把 <span class="math inline">\(S\)</span> 这一维干掉，设 <spanclass="math inline">\(f(i,x)\)</span> 为时间 <spanclass="math inline">\(i\)</span> 在点 <spanclass="math inline">\(x\)</span>，合法的购买方案数。状态设计上没有问题，但是因为不知道有没有买完所以转移不动，我们只能求出购买任意物品的方案数。</p><p>考虑容斥。设 <span class="math inline">\(F(S)\)</span> 为钦定只能购买<span class="math inline">\(S\)</span> 内物品的方案数，<spanclass="math inline">\(G(S)\)</span> 为恰好购买 <spanclass="math inline">\(S\)</span> 内物品的方案数，有 <spanclass="math display">\[F(S) = \sum_{T \subseteq S} G(S)\]</span></p><p><span class="math display">\[G(S) = \sum_{T \subseteq S} (-1)^{|S|-|T|} F(T)\]</span></p><p>答案就是 <span class="math inline">\(G(U)\)</span>。</p><p>所以我们只要枚举集合 <spanclass="math inline">\(S\)</span>，判一下哪些边卖的物品集合是 <spanclass="math inline">\(S\)</span> 的子集。显然有转移 <spanclass="math display">\[f(i,x) = \sum_{y \rightarrow x} f(i-1,y) + [s(y \rightarrow x) \subseteqS ]f(i-2,y)\]</span> 线性变换，<span class="math inline">\(T\)</span>的范围也很大，考虑矩阵加速。</p><p>我们搞出一个 <span class="math inline">\((2n+1) \times 1\)</span>的向量。 <span class="math display">\[\begin{bmatrix}f(i-1,1)\\f(i-1,2)\\\vdots\\f(i,1)\\f(i,2)\\\vdots\\ans\end{bmatrix}\]</span> 称上述向量为 <span class="math inline">\(i\)</span>阶段，考虑如何变换到 <span class="math inline">\(i+1\)</span> 阶段。</p><p>考虑转移矩阵。</p><ul><li><p><span class="math inline">\((i,i+n)\)</span> 都应置为 <spanclass="math inline">\(1\)</span>，把 <spanclass="math inline">\(i\)</span> 时刻的 <spanclass="math inline">\(n\)</span> 个状态平移上去。</p></li><li><p>对于边 <span class="math inline">\((x \rightarrow y)\)</span>，把<span class="math inline">\((y+n,x+n)\)</span> 置为 <spanclass="math inline">\(1\)</span>。</p></li><li><p>对于合法边 <span class="math inline">\((x \rightarrowy)\)</span>，把 <span class="math inline">\((y+n,x)\)</span> 置为 <spanclass="math inline">\(1\)</span>。</p></li><li><p>对于 <span class="math inline">\(ans\)</span>，只需要把 <spanclass="math inline">\((2n+1,2n+1)\)</span> 和 <spanclass="math inline">\((2n+1,n+1)\)</span> 置为 <spanclass="math inline">\(1\)</span> 即可。</p></li></ul><p>考虑初始向量。</p><ul><li><span class="math inline">\((1,1)\)</span> 置为 <spanclass="math inline">\(1\)</span>。</li><li>对于边 <span class="math inline">\((x \rightarrow y)\)</span>，把<span class="math inline">\((y+n,1)\)</span> 置为 <spanclass="math inline">\(1\)</span>。</li></ul><p>然后跑矩阵快速幂即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">40</span>, M=<span class="hljs-number">505</span>, mod=<span class="hljs-number">5557</span>;<br><span class="hljs-type">int</span> n, m, U, ans, T;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> x, y, s;<br>&#125; e[M];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<br>    <span class="hljs-type">int</span> m[<span class="hljs-number">2</span>*N][<span class="hljs-number">2</span>*N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(m,<span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-type">int</span>* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> m[i]; &#125;<br>    Mat <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Mat&amp; b) <span class="hljs-type">const</span> &#123;<br>        Mat c;<br>        c.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">2</span>*n;++k)  <br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2</span>*n;++j)<br>                    (c.m[i][j]+=m[i][k]*b.m[k][j]%mod)%=mod;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125; base, trans;<br><span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br>    Mat c;<br>    c.<span class="hljs-built_in">clear</span>(); <br>    c.<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br>string str;<br>unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; tb;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:str) res|=<span class="hljs-number">1</span>&lt;&lt;tb[x];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyGO</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<br>    base.<span class="hljs-built_in">clear</span>();<br>    trans.<span class="hljs-built_in">clear</span>();<br>    base[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    trans[<span class="hljs-number">2</span>*n][<span class="hljs-number">2</span>*n]=trans[<span class="hljs-number">2</span>*n][n]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) trans[i][i+n]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>        <span class="hljs-type">int</span> x=e[i].x, y=e[i].y;<br>        ++trans[y+n][x+n];<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) ++base[y+n][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>((S&amp;e[i].s)==e[i].s)  ++trans[y+n][x];<br>    &#125;<br>    base=<span class="hljs-built_in">fp</span>(trans,T)*base;<br>    <span class="hljs-keyword">return</span> base[<span class="hljs-number">2</span>*n][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>    tb[<span class="hljs-string">&#x27;B&#x27;</span>]=<span class="hljs-number">0</span>, tb[<span class="hljs-string">&#x27;J&#x27;</span>]=<span class="hljs-number">1</span>, tb[<span class="hljs-string">&#x27;M&#x27;</span>]=<span class="hljs-number">2</span>, tb[<span class="hljs-string">&#x27;P&#x27;</span>]=<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>        e[i].x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, e[i].y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<br>        cin&gt;&gt;str;<br>        e[i].s=<span class="hljs-built_in">get</span>(str);<br>    &#125;<br>    T=<span class="hljs-built_in">read</span>();<br>    U=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>)<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<br>        <span class="hljs-type">int</span> cnt=__builtin_popcount(S);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">4</span>-cnt)&amp;<span class="hljs-number">1</span>) (ans-=<span class="hljs-built_in">MyGO</span>(S)-mod)%=mod;<br>        <span class="hljs-keyword">else</span> (ans+=<span class="hljs-built_in">MyGO</span>(S))%=mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;注意「采购方式包含了她经过的结点的次序，以及她在每条路上买不买材料，但不计她在哪个商店买了什么」，所以设
&lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,x,S)&#92;)&lt;/span&gt; 表示时间 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 在点 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;，取得的材料集合为 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 是假的，因为 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;
这一维一定会考虑到在每个店买了什么。&lt;/p&gt;
&lt;p&gt;考虑把 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 这一维干掉，设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,x)&#92;)&lt;/span&gt; 为时间 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 在点 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;，合法的购买方案数。状态设计上没有问题，但是因为不知道有没有买完所以转移不动，我们只能求出购买任意物品的方案数。&lt;/p&gt;
&lt;p&gt;考虑容斥。设 &lt;span class=&quot;math inline&quot;&gt;&#92;(F(S)&#92;)&lt;/span&gt; 为钦定只能购买
&lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 内物品的方案数，&lt;span class=&quot;math inline&quot;&gt;&#92;(G(S)&#92;)&lt;/span&gt; 为恰好购买 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 内物品的方案数，有 &lt;span class=&quot;math display&quot;&gt;&#92;[
F(S) = &#92;sum_{T &#92;subseteq S} G(S)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
G(S) = &#92;sum_{T &#92;subseteq S} (-1)^{|S|-|T|} F(T)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;答案就是 &lt;span class=&quot;math inline&quot;&gt;&#92;(G(U)&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以我们只要枚举集合 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;，判一下哪些边卖的物品集合是 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 的子集。显然有转移 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(i,x) = &#92;sum_{y &#92;rightarrow x} f(i-1,y) + [s(y &#92;rightarrow x) &#92;subseteq
S ]f(i-2,y)
&#92;]&lt;/span&gt; 线性变换，&lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;
的范围也很大，考虑矩阵加速。&lt;/p&gt;
&lt;p&gt;我们搞出一个 &lt;span class=&quot;math inline&quot;&gt;&#92;((2n+1) &#92;times 1&#92;)&lt;/span&gt;
的向量。 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{bmatrix}
f(i-1,1)
&#92;&#92;
f(i-1,2)
&#92;&#92;
&#92;vdots
&#92;&#92;
f(i,1)
&#92;&#92;
f(i,2)
&#92;&#92;
&#92;vdots
&#92;&#92;
ans
&#92;end{bmatrix}
&#92;]&lt;/span&gt; 称上述向量为 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt;
阶段，考虑如何变换到 &lt;span class=&quot;math inline&quot;&gt;&#92;(i+1&#92;)&lt;/span&gt; 阶段。&lt;/p&gt;
&lt;p&gt;考虑转移矩阵。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;((i,i+n)&#92;)&lt;/span&gt; 都应置为 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;，把 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 时刻的 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个状态平移上去。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于边 &lt;span class=&quot;math inline&quot;&gt;&#92;((x &#92;rightarrow y)&#92;)&lt;/span&gt;，把
&lt;span class=&quot;math inline&quot;&gt;&#92;((y+n,x+n)&#92;)&lt;/span&gt; 置为 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于合法边 &lt;span class=&quot;math inline&quot;&gt;&#92;((x &#92;rightarrow
y)&#92;)&lt;/span&gt;，把 &lt;span class=&quot;math inline&quot;&gt;&#92;((y+n,x)&#92;)&lt;/span&gt; 置为 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(ans&#92;)&lt;/span&gt;，只需要把 &lt;span class=&quot;math inline&quot;&gt;&#92;((2n+1,2n+1)&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;((2n+1,n+1)&#92;)&lt;/span&gt; 置为 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt; 即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="图论" scheme="https://yozora0908.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="矩阵" scheme="https://yozora0908.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="容斥原理" scheme="https://yozora0908.top/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
    <category term="子集反演" scheme="https://yozora0908.top/tags/%E5%AD%90%E9%9B%86%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>luogu4582 [FJOI2014] 树的重心 题解</title>
    <link href="https://yozora0908.top/2023/lg4582-solution/"/>
    <id>https://yozora0908.top/2023/lg4582-solution/</id>
    <published>2023-10-23T14:07:25.000Z</published>
    <updated>2023-10-23T14:34:19.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>考虑用 DP 求一个东西： <span class="math inline">\(f(x,i)\)</span>表示以 <span class="math inline">\(x\)</span> 为根的子树中，选出包含<span class="math inline">\(x\)</span> 的大小为 <spanclass="math inline">\(i\)</span> 的连通块的方案数。</p><p>分重心的数量进行讨论。</p><h3 id="两个重心">两个重心</h3><p>如果原树有两个重心，由于这两个重心必然相邻，设其为 <spanclass="math inline">\(cen_1\)</span> 与 <spanclass="math inline">\(cen_2\)</span>，那么答案一定是二者各带上一个大小相同的连通块加上边<span class="math inline">\((cen_1,cen_2)\)</span> 构成的子图。</p><p>分别以两个重心为根，跑上述 DP 即可。 <span class="math display">\[\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor} \Big( f(cen_1,i) \timesf(cen_2,i) \Big)\]</span></p><h3 id="一个重心">一个重心</h3><p>由于数据范围不大，我们考虑枚举子图的大小 <spanclass="math inline">\(siz\)</span>，然后我们一定要保留重心，所以重心的每一棵子树大小的<span class="math inline">\(2\)</span> 倍必须小于 <spanclass="math inline">\(siz\)</span>。</p><p>把重心拎起来跑上述 DP，然后对在重心处暴力卷积即可。</p><h3 id="code">CODE</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, mod=<span class="hljs-number">10007</span>;<br><span class="hljs-type">int</span> T, n, tim, sz[N], f[N][N], g[N];<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> cen, cen2;<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcen</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    sz[x]=<span class="hljs-number">1</span>, h[x]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        <span class="hljs-built_in">getcen</span>(y,x);<br>        sz[x]+=sz[y];<br>        h[x]=<span class="hljs-built_in">max</span>(h[x],sz[y]);<br>    &#125;<br>    h[x]=<span class="hljs-built_in">max</span>(h[x],n-sz[x]);<br>    <span class="hljs-keyword">if</span>(!cen||h[x]&lt;=h[cen]) cen=x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    sz[x]=<span class="hljs-number">1</span>;<br>    f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x]+sz[y];++i) g[i]=f[x][i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[y];++j)<br>                (g[i+j]+=f[x][i]*f[y][j]%mod)%=mod;<br>        sz[x]+=sz[y];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> sub1 &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> siz)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x=cen;<br>        <span class="hljs-built_in">SET</span>(f[x],<span class="hljs-number">0</span>);<br>        sz[x]=<span class="hljs-number">1</span>;<br>        f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x]+sz[y];++i) g[i]=f[x][i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[y]&amp;&amp;<span class="hljs-number">2</span>*j&lt;siz;++j)<br>                    (g[i+j]+=f[x][i]*f[y][j]%mod)%=mod;<br>            sz[x]+=sz[y];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[x][siz];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(cen,<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=<span class="hljs-built_in">calc</span>(i))%=mod;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %lld: %lld\n&quot;</span>,tim,ans);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">namespace</span> sub2 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(cen,cen2);<br>        <span class="hljs-built_in">dfs</span>(cen2,cen);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n/<span class="hljs-number">2</span>) (ans+=f[cen][i]*f[cen2][i]%mod)%=mod;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %lld: %lld\n&quot;</span>,tim,ans);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) p[i].<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>    &#125;<br>    cen=cen2=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">getcen</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*h[cen]&lt;n) &#123;<br>        sub1::<span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[cen]) &#123;<br>        <span class="hljs-keyword">if</span>(h[cen]==sz[x]) &#123; cen2=x; <span class="hljs-keyword">break</span>; &#125;<br>    &#125;<br>    sub2::<span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    T=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(tim=<span class="hljs-number">1</span>;tim&lt;=T;++tim) <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;考虑用 DP 求一个东西： &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,i)&#92;)&lt;/span&gt;
表示以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树中，选出包含
&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 的大小为 &lt;span class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 的连通块的方案数。&lt;/p&gt;
&lt;p&gt;分重心的数量进行讨论。&lt;/p&gt;
&lt;h3 id=&quot;两个重心&quot;&gt;两个重心&lt;/h3&gt;
&lt;p&gt;如果原树有两个重心，由于这两个重心必然相邻，设其为 &lt;span class=&quot;math inline&quot;&gt;&#92;(cen_1&#92;)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;&#92;(cen_2&#92;)&lt;/span&gt;，那么答案一定是二者各带上一个大小相同的连通块加上边
&lt;span class=&quot;math inline&quot;&gt;&#92;((cen_1,cen_2)&#92;)&lt;/span&gt; 构成的子图。&lt;/p&gt;
&lt;p&gt;分别以两个重心为根，跑上述 DP 即可。 &lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;sum_{i=1}^{&#92;lfloor &#92;frac{n}{2} &#92;rfloor} &#92;Big( f(cen_1,i) &#92;times
f(cen_2,i) &#92;Big)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;一个重心&quot;&gt;一个重心&lt;/h3&gt;
&lt;p&gt;由于数据范围不大，我们考虑枚举子图的大小 &lt;span class=&quot;math inline&quot;&gt;&#92;(siz&#92;)&lt;/span&gt;，然后我们一定要保留重心，所以重心的每一棵子树大小的
&lt;span class=&quot;math inline&quot;&gt;&#92;(2&#92;)&lt;/span&gt; 倍必须小于 &lt;span class=&quot;math inline&quot;&gt;&#92;(siz&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;把重心拎起来跑上述 DP，然后对在重心处暴力卷积即可。&lt;/p&gt;
&lt;h3 id=&quot;code&quot;&gt;CODE&lt;/h3&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="树的重心" scheme="https://yozora0908.top/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>luogu3647 [APIO2014] 连珠线</title>
    <link href="https://yozora0908.top/2023/lg3647-solution/"/>
    <id>https://yozora0908.top/2023/lg3647-solution/</id>
    <published>2023-10-23T14:07:14.000Z</published>
    <updated>2023-10-23T15:05:53.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>首先要读明白题。</p><p>一开始<strong>只有一个点</strong>，只能在一个已有点和<strong>刚加入的新点</strong>之间连接红线，同时要保证始终只有一个连通块。</p><p>机房里有人因为理解错题意导致做不动。</p><p>发现不知道初始点做起来是相当胃疼的，具体怎么胃疼可以自行手玩。</p><p>枚举初始点，把初始点作为树根，这样所有的蓝边都是由祖孙生成的。</p><p>设 <span class="math inline">\(f(x,0/1)\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，<spanclass="math inline">\(x\)</span> 不是/是蓝边的中点的最大收益。</p><p>转移是平凡的。 <span class="math display">\[f(x,0) = \sum_{y \in son(x)} \max\Big( f(y,0),f(y,1)+z \Big)\]</span> 对于 <spanclass="math inline">\(f(x,1)\)</span>，我们能发现其相比 <spanclass="math inline">\(f(x,0)\)</span>仅仅多了一个限制条件：有且仅有一个儿子作为蓝边端点。</p><p>直接令 <span class="math inline">\(f(x,1) = f(x,1)\)</span>，然后加上<span class="math inline">\(\Delta = \max\Big\{ f(y,0)+z - \max\Big(f(y,0),f(y,1)+z \Big) \Big\}\)</span>，把最优的那一个换出来即可。</p><p>这样做是 <span class="math inline">\(O(n^2)\)</span>的，考虑优化。</p><p>每个子节点都是相对独立的，只需要记录 <spanclass="math inline">\(\Delta\)</span> 的次大值即可换根，复杂度 <spanclass="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x1f1f1f1f1f1f1f1f</span>;<br><span class="hljs-type">int</span> n, ans, f[N][<span class="hljs-number">2</span>], d[N], mx[N][<span class="hljs-number">2</span>], w[N];<br>vector&lt;PII &gt; p[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> calc(y,z) f[y][0]+z-max(f[y][0],f[y][1]+z)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>mx[x][<span class="hljs-number">0</span>]=mx[x][<span class="hljs-number">1</span>]=-inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<br><span class="hljs-type">int</span> y=t.fi, z=t.se;<br><span class="hljs-keyword">if</span>(y==fa) &#123; <span class="hljs-keyword">continue</span>; &#125;<br><span class="hljs-built_in">dfs</span>(y,x);<br>f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]+z);<br><br><span class="hljs-type">int</span> d=<span class="hljs-built_in">calc</span>(y,z);<br><span class="hljs-keyword">if</span>(d&gt;mx[x][<span class="hljs-number">0</span>]) mx[x][<span class="hljs-number">1</span>]=mx[x][<span class="hljs-number">0</span>], mx[x][<span class="hljs-number">0</span>]=d;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;mx[x][<span class="hljs-number">1</span>]) mx[x][<span class="hljs-number">1</span>]=d;<br>&#125;<br>f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">0</span>]+mx[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,f[x][<span class="hljs-number">0</span>]);<br><span class="hljs-type">int</span> fx0=f[x][<span class="hljs-number">0</span>], fx1=f[x][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<br><span class="hljs-type">int</span> y=t.fi, z=t.se;<br><span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<br><br><span class="hljs-type">int</span> fy0=f[y][<span class="hljs-number">0</span>], fy1=f[y][<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> my0=mx[y][<span class="hljs-number">0</span>], my1=mx[y][<span class="hljs-number">1</span>];<br><br>f[x][<span class="hljs-number">0</span>]-=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]+z);<br><span class="hljs-type">int</span> d=<span class="hljs-built_in">calc</span>(y,z);<br><br>f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">0</span>]+(d==mx[x][<span class="hljs-number">0</span>]? mx[x][<span class="hljs-number">1</span>]:mx[x][<span class="hljs-number">0</span>]);<br>f[y][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[x][<span class="hljs-number">0</span>],f[x][<span class="hljs-number">1</span>]+z);<br>d=<span class="hljs-built_in">calc</span>(x,z);<br><span class="hljs-keyword">if</span>(d&gt;mx[y][<span class="hljs-number">0</span>]) mx[y][<span class="hljs-number">1</span>]=mx[y][<span class="hljs-number">0</span>], mx[y][<span class="hljs-number">0</span>]=d;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;mx[y][<span class="hljs-number">1</span>]) mx[y][<span class="hljs-number">1</span>]=d;<br><br>f[y][<span class="hljs-number">1</span>]=f[y][<span class="hljs-number">0</span>]+mx[y][<span class="hljs-number">0</span>];<br><span class="hljs-built_in">dfs2</span>(y,x);<br><br>f[x][<span class="hljs-number">0</span>]=fx0, f[x][<span class="hljs-number">1</span>]=fx1;<br>f[y][<span class="hljs-number">0</span>]=fy0, f[y][<span class="hljs-number">1</span>]=fy1, mx[y][<span class="hljs-number">0</span>]=my0, mx[y][<span class="hljs-number">1</span>]=my1;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br><span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<br>p[x].<span class="hljs-built_in">pb</span>(&#123;y,z&#125;), p[y].<span class="hljs-built_in">pb</span>(&#123;x,z&#125;);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;首先要读明白题。&lt;/p&gt;
&lt;p&gt;一开始&lt;strong&gt;只有一个点&lt;/strong&gt;，只能在一个已有点和&lt;strong&gt;刚加入的新点&lt;/strong&gt;之间连接红线，同时要保证始终只有一个连通块。&lt;/p&gt;
&lt;p&gt;机房里有人因为理解错题意导致做不动。&lt;/p&gt;
&lt;p&gt;发现不知道初始点做起来是相当胃疼的，具体怎么胃疼可以自行手玩。&lt;/p&gt;
&lt;p&gt;枚举初始点，把初始点作为树根，这样所有的蓝边都是由祖孙生成的。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,0/1)&#92;)&lt;/span&gt; 为以 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 为根的子树中，&lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 不是/是蓝边的中点的最大收益。&lt;/p&gt;
&lt;p&gt;转移是平凡的。 &lt;span class=&quot;math display&quot;&gt;&#92;[
f(x,0) = &#92;sum_{y &#92;in son(x)} &#92;max&#92;Big( f(y,0),f(y,1)+z &#92;Big)
&#92;]&lt;/span&gt; 对于 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,1)&#92;)&lt;/span&gt;，我们能发现其相比 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,0)&#92;)&lt;/span&gt;
仅仅多了一个限制条件：有且仅有一个儿子作为蓝边端点。&lt;/p&gt;
&lt;p&gt;直接令 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,1) = f(x,1)&#92;)&lt;/span&gt;，然后加上
&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Delta = &#92;max&#92;Big&#92;{ f(y,0)+z - &#92;max&#92;Big(
f(y,0),f(y,1)+z &#92;Big) &#92;Big&#92;}&#92;)&lt;/span&gt;，把最优的那一个换出来即可。&lt;/p&gt;
&lt;p&gt;这样做是 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(n^2)&#92;)&lt;/span&gt;
的，考虑优化。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="换根法" scheme="https://yozora0908.top/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>luogu3573 [POI2014] RAJ-Rally 题解</title>
    <link href="https://yozora0908.top/2023/lg3573-solution/"/>
    <id>https://yozora0908.top/2023/lg3573-solution/</id>
    <published>2023-10-23T14:06:55.000Z</published>
    <updated>2023-10-23T14:30:27.776Z</updated>
    
    <content type="html"><![CDATA[<p>设 <span class="math inline">\(f_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 结尾的最长路径，<spanclass="math inline">\(g_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 开头的最长路径，那么答案就是 <spanclass="math inline">\(\max_{(x,y) \in E} \{f_x+1+g_y\}\)</span>。</p><p>考虑一个性质：对于一个点 <spanclass="math inline">\(x\)</span>，设拓扑序小于它的点集为 <spanclass="math inline">\(S\)</span>，拓扑序大于它的点集为 <spanclass="math inline">\(T\)</span>，以 <spanclass="math inline">\(S\)</span> 中节点 <spanclass="math inline">\(y\)</span> 结尾的路径 <spanclass="math inline">\(f_y\)</span> 和以 <spanclass="math inline">\(T\)</span> 中节点 <spanclass="math inline">\(z\)</span> 开头的路径 <spanclass="math inline">\(g_z\)</span> 均与 <spanclass="math inline">\(x\)</span> 无关。最长路径可以刻画为 <spanclass="math inline">\(S\)</span> 内部的最长路径、<spanclass="math inline">\(T\)</span> 内部的最长路径，<spanclass="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的最长路径。</p><p>按照拓扑序枚举点 <spanclass="math inline">\(x\)</span>，考虑如何维护删掉点 <spanclass="math inline">\(x\)</span> 后的最长路径。初始所有点都在 <spanclass="math inline">\(T\)</span> 中，每枚举到一个点，就把它从 <spanclass="math inline">\(T\)</span> 中删除，同时干掉所有形如 <spanclass="math inline">\(f_y + 1 + g_x\)</span> 的路径，其中存在边 <spanclass="math inline">\((y,x)\)</span>。此时最长的路径就是删掉 <spanclass="math inline">\(x\)</span> 时的答案。然后把 <spanclass="math inline">\(x\)</span> 加入 <spanclass="math inline">\(S\)</span>，增加的新路径是 <spanclass="math inline">\(f_x+1+g_y\)</span>，其中存在边 <spanclass="math inline">\((x,y)\)</span>。</p><p>用一个支持插入删除查询最大值的神秘数据结构即可维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, in1[N], in2[N], f[N], g[N];<br><span class="hljs-type">int</span> cnt, topo[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N], b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort1</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(in1[i]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>topo[++cnt]=x;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<br>f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(--in1[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) &#123;<br><span class="hljs-type">int</span> x=topo[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:b[x]) &#123;<br>g[y]=<span class="hljs-built_in">max</span>(g[y],g[x]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">heap</span> &#123;<br>priority_queue&lt;<span class="hljs-type">int</span>&gt; a, b;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; a.<span class="hljs-built_in">push</span>(x); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; b.<span class="hljs-built_in">push</span>(x); &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span>(b.<span class="hljs-built_in">size</span>()&amp;&amp;a.<span class="hljs-built_in">top</span>()==b.<span class="hljs-built_in">top</span>()) a.<span class="hljs-built_in">pop</span>(), b.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> a.<span class="hljs-built_in">top</span>();<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br><span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>p[x].<span class="hljs-built_in">pb</span>(y), b[y].<span class="hljs-built_in">pb</span>(x);<br>++in1[y], ++in2[x];<br>&#125;<br><span class="hljs-built_in">toposort1</span>();<br><span class="hljs-built_in">toposort2</span>();<br>heap q;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>, len=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) q.<span class="hljs-built_in">push</span>(g[i]);<br>len=q.<span class="hljs-built_in">top</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br><span class="hljs-type">int</span> x=topo[i];<br>q.<span class="hljs-built_in">pop</span>(g[x]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:b[x]) &#123;<br>q.<span class="hljs-built_in">pop</span>(f[y]+<span class="hljs-number">1</span>+g[x]);<br>&#125;<br><span class="hljs-type">int</span> t=q.<span class="hljs-built_in">top</span>();<br><span class="hljs-keyword">if</span>(t&lt;len) ans=x, len=t;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<br>q.<span class="hljs-built_in">push</span>(f[x]+<span class="hljs-number">1</span>+g[y]);<br>&#125;<br>q.<span class="hljs-built_in">push</span>(f[x]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,ans,len);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f_x&#92;)&lt;/span&gt; 为以 &lt;span
class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 结尾的最长路径，&lt;span
class=&quot;math inline&quot;&gt;&#92;(g_x&#92;)&lt;/span&gt; 为</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="图论" scheme="https://yozora0908.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>luogu2757 [国家集训队] 等差子序列 题解</title>
    <link href="https://yozora0908.top/2023/lg2757-solution/"/>
    <id>https://yozora0908.top/2023/lg2757-solution/</id>
    <published>2023-10-23T14:06:49.000Z</published>
    <updated>2023-10-23T14:29:22.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>关于等差数列的存在问题，一个常见的套路就是枚举中项，只考虑左边右边各一项。然后<span class="math inline">\(O(n^2)\)</span> 做法就很显然了。</p><p>考虑一个很厉害的转化：我们把 <span class="math inline">\(1 \simn\)</span> 堪称一个 0/1 序列，第 <span class="math inline">\(i\)</span>位是 <span class="math inline">\(1\)</span> 当且仅当数字 <spanclass="math inline">\(i\)</span>已经出现过了。那么存在等差数列的充要条件变成了从左往右扫到数字 <spanclass="math inline">\(i\)</span> 时，存在一个 <spanclass="math inline">\(k\)</span>，满足序列中 <spanclass="math inline">\(i-k\)</span> 与 <spanclass="math inline">\(i+k\)</span>的值不同；不存在等差数列的充要条件则是 <spanclass="math inline">\([i-lim,i+lim]\)</span> 回文，其中 <spanclass="math inline">\(lim = \min(i-1,n-i)\)</span>。</p><p>回文可以用哈希解决，我们要支持的操作是单点修改和区间查询哈希值，维护正反哈希值后线段树即可维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> uint P=<span class="hljs-number">1610612741ull</span>;<br><span class="hljs-type">int</span> T, n, a[N];<br>uint pw[N];<br>uint ha[N&lt;&lt;<span class="hljs-number">2</span>], iha[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ha[x]=ha[x&lt;&lt;<span class="hljs-number">1</span>]+ha[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]*pw[mid-l+<span class="hljs-number">1</span>];<br>    iha[x]=iha[x&lt;&lt;<span class="hljs-number">1</span>]*pw[r-mid]+iha[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    ha[x]=iha[x]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) &#123; ha[x]=iha[x]=d; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">upd</span>(p,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">upd</span>(p,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-built_in">pushup</span>(x,l,r);<br>&#125;<br><span class="hljs-function">uint <span class="hljs-title">getha</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> ha[x];<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, ll=<span class="hljs-number">0</span>;<br>    uint res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) ll=<span class="hljs-number">1</span>, res=<span class="hljs-built_in">getha</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) &#123;<br>        uint t=<span class="hljs-built_in">getha</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-keyword">if</span>(ll) res+=t*pw[mid-<span class="hljs-built_in">max</span>(L,l)+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> res=t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">uint <span class="hljs-title">getiha</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> iha[x];<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, rr=<span class="hljs-number">0</span>;<br>    uint res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(R&gt;mid) rr=<span class="hljs-number">1</span>, res=<span class="hljs-built_in">getiha</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) &#123;<br>        uint t=<span class="hljs-built_in">getiha</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>        <span class="hljs-keyword">if</span>(rr) res+=t*pw[<span class="hljs-built_in">min</span>(r,R)-(mid+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> res=t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5e5</span>;++i) pw[i]=pw[i<span class="hljs-number">-1</span>]*P;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>        <span class="hljs-keyword">if</span>(fg) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> x=a[i];<br>        <span class="hljs-built_in">upd</span>(x,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> len=<span class="hljs-built_in">min</span>(x<span class="hljs-number">-1</span>,n-x);<br>        uint l=<span class="hljs-built_in">getha</span>(x-len,x), r=<span class="hljs-built_in">getiha</span>(x,x+len);<br>        <span class="hljs-keyword">if</span>(l!=r) fg=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fg) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Y&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;N&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    T=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;关于等差数列的存在问题，一个常见的套路就是枚举中项，只考虑左边右边各一项。然后
&lt;span class=&quot;math inline&quot;&gt;&#92;(O(n^2)&#92;)&lt;/span&gt; 做法就很显然了。&lt;/p&gt;
&lt;p&gt;考虑</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="https://yozora0908.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="多项式哈希" scheme="https://yozora0908.top/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>CF1824C LuoTianyi and XOR-Tree 题解</title>
    <link href="https://yozora0908.top/2023/cf1824c-solution/"/>
    <id>https://yozora0908.top/2023/cf1824c-solution/</id>
    <published>2023-10-23T14:06:34.000Z</published>
    <updated>2023-10-23T14:24:37.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>考虑一个暴力。</p><p>设 <span class="math inline">\(f(x,i)\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，每个叶子到 <spanclass="math inline">\(x\)</span> 的路径的点权异或和为 <spanclass="math inline">\(i\)</span> 时的最小代价。</p><p>对于 <span class="math inline">\(f(x,i)\)</span>，不难发现只有当<span class="math inline">\(j = a_x \oplus i\)</span> 时，<spanclass="math inline">\(f(x,i) = f(y,j)\)</span>，否则 <spanclass="math inline">\(f(x,i) = f(y,j&#39;)+1\)</span>，因此维护前缀后缀<span class="math inline">\(\min\)</span> 即可做到 <spanclass="math inline">\(O(n^2)\)</span>。</p><p>考虑一个性质。</p><p>如果 <span class="math inline">\(f(y,j&#39;) &gt;f(y,j)\)</span>，那么可以通过修改一个点的权值的方式使得 <spanclass="math inline">\(j\)</span> 变为 <spanclass="math inline">\(j&#39;\)</span>，同时 <spanclass="math inline">\(f(y,j&#39;) \ge f(y,j)\)</span>。因此对 <spanclass="math inline">\(x\)</span> 有用的的只有满足 <spanclass="math inline">\(f(y,j)\)</span> 取到最小值的 <spanclass="math inline">\(j\)</span>。</p><p>设这些 <span class="math inline">\(j\)</span> 构成的可重集合为 <spanclass="math inline">\(G(x)\)</span>，容易发现最优决策就是取 <spanclass="math inline">\(G(x)\)</span> 中出现次数最多的 <spanclass="math inline">\(j\)</span>。</p><p>如何维护 <spanclass="math inline">\(G(x)\)</span>？本质上是叶子节点的信息集，用<code>std::map</code>维护，启发式合并即可，复杂度<span class="math inline">\(O(n \log^2 n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, ans, a[N], id[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp[N], s;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(fa&amp;&amp;p[x].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) &#123;<br>        mp[id[x]][a[x]]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, mx=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        a[y]^=a[x];<br>        <span class="hljs-comment">// 注意这里</span><br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        ++cnt;<br>        <span class="hljs-keyword">if</span>(mp[id[x]].<span class="hljs-built_in">size</span>()&lt;mp[id[y]].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(id[x],id[y]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:mp[id[y]]) &#123;<br>            mp[id[x]][t.fi]+=t.se;<br>            mx=<span class="hljs-built_in">max</span>(mx,mp[id[x]][t.fi]);<br>        &#125;<br>        <span class="hljs-comment">// 启发式合并</span><br>    &#125;<br>    ans+=cnt-mx;<br>    <span class="hljs-keyword">if</span>(mx&gt;<span class="hljs-number">1</span>) &#123;<br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:mp[id[x]]) &#123;<br>            <span class="hljs-keyword">if</span>(t.se==mx) s[t.fi]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(s,mp[id[x]]);<br>        <span class="hljs-comment">// 更新后map中元素数量总和至多为原来的一半</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), id[i]=i;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans+(!mp[id[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;考虑一个暴力。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(x,i)&#92;)&lt;/span&gt; 为以 &lt;span
class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="树论" scheme="https://yozora0908.top/tags/%E6%A0%91%E8%AE%BA/"/>
    
    <category term="启发式合并" scheme="https://yozora0908.top/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>CF1110F Nearest Leaf 题解</title>
    <link href="https://yozora0908.top/2023/cf1110f-solution/"/>
    <id>https://yozora0908.top/2023/cf1110f-solution/</id>
    <published>2023-10-23T14:06:24.000Z</published>
    <updated>2023-10-23T14:32:21.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>静态问题，把询问离线了挂到节点上。</p><p>直接 <span class="math inline">\(\text{DFS}\)</span>似乎难以解决。不妨考虑以每个询问中的 <spanclass="math inline">\(x\)</span>为根的情况，此时的问题相当简单，然而复杂度是 <spanclass="math inline">\(O(n^2)\)</span> 的。</p><p>能发现以每个点为根的过程中，不会产生新的叶子。大胆地考虑使用换根法，对于一条树边<spanclass="math inline">\((x,y)\)</span>，分别以二者为根的情况仅仅相差一条边，设其权值为<span class="math inline">\(z\)</span>。更进一步地，以 <spanclass="math inline">\(x\)</span> 为根时 <spanclass="math inline">\(y\)</span> 的子树中的叶子权值要 <spanclass="math inline">\(-z\)</span>，其余要 <spanclass="math inline">\(+z\)</span>。</p><p>把叶子拍到以 <span class="math inline">\(1\)</span> 为根的 <spanclass="math inline">\(\text{DFS}\)</span>序上，做减法的叶子是一段区间，做加法的叶子是前缀和后缀，询问区间 <spanclass="math inline">\(\min\)</span>。线段树即可维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">7e18</span>;<br><span class="hljs-type">int</span> n, Q, d[N], lim[N], ans[N];<br><span class="hljs-type">bool</span> isl[N];<br>vector&lt;PII &gt; p[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> id, l, r;<br>    <span class="hljs-built_in">node</span>() &#123;&#125;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c) &#123; id=a, l=b, r=c; &#125;<br>&#125;;<br>vector&lt;node&gt; q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    lim[x]=x;<br>    <span class="hljs-keyword">if</span>(p[x].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) isl[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<br>        <span class="hljs-type">int</span> y=t.fi, z=t.se;<br>        d[y]=d[x]+z;<br>        <span class="hljs-built_in">dfs</span>(y);<br>        lim[x]=<span class="hljs-built_in">max</span>(lim[x],lim[y]);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=<span class="hljs-built_in">min</span>(t[x&lt;&lt;<span class="hljs-number">1</span>],t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<br>    t[x]+=d;<br>    tag[x]+=d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(tag[x]!=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,tag[x]);<br>        <span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,tag[x]);<br>        tag[x]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-keyword">if</span>(isl[l]) t[x]=d[l]; <span class="hljs-keyword">else</span> t[x]=inf; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,d); <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">pushdown</span>(x);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, res=inf;<br>    <span class="hljs-built_in">pushdown</span>(x);<br>    <span class="hljs-keyword">if</span>(L&lt;=mid) res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid));<br>    <span class="hljs-keyword">if</span>(R&gt;mid) res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:q[x]) &#123;<br>        <span class="hljs-type">int</span> i=t.id, l=t.l, r=t.r;        <br>        ans[i]=<span class="hljs-built_in">query</span>(l,r);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<br>        <span class="hljs-type">int</span> y=t.fi, z=t.se;<br>        <span class="hljs-built_in">upd</span>(y,lim[y],-z);<br>        <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>) <span class="hljs-built_in">upd</span>(<span class="hljs-number">1</span>,y<span class="hljs-number">-1</span>,z);<br>        <span class="hljs-keyword">if</span>(lim[y]+<span class="hljs-number">1</span>&lt;=n) <span class="hljs-built_in">upd</span>(lim[y]+<span class="hljs-number">1</span>,n,z);<br>        <span class="hljs-built_in">dfs2</span>(y);<br>        <span class="hljs-built_in">upd</span>(y,lim[y],z);<br>        <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>) <span class="hljs-built_in">upd</span>(<span class="hljs-number">1</span>,y<span class="hljs-number">-1</span>,-z);<br>        <span class="hljs-keyword">if</span>(lim[y]+<span class="hljs-number">1</span>&lt;=n) <span class="hljs-built_in">upd</span>(lim[y]+<span class="hljs-number">1</span>,n,-z);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(i&gt;x) p[x].<span class="hljs-built_in">pb</span>(&#123;i,z&#125;);<br>        <span class="hljs-keyword">else</span> p[i].<span class="hljs-built_in">pb</span>(&#123;x,z&#125;);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<br>        q[x].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(i,l,r));<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;静态问题，把询问离线了挂到节点上。&lt;/p&gt;
&lt;p&gt;直接 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;text{DFS}&#92;)&lt;/span&gt;
似乎难以解决。不妨考虑以每个询问中的 &lt;span
</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="换根法" scheme="https://yozora0908.top/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
    <category term="线段树" scheme="https://yozora0908.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF895C Square Subsets 题解</title>
    <link href="https://yozora0908.top/2023/cf895c-solution/"/>
    <id>https://yozora0908.top/2023/cf895c-solution/</id>
    <published>2023-10-23T14:06:17.000Z</published>
    <updated>2023-10-23T14:20:17.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>注意到值域很小，然后值域范围内的质数只有 <spanclass="math inline">\(19\)</span> 个。</p><p>把相同的数合并成内部有标号的等价类，设 <spanclass="math inline">\(f(i,S)\)</span> 为考虑了 <spanclass="math inline">\(1 \sim i\)</span>的数，选出的数的乘积中，每个质因子出现次数奇偶性为 <spanclass="math inline">\(S\)</span> 的方案数。</p><p>枚举选奇数个还是偶数个，随便转移。</p><p>貌似要滚动一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> pr[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>,<span class="hljs-number">41</span>,<span class="hljs-number">43</span>,<span class="hljs-number">47</span>,<span class="hljs-number">53</span>,<span class="hljs-number">59</span>,<span class="hljs-number">61</span>,<span class="hljs-number">67</span>&#125;;<br><span class="hljs-type">int</span> n, U, lim, c[<span class="hljs-number">80</span>], pw[N], p[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)+<span class="hljs-number">5</span>], f[<span class="hljs-number">2</span>][(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">19</span>;++i) <span class="hljs-keyword">if</span>(x%pr[i]==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> e=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x%pr[i]==<span class="hljs-number">0</span>) x/=pr[i], e^=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(e) res|=(<span class="hljs-number">1</span>&lt;&lt;i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<br>        ++c[x];<br>        lim=<span class="hljs-built_in">max</span>(lim,c[x]);<br>        <span class="hljs-keyword">if</span>(c[x]==<span class="hljs-number">1</span>) &#123;<br>            p[x]=<span class="hljs-built_in">trans</span>(x);<br>            <span class="hljs-comment">// printf(&quot;p[%lld][0]=%lld\n&quot;,x,p[x]);</span><br>        &#125;<br>    &#125;<br>    pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,lim) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;<br>    U=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)<span class="hljs-number">-1</span>;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">70</span>;++i) &#123;<br>        <span class="hljs-built_in">SET</span>(f[i&amp;<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">rep</span>(S,<span class="hljs-number">0</span>,U) &#123;<br>            <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) (f[i&amp;<span class="hljs-number">1</span>][S]=f[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][S])%=mod;<br>            <span class="hljs-keyword">if</span>(c[i]&gt;<span class="hljs-number">0</span>) (f[i&amp;<span class="hljs-number">1</span>][S^p[i]]+=f[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][S]*pw[c[i]<span class="hljs-number">-1</span>]%mod)%=mod;<br>            <span class="hljs-keyword">if</span>(c[i]&gt;<span class="hljs-number">0</span>) (f[i&amp;<span class="hljs-number">1</span>][S]+=f[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][S]*pw[c[i]<span class="hljs-number">-1</span>]%mod)%=mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>+mod)%mod);<br>    <span class="hljs-comment">// 减掉一个都不选的方案</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;注意到值域很小，然后值域范围内的质数只有 &lt;span
class=&quot;math inline&quot;&gt;&#92;(19&#92;)&lt;/span&gt; 个。&lt;/p&gt;
&lt;p&gt;把相同的数合并成内部有标号的等价类，设 &lt;span
clas</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="状态压缩" scheme="https://yozora0908.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>CF833B The Bakery 题解</title>
    <link href="https://yozora0908.top/2023/cf833b-solution/"/>
    <id>https://yozora0908.top/2023/cf833b-solution/</id>
    <published>2023-10-23T14:06:06.000Z</published>
    <updated>2023-10-23T14:18:51.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>设 <span class="math inline">\(f(i,j)\)</span> 考虑序列前 <spanclass="math inline">\(i\)</span> 个元素，划分了 <spanclass="math inline">\(j\)</span> 段的最大价值。</p><p><span class="math display">\[f(i,j) = \max_{k \in [0,i-1]} \Big\{ f(k,j-1) + w(k+1,i) \Big\}\]</span> 貌似无法优化了。</p><p>求出 <span class="math inline">\(a_i\)</span> 上一次出现的 <spanclass="math inline">\(pre_i\)</span>，所以它会 <spanclass="math inline">\([pre_i+1,i]\)</span> 产生 <spanclass="math inline">\(1\)</span> 的贡献。</p><p>由于 <span class="math inline">\(k \le 50\)</span>，我们不妨开 <spanclass="math inline">\(k\)</span> 棵线段树。借用扫描线的思想，第 <spanclass="math inline">\(j\)</span> 棵线段树的位置 <spanclass="math inline">\(i\)</span> 维护 <spanclass="math inline">\(f(i-1,j)+w(i,i&#39;)\)</span>，其中 <spanclass="math inline">\(i&#39;\)</span>是当前扫到的位置。这样每个元素的贡献就是一个区间修改，求解一个 <spanclass="math inline">\(f(i,j)\)</span> 也变成了查询区间最大值，然后让第<span class="math inline">\(j\)</span> 棵线段树的位置 <spanclass="math inline">\(i+1\)</span> 单点加上 <spanclass="math inline">\(f(i,j)\)</span> 即可。</p><p>复杂度 <span class="math inline">\(O(nk \log n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">35005</span>, M=<span class="hljs-number">51</span>;<br><span class="hljs-type">int</span> n, m, a[N], pre[N], lst[N];<br><span class="hljs-type">int</span> f[M][N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=<span class="hljs-built_in">max</span>(t[x&lt;&lt;<span class="hljs-number">1</span>],t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<br>t[x]+=d;<br>tag[x]+=d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tag[x]!=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,tag[x]);<br><span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,tag[x]);<br>tag[x]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,d); <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-built_in">pushdown</span>(x);<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<br><span class="hljs-built_in">pushdown</span>(x);<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid));<br><span class="hljs-keyword">if</span>(R&gt;mid) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r));<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125; T[M];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>a[i]=<span class="hljs-built_in">read</span>();<br>pre[i]=lst[a[i]];<br>lst[a[i]]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<br>T[j].<span class="hljs-built_in">upd</span>(pre[i]+<span class="hljs-number">1</span>,i,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>) &#123;<br>f[<span class="hljs-number">1</span>][i]=f[<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]+(pre[i]==<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(i&lt;n) T[<span class="hljs-number">1</span>].<span class="hljs-built_in">upd</span>(i+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,f[<span class="hljs-number">1</span>][i]);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>)f[j][i]=T[j<span class="hljs-number">-1</span>].<span class="hljs-built_in">query</span>(j<span class="hljs-number">-1</span>,i);<br><span class="hljs-keyword">if</span>(i&lt;n) T[j].<span class="hljs-built_in">upd</span>(i+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,f[j][i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[m][n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(f(i,j)&#92;)&lt;/span&gt; 考虑序列前 &lt;span
class=&quot;math inline&quot;&gt;&#92;(i&#92;)&lt;/span&gt; 个元素，划分了 &lt;spa</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="线段树" scheme="https://yozora0908.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF708C Centroids 题解</title>
    <link href="https://yozora0908.top/2023/cf708c-solution/"/>
    <id>https://yozora0908.top/2023/cf708c-solution/</id>
    <published>2023-10-23T14:05:46.000Z</published>
    <updated>2023-10-23T14:32:40.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solution">Solution</h2><p>考虑一个点 <span class="math inline">\(x\)</span>何时能通过改造成为重心，为了方便，钦定 <spanclass="math inline">\(x\)</span> 为树根。</p><p>通过操作干掉的子树一定会接到 <span class="math inline">\(x\)</span>上，否则不优。</p><ol type="1"><li><span class="math inline">\(\max_{y \in son(x)} \{ sz_y\} \le\lfloor \frac{n}{2} \rfloor\)</span>。</li><li>存在 <span class="math inline">\(y \in son(x)\)</span> 满足 <spanclass="math inline">\(sz_y &gt; \lfloor \frac{n}{2}\rfloor\)</span>，但是 <span class="math inline">\(y\)</span>的子树中存在一棵子树 <span class="math inline">\(z\)</span>，满足 <spanclass="math inline">\(sz_z \le \lfloor \frac{n}{2} \rfloor\)</span> 并且<span class="math inline">\(sz_y - sz_z \le \lfloor \frac{n}{2}\rfloor\)</span>。</li></ol><p>第一种情况是平凡的，预处理重儿子即可，不再赘述。</p><p>对于第二种情况，不难发现取 <span class="math inline">\(z\)</span> 为<span class="math inline">\(sz\)</span> 最大的 <spanclass="math inline">\(i\)</span>，满足 <span class="math inline">\(sz_i\le \lfloor \frac{n}{2} \rfloor\)</span> 最优。通过树形 DP不难求出。</p><p>对于每个节点的情况，考虑用换根 DP 统计答案。唯一的困难就是，如果从<span class="math inline">\(x\)</span> 进入了 <spanclass="math inline">\(z\)</span> 所在的子树，那么就需要有一个次大的<span class="math inline">\(z&#39;\)</span> 来代替关于 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(z\)</span>。</p><p>设 <span class="math inline">\(f(x,0)\)</span> 为满足条件的 <spanclass="math inline">\(sz\)</span> 最大的 <spanclass="math inline">\(z\)</span>，<spanclass="math inline">\(f(x,1)\)</span> 是次大，同时记录 <spanclass="math inline">\(f(x,0)\)</span> 的来源 <spanclass="math inline">\(id_x\)</span> 即可换根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>        c=<span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, sz[N], son[N], f[N][<span class="hljs-number">2</span>], id[N];<br><span class="hljs-type">int</span> ans[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    sz[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br>        <span class="hljs-built_in">dfs</span>(y,x);<br>        sz[x]+=sz[y];<br>        <span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(sz[y]&gt;n/<span class="hljs-number">2</span>) t=f[y][<span class="hljs-number">0</span>]; <span class="hljs-keyword">else</span> t=sz[y];<br>        <span class="hljs-keyword">if</span>(t&gt;f[x][<span class="hljs-number">0</span>]) f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">0</span>], f[x][<span class="hljs-number">0</span>]=t, id[x]=y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;f[x][<span class="hljs-number">1</span>]) f[x][<span class="hljs-number">1</span>]=t;<br>    &#125;<br>    <span class="hljs-comment">// printf(&quot;f[%lld][0]=%lld f[%lld][1]=%lld\n&quot;,x,f[x][0],x,f[x][1]);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(sz[son[x]]&lt;=n/<span class="hljs-number">2</span>) ans[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[son[x]][<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>&amp;&amp;sz[son[x]]-f[son[x]][<span class="hljs-number">0</span>]&lt;=n/<span class="hljs-number">2</span>) ans[x]=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// if(x==1||x==3) &#123;</span><br>    <span class="hljs-comment">//     printf(&quot;f[%lld][0]=%lld f[%lld][1]=%lld\n&quot;,x,f[x][0],x,f[x][1]);</span><br>    <span class="hljs-comment">//     printf(&quot;son[%lld]=%lld\n&quot;,x,son[x]);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-type">int</span> szx=sz[x], fx0=f[x][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<br><br>        <span class="hljs-type">int</span> szy=sz[y], sony=son[y], fy0=f[y][<span class="hljs-number">0</span>], fy1=f[y][<span class="hljs-number">1</span>], idy=id[y];<br><br>        sz[x]=n-sz[y];<br>        sz[y]=n;<br>        <span class="hljs-keyword">if</span>(sz[x]&gt;sz[son[y]]) son[y]=x;<br>        <span class="hljs-keyword">if</span>(y!=id[x]) &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(sz[x]&gt;n/<span class="hljs-number">2</span>) t=f[x][<span class="hljs-number">0</span>]; <span class="hljs-keyword">else</span> t=sz[x];<br>            <span class="hljs-keyword">if</span>(t&gt;f[y][<span class="hljs-number">0</span>]) f[y][<span class="hljs-number">1</span>]=f[y][<span class="hljs-number">0</span>], f[y][<span class="hljs-number">0</span>]=t, id[y]=x;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;f[y][<span class="hljs-number">1</span>]) f[y][<span class="hljs-number">1</span>]=t;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(sz[x]&gt;n/<span class="hljs-number">2</span>) t=f[x][<span class="hljs-number">1</span>]; <span class="hljs-keyword">else</span> t=sz[x];<br>            <span class="hljs-keyword">if</span>(t&gt;f[y][<span class="hljs-number">0</span>]) f[y][<span class="hljs-number">1</span>]=f[y][<span class="hljs-number">0</span>], f[y][<span class="hljs-number">0</span>]=t, id[y]=x;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;f[y][<span class="hljs-number">1</span>]) f[y][<span class="hljs-number">1</span>]=t;<br>            f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-built_in">dfs2</span>(y,x);<br><br>        sz[x]=szx, f[x][<span class="hljs-number">0</span>]=fx0;<br>        sz[y]=szy, son[y]=sony, f[y][<span class="hljs-number">0</span>]=fy0, f[y][<span class="hljs-number">1</span>]=fy1, id[y]=idy;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>        p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;考虑一个点 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt;
何时能通过改造成为重心，为了方便，钦定 &lt;span
class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span</summary>
      
    
    
    
    <category term="题解" scheme="https://yozora0908.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DP" scheme="https://yozora0908.top/tags/DP/"/>
    
    <category term="树形DP" scheme="https://yozora0908.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="换根法" scheme="https://yozora0908.top/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
    <category term="树的重心" scheme="https://yozora0908.top/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
  </entry>
  
</feed>
