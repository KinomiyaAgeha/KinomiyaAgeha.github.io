<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>yozora0908's blog - φ(゜▽゜*)♪</title><meta name="author" content="yozora0908"><meta name="copyright" content="yozora0908"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description"><link rel="shortcut icon" href="/img/4.png"><link rel="canonical" href="https://yozora0908.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yozora0908\'s blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-13 18:45:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/13/5fHjuPvxm9dwasc.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">yozora0908's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">yozora0908's blog</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/noip-record1/" title="「NOIP Record」#1 贪心">「NOIP Record」#1 贪心</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-12T12:04:05.000Z" title="发表于 2022-11-12 20:04:05">2022-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a></span></div><div class="content">前言
NOIP 快要到了，进行一个习的复。
无意间发现自己连很多贪心题都不会做了，于是就有了这篇文章，完善一下贪心的思维方式。

一些问题
Buy Low Sell High

You can perfectly predict the price of a certain stock for the next
\(N\) days. You would like to profit on
this knowledge, but only want to transact one share of stock per day.
That is, each day you will either buy one share, sell one share, or do
nothing. Initially you own zero shares, and you cannot sell shares when
you don't own any. At the end of the \(N\) days you would like to again own ze ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg8818-solution/" title="luogu8818 策略游戏 题解">luogu8818 策略游戏 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-12T12:03:50.000Z" title="发表于 2022-11-12 20:03:50">2022-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B2%A1%E6%9C%89%E6%A0%87%E5%BF%97%E6%80%A7%E7%AE%97%E6%B3%95/">没有标志性算法</a></span></div><div class="content">分析
经典先手想要最大化，后手想要最小化。

我们不必拘泥于各种分类讨论，仔细思考不难发现，对于每一方，只有 4
种决策：最大正数，最小正数，最大负数，最小负数。枚举先手的情况，如果选择合法，那么就枚举后手的情况，将乘积取最小值，最后将所有先手的情况取个最大即可。
CODE
#include&lt;bits/stdc++.h>
using namespace std;
#define int long long
#define SET(a,b) memset(a,b,sizeof(a))
int read() &#123;
	int a=0, f=1; char c=getchar();
	while(!isdigit(c)) &#123;
		if(c=='-') f=-1;
		c=getchar();
	&#125;
	while(isdigit(c)) a=a*10+c-'0', c=getchar();
	return a*f;
&#125;
const int N=1e5+5, inf=1e18;
int n, m, q, a[N], b[N], lg[N];
 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg8817-solution/" title="luogu8817 假期计划 题解">luogu8817 假期计划 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-12T12:03:39.000Z" title="发表于 2022-11-12 20:03:39">2022-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a></span></div><div class="content">分析
用 \(n\) 次 BFS
求出任意两点之间的距离。

枚举 \(b,c\)，预处理 \(p(b,0/1/2)\)，表示能到达 \(1\) 和 \(b\) 的最大/次大/第三大值，\(q(c,0/1/2)\) 同理。
那么接下来就是要求选出的两个点不等于 \(b,c\) 且不相等，是一个大分类讨论。
但是注意到最多 \(9\)
种搭配，所以只要求合法的最大值即可。
教训：不要上来就刚分类讨论，一定要把思路完善到底。对于这类有着很有限的情况和很复杂的分类，可以枚举所有合法方案取最优。
CODE
#include&lt;bits/stdc++.h>
using namespace std;
#define int long long
#define SET(a,b) memset(a,b,sizeof(a))
int read() &#123;
	int a=0, f=1; char c=getchar();
	while(!isdigit(c)) &#123;
		if(c=='-') f=-1;
		c=getchar();
	&#125;
	while(is ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg7716-solution/" title="luogu7716 Covering 题解">luogu7716 Covering 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-12T11:59:17.000Z" title="发表于 2022-11-12 19:59:17">2022-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a></span></div><div class="content">设 \(f(i,j)\) 为前 \(i\) 个纸片 ，用了 \(j\) 个的方案数。

对于一个纸片 \(i\)，如果它没有被覆盖过，那么直接继承 \(f(i-1,j-1)\)。
否则如果它没有被完全覆盖，设 \(t\)
为它所在的位置的四个方向上，编号大于它的个数。它可以把自己的另一半放到
\(t\) 个位置上。 \[
f(i,j) = tf(i-1,j-1)
\] 如果被完全覆盖，那么可以不放它，也可以放到编号大于 \(i\) 的两个位置下面，设 \(s_i\)
为有多少能防止一个纸片的位置，满足两个格子编号大于 \(i\)。 \[
f(i,j) = f(i-1,j) + s_i \cdot f(i-1,j-1)
\] 实现的时候注意几个细节。出现在棋盘上的编号是必须选取的，因此设
\(J\)
为当前棋盘已经出现了几个纸片，转移的时候强制从 \(j=J+1\) 开始。
\(s_i\)
可以预处理，再做一个后缀和。
CODE
const int N=1e3+5, mod=1e9+7;
int t, n, m, k, l, r, a[N][N], s[N ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg7715-solution/" title="luogu7715 Shape 题解">luogu7715 Shape 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-11-12T11:58:42.000Z" title="发表于 2022-11-12 19:58:42">2022-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a></span></div><div class="content">直接枚举 \((x_1,y_1)\)，\((x_2,y_2)\)，对每行每列都做前缀和，可以得到
20pts。

枚举点不如枚举横杠，设 \(f(x,y)\)
为在节点 \((x,y)\)，同时往上下方向扩展的格数。对于一个
\(x\)，枚举 \(y_1,y_2\)，如果 \((x,y_1)\) 和 \((x,y_2)\) 构成一个横杠，那么贡献为 \(\min\{ f(x,y_1),f(x,y_2) \}\)。
可以拿到 50pts。
枚举横杠又不如枚举极长横杠。
考虑对于每一行 \(x\)，直接处理两个黑色格子中间的部分，设为
\([l,r]\)，那么贡献为 \[
\sum_{y_1=l}^r \sum_{y2=y_1+1}^r \min\{f(x,y_1),f(x,y_2)\}
\] 考虑如果将 \(f(x,y)\)
递增排序，那么对于排名为 \(k\) 的 \(f(x,y_0)\) 会贡献出 \(r-k\) 次。
于是乎这部分的复杂度为 \(O(nm \log_2
m)\)，可以通过。
关于 \(f\)
的预处理，要摒弃求前缀和暴力判断的做法，下 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg6748-solution/" title="luogu6748 Fallen Lord 题解">luogu6748 Fallen Lord 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-23T03:55:45.000Z" title="发表于 2022-10-23 11:55:45">2022-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A0%91%E5%BD%A2DP/">树形DP</a></span></div><div class="content">值得一提的是，我一开始读错题，认为对于节点 \(x\)，是根到它的路径上的中位数不能超过 \(a_x\)，导致连暴力都不会打。

分析
发现每条边 \((x,y)\) 的权值只可能是
\(a_x\)，\(a_y\)，\(m\)。
对于一个节点 \(x\)，与它相连的所有边权的中位数不超过 \(a_x\)，那么 \(deg_x\) 条边中，最多有 \(\lfloor \frac{deg_x}{2} \rfloor + 1\)
条边小于等于 \(a_x\)，也就是至多有
\(\lceil \frac{deg_x}{2} \rceil - 1\)
条边权大于 \(a_x\)。设其为 \(t\)。
设 \(f(x,0/1)\) 表示 \((x,fa_x)\) 的权值是小于等于还是大于 \(a_x\)。
对于 \(f(x,0)\)，在 \(x\) 连向子节点的边中，最多可以有 \(t\) 条边大于 \(a_x\)。
对于 \(f(x,1)\)，这样的边数为 \(t-1\)。
考虑 \(x\) 的子节点 \(y\)，设 \(g(y,0)\) 为 \((x,y)\) 的边小于 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf981d-solution/" title="CF981D Bookshelves 题解">CF981D Bookshelves 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-23T03:54:58.000Z" title="发表于 2022-10-23 11:54:58">2022-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a></span></div><div class="content">分析
按位贪心。

由于高位的 \(1\) 优于低位的所有
\(1\)，所以考虑一个过程check(x)，表示是否能够在保证更高位的
\(1\)
不会减少的情况下，使得当前这一位为 \(1\)。
设 \(f(i,j)\) 表示前 \(i\) 本书，划分成 \(j\) 段是否可行。 \[
f(i,j) = \operatorname{OR}_{k=0}^{i-1} f(k,j-1) \operatorname{AND}
[sum(k+1,i) \&amp; x = x]
\] 如果 \(sum(k+1,i) \&amp; x =
x\)，那么说明这一段在满足之前所有 \(1\) 的情况下还能满足这一位是 \(1\)。至于其他位则不必关心。
CODE
const int N=55;
int n, k, s[N], f[N][N];
int check(int x) &#123;
	SET(f,0);
	f[0][0]=1;
	for(int i=1;i&lt;=n;++i) &#123;
		for(int j=1;j&lt;=k;++j) for(int k=0 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg8162-solution/" title="luogu8162 让我们赢得选举 题解">luogu8162 让我们赢得选举 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-22T13:52:14.000Z" title="发表于 2022-10-22 21:52:14">2022-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a></span></div><div class="content">分析
首先让自己和协作者在多个不同的州演讲一定不优。

证明：反证法。假设更优，那么由于自己和协作者的演讲速度相同，所以在同样的时间里，让协作者为自己「加速」和分头演讲的总量是不变的。而让自己加速能够在更短的时间里得到正在演讲的那个州的票，矛盾。
其次，对于任意一个州，它的演讲时间只能为 \(A_i\)，\(B_i[B_i
\neq -1]\)，\(0\)。这个是显然的。为了方便起见，分别称之为
2 类州，1 类州和 3 类州。
对于所有 1 类州，一定最先被演讲完。
证明：微扰。如果存在一个 1 类州在一个 2 类州之后，将二者交换后，在
\(j\) 演讲的时候就多了一个演讲者，在
\(B_i\)
演讲时演讲者数量不变，显然更优。
对于所有 1 类州，一定按照 \(B_i\)
为第一关键字，\(A_i\)
为第二关键字递增排序。
证明：微扰。如果存在一种不符合这个法则的方案，设他们为 \((i,j)\)，那么得到两张票的用时为 \[
\frac{B_i}{k} + \frac{B_j}{k+1}
\] 交换后为 \[
\frac{B_i}{k+1} ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/tititi-solution-4/" title="杂题选讲4">杂题选讲4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-22T13:51:55.000Z" title="发表于 2022-10-22 21:51:55">2022-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/">二分答案</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">组合数学</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a></span></div><div class="content">杂题选讲 4.

luogu8110 矩阵
分析
萌萌题。 \[
A^2_{i,j} = \sum_{i=k}^n A_{i,k} \cdot A_{k,j} = \sum_{k=1}^n
a_ib_ka_kb_j = a_ib_j\Big( (\sum_{k=1}^n a_ib_i)  = d\Big)
\]
\[
\sum_{i=1}^n \sum_{j=1}^n A^2_{i,j} = \sum_{i=1}^n \sum_{j=1}^n a_ib_jd
= \Big( \sum_{i=1}^n a_i \cdot \sum_{i=1}^n b_i \Big) d
\]
归纳一下得到答案。
CODE
int n, k, sa, sb, a[N], b[N];
int fp(int a,int b) &#123;
	int c=1;
	for(;b;a=a*a%mod,b>>=1) if(b&amp;1) c=c*a%mod;
	return c;
&#125;
signed main() &#123;
	n=read(), k=read();
	for( ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/lg8112-solution/" title="luogu8112 符文破译 题解">luogu8112 符文破译 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-10-22T13:51:29.000Z" title="发表于 2022-10-22 21:51:29">2022-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调队列</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%89%A9%E5%B1%95kmp/">扩展kmp</a></span></div><div class="content">分析
显然 \(Z\) 函数。
由于在 \(Z\)
函数中考虑的是匹配串的后缀，所以从后往前考虑。

设 \(f_i\) 为考虑 \([i,n]\)，能够划分的最小段数，设 \(g_i\) 为匹配串的 \([i,n]\) 与模式串的 LCP 长度。
转是显然的。
\[
f_i = \min_{j \in [i+1,i+g_i]} \{ f_j  \} + 1
\]
虽然 \(i+g_i\)
不存在单调性，但是考虑如果存在 \(i&lt;j\)，满足 \(g_i &gt; g_j\)，那么从 \(j\) 划分一定不优，于是直接把 \(j\)
删掉就行，这样就满足单调性，可以用单调队列优化。
不难证明，如果这样做后无解，那么不这样做一定无解。
CODE
const int N=1e7+5, inf=0x3f3f3f3f;
int n, m, z[N], g[N], f[N], q[N];
char s[N], t[N];
void Z() &#123;
	int l=0, r=0;
	z[0]=n;
	for(int i=1;i&lt;n;++i) &#123 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/#content-inner">21</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yozora0908</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="sticky_layout"><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/2-SAT/" style="font-size: 1.1em; color: #999">2-SAT</a> <a href="/tags/2021%E7%9A%84%E5%A4%8F%E5%A4%A9/" style="font-size: 1.14em; color: #999b9d">2021的夏天</a> <a href="/tags/2021%E7%9A%84%E6%9A%91%E5%81%87/" style="font-size: 1.18em; color: #999ca1">2021的暑假</a> <a href="/tags/2022%E7%9A%84%E6%9A%91%E5%81%87/" style="font-size: 1.1em; color: #999">2022的暑假</a> <a href="/tags/AtCoder/" style="font-size: 1.14em; color: #999b9d">AtCoder</a> <a href="/tags/Codeforces/" style="font-size: 1.42em; color: #99a6b7">Codeforces</a> <a href="/tags/DAG/" style="font-size: 1.18em; color: #999ca1">DAG</a> <a href="/tags/DP/" style="font-size: 1.5em; color: #99a9bf">DP</a> <a href="/tags/Floyd/" style="font-size: 1.1em; color: #999">Floyd</a> <a href="/tags/KMP%E7%AE%97%E6%B3%95/" style="font-size: 1.18em; color: #999ca1">KMP算法</a> <a href="/tags/Lucas%E5%AE%9A%E7%90%86/" style="font-size: 1.1em; color: #999">Lucas定理</a> <a href="/tags/Miku/" style="font-size: 1.1em; color: #999">Miku</a> <a href="/tags/NowCoder/" style="font-size: 1.18em; color: #999ca1">NowCoder</a> <a href="/tags/OI/" style="font-size: 1.18em; color: #999ca1">OI</a> <a href="/tags/SOS/" style="font-size: 1.14em; color: #999b9d">SOS</a> <a href="/tags/SPFA/" style="font-size: 1.1em; color: #999">SPFA</a> <a href="/tags/Trie/" style="font-size: 1.18em; color: #999ca1">Trie</a> <a href="/tags/VOCALOID/" style="font-size: 1.1em; color: #999">VOCALOID</a> <a href="/tags/yozora-Round/" style="font-size: 1.3em; color: #99a1ac">yozora Round</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/" style="font-size: 1.14em; color: #999b9d">中国剩余定理</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 1.3em; color: #99a1ac">二分图</a> <a href="/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" style="font-size: 1.34em; color: #99a3b0">二分答案</a> <a href="/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/" style="font-size: 1.1em; color: #999">交互题</a> <a href="/tags/%E5%80%8D%E5%A2%9E/" style="font-size: 1.14em; color: #999b9d">倍增</a> <a href="/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">决策单调性优化</a> <a href="/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/" style="font-size: 1.14em; color: #999b9d">分数规划</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 1.14em; color: #999b9d">分治</a> <a href="/tags/%E5%8C%BA%E9%97%B4DP/" style="font-size: 1.34em; color: #99a3b0">区间DP</a> <a href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size: 1.38em; color: #99a4b4">单调队列</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 1.18em; color: #999ca1">双指针</a> <a href="/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size: 1.1em; color: #999">双连通分量</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 1.46em; color: #99a7bb">图论</a> <a href="/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/" style="font-size: 1.14em; color: #999b9d">基环树</a> <a href="/tags/%E5%A4%B1%E9%85%8D%E6%A0%91/" style="font-size: 1.1em; color: #999">失配树</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 1.26em; color: #999fa8">字符串</a> <a href="/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" style="font-size: 1.18em; color: #999ca1">容斥原理</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size: 1.1em; color: #999">差分</a> <a href="/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/" style="font-size: 1.14em; color: #999b9d">差分约束系统</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 1.22em; color: #999ea4">并查集</a> <a href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size: 1.18em; color: #999ca1">强连通分量</a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By yozora0908</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["Sky Arrow"],
      startDelay: 300,
      typeSpeed: 150,
      loop: false,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = 'Sky Arrow'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script></div></body></html>