<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LOJ#2331 某位歌姬的故事 题解</title>
    <link href="/2023/loj2331-solution/"/>
    <url>/2023/loj2331-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="solution">Solution</h2><p>对于每个位置 <span class="math inline">\(i\)</span>，我们维护一个<span class="math inline">\(up_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 能填入的上界。这样每个限制 <spanclass="math inline">\((l,r,x)\)</span> 相当于让 <spanclass="math inline">\(i \in [l,r]\)</span> 的 <spanclass="math inline">\(up_i\)</span> 对 <spanclass="math inline">\(x\)</span> 取 <spanclass="math inline">\(\min\)</span>。</p><p>继续分析限制，发现它其实限制了两点：</p><ol type="1"><li><span class="math inline">\(\forall i \in [l,r]\)</span>，<spanclass="math inline">\(a_i \le x\)</span>。</li><li><span class="math inline">\(\exists i \in [l,r]\)</span>，<spanclass="math inline">\(a_i = x\)</span>。</li></ol><p><span class="math inline">\(up_i\)</span>已经保证了第一点，考虑如何满足第二点。</p><p>对于一个限制 <span class="math inline">\((l,r,x)\)</span>，能取到<span class="math inline">\(w\)</span> 的位置 <spanclass="math inline">\(k\)</span> 一定满足 <span class="math inline">\(k\in [l,r]\)</span> 并且 <span class="math inline">\(up_k =x\)</span>。但我们计数的序列要求本质不同，所以不能“钦定一个 <spanclass="math inline">\(a_k\)</span> 取 <spanclass="math inline">\(x\)</span> 然后剩下的随便选”，否则会出现重复。</p><p>仔细思考不难发现，<span class="math inline">\(up_i\)</span>不同的点是相对独立的。所以我们枚举每个 <spanclass="math inline">\(x\)</span>，把所有 <spanclass="math inline">\(up_i=x\)</span>的点提取出来，同时处理满足这些限制的方案数。</p><div class="note note-primary">            <p>注意，本来我们应该对于每个限制单独提取相应的点，但是这样需要维护区间信息，大大增加工作量。</p>          </div><p>把坐标离散化了，设 <span class="math inline">\(f(i,j)\)</span>为考虑了前 <span class="math inline">\(i\)</span> 个位置，其中上一个<span class="math inline">\(x\)</span> 的位置在 <spanclass="math inline">\(j\)</span> 的方案数。转移比较平凡，不再赘述。</p><p>但是本题最难处理的地方在于细节，下面简单列举。</p><ul><li><p>需要处理没有被限制区间覆盖到的点。</p></li><li><p>离散化后，DP前提取的是限制的端点，真正有贡献的则是夹在端点间的点。</p></li><li><p>提取的点之间，就算是被同一个限制覆盖，也可能是不连续的。</p></li><li><p>DP 转移时，如果要 <span class="math inline">\(f(i-1,j)\rightarrow f(i,j)\)</span>，那么必须要求 <spanclass="math inline">\(i-1\)</span> 与 <spanclass="math inline">\(i\)</span> 在同一个限制区间里。</p></li></ul><p>为了更好地处理区间边界问题，使用<strong>左闭右开</strong>。它的好处是离散化后任意两个坐标对应的值相减，都是区间内点的个数。</p><p>具体细节的处理见代码。</p><p>时间复杂度 <span class="math inline">\(\mathcal{O}(Q^3)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353ll</span>;<span class="hljs-type">int</span> T, n, q, A, up[N], L[N];<span class="hljs-type">int</span> cnt, t[N];<span class="hljs-type">int</span> cntx, x[N];<span class="hljs-type">int</span> lim, p[N];ll f[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r, x;&#125; a[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;ll c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=<span class="hljs-number">1ll</span>*a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">ll <span class="hljs-title">DP</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;lim=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-keyword">if</span>(up[i]==k) p[++lim]=i, L[lim]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) <span class="hljs-keyword">if</span>(a[i].x==k) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">lower_bound</span>(p+<span class="hljs-number">1</span>,p+lim+<span class="hljs-number">1</span>,a[i].l)-p;<span class="hljs-type">int</span> r=<span class="hljs-built_in">lower_bound</span>(p+<span class="hljs-number">1</span>,p+lim+<span class="hljs-number">1</span>,a[i].r)-p<span class="hljs-number">-1</span>;L[r]=<span class="hljs-built_in">max</span>(L[r],l);        <span class="hljs-comment">// 维护限制区间内最靠右边的点，对应的最靠右的能覆盖到它的左端点</span>&#125;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1ll</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i) &#123;f[i][i]=<span class="hljs-number">0</span>;ll k1=<span class="hljs-built_in">fp</span>(k,t[p[i]+<span class="hljs-number">1</span>]-t[p[i]]), k2=<span class="hljs-built_in">fp</span>(k<span class="hljs-number">-1</span>,t[p[i]+<span class="hljs-number">1</span>]-t[p[i]]);        <span class="hljs-comment">// 如果端点p[i]被x=k的端点覆盖了，那么[p[i],p[i+1])中的点就一定满足up=k</span>        <span class="hljs-comment">// k2是这一段的值都小于k的方案数</span>        <span class="hljs-comment">// k1是这一段的值都不能超过k的方案数</span>        <span class="hljs-comment">// 二者之差是至少存在一个k，都不能超过k的方案数</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) &#123;f[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L[i]&lt;=j) f[i][j]=f[i<span class="hljs-number">-1</span>][j]*k2%mod;            <span class="hljs-comment">// 如果i到达了某个限制区间最靠右的坐标，那么就必须要在这个限制区间内转移过来</span>            <span class="hljs-comment">// i每次增加1，所以能保证正确性</span>(f[i][i]+=f[i<span class="hljs-number">-1</span>][j]*(k1-k2+mod)%mod)%=mod;&#125;&#125;ll res=<span class="hljs-number">0ll</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i) (res+=f[lim][i])%=mod;<span class="hljs-keyword">return</span> res; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;cnt=cntx=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) &#123;a[i].l=<span class="hljs-built_in">read</span>(), a[i].r=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, a[i].x=<span class="hljs-built_in">read</span>();        <span class="hljs-comment">// 左闭右开</span>t[++cnt]=a[i].l, t[++cnt]=a[i].r;x[++cntx]=a[i].x;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;t[++cnt]=<span class="hljs-number">1</span>, t[++cnt]=n+<span class="hljs-number">1</span>;    <span class="hljs-comment">// 需要加入端点</span><span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>);cnt=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) up[i]=<span class="hljs-number">1e9</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) &#123;a[i].l=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>,a[i].l)-t;a[i].r=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>,a[i].r)-t;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a[i].l;j&lt;a[i].r;++j) up[j]=<span class="hljs-built_in">min</span>(up[j],a[i].x);        <span class="hljs-comment">// 把范围内的端点都覆盖了，注意左闭右开</span>&#125;<span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+cntx+<span class="hljs-number">1</span>);cntx=<span class="hljs-built_in">unique</span>(x+<span class="hljs-number">1</span>,x+cntx+<span class="hljs-number">1</span>)-(x+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">input</span>();<span class="hljs-built_in">lsh</span>();ll ans=<span class="hljs-number">1ll</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cntx;++i) &#123;(ans*=<span class="hljs-built_in">DP</span>(x[i]))%=mod;<span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>(up[i]==<span class="hljs-number">1e9</span>) &#123;        <span class="hljs-comment">// 最后仍然没有被覆盖到的端点</span>        <span class="hljs-comment">// 其实是某些右端点+1后的位置</span>(ans*=<span class="hljs-built_in">fp</span>(A,t[i+<span class="hljs-number">1</span>]-t[i]))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="题外话">题外话</h2><p>有很多细节，很难写。</p><p>但是可以退而求其次，不离散化，用这个做法对付 <spanclass="math inline">\(n \le 500\)</span> 的测试点也是绰绰有余。</p><p>不愧是集训队的题目，真是令人印象深刻啊。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ#3267 Help Yourself 题解</title>
    <link href="/2023/loj3267-solution/"/>
    <url>/2023/loj3267-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="help-yourself-gold">Help Yourself Gold</h2><p>考虑每条线段的贡献。</p><p>把所有线段按左端点排序，设 <span class="math inline">\(f(i)\)</span>为前 <span class="math inline">\(i\)</span> 条线段所有子集的贡献和。</p><ul><li>不选 <span class="math inline">\(i\)</span>，贡献是 <spanclass="math inline">\(f(i-1)\)</span>。</li><li>选 <span class="math inline">\(i\)</span>。设有 <spanclass="math inline">\(cnt\)</span> 条线段 <spanclass="math inline">\(j\)</span> 满足 <span class="math inline">\(r_j&lt; l_i\)</span>，那么当选出的线段子集是这些线段的子集时，贡献都会增加<span class="math inline">\(1\)</span>，否则不变。因此贡献是 <spanclass="math inline">\(f(i-1)+2^{cnt}\)</span>。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, pw[N], f[<span class="hljs-number">2</span>*N], cnt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a,PII b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.se&lt;b.se; &#125;PII a[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>(), pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod, cnt[a[i].se]=<span class="hljs-number">1</span>;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) cnt[i]+=cnt[i<span class="hljs-number">-1</span>];f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]%mod+pw[cnt[a[i].fi<span class="hljs-number">-1</span>]])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="help-yourself-platinum">Help Yourself Platinum</h3><p>把所有线段按照左端点排序。</p><p>设 <span class="math inline">\(f_{\delta}(i,r)\)</span> 表示考虑了前<span class="math inline">\(i\)</span> 条线段，最右边的端点在 <spanclass="math inline">\(r\)</span>，所有线段子集的<strong>并</strong>的连通块数<span class="math inline">\(\delta\)</span> 次方和。</p><p>形式化地，有 <span class="math display">\[f_{\delta}(i,r) = \sum_{S \subseteq U, \text{endpos}(S)=r}\text{cnt}(S)^{\delta}\]</span> 其中 <span class="math inline">\(\text{cnt}(S)\)</span>为线段<strong>并</strong> <span class="math inline">\(S\)</span>的连通块数量。</p><p>定义变换 <spanclass="math inline">\(\mathcal{T}\Big(f_{\delta}(i,r)\Big)\)</span>表示对状态 <span class="math inline">\(f_{\delta}(i,r)\)</span> 中所有<span class="math inline">\(\text{cnt}(S)\)</span> 进行 <spanclass="math inline">\(+1\)</span> 操作后得到的值。</p><p>对新加入的线段端点进行讨论，可得 <span class="math display">\[f_{\delta}(i,r_i) = \sum_{j=0}^{l_i-1}\mathcal{T}\Big(f_{\delta}(i-1,j)\Big) + \sum_{j=l_i}^{r_i}f_{\delta}(i-1,j)\]</span> 然后对于 <span class="math inline">\(j &gt; r_i\)</span>，有<span class="math display">\[f_{\delta}(i-1,j) \rightarrow f_{\delta}(i,j)\]</span> 然后我们考虑如何实现 <spanclass="math inline">\(\mathcal{T}\)</span>。 <spanclass="math display">\[\mathcal{T}\Big(f_{\delta}(i,j)\Big) = \sum_{S \subseteq U}\Big(\text{cnt}(S)+1\Big)^{\delta} = \sum_{S \subseteq U}\sum_{k=0}^{\delta} \binom{\delta}{k} \text{cnt}(S)^{k} =\sum_{k=0}^{\delta} \binom{\delta}{k} f_{k}(i,j)\]</span></p><p>可以 <span class="math inline">\(O(K)\)</span> 求出。</p><p>所以得到了一个 <span class="math inline">\(O(n^2 K^2)\)</span>的做法，可以得到 <span class="math inline">\(50\text{pts}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, K, pre[N], f[<span class="hljs-number">12</span>][N][<span class="hljs-number">2</span>*N];<span class="hljs-type">int</span> c[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];PII a[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(t,<span class="hljs-number">0</span>,k) &#123;(res+=c[k][t]*f[t][i][j]%mod)%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;f[k][<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>].se]=<span class="hljs-number">1</span>;f[k][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=(k==<span class="hljs-number">0</span>? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> l=a[i].fi, r=a[i].se;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,pre[i]) f[k][i][j]+=f[k][i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">// f[k][i][r]=f[k][i-1][r];</span><span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>) &#123;(f[k][i][r]+=<span class="hljs-built_in">T</span>(k,i<span class="hljs-number">-1</span>,j))%=mod;&#125;<span class="hljs-built_in">rep</span>(j,l,r) &#123;(f[k][i][r]+=f[k][i<span class="hljs-number">-1</span>][j])%=mod;&#125;<span class="hljs-built_in">rep</span>(j,r+<span class="hljs-number">1</span>,pre[i])  &#123;(f[k][i][j]+=f[k][i<span class="hljs-number">-1</span>][j])%=mod;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) pre[i]=<span class="hljs-built_in">max</span>(pre[i<span class="hljs-number">-1</span>],a[i].se);c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=K;++k) <span class="hljs-built_in">calc</span>(k);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,pre[n]) (ans+=f[K][n][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>考虑优化。</p><p>观察 <span class="math inline">\(\mathcal{T}\)</span>，可以发现 <spanclass="math display">\[\sum_{j=0}^{l_i-1} \mathcal{T}\Big(f_{\delta}(i-1,j)\Big) =\mathcal{T}\Big( \sum_{j=0}^{l_i-1} f_{\delta}(i-1,j) \Big)\]</span> 组合意义比较 <spanclass="math inline">\(\text{Trivial}\)</span>。</p><p>套路性的把 <span class="math inline">\(j\)</span>这一维拍到线段树上，每个线段树节点维护 <spanclass="math inline">\(j\)</span> 点上 <span class="math inline">\(\delta\in [0,K]\)</span> 时对应的 <span class="math inline">\(f\)</span>值。</p><p>每加入一条线段 <spanclass="math inline">\([l_i,r_i]\)</span>，做三种操作：</p><ol type="1"><li>对 <span class="math inline">\(r_i\)</span> 单点加 <spanclass="math inline">\(\mathcal{T}\Big( \sum_{j=0}^{l_i-1}f_{\delta}(i-1,j) \Big)\)</span>。</li><li>对 <span class="math inline">\(r_i\)</span> 单点加 <spanclass="math inline">\(\sum_{j=l_i}^{r_i}f_{\delta}(i-1,j)\)</span>。</li><li>对 <span class="math inline">\([r_i+1,2n]\)</span> 区间乘 <spanclass="math inline">\(2\)</span>。</li></ol><p>注意查询操作需要在修改操作之前。</p><p>时间复杂度 <span class="math inline">\(O(n K^2 + n \log_2nK)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, K, c[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];PII a[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> s[<span class="hljs-number">11</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(s,<span class="hljs-number">0</span>); &#125;<span class="hljs-built_in">node</span>() &#123; <span class="hljs-built_in">init</span>(); &#125;node <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> node&amp; o) &#123;node r=*<span class="hljs-keyword">this</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,K) r.s[i]=(s[i]+o.s[i])%mod;<span class="hljs-keyword">return</span> r;&#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a) &#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,K) (s[i]*=a)%=mod;&#125;&#125;;node t[N&lt;&lt;<span class="hljs-number">3</span>];<span class="hljs-type">int</span> tag[N&lt;&lt;<span class="hljs-number">3</span>];<span class="hljs-function">node <span class="hljs-title">T</span><span class="hljs-params">(node a)</span> </span>&#123;node res=<span class="hljs-built_in">node</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;++j) &#123;(res.s[i]+=c[i][j]*a.s[j]%mod)%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;t[x]*=d;(tag[x]*=d)%=mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,tag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,tag[x]);tag[x]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;tag[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l==r) &#123;<span class="hljs-keyword">if</span>(l==<span class="hljs-number">0</span>) t[x].s[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function">node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<span class="hljs-built_in">pushdown</span>(x);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;node res=<span class="hljs-built_in">node</span>();<span class="hljs-keyword">if</span>(L&lt;=mid) res=res+<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) res=res+<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf</span><span class="hljs-params">(<span class="hljs-type">int</span> p,node&amp; d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) &#123;t[x]=t[x]+d;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">pushdown</span>(x);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">mdf</span>(p,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf</span>(p,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> r=m)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;<span class="hljs-built_in">maketag</span>(x,d);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">pushdown</span>(x);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();m=n&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">prework</span>();<span class="hljs-built_in">build</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> l=a[i].fi, r=a[i].se;node d=<span class="hljs-built_in">T</span>(<span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>))+<span class="hljs-built_in">query</span>(l,r);<span class="hljs-built_in">mdf</span>(r,d);<span class="hljs-keyword">if</span>(r+<span class="hljs-number">1</span>&lt;=m) <span class="hljs-built_in">upd</span>(r+<span class="hljs-number">1</span>,m,<span class="hljs-number">2</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t[<span class="hljs-number">1</span>].s[K]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1707C DFS Trees 题解</title>
    <link href="/2023/cf1707c-solution/"/>
    <url>/2023/cf1707c-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>考虑这个算法什么时候会假掉。</p><p>如果这样选出的一条边 <span class="math inline">\((x,y)\)</span> 不在MST 中，那么说明此时 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 已经连通，也就说这条边是 MST上的返祖边。</p><p>直接考虑以每个节点为根，是否会选出 MST上的返祖边并不容易。我们尝试从每条边入手，考虑以哪些节点为根时，这条边会成为返祖边。</p><p>由于边权各不相同，所以 MST 唯一。我们先把 MST 求出来，设其为 <spanclass="math inline">\(T\)</span>，随便定一个根。</p><p>考虑每一条非 MST 边 <span class="math inline">\((x,y)\)</span>，钦定<span class="math inline">\(\text{dep}(x) \ge\text{dep}(y)\)</span>，<span class="math inline">\(z =\text{LCA}(x,y)\)</span>。</p><ul><li>如果 <span class="math inline">\(z \neq y\)</span>，那么只有以 <spanclass="math inline">\(\text{subtree}(x)\)</span> 或 <spanclass="math inline">\(\text{subtree}(y)\)</span>中的节点为根时，才会使得这条边被错误地加入 MST。</li><li>如果 <span class="math inline">\(z = y\)</span>，那么就是 <spanclass="math inline">\(\text{subtree}(x)\)</span> 中的节点，以及 <spanclass="math inline">\(T - \text{subtree}\Big(son_x(y)\Big)\)</span>中的节点。</li></ul><p>其中 <span class="math inline">\(son_x(y)\)</span> 表示 <spanclass="math inline">\(y\)</span> 一个子节点，满足其所在子树包含 <spanclass="math inline">\(x\)</span>。</p><p>那么从 <span class="math inline">\(x\)</span> 执行算法，能求出 MST的充要条件是 <span class="math inline">\(x\)</span>被上述每一条边都统计到一次。</p><p>问题转化为子树加，单点查，再转化一下就是单点加，求树上前缀和。</p><p><span class="math inline">\(son_x(y)\)</span>可以用倍增轻松找到。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, v[N&lt;&lt;<span class="hljs-number">1</span>], f[N][<span class="hljs-number">17</span>], dep[N], c[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, z;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node b) &#123;<span class="hljs-keyword">return</span> z&lt;b.z;&#125;&#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);dsu.<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=dsu.<span class="hljs-built_in">get</span>(e[i].x), y=dsu.<span class="hljs-built_in">get</span>(e[i].y);<span class="hljs-keyword">if</span>(x!=y) &#123;v[i]=<span class="hljs-number">1</span>;dsu.fa[x]=y;<span class="hljs-comment">// if(++cnt==n-1) break;</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(v[i]) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>;f[x][<span class="hljs-number">0</span>]=fa;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">16</span>;++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) <span class="hljs-keyword">if</span> (dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;c[y]+=c[x];<span class="hljs-built_in">dfs2</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;e[i].x=<span class="hljs-built_in">read</span>(), e[i].y=<span class="hljs-built_in">read</span>(), e[i].z=i;&#125;<span class="hljs-built_in">kruskal</span>();<span class="hljs-built_in">build</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">if</span>(z==y) &#123;++c[<span class="hljs-number">1</span>], ++c[x];<span class="hljs-type">int</span> t=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">16</span>;~j;--j) <span class="hljs-keyword">if</span>(dep[f[t][j]]&gt;dep[y]) t=f[t][j];--c[t]; &#125; <span class="hljs-keyword">else</span> ++c[x], ++c[y];&#125;<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(c[i]==m-n+<span class="hljs-number">1</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>树上倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ#2955 保卫王国 题解</title>
    <link href="/2023/loj2955-solution/"/>
    <url>/2023/loj2955-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="部分分">部分分</h2><p>先考虑暴力怎么打。</p><p>规定原树为 <span class="math inline">\(T\)</span>，以 <spanclass="math inline">\(x\)</span> 为根的子树为 <spanclass="math inline">\(T(x)\)</span>。</p><p>设 <span class="math inline">\(f(x,0/1)\)</span> 为考虑 <spanclass="math inline">\(T(x)\)</span>，其中 <spanclass="math inline">\(x\)</span> 选或不选的最小权点覆盖，设 <spanclass="math inline">\(g(x,0/1)\)</span> 为考虑 <spanclass="math inline">\(T-T(x)\)</span>，其中 <spanclass="math inline">\(x\)</span> 选或不选的最小权点覆盖。有转移 <spanclass="math display">\[f(x,0) = \sum_{y \in son(x)} f(y,1)\]</span></p><p><span class="math display">\[f(y,1) = \sum_{y \in son(x)} \min\Big(f(y,0),f(y,1)\Big)\]</span></p><p><span class="math display">\[g(y,0) = g(x,1) + f(x,1) - \min\Big(f(y,0),f(y,1)\Big)\]</span></p><p><span class="math display">\[g(y,1) = \min \Big( g(x,0)+f(x,0)-f(y,1),g(y,0) \Big)\]</span></p><p>预处理 <span class="math inline">\(f\)</span> 与 <spanclass="math inline">\(g\)</span>，复杂度是 <spanclass="math inline">\(O(n)\)</span> 的。</p><p>设 <span class="math inline">\(z =\text{LCA}(x,y)\)</span>，对于每个询问，我们暴力修改 <spanclass="math inline">\(f(x)\)</span> 与 <spanclass="math inline">\(f(y)\)</span>，然后求出 <spanclass="math inline">\(f(z)\)</span> 即可。</p><p>这样可以通过前 <span class="math inline">\(11\)</span> 个测试点。</p><p>对于链的情况，我们直接预处理前缀与后缀最小权点覆盖，然后对 <spanclass="math inline">\([x,y]\)</span> 做矩阵加速的最小权点覆盖即可。</p><p>然后就通过前 <span class="math inline">\(17\)</span> 个点了。</p><h2 id="正解">正解</h2><p>承接上文，我不会动态 DP。</p><p>设 <span class="math inline">\(fa(x,i)\)</span> 为 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(2^i\)</span> 级祖先，<spanclass="math inline">\(h(x,i,a,b)\)</span> 为从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(fa(x,i)\)</span>，其中 <spanclass="math inline">\(x\)</span> 的驻军状态是 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(fa(x,i)\)</span> 的驻军状态是 <spanclass="math inline">\(b\)</span>，这条链的最小代价。</p><p>这个的预处理就比上一题简单不少了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// int h[N][17][2][2]</span><span class="hljs-keyword">auto</span> H=h[y][<span class="hljs-number">0</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">0</span>]-f[y][<span class="hljs-number">1</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=H[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<span class="hljs-comment">// 然后倍增一下</span></code></pre></div><p>根据个人习惯把询问改为 <spanclass="math inline">\((x,a,y,b)\)</span>，表示强制令节点 <spanclass="math inline">\(x\)</span> 的状态为 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(y\)</span>的状态为 <span class="math inline">\(b\)</span>。</p><p>钦定 <span class="math inline">\(\text{dep}(x) \ge\text{dep}(y)\)</span>，<span class="math inline">\(z =\text{LCA}(x,y)\)</span>。</p><p>如果 <span class="math inline">\(z=y\)</span>，那么直接倍增出 <spanclass="math inline">\((x,y)\)</span> 的最小代价，加上 <spanclass="math inline">\(f(x,a)\)</span> 与 <spanclass="math inline">\(g(y,b)\)</span>。</p><p>否则拆成 <span class="math inline">\(\Big(x,pre_x(z)\Big)\)</span> 与<span class="math inline">\(\Big(y,pre_y(z)\Big)\)</span>两条链，分别倍增求出，再拼起来。</p><p>其中 <span class="math inline">\(pre_x(z)\)</span> 表示 <spanclass="math inline">\(x\)</span> 的一个祖先，满足它是 <spanclass="math inline">\(y\)</span> 的一个子节点。</p><p>求 <span class="math inline">\(pre_x(z)\)</span> 的过程可以放进倍增求<span class="math inline">\(\text{LCA}\)</span> 中，很方便。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x0f0f0f0f0f0f0f0f</span>;<span class="hljs-type">int</span> n, m, lim, c[N], dep[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>], g[N][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> fa[N][<span class="hljs-number">17</span>], h[N][<span class="hljs-number">17</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">char</span> s[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span></span><span class="hljs-function"></span>&#123;    dep[x]=dep[fr]+<span class="hljs-number">1</span>;    fa[x][<span class="hljs-number">0</span>]=fr;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];++i) fa[x][i]=fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=c[x];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;        <span class="hljs-built_in">dfs1</span>(y,x);        f[x][<span class="hljs-number">0</span>]+=f[y][<span class="hljs-number">1</span>];        f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;g[y][<span class="hljs-number">0</span>]=g[x][<span class="hljs-number">1</span>]+f[x][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);g[y][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(g[x][<span class="hljs-number">0</span>]+f[x][<span class="hljs-number">0</span>]-f[y][<span class="hljs-number">1</span>],g[y][<span class="hljs-number">0</span>]);<span class="hljs-keyword">auto</span> H=h[y][<span class="hljs-number">0</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">0</span>]-f[y][<span class="hljs-number">1</span>];H[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=H[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[y];++i) <span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(c,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;h[y][i][a][c]=<span class="hljs-built_in">min</span>(h[y][i][a][c],h[y][i<span class="hljs-number">-1</span>][a][b]+h[fa[y][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>][b][c]);&#125;<span class="hljs-built_in">dfs2</span>(y,x);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;res[a]=<span class="hljs-number">0</span>;res[a^<span class="hljs-number">1</span>]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]&amp;&amp;dep[fa[x][i]]&gt;=dep[y]) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">2</span>,inf)</span></span>;<span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) t[b]=<span class="hljs-built_in">min</span>(t[b],res[a]+h[x][i][a][b]);x=fa[x][i], res=t;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> tx=x, ty=y;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]&amp;&amp;dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];<span class="hljs-keyword">if</span>(x==y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">calc</span>(tx,a,y)[b]+f[tx][a]+g[y][b];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i], y=fa[y][i];<span class="hljs-type">int</span> z=fa[x][<span class="hljs-number">0</span>]; <span class="hljs-keyword">auto</span> F=<span class="hljs-built_in">calc</span>(tx,a,x), G=<span class="hljs-built_in">calc</span>(ty,b,y);<span class="hljs-type">int</span> res0=F[<span class="hljs-number">1</span>]+G[<span class="hljs-number">1</span>]+(f[z][<span class="hljs-number">0</span>]-f[x][<span class="hljs-number">1</span>]-f[y][<span class="hljs-number">1</span>])+g[z][<span class="hljs-number">0</span>];<span class="hljs-type">int</span> res1=<span class="hljs-built_in">min</span>(F[<span class="hljs-number">0</span>],F[<span class="hljs-number">1</span>])+<span class="hljs-built_in">min</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">1</span>])+(f[z][<span class="hljs-number">1</span>]-<span class="hljs-built_in">min</span>(f[x][<span class="hljs-number">0</span>],f[x][<span class="hljs-number">1</span>])-<span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]))+g[z][<span class="hljs-number">1</span>];    <span class="hljs-comment">// 两种情况为z是否驻军</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(res0,res1)+f[tx][a]+f[ty][b];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;defense.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;defense.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>&lt;&lt;(lim+<span class="hljs-number">1</span>)&lt;=n) ++lim;<span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0x0f</span>);<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), a=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y), <span class="hljs-built_in">swap</span>(a,b);<span class="hljs-keyword">if</span>(!a&amp;&amp;!b&amp;&amp;fa[x][<span class="hljs-number">0</span>]==y) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>(x,a,y,b));&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树论</tag>
      
      <tag>树上倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8820 数据传输 题解</title>
    <link href="/2023/lg8820-solution/"/>
    <url>/2023/lg8820-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>下文用 <span class="math inline">\(step\)</span> 代替题目中的 <spanclass="math inline">\(k\)</span>。</p><h2 id="部分分">部分分</h2><p>先考虑一下暴力怎么打。</p><p><span class="math inline">\(k=1\)</span>的情况等于送的，就不说了。</p><p>对于前 <span class="math inline">\(11\)</span> 个点，可以用 <spanclass="math inline">\(n\)</span> 次 <spanclass="math inline">\(\text{BFS}\)</span>预处理出树上任意两点距离，对能够到达的点连边，跑 <spanclass="math inline">\(n\)</span> 遍 <spanclass="math inline">\(\text{Dijkstra}\)</span> 再回答询问，实测 LOJ可以通过。</p><p>虽然题目没有设置特殊图的部分分，但是这里仍然提一嘴。</p><p>链怎么做？我们能发现在链上通过反复横跳来避免到达某些节点是不优的，所以设<span class="math inline">\(f(i)\)</span> 为到达位置 <spanclass="math inline">\(i\)</span> 的最小点权和，有 <spanclass="math display">\[f(i) = \min_{j=1}^{step} \{ f(i-j) \}\]</span> 可以矩阵加速。</p><p>菊花是送的。</p><h2 id="正解">正解</h2><p>由于本人不会动态 DP，所以只能参考 Dottle 的树上倍增做法。</p><p>我们遇到的最大困难，就是从 <span class="math inline">\(x\)</span> 往<span class="math inline">\(y\)</span> 跳的过程可以不只经过路径 <spanclass="math inline">\((x,y)\)</span>上的点，从而大大增多了要考虑的情况。</p><p>先转化一下图论模型：寻找代价最小的一条从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span>的路径，其中代价定义为路径中的若干节点的点权。可以自己指定哪些点权计入答案，但是不允许出现连续的<span class="math inline">\(step\)</span> 个点不计入答案。</p><p>设二元组 <span class="math inline">\((x,k)\)</span> 表示到达节点<span class="math inline">\(x\)</span>，包括 <spanclass="math inline">\(x\)</span> 在内，最后一段已经有 <spanclass="math inline">\(k\)</span> 个节点没有标记。</p><p>建议新图，连两种边：</p><ol type="1"><li>如果树中有边 <span class="math inline">\((x,y)\)</span>，连边 <spanclass="math inline">\((x,k) \rightarrow (y,0)\)</span>，权值为 <spanclass="math inline">\(v_y\)</span>。</li><li>如果树中有边 <span class="math inline">\((x,y)\)</span>，且 <spanclass="math inline">\(k+1&lt;step\)</span>那么连边 <spanclass="math inline">\((x,k) \rightarrow (y,k+1)\)</span>，权值为 <spanclass="math inline">\(0\)</span>。</li></ol><p>由于 <span class="math inline">\((x,y)\)</span>路径上的点可能不被计入答案，但是一定会以某种方式被经过，可以用倍增来优化。</p><p>设 <span class="math inline">\(f(x,i)\)</span> 表示原树中 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(2^i\)</span> 级祖先， <spanclass="math inline">\(d(x,i,a,b)\)</span> 表示在新图中，从 <spanclass="math inline">\((x,a)\)</span> 到达 <spanclass="math inline">\(\Big( f(x,i),b\Big)\)</span> 的最小边权。</p><p>下面讨论如何求出 <spanclass="math inline">\(d(x,0,a,b)\)</span>，为了方便就不打公式了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// int d[N][18][3][3];</span><span class="hljs-keyword">auto</span> D=d[x][<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(step==<span class="hljs-number">1</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=v[fa];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(step==<span class="hljs-number">2</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=v[fa], D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> &#123;D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=v[fa];D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;D[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=mn[x];    <span class="hljs-comment">// mn[x]表示与x相邻点中的最小点权</span>&#125;<span class="hljs-comment">// D[k][0]与D[k][k+1]的边就是上文叙述的</span><span class="hljs-comment">// 比较特殊的是从x跳到一个中转点，贡献中转点的点权后再到达fa，同时不贡献v[fa]</span><span class="hljs-comment">// 不难发现当step=1和2时，都一定会贡献出v[fa]</span><span class="hljs-comment">// 想要贡献出mn[x]而不是v[fa]，那么D的第二维一定是2</span></code></pre></div><p>然后就是常规倍增，把状态从中间拼起来即可。</p><p>对于一个询问 <span class="math inline">\((x,y)\)</span>，我们求出<span class="math inline">\(z = \text{LCA}(x,y)\)</span>，分别从 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 往 <spanclass="math inline">\(z\)</span> 跳，倍增出关于所有状态的最优解，最后从<span class="math inline">\(z\)</span> 处拼起来即可。</p><p>注意有 corner case。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x0f0f0f0f0f0f0f0f</span>;<span class="hljs-type">int</span> n, Q, lim, step, v[N], mn[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">18</span>], dep[N];<span class="hljs-type">int</span> d[N][<span class="hljs-number">18</span>][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">0</span>]=fa;dep[x]=dep[fa]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">auto</span> D=d[x][<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(step==<span class="hljs-number">1</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=v[fa];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(step==<span class="hljs-number">2</span>) D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=v[fa], D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> &#123;D[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=v[fa];D[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=D[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;D[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=D[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=mn[x];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];++i) <span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(c,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;d[x][i][a][c]=<span class="hljs-built_in">min</span>(d[x][i][a][c],d[x][i<span class="hljs-number">-1</span>][a][b]+d[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>][b][c]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">3</span>,v[x])</span></span>;    <span class="hljs-comment">// 小技巧，把所有状态的答案扔进一个vector里面</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lim;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]&amp;&amp;dep[f[x][i]]&gt;=dep[y]) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">3</span>,inf)</span></span>;<span class="hljs-built_in">rep</span>(a,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(b,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) t[b]=<span class="hljs-built_in">min</span>(t[b],res[a]+d[x][i][a][b]);x=f[x][i];res=t;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">auto</span> F=<span class="hljs-built_in">calc</span>(x,z), G=<span class="hljs-built_in">calc</span>(y,z);<span class="hljs-type">int</span> res=inf;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,step<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,step<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(F[i]!=inf&amp;&amp;G[j]!=inf) &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;j==<span class="hljs-number">0</span>) res=<span class="hljs-built_in">min</span>(res,F[i]+G[j]-v[z]); <span class="hljs-comment">// 此时v[z]会被重复计算</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+j&gt;step) res=<span class="hljs-built_in">min</span>(res,F[i]+G[j]+mn[z]); <span class="hljs-comment">// 此时必须找一个落脚点才能拼起来</span><span class="hljs-keyword">else</span> res=<span class="hljs-built_in">min</span>(res,F[i]+G[j]);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;transmit.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;transmit.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>(), step=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=mn[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);mn[x]=<span class="hljs-built_in">min</span>(mn[x],v[y]);mn[y]=<span class="hljs-built_in">min</span>(mn[y],v[x]);&#125;<span class="hljs-keyword">while</span>((<span class="hljs-number">1</span>&lt;&lt;(lim+<span class="hljs-number">1</span>))&lt;=n) ++lim;<span class="hljs-built_in">SET</span>(d,<span class="hljs-number">0x0f</span>);<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>(x,y));&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树论</tag>
      
      <tag>树上倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6563 [SBCOI2020] 一直在你身旁 题解</title>
    <link href="/2023/lg6563-solution/"/>
    <url>/2023/lg6563-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="luogu6563-sbcoi2020-一直在你身旁">luogu6563 [SBCOI2020]一直在你身旁</h3><p>不妨称需要的电线为答案电线。</p><p>注意到购买长度为 <span class="math inline">\(k\)</span>的电线本质上是把答案电线的取值范围从 <spanclass="math inline">\([i,j]\)</span> 缩小到了 <spanclass="math inline">\([i,k]\)</span> 或 <spanclass="math inline">\([k+1,j]\)</span>。虽然无法确定到底是在哪一个区间，但是最坏的情况一定是答案电线在二者中代价更大的里面，同时我们完成了对子问题的划分，直接上区间DP。</p><p>我们把拓扑序反过来，使得这个过程符合区间 DP。设 <spanclass="math inline">\(f(i,j)\)</span> 为答案电线的取值范围是 <spanclass="math inline">\([i,j]\)</span>时，最坏情况下找到答案电线还需要的最小代价。</p><p>显然有 <span class="math display">\[f(i,j) = \min_{k \in [i,j-1]} \Big\{ \max \Big(f(i,k),f(k+1,j) \Big) +a_k \Big\}\]</span> 考虑优化。</p><p>打表发现确实有决策单调性，但是是分段单调，不太容易下手。</p><p>从实际意义的角度似乎不是很显然。</p><p>套路地把 <span class="math inline">\(\max\)</span>拆开，考虑会在哪边取到。</p><p>注意到 <span class="math inline">\(\{a_i\}\)</span>单调不降，再感性理解一下，<span class="math inline">\(f(i,k)\)</span>关于 <span class="math inline">\(k\)</span> 单调增，<spanclass="math inline">\(f(k+1,j)\)</span> 关于 <spanclass="math inline">\(k+1\)</span> 单调减，从而 <spanclass="math inline">\(f(i,k)-f(k+1,j)\)</span> 关于 <spanclass="math inline">\(k\)</span> 单调不降，也就是存在临界点。</p><p>可以用二分找到最小的使得 <spanclass="math inline">\(f(i,k)&gt;f(k+1,j)\)</span> 的 <spanclass="math inline">\(k\)</span>，记为 <spanclass="math inline">\(p\)</span>。</p><p>然而有 <span class="math inline">\(f(i,j) \lef(i,j+1)\)</span>，所以在 <span class="math inline">\(i\)</span> 或者<span class="math inline">\(j\)</span> 变化时，<spanclass="math inline">\(p\)</span> 也是单调的，用一个指针维护即可。</p><p>接下来讨论一个决策点 <span class="math inline">\(k\)</span> 与 <spanclass="math inline">\(p\)</span> 的关系。</p><ul><li><span class="math inline">\(k &lt; p\)</span>。此时取到的是 <spanclass="math inline">\(f(k+1,j)+a_k\)</span>，发现这东西和 <spanclass="math inline">\(i\)</span> 无关。在 <spanclass="math inline">\(j\)</span> 固定时可以用单调队列维护。</li><li><span class="math inline">\(k \ge p\)</span>，此时取到的时 <spanclass="math inline">\(f(i,k)+a_k\)</span>，它关于 <spanclass="math inline">\(k\)</span> 单调增，最终取到的一定是 <spanclass="math inline">\(f(i,p)+a_p\)</span>。</li></ul><p>综上所述，在右端点固定，左端点递减时，我们可以做到均摊 <spanclass="math inline">\(O(1)\)</span> 地转移。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">7105</span>;<span class="hljs-type">int</span> T, n, a[N];<span class="hljs-type">int</span> q[N];ll f[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) &#123;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;f[j<span class="hljs-number">-1</span>][j]=a[j<span class="hljs-number">-1</span>];q[++r]=j<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j<span class="hljs-number">-2</span>,k=j;i;--i) &#123;<span class="hljs-keyword">while</span>(k&gt;i&amp;&amp;f[i][k<span class="hljs-number">-1</span>]&gt;f[k][j]) --k;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;=k) ++l;f[i][j]=f[i][k]+a[k];<span class="hljs-keyword">if</span>(l&lt;=r) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[q[l]+<span class="hljs-number">1</span>][j]+a[q[l]]);<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[q[r]+<span class="hljs-number">1</span>][j]+a[q[r]]&gt;=f[i+<span class="hljs-number">1</span>][j]+a[i]) --r;q[++r]=i;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>单调队列</tag>
      
      <tag>决策单调性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#20 树论（1）树上差分与树上倍增</title>
    <link href="/2023/noip-record-1/"/>
    <url>/2023/noip-record-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="树上差分">树上差分</h2><p>从抽象代数的角度讲，树上差分可以维护所有群上信息。</p><p>换句话说，满足结合律，存在「可减性」。</p><blockquote><p>通过差分我们能将一个高纬问题以常数代价转化为低维问题，而问题低一维往往会简单非常多</p><p>—— lxl</p></blockquote><p>太 <span class="math inline">\(\textit{Trivial}\)</span>的我们就不提了。</p><p>下文成「前缀」为根到节点的路径。</p><h3 id="luogu8201-yloi2021-生活在树上hard-version">luogu8201 [yLOI2021]生活在树上（hard version）</h3><p>考虑这样一个结论。</p><blockquote><p>树上路径 <span class="math inline">\((t,x)\)</span> 与 <spanclass="math inline">\((t,y)\)</span>，一定是先有一段重合的路径，再与路径<span class="math inline">\((x,y)\)</span> 交于一点 <spanclass="math inline">\(z\)</span>，然后分别连向对应的点。</p></blockquote><p>这个有什么用呢？我们可以把 <spanclass="math inline">\(\text{dis}_{t,a} \oplus \text{dis}_{t,b} =k\)</span> 转化为 <span class="math inline">\(\text{dis}_{a,b} \oplusw_z = k\)</span>， 其中 <span class="math inline">\(z\)</span> 是 <spanclass="math inline">\(t\)</span> 与路径 <spanclass="math inline">\((a,b)\)</span> 的交点。</p><p>更进一步地，询问 <span class="math inline">\((a,b,k)\)</span>等价于查询路径 <span class="math inline">\((a,b)\)</span> 上是否存在点<span class="math inline">\(z\)</span>，满足 <spanclass="math inline">\(w_z = k \oplus \text{dis}_{a,b}\)</span>。</p><p>设 <span class="math inline">\(h(x,k)\)</span> 为根到 <spanclass="math inline">\(x\)</span> 的路径上，点权为 <spanclass="math inline">\(k\)</span> 的点的个数，<spanclass="math inline">\(c=\operatorname{LCA}(a,b)\)</span>。</p><p>我们把询问拆成前缀，放到 <spanclass="math inline">\(a,b,c,fa(c)\)</span> 上，在对应点处打上 <spanclass="math inline">\(k \oplus \text{dis}_{a,b}\)</span>的标记。开一个全局桶，一个点的贡献只会在其子树中产生，访问时加入，回溯时撤销即可。然后开个<code>std::unordered_map</code>数组统计在<span class="math inline">\(x\)</span> 处统计所有标记对应的值，就能在<span class="math inline">\(O(n)-O(1)\)</span> 的复杂度内解决问题。</p><blockquote><p>把对路径的询问差分成对前缀的询问。</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, w[N], d[N];<span class="hljs-type">int</span> son[N], dep[N], sz[N], top[N], fa[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, z, k;&#125; q[N];vector&lt;<span class="hljs-type">int</span>&gt; r[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp, ans[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr;dep[x]=dep[fr]+<span class="hljs-number">1</span>;sz[x]=<span class="hljs-number">1</span>;d[x]=d[fr]^w[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) &#123;<span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;++mp[w[x]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:r[x]) ans[x][y]=mp[y];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;<span class="hljs-built_in">dfs3</span>(y);&#125;--mp[w[x]];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>(), q[i].k=<span class="hljs-built_in">read</span>();q[i].z=<span class="hljs-built_in">lca</span>(q[i].x,q[i].y);q[i].k=q[i].k^d[q[i].x]^d[q[i].y]^w[q[i].z];<span class="hljs-type">int</span> x=q[i].x, y=q[i].y, z=q[i].z, k=q[i].k;r[x].<span class="hljs-built_in">pb</span>(k), r[y].<span class="hljs-built_in">pb</span>(k);r[z].<span class="hljs-built_in">pb</span>(k), r[fa[z]].<span class="hljs-built_in">pb</span>(k);&#125;<span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=q[i].x, y=q[i].y, z=q[i].z, k=q[i].k;<span class="hljs-type">int</span> cnt=ans[x][k]+ans[y][k]-ans[z][k]-ans[fa[z]][k];<span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YeS&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;nO&quot;</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu1600-noip2016-提高组-天天爱跑步">luogu1600 [NOIP2016提高组] 天天爱跑步</h3><p><ahref="https://yozora0908.github.io/2021/lg1600-solution">link</a></p><blockquote><p>把路径的贡献拆成前缀的贡献，维护子树和。</p></blockquote><h3 id="luogu2680-noip2015-提高组-运输计划">luogu2680 [NOIP2015 提高组]运输计划</h3><p>首先答案是可以二分的。</p><p>问题转化为：判定是否能通过把一条边的权值置为 <spanclass="math inline">\(0\)</span>，使得给定的路径中，最长的路径不超过<span class="math inline">\(mid\)</span>，</p><p>我们考虑所有长度超过 <span class="math inline">\(mid\)</span>的路径，设其的数量为 <span class="math inline">\(cnt\)</span>。那么<span class="math inline">\(mid\)</span> 可行当且仅当存在一条被经过<span class="math inline">\(cnt\)</span> 次，并且其长度大于等于 <spanclass="math inline">\(\max_{i=1}^m \big\{dis(u_i,v_i) \big\} -mid\)</span>。</p><p>怎么做？把路径差分了再做子树和，求出每条边被覆盖的次数，检查一遍即可。</p><p>但是这题卡常，需要预处理出 <spanclass="math inline">\(\text{DFS}\)</span> 序再倒着做子树和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2680 [NOIP2015 提高组] 运输计划</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2680</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 292 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, c[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> sz[N], fa[N], son[N], dep[N], d[N], top[N];<span class="hljs-type">int</span> num,  idf[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, z, d;&#125; a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>  </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr, dep[x]=dep[fr]+<span class="hljs-number">1</span>;idf[++num]=x;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;d[y]=d[x]+z;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(!son[x]||sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa[x]||y==son[x]) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">return</span> dep[x]&lt;dep[y]? x:y;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>, cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) c[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(a[i].d&gt;x) &#123;++c[a[i].x], ++c[a[i].y], c[a[i].z]-=<span class="hljs-number">2</span>;mx=<span class="hljs-built_in">max</span>(mx,a[i].d-x);++cnt;&#125;<span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) c[fa[idf[i]]]+=c[idf[i]];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">if</span>(d[i]-d[fa[i]]&gt;=mx&amp;&amp;c[i]==cnt) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i].x=<span class="hljs-built_in">read</span>(), a[i].y=<span class="hljs-built_in">read</span>();a[i].z=<span class="hljs-built_in">lca</span>(a[i].x,a[i].y);a[i].d=d[a[i].x]+d[a[i].y]<span class="hljs-number">-2</span>*d[a[i].z];R=<span class="hljs-built_in">max</span>(R,a[i].d);&#125;<span class="hljs-keyword">while</span>(L&lt;R) &#123;<span class="hljs-type">int</span> mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) R=mid; <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,L);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4219-bjoi2014-大融合">luogu4219 [BJOI2014] 大融合</h3><p>对于一个询问 <spanclass="math inline">\((x,y)\)</span>，答案就是两边连通块大小之积。</p><p>不过显然不能直接做。</p><p>考虑离线，把树定根后建起来。钦定 <spanclass="math inline">\(\text{dep}(x) \le\text{dep}(y)\)</span>，那么答案就是<strong>此时与 <spanclass="math inline">\(x\)</span>连通的子树大小</strong>减去<strong>此时以 <spanclass="math inline">\(y\)</span>为根且连通的子树大小</strong>，最后再乘上后者。注意这里的子树就是定根后原树中的。</p><p>这个怎么维护呢？用并查集维护连通块，每个连通块的根是原树种深度最低的那个点。如果连边<span class="math inline">\((x,y)\)</span>，那么 <spanclass="math inline">\(y\)</span> 此时所在连通块一定都会贡献到 <spanclass="math inline">\(x\)</span> 以及其父亲的子树中去。</p><p>也就是说这是个链加，我们直接差分掉。问题转化为链加，单点求子树和，摊到<span class="math inline">\(\text{DFS}\)</span>序上即可用树状数组维护。在 <span class="math inline">\(x\)</span>处产生贡献，同时在 <span class="math inline">\(x\)</span>所在连通块的根<strong>在原树中的父亲处消去贡献</strong>，这样就能保证只会贡献到当前连通情况下的点上。</p><p>对于每个询问，与 <span class="math inline">\(x\)</span>连通的子树大小就是此时 <span class="math inline">\(x\)</span>所在连通块的大小，以 <span class="math inline">\(y\)</span>为根且连通的子树大小就是 <span class="math inline">\(y\)</span>的子树和再加上 <span class="math inline">\(1\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, Q, dep[N], tfa[N], tsz[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span> &#123;<span class="hljs-type">int</span> op, x, y;&#125; q[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=y;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res; <span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];<span class="hljs-keyword">return</span> res;&#125;&#125; T, bit;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;dep[x]=dep[fr]+<span class="hljs-number">1</span>;tfa[x]=fr;dfn[x]=++num;tsz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fr) &#123;<span class="hljs-built_in">dfs</span>(y,x);tsz[x]+=tsz[y];&#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N], sz[N], siz[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, siz[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-type">int</span> fx=<span class="hljs-built_in">get</span>(x), fy=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span>;fa[y]=fx;siz[fx]+=siz[y];T.<span class="hljs-built_in">upd</span>(dfn[x],siz[y]);T.<span class="hljs-built_in">upd</span>(dfn[tfa[fx]],-siz[y]);&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-type">char</span> s[<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>) q[i].op=<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> q[i].op=<span class="hljs-number">2</span>;q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(q[i].x,q[i].y);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);dsu.<span class="hljs-built_in">init</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;<span class="hljs-type">int</span> x=q[i].x, y=q[i].y;<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;dsu.<span class="hljs-built_in">merge</span>(x,y);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-type">int</span> size=dsu.siz[dsu.<span class="hljs-built_in">get</span>(x)];<span class="hljs-type">int</span> szy=T.<span class="hljs-built_in">query</span>(dfn[y]+tsz[y]<span class="hljs-number">-1</span>)-T.<span class="hljs-built_in">query</span>(dfn[y]<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(size-szy)*szy);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4211-lnoi2014-lca">luogu4211 [LNOI2014] LCA</h3><p>首先把询问差分了，考虑求 $_{i=1}^r ((i,z)) $。</p><p>从贡献的角度，<spanclass="math inline">\(\text{dep}\Big(\text{LCA}(i,z)\Big)\)</span>可以被具象化为根到 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(z\)</span> 的路径上交点的个数。</p><p>把询问离线了，询问挂到 <span class="math inline">\(l-1\)</span> 与<span class="math inline">\(r\)</span> 上。从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 枚举节点 <spanclass="math inline">\(i\)</span>，并且使根到 <spanclass="math inline">\(i\)</span> 的路径点权都 <spanclass="math inline">\(+1\)</span>。</p><p>具体地，对于一个询问 <spanclass="math inline">\((z,op,id)\)</span>，我们查询此时根到 <spanclass="math inline">\(z\)</span> 的链和，带上系数 <spanclass="math inline">\(op\)</span> 累加进 <spanclass="math inline">\(ans(id)\)</span> 即可。</p><p>树剖套线段树即可维护。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">201314</span>;<span class="hljs-type">int</span> n, m, ans[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">int</span> son[N], top[N], dep[N], sz[N], fa[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr;sz[x]=<span class="hljs-number">1</span>;dep[x]=dep[fr]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;dfn[x]=++num;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125; &#125;<span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> d)</span> </span>&#123;t[x]+=(r-l+<span class="hljs-number">1</span>)*d;tag[x]+=d;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid,tag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,tag[x]);tag[x]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seg_upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,l,r,d); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">Seg_upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">Seg_upd</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Seg_query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) (res+=<span class="hljs-built_in">Seg_query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid))%=mod;<span class="hljs-keyword">if</span>(R&gt;mid) (res+=<span class="hljs-built_in">Seg_query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r))%=mod;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span> &#123;<span class="hljs-type">int</span> z, op, id;<span class="hljs-built_in">Q</span>() &#123;&#125;<span class="hljs-built_in">Q</span>(<span class="hljs-type">int</span> _z,<span class="hljs-type">int</span> _op,<span class="hljs-type">int</span> _id) &#123; z=_z, op=_op, id=_id; &#125; &#125;;vector&lt;Q&gt; q[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">Seg_upd</span>(dfn[top[x]],dfn[x],<span class="hljs-number">1</span>);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">Seg_upd</span>(dfn[x],dfn[y],<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);(res+=<span class="hljs-built_in">Seg_query</span>(dfn[top[x]],dfn[x]))%=mod;x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);(res+=<span class="hljs-built_in">Seg_query</span>(dfn[x],dfn[y]));<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">upd</span>(<span class="hljs-number">1</span>,i,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:q[i]) &#123;<span class="hljs-type">int</span> z=t.z, op=t.op, id=t.id;<span class="hljs-type">int</span> res=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,z);ans[id]+=res*op;(ans[id]+=mod)%=mod;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;p[x].<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, r=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>, z=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;q[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">Q</span>(z,<span class="hljs-number">1</span>,i));<span class="hljs-keyword">if</span>(l<span class="hljs-number">-1</span>&gt;<span class="hljs-number">0</span>) q[l<span class="hljs-number">-1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">Q</span>(z,<span class="hljs-number">-1</span>,i));&#125;<span class="hljs-built_in">solve</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4216-scoi2015情报传递">luogu4216 [SCOI2015]情报传递</h3><p>发现操作一挺难搞的。</p><p>考虑第二种操作。<span class="math inline">\(i\)</span> 时刻点权大于<span class="math inline">\(c\)</span>，等价于开始时间小于 <spanclass="math inline">\(i-c\)</span>。问题转化为求一条链上小于某个数的个数。</p><p>lxl 课件上说用树剖 + 树状数组可以做到 <span class="math inline">\(O(m\log_2^2 n)\)</span>，但是我不会。</p><p>继续观察。如果我们把操作一看成一个点的点权从 <spanclass="math inline">\(0\)</span> 变成 <spanclass="math inline">\(1\)</span>，问题等价于求 <spanclass="math inline">\(i-c-1\)</span> 时刻 <spanclass="math inline">\((x,y)\)</span> 的链和。</p><p>把询问差分成前缀和相减，离线后挂到时间上，单点加转化为子树加，树状数组即可维护。</p><p>时间复杂度是 <span class="math inline">\(O(m \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, rt, Q, ans[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> &#123;<span class="hljs-type">int</span> op, x, y, c;&#125; q[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y, id;&#125;;vector&lt;node&gt; v[N];<span class="hljs-type">int</span> son[N], top[N], dep[N], sz[N], fa[N];<span class="hljs-type">int</span> num, dfn[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=d;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];<span class="hljs-keyword">return</span> res;&#125;&#125; T;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr;sz[x]=<span class="hljs-number">1</span>;dep[x]=dep[fr]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;dfn[x]=++num;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">return</span> dep[x]+dep[y]-dep[z]-dep[fa[z]];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">return</span> T.<span class="hljs-built_in">query</span>(dfn[x])+T.<span class="hljs-built_in">query</span>(dfn[y])-T.<span class="hljs-built_in">query</span>(dfn[z])-T.<span class="hljs-built_in">query</span>(dfn[fa[z]]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>) p[x].<span class="hljs-built_in">pb</span>(i); <span class="hljs-keyword">else</span> rt=i;&#125;Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) &#123;q[i].op=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;q[i].x=<span class="hljs-built_in">read</span>(), q[i].y=<span class="hljs-built_in">read</span>(), q[i].c=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(i-q[i].c<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) v[i-q[i].c<span class="hljs-number">-1</span>].<span class="hljs-built_in">pb</span>((node)&#123;q[i].x,q[i].y,i&#125;);&#125; <span class="hljs-keyword">else</span> q[i].x=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">dfs1</span>(rt,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(rt,rt);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,Q) &#123;<span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> x=q[i].x;T.<span class="hljs-built_in">upd</span>(dfn[x],<span class="hljs-number">1</span>);T.<span class="hljs-built_in">upd</span>(dfn[x]+sz[x],<span class="hljs-number">-1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v[i]) &#123;ans[t.id]=<span class="hljs-built_in">calc</span>(t.x,t.y);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,Q) <span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,<span class="hljs-built_in">dis</span>(q[i].x,q[i].y),ans[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="树上倍增">树上倍增</h2><p>没啥技巧，直接上题。</p><h3 id="cf932d-tree">CF932D Tree</h3><p>设 <span class="math inline">\(f(x,i)\)</span> 表示从 <spanclass="math inline">\(x\)</span> 往上提取一个长度为 <spanclass="math inline">\(2^i\)</span> 的点权单调不降子序列（不含 <spanclass="math inline">\(x\)</span>），最后一项的节点编号。</p><p>发现要是能处理出 <span class="math inline">\(f(x,0)\)</span>就做完了。</p><p>对于一个新加入的 <span class="math inline">\(x\)</span>，如果 <spanclass="math inline">\(f(x,0) \neq fa(x)\)</span>，那么就从 <spanclass="math inline">\(fa(x)\)</span> 向上找到最后一个满足 <spanclass="math inline">\(w_p &lt; w_x\)</span> 的 <spanclass="math inline">\(p\)</span>，<spanclass="math inline">\(fa(p)\)</span> 就是 <spanclass="math inline">\(f(x,0)\)</span>。</p><h3 id="cf519e-a-and-b-and-lecture-rooms">CF519E A and B and LectureRooms</h3><p>运用本文第一题的结论。</p><p>一个点分别到 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 的路径，一定是先重合一段，然后路径<span class="math inline">\((x,y)\)</span>的一个点上分开。也就是说，到二者的距离相等的点，一定满足这个交点是路径<span class="math inline">\((x,y)\)</span> 的中点。</p><p>设中点为 <span class="math inline">\(p\)</span>，考虑其与 <spanclass="math inline">\(z=\text{LCA}(x,y)\)</span> 的关系。</p><p>设 <span class="math inline">\(pre_x(y)\)</span> 为 <spanclass="math inline">\(x\)</span> 的一个祖先，满足其是 <spanclass="math inline">\(y\)</span> 的子节点。</p><ul><li><span class="math inline">\(p=z\)</span>，答案就是 <spanclass="math inline">\(n-pre_x(z)-pre_y(z)\)</span>。</li><li><span class="math inline">\(p\)</span> 在靠近 <spanclass="math inline">\(x\)</span> 的那一侧，答案是 <spanclass="math inline">\(sz_{p} - pre_x(p)\)</span>。</li><li><span class="math inline">\(p\)</span> 在靠近 <spanclass="math inline">\(y\)</span> 的那一侧，答案是 <spanclass="math inline">\(sz_p - pre_y(p)\)</span>。</li></ul><p><span class="math inline">\(\text{dep}(p)\)</span> 可以根据 <spanclass="math inline">\((x,y,z)\)</span> 的深度关系得到，然后倍增求出<span class="math inline">\(q\)</span>。</p><p><span class="math inline">\(pre_x(y)\)</span> 也可以从 <spanclass="math inline">\(x\)</span> 往上倍增出来。</p><h3 id="luogu8820-csp-s-2022-数据传输">luogu8820 [CSP-S 2022]数据传输</h3><p><ahref="https://yozora0908.github.io/2023/lg8820-solution">link</a></p><h3 id="loj-2955.-noip2018保卫王国">LOJ #2955. 「NOIP2018」保卫王国</h3><p><ahref="https://yozora0908.github.io/2023/loj2955-solution">link</a></p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树论</tag>
      
      <tag>树上倍增</tag>
      
      <tag>线段树</tag>
      
      <tag>树状数组</tag>
      
      <tag>树上差分</tag>
      
      <tag>树链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#19 费用提前计算</title>
    <link href="/2023/noip-record-19/"/>
    <url>/2023/noip-record-19/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>未完待续</p><h3 id="cf1107e-vasya-and-binary-string">CF1107E Vasya and BinaryString</h3><p>设 <span class="math inline">\(f(i,j,t)\)</span> 为删去区间 <spanclass="math inline">\([i,j]\)</span>，其中区间右边还有 <spanclass="math inline">\(t\)</span> 个与 <spanclass="math inline">\(S[j]\)</span> 相同的字符的最大收益。</p><p><span class="math display">\[f(i,j,t) = \max \begin{cases}f(i,j-1,0) + a_{t+1}\\\max _{k=i}^{j-1} \Big\{ f(i,k,t+1) + f(k+1,j-1,0)  \Big\}\end{cases}\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, a[N], f[N][N][N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> t)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">return</span> a[t+<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(f[i][j][t]) <span class="hljs-keyword">return</span> f[i][j][t];<span class="hljs-type">int</span>&amp; res=f[i][j][t];res=<span class="hljs-built_in">dfs</span>(i,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+a[t+<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;++k) <span class="hljs-keyword">if</span>(s[k]==s[j]) &#123;res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+<span class="hljs-built_in">dfs</span>(i,k,t+<span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>));&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>费用提前计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu9221 「TAOI-1」Pentiment 题解</title>
    <link href="/2023/lg9221-solution/"/>
    <url>/2023/lg9221-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>先考虑部分分怎么打。</p><p>根据个人习惯，规定下文中「直角蛇」是从最上面一行到达最下面一行。</p><h3 id="subtask-2">subtask 2</h3><p>不妨这样考虑：到达每一行后，都可以通过左右移动，到达下一行的任意一个位置。到达第一行的位置可以任选；从任意位置到达最后一行后，可以再通过左右移动，在任意位置结束。所以答案就是<span class="math display">\[m^{n+1}\]</span></p><h3 id="subtask-1-and-3">subtask 1 and 3</h3><p>这两个子任务都可以用 <span class="math inline">\(O(nm)\)</span>的做法解决。</p><p>结合 subtask 2，我们对每一行考虑。发现第 <spanclass="math inline">\(i-1\)</span> 行和第 <spanclass="math inline">\(i\)</span> 行本质上是「输送与接收」的关系。</p><p>不妨称不能走的节点为关键点，我们能发现如下性质。</p><ul><li><p>关键点把第 <span class="math inline">\(i-1\)</span> 行和第 <spanclass="math inline">\(i\)</span>行划分成了若干个连续段，只有当两行的连续段有交时，才能完成方案的传递。</p></li><li><p>到达同一个连续段内任意节点的方案数是相等的。这个容易理解，我们到达这一段后可以左右任意走。</p></li></ul><p>这两个性质启发我们这样做：</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为直角蛇到达 <spanclass="math inline">\((i,j)\)</span> 的方案数。对于第 <spanclass="math inline">\(i\)</span> 行，如果 <spanclass="math inline">\((i,j)\)</span> 不是关键点，我们就把 <spanclass="math inline">\(f(i-1,j)\)</span> 的方案下传到 <spanclass="math inline">\(f(i,j)\)</span>。然后对 <spanclass="math inline">\(j\)</span>这一维做前缀和，最后扫一遍，每个点的方案就是其所在连续段的总和。</p><p>使用滚动数组，时间和空间都可以接受。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, q;bitset&lt;10002&gt; v[<span class="hljs-number">10002</span>];bitset&lt;1000002&gt; v1[<span class="hljs-number">3</span>];<span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][<span class="hljs-number">10002</span>], r[<span class="hljs-number">10002</span>], s[<span class="hljs-number">10002</span>];<span class="hljs-keyword">namespace</span> sub3 &#123;    <span class="hljs-comment">// 这是subtask3的代码。</span>    <span class="hljs-comment">// 如果要求解subtask1，那么就交换行和列，用v1做标记即可。</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> lst=m;<span class="hljs-built_in">per</span>(j,m,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(v[i][j]) r[j]=j, lst=j<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span> r[j]=lst;&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;f[i&amp;<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!v[i][j]) &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) s[j]=<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> s[j]=f[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j];s[j]=(<span class="hljs-number">1ll</span>*s[j]+s[j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;R=r[j];<span class="hljs-keyword">if</span>(!v[i][j]) f[i&amp;<span class="hljs-number">1</span>][j]=(s[R]-s[L]+mod)%mod;<span class="hljs-keyword">else</span> L=j, f[i&amp;<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-type">int</span> L=<span class="hljs-number">0</span>, R=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) ans=(<span class="hljs-number">1ll</span>*ans+f[n&amp;<span class="hljs-number">1</span>][i])%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;&#125;;</code></pre></div><h3 id="subtask-6">subtask 6</h3><p>我们发现方案的下传像是在做类似于区间合并的东西。由于本人太菜，不会使用数据结构，所以就对着题解中的离线做法写了，就此学习一下此类问题的处理方法。</p><p>对于连续的不存在关键点的行，其方案数是容易求出的，所以有用的只有不同行的关键点。对此我们可以将所有关键点按照横坐标排序。</p><p>先不考虑连续空行的情况。我们应该先找到一个临界点 <spanclass="math inline">\(i\)</span>，满足 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+1\)</span> 在不同行，再维护一个上一行的末尾位置<spanclass="math inline">\(k\)</span>。这样我们就能得到这一整行的信息了，同时要维护上一行的区间以及区间内每个位置的方案数（每个位置的方案数都相等）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r; ll x;    <span class="hljs-comment">// 区间[l,r]，每个点的方案数都是x</span><span class="hljs-built_in">node</span>() &#123;&#125;;<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _l,<span class="hljs-type">int</span> _r,ll _x) &#123; l=_l, r=_r, x=_x; &#125;&#125; f[N];</code></pre></div><p>考虑如何区间合并。对于当前行的区间，只要上一行的某个区间与其有交，方案就能下传，看起来不很好做。但反过来想，如果当前行被上一行两个区间下传方案了，那么说明一定有关键点把上面那两个区间隔开。也就是说，如果我们把上一行的关键点当作当前行的关键点，这样得到的区间一定会被上一行唯一确定的一个区间下传方案。</p><p>我们先把两行的关键点都存下来，排序后去重。</p><p>对于两个关键点确定的一个区间 <spanclass="math inline">\([L,R]\)</span>，我们找到之前合并完的第一个与这个区间有交的区间，<spanclass="math inline">\([L,R]\)</span> 的方案数就是 <spanclass="math inline">\(R-L+1\)</span> 乘那个区间的方案。注意要把边界<span class="math inline">\(0\)</span> 与 <spanclass="math inline">\(m+1\)</span> 都加入。</p><div class="code-wrapper"><pre><code class="hljs cpp">p.<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>==a[i].fi) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&amp;&amp;a[j].fi==a[k].fi;--j) b[++tot]=a[j].se;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k+<span class="hljs-number">1</span>;j&lt;=i;++j) b[++tot]=a[j].se, p[a[j].se]=<span class="hljs-number">1</span>;b[++tot]=<span class="hljs-number">0</span>, b[++tot]=m+<span class="hljs-number">1</span>;<span class="hljs-built_in">uniq</span>(b,tot);vector&lt;node&gt; v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,pos=<span class="hljs-number">1</span>;j&lt;tot;++j) &#123;<span class="hljs-keyword">if</span>(b[j]&amp;&amp;!p.<span class="hljs-built_in">count</span>(b[j])) v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(b[j],b[j],<span class="hljs-number">0ll</span>));<span class="hljs-type">int</span> L=b[j]+<span class="hljs-number">1</span>, R=b[j+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(L&gt;R) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">while</span>(pos&lt;=cnt&amp;&amp;f[pos].r&lt;L) ++pos;ll sum=f[pos].x*(R-L+<span class="hljs-number">1</span>)%mod;v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(L,R,sum));&#125;</code></pre></div><p>对于合并，只需要将上一行的关键点当作连接区间的桥梁。具体地，我们将通过上述做法得到的区间都存下来，然后把上一行的关键点当作长度为<span class="math inline">\(1\)</span>的区间加进去。合并时，只需要扫一边所有区间，根据端点判断是否可以合并即可，方案数就直接累加。</p><div class="code-wrapper"><pre><code class="hljs cpp">cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> xx:v) &#123;<span class="hljs-keyword">if</span>(!cnt||f[cnt].r!=xx.l<span class="hljs-number">-1</span>) f[++cnt]=xx;<span class="hljs-keyword">else</span> f[cnt].r=xx.r, (f[cnt].x+=xx.x)%=mod;&#125;</code></pre></div><p>对于连续的没有关键点的行，我们只需要先将方案下放并累加，然后乘 <spanclass="math inline">\(m\)</span> 的对应次幂，最后只留下 <spanclass="math inline">\([1,m]\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>!=a[i].fi) &#123;<span class="hljs-type">int</span> dx=a[i].fi-a[k].fi<span class="hljs-number">-2</span>;    ll sum=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) (sum+=f[j].x*(f[j].r-f[j].l+<span class="hljs-number">1</span>)%mod)%=mod;(sum*=<span class="hljs-built_in">fp</span>(m,dx))%=mod;f[<span class="hljs-number">1</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,m,sum);cnt=<span class="hljs-number">1</span>;&#125;</code></pre></div><p>做完之后，最后一定还剩下若干没有关键点的行，照做即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, q, cnt, ans, b[N], t[N];PII a[N];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; p;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r; ll x;<span class="hljs-built_in">node</span>() &#123;&#125;;<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _l,<span class="hljs-type">int</span> _r,ll _x) &#123; l=_l, r=_r, x=_x; &#125;&#125; f[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;ll c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=<span class="hljs-number">1ll</span>*a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uniq</span><span class="hljs-params">(<span class="hljs-type">int</span>* b,<span class="hljs-type">int</span>&amp; tot)</span> </span>&#123;<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+tot+<span class="hljs-number">1</span>);tot=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+tot+<span class="hljs-number">1</span>)-b<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) a[i].fi=<span class="hljs-built_in">read</span>(), a[i].se=<span class="hljs-built_in">read</span>();    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;f[++cnt]=<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,m,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,q) <span class="hljs-keyword">if</span>(i==q||a[i].fi!=a[i+<span class="hljs-number">1</span>].fi) &#123;<span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>!=a[i].fi) &#123;<span class="hljs-type">int</span> dx=a[i].fi-a[k].fi<span class="hljs-number">-2</span>; ll sum=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) (sum+=f[j].x*(f[j].r-f[j].l+<span class="hljs-number">1</span>)%mod)%=mod;(sum*=<span class="hljs-built_in">fp</span>(m,dx))%=mod;f[<span class="hljs-number">1</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,m,sum);cnt=<span class="hljs-number">1</span>;&#125;p.<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[k].fi+<span class="hljs-number">1</span>==a[i].fi) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&amp;&amp;a[j].fi==a[k].fi;--j) b[++tot]=a[j].se;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k+<span class="hljs-number">1</span>;j&lt;=i;++j) b[++tot]=a[j].se, p[a[j].se]=<span class="hljs-number">1</span>;b[++tot]=<span class="hljs-number">0</span>, b[++tot]=m+<span class="hljs-number">1</span>;<span class="hljs-built_in">uniq</span>(b,tot);vector&lt;node&gt; v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,pos=<span class="hljs-number">1</span>;j&lt;tot;++j) &#123;<span class="hljs-keyword">if</span>(b[j]&amp;&amp;!p.<span class="hljs-built_in">count</span>(b[j])) v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(b[j],b[j],<span class="hljs-number">0ll</span>));<span class="hljs-type">int</span> L=b[j]+<span class="hljs-number">1</span>, R=b[j+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(L&gt;R) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">while</span>(pos&lt;=cnt&amp;&amp;f[pos].r&lt;L) ++pos;ll sum=f[pos].x*(R-L+<span class="hljs-number">1</span>)%mod;v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(L,R,sum));&#125;cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> xx:v) &#123;<span class="hljs-keyword">if</span>(!cnt||f[cnt].r!=xx.l<span class="hljs-number">-1</span>) f[++cnt]=xx;<span class="hljs-keyword">else</span> f[cnt].r=xx.r, (f[cnt].x+=xx.x)%=mod;&#125;k=i;&#125;<span class="hljs-type">int</span> dx=n-a[k].fi;    ll sum=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) (sum+=f[i].x*(f[i].r-f[i].l+<span class="hljs-number">1</span>)%mod)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sum*<span class="hljs-built_in">fp</span>(m,dx)%mod);&#125;</code></pre></div><p>计数部分不难，难在对区间的处理。</p><p>怎么说，在考场上，除非时间很充足并且有很大把握，否则是不会去写这种题的。</p><p>但过一遍这道题也有所收获。</p><p>初看这道题，很容易与某组合典题联系起来，从而想到利用关键点去容斥。尽管正解不是这样做，但最终也需要在关键点上下功夫，算是完善一下科技树并锻炼代码能力了。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>计数</tag>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#18 区间DP</title>
    <link href="/2023/noip-record-18/"/>
    <url>/2023/noip-record-18/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="区间形态的扩展">区间形态的扩展</h2><h3 id="luogu3205-hnoi2010-合唱队">luogu3205 [HNOI2010] 合唱队</h3><p>队列的形成方式是不断往左或往右扩展。</p><p>考虑区间 DP。发现对于一个区间 <spanclass="math inline">\([i,j]\)</span>，最后一个元素的来源会对转移产生影响，所以设<span class="math inline">\(f(i,j,0/1)\)</span> 为考虑区间 <spanclass="math inline">\([i,j]\)</span>，其中最后一个元素是从左边还是右边加入的方案数。</p><p>转移很简单 <span class="math display">\[f(i,j,0) = [a_i &lt; a_{i+1}]f(i+1,j,0) + [a_i &lt; a_j] f(i+1,j,0)\]</span></p><p><span class="math display">\[f(i,j,1) = [a_j &gt; a_{i}] f(i,j-1,0) + [a_j &gt; a_{j-1}] f(i,j-1,1)\]</span></p><p>注意对于 <spanclass="math inline">\([i,i]\)</span>，钦定从一边转移过来即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3205 [HNOI2010] 合唱队</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3205</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">19650827</span>;<span class="hljs-type">int</span> n, a[N], f[N][N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(),  f[i][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(a[i]&lt;a[i+<span class="hljs-number">1</span>]) (f[i][j][<span class="hljs-number">0</span>]+=f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>])%=mod;<span class="hljs-keyword">if</span>(a[i]&lt;a[j]) (f[i][j][<span class="hljs-number">0</span>]+=f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>])%=mod;<span class="hljs-keyword">if</span>(a[j]&gt;a[i]) (f[i][j][<span class="hljs-number">1</span>]+=f[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>])%=mod;<span class="hljs-keyword">if</span>(a[j]&gt;a[j<span class="hljs-number">-1</span>]) (f[i][j][<span class="hljs-number">1</span>]+=f[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>]+f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>])%mod);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="某道题">某道题</h3><blockquote><p>你有 <span class="math inline">\([1,n]\)</span> 中的正整数各 <spanclass="math inline">\(2\)</span> 个，存在 <spanclass="math inline">\(k\)</span> 个限制。</p><p>要求将这 <span class="math inline">\(2n\)</span>个数排成一个序列，满足以下两个条件：</p><ul><li>如果存在一个最大的数所在的的位置 <spanclass="math inline">\(p\)</span>，满足 <spanclass="math inline">\(p&gt;1\)</span>，那么 <spanclass="math inline">\([1,p]\)</span> 中的数单调不降。</li><li>如果存在一个最大的数所在的的位置 <spanclass="math inline">\(p\)</span>，满足 <spanclass="math inline">\(p&lt;n\)</span>，那么 <spanclass="math inline">\([p,n]\)</span> 中的数单调不增。</li></ul><p>每个限制条件形如<code>x op y</code>。</p><p>其中<code>op</code>可能为<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;=</code>，<code>&gt;</code>，表示下标为<span class="math inline">\(x\)</span> 的数与下标为 <spanclass="math inline">\(y\)</span> 的数必须满足的大小关系。</p><p>求方案数，对 <span class="math inline">\(998244353\)</span>取模。</p><p><span class="math inline">\(n \le 1000\)</span>，<spanclass="math inline">\(0 \le k \le 3 \times 10^4\)</span>。</p><p>注意：原题没有取模，<span class="math inline">\(n \le500\)</span>。但是复杂度的瓶颈在于高精度，所以这里加上取模，并且增大数据范围。</p></blockquote><p>先不考虑限制。</p><p>如何生成这样的序列呢？考虑从大到小放。两个 <spanclass="math inline">\(n\)</span>肯定要放到中间，剩下的数要么两边放一个，要么都放在一边。这样就是呈区间形态的扩展方式，考虑区间DP。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为考虑了 <spanclass="math inline">\([k,n]\)</span> 中的数，放完了区间 <spanclass="math inline">\([i,j]\)</span> 的方案。</p><p>仔细思考能发现记录 <span class="math inline">\(k\)</span>根本没有用，只要区间扩展时每次只扩展 <spanclass="math inline">\(2\)</span> 的长度，就一定合法。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为放完了区间 <spanclass="math inline">\([i,j]\)</span> 的方案数。</p><p>如果没有限制的话，能发现答案就是 <spanclass="math inline">\(3^{n-1}\)</span>。</p><p>考虑限制。</p><p>我们讨论三种方法是否会受限制。</p><ol type="1"><li>放的两个位置必须都允许相等。</li><li>这两个位置都必须严格小于其他位置。</li></ol><p>暴力判断就是 <span class="math inline">\(O(n)\)</span> 的。</p><p>利用大小关系的对称性。设 <span class="math inline">\(s(i,j)\)</span>为 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span> 的限制，没有就是 <spanclass="math inline">\(0\)</span>，<code>&lt;</code>是 <spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(\le\)</span> 是 <spanclass="math inline">\(2\)</span>，<code>=</code>是 <spanclass="math inline">\(3\)</span>。对 <spanclass="math inline">\(j\)</span> 这一维求前缀和，就能 <spanclass="math inline">\(O(1)\)</span>判断一个区间对一个位置的限制，加以讨论即可做到 <spanclass="math inline">\(O(n^2)\)</span>。</p><p>下面的代码是带着高精的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;string st;<span class="hljs-type">int</span> n, k, p[N][N], s[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Int</span> &#123;<span class="hljs-type">short</span> a[<span class="hljs-number">245</span>], deg=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(a,<span class="hljs-number">0</span>); deg=<span class="hljs-number">0</span>; &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">zero</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> !deg||(deg==<span class="hljs-number">1</span>&amp;&amp;a[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>); &#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">int</span> x) &#123; deg=<span class="hljs-number">1</span>; a[deg<span class="hljs-number">-1</span>]=x; &#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(Int&amp; x) &#123;deg=<span class="hljs-built_in">max</span>(deg,x.deg);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;deg;++i) &#123;a[i]+=x.a[i];a[i+<span class="hljs-number">1</span>]+=a[i]/<span class="hljs-number">10</span>;a[i]%=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">while</span>(a[deg]) ++deg;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=deg<span class="hljs-number">-1</span>;~i;--i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);&#125;&#125; f[N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>()*<span class="hljs-number">2</span>, k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>();cin&gt;&gt;st;<span class="hljs-type">int</span> r=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;&lt;&quot;</span>) p[l][r]=<span class="hljs-number">1</span>, p[r][l]=<span class="hljs-number">5</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;&lt;=&quot;</span>) p[l][r]=<span class="hljs-number">2</span>, p[r][l]=<span class="hljs-number">4</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;=&quot;</span>) p[l][r]=p[r][l]=<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st==<span class="hljs-string">&quot;&gt;=&quot;</span>) p[l][r]=<span class="hljs-number">4</span>, p[r][l]=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> p[l][r]=<span class="hljs-number">5</span>, p[r][l]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) s[i][j]=s[i][j<span class="hljs-number">-1</span>]+(p[i][j]&gt;<span class="hljs-number">2</span>);f[<span class="hljs-number">1</span>][n]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(!p[i][i+<span class="hljs-number">1</span>]||(p[i][i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">2</span>&amp;&amp;p[i][i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-number">4</span>)) f[i][i+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;l+=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(!f[i][j].<span class="hljs-built_in">zero</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(p[i][i+<span class="hljs-number">1</span>]!=<span class="hljs-number">1</span>&amp;&amp;p[i][i+<span class="hljs-number">1</span>]!=<span class="hljs-number">5</span>&amp;&amp;!f[i+<span class="hljs-number">2</span>][j].<span class="hljs-built_in">zero</span>()) &#123;<span class="hljs-keyword">if</span>(s[i][j]==s[i][i+<span class="hljs-number">1</span>]&amp;&amp;s[i+<span class="hljs-number">1</span>][j]==s[i+<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>]) f[i][j]+=f[i+<span class="hljs-number">2</span>][j];&#125;<span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>][j]!=<span class="hljs-number">1</span>&amp;&amp;p[j<span class="hljs-number">-1</span>][j]!=<span class="hljs-number">5</span>&amp;&amp;!f[i][j<span class="hljs-number">-2</span>].<span class="hljs-built_in">zero</span>()) &#123;<span class="hljs-keyword">if</span>(s[j][j<span class="hljs-number">-2</span>]==s[j][i<span class="hljs-number">-1</span>]&amp;&amp;s[j<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>]==s[j<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>]) f[i][j]+=f[i][j<span class="hljs-number">-2</span>];&#125;<span class="hljs-keyword">if</span>(p[i][j]!=<span class="hljs-number">1</span>&amp;&amp;p[i][j]!=<span class="hljs-number">5</span>&amp;&amp;!f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>].<span class="hljs-built_in">zero</span>()) &#123;<span class="hljs-keyword">if</span>(s[i][j<span class="hljs-number">-1</span>]==s[i][i]&amp;&amp;s[j][j<span class="hljs-number">-1</span>]==s[j][i]) f[i][j]+=f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];&#125;&#125;f[<span class="hljs-number">1</span>][n].<span class="hljs-built_in">print</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu6563-sbcoi2020-一直在你身旁">luogu6563 [SBCOI2020]一直在你身旁</h3><p><ahref="https://yozora0908.github.io/2023/lg6563-solution">link</a></p><h2 id="求出区间信息后贪心划分">求出区间信息后贪心划分</h2><h3 id="uva1437-string-painter">UVA1437 String painter</h3><blockquote><p>我断言一定存在一种最优的方案满足对于任意两次染色：它们的区间要么不交，要么靠后的那次被靠前的那次包含并且不共端点。</p><p>By <a href="https://www.luogu.com.cn/user/174045">FZzzz</a></p></blockquote><p>先考虑空串怎么做。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为完成区间 <spanclass="math inline">\([i,j]\)</span> 的涂色的最小代价。</p><ul><li>如果 <span class="math inline">\(S[i]=S[j]\)</span>，那么 <spanclass="math inline">\(f(i,j) = f(i,j-1)\)</span>。</li><li>否则一定一个断点，满足左右两边的染色区间不相交。枚举断点即可。</li></ul><p>考虑原问题，不难发现最优解一定是若干个不相交区间的 <spanclass="math inline">\(f\)</span> 拼接成的。</p><p>设 <span class="math inline">\(g(i)\)</span> 为完成 <spanclass="math inline">\([1,i]\)</span> 的涂色的最小代价。如果 <spanclass="math inline">\(A[i] = B[i]\)</span>，那么直接继承 <spanclass="math inline">\(g(i-1)\)</span>。否则枚举最后一段的划分点，求<span class="math inline">\(\min_{j=1}^{i-1} \Big\{g(j)+f(j+1,i)\Big\}\)</span></p><h3 id="luogu2470-scoi2007-压缩">luogu2470 [SCOI2007] 压缩</h3><p>和上面那题的套路很像。</p><p>先考虑没有<code>M</code>的情况。</p><p>发现直接做是不行的，比如<code>aaaabaaaab</code>，最短的压缩应该是<code>aRRbR</code>。也就是说，这里有一个子问题的结构。</p><p>设 <span class="math inline">\(g(i,j)\)</span>为不考虑<code>M</code>，区间 <span class="math inline">\([i,j]\)</span>的最小压缩长度。</p><p>仔细思考，发现这个区间能折半的话就折半，否则就只能拖在后面。 <spanclass="math display">\[g(i,j) = \min \begin{cases}g(i,i+mid-1)+1 &amp; \text{if } \; valid(i,j)\\g(i,j-1)+1\end{cases}\]</span> 其中 <span class="math inline">\(valid(i,j)\)</span> 表示<span class="math inline">\([i,j]\)</span>能否从中间划分成两个相同的串。</p><p>然后设 <span class="math inline">\(f(i)\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 的最小划分，有 <spanclass="math display">\[f(i) = \min_{j=0}^{i-1} \Big\{ f(j) + g(j+1,i) \Big\}\]</span> 如果用哈希求 <spanclass="math inline">\(valid(i,j)\)</span>，那么复杂度就是 <spanclass="math inline">\(O(n^2)\)</span>，优于洛谷题解区所有题解。</p><p>但是数据太水，如果用哈希可能因为常数大跑得更慢，所以本人采用了暴力做法，是<span class="math inline">\(O(n^3)\)</span> 的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-type">int</span> n, f[N], g[N][N];string s;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;cin&gt;&gt;s;n=s.<span class="hljs-built_in">size</span>();s=<span class="hljs-string">&quot; &quot;</span>+s;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) g[i][i]=<span class="hljs-number">1</span>, g[i][i+<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> lim=<span class="hljs-number">3</span>;lim&lt;=n;++lim) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+lim<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+lim<span class="hljs-number">-1</span>;<span class="hljs-type">int</span>&amp; res=g[i][j];res=lim;<span class="hljs-keyword">if</span>(lim%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;s.<span class="hljs-built_in">substr</span>(i,lim/<span class="hljs-number">2</span>)==s.<span class="hljs-built_in">substr</span>(i+lim/<span class="hljs-number">2</span>,lim/<span class="hljs-number">2</span>)) res=<span class="hljs-built_in">min</span>(res,g[i][i+lim/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);res=<span class="hljs-built_in">min</span>(res,g[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i]=g[<span class="hljs-number">1</span>][i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) &#123;f[i]=<span class="hljs-built_in">min</span>(f[i],f[j]+g[j+<span class="hljs-number">1</span>][i]+<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>类题还有<ahref="https://yozora0908.github.io/2022/cf1312e-solution/">CF1312E ArrayShrinking</a></p><h2 id="对相交区间的处理">对相交区间的处理</h2><h3 id="luogu5851-usaco19dec-greedy-pie-eaters">luogu5851 [USACO19DEC]Greedy Pie Eaters</h3><p>一个合法的顺序，一定若干个区间不断向外扩展。</p><p>一次收益只需要保证一个元素的存在，可以就此入手。</p><p>区间重叠难以处理，而数据范围较小，可以对区间范围进行限制。</p><p>设 <span class="math inline">\(g(k,i,j)\)</span> 为只考虑被 <spanclass="math inline">\([i,j]\)</span> 完全包含的区间，所有覆盖过 <spanclass="math inline">\(k\)</span> 的区间的最大权值。</p><p>容易在 <span class="math inline">\(O(n^3)\)</span>的时间里处理出来。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为只考虑被 <spanclass="math inline">\([i,j]\)</span>完全包含的区间，能够产生的最大收益。</p><p>枚举最后一个被干掉的元素 <spanclass="math inline">\(k\)</span>，有转移 <span class="math display">\[f(i,j) = \max_{k=i}^j \Big\{ f(i,k-1) + g(k,i,j) + f(k+1,j)  \Big\}\]</span> 对于区间 <spanclass="math inline">\([i,j]\)</span>，一定存在最后一个被干掉的元素。想要这个元素此时依然存在，之前选择的区间就不能包含它，而两边都是子问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P5851 [USACO19DEC] Greedy Pie Eaters P</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P5851</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>;<span class="hljs-type">int</span> n, m, f[N][N], g[N][N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> w=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(k,l,r) g[k][l][r]=<span class="hljs-built_in">max</span>(g[k][l][r],w);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(k,i,j) &#123;g[k][i][j]=<span class="hljs-built_in">max</span>(&#123;g[k][i][j],g[k][i+<span class="hljs-number">1</span>][j],g[k][i][j<span class="hljs-number">-1</span>]&#125;);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][i]=<span class="hljs-built_in">max</span>(f[i][i],g[i][i][i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(k,i,j) &#123;f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][k<span class="hljs-number">-1</span>]+g[k][i][j]+f[k+<span class="hljs-number">1</span>][j]);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj2688.-poi2015洗车">LOJ#2688. 「POI2015」洗车</h3><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为考虑洗车店区间<span class="math inline">\([i,j]\)</span> 和被区间 <spanclass="math inline">\([i,j]\)</span> 完全包含的消费者区间，<spanclass="math inline">\([i,j]\)</span> 的最小值为 <spanclass="math inline">\(k\)</span> 时，能得到的最大收益。</p><p>先将 <span class="math inline">\(c_i\)</span> 离散化了。</p><p>我们把贡献放到点上，求出 <span class="math inline">\(g(p,k)\)</span>表示在当前区间内，覆盖了 <span class="math inline">\(p\)</span> 且 <spanclass="math inline">\(c_i \ge k\)</span> 的区间数量。有转移 <spanclass="math display">\[f(i,j,k) = \max_{p=i}^j \Big\{ f(i,p-1,k) + g(p,k) \times val(k)+  f(p+1,j,k)  \Big\}\]</span> 正确性就比较显然了。</p><p>输出方案只需要记录最优决策点和对应决策值。</p><div class="note note-primary">            <p><ahref="https://www.cnblogs.com/dysyn1314/p/12524538.html">duyi</a>的博客中说这是笛卡尔树DP。</p><p>这个说法我无法否认，因为这就是自底向上重现最值分治的过程。</p><p>但是也完全可以当作区间 DP 来思考。</p>          </div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3592 [POI2015] MYJ</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3592</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>, M=<span class="hljs-number">4005</span>;<span class="hljs-type">int</span> n, m, cnt, a[M], b[M], c[M], t[M];<span class="hljs-type">int</span> f[N][N][M], g[N][M], lst[N][N][M], v[N][N][M], ans[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);cnt=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) c[i]=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>,c[i])-t;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span>;ans[lst[i][j][k]]=t[v[i][j][k]];<span class="hljs-built_in">print</span>(i,lst[i][j][k]<span class="hljs-number">-1</span>,v[i][j][k]);<span class="hljs-built_in">print</span>(lst[i][j][k]+<span class="hljs-number">1</span>,j,v[i][j][k]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>(), c[i]=t[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">lsh</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(i&lt;=a[k]&amp;&amp;b[k]&lt;=j) &#123;<span class="hljs-built_in">rep</span>(p,a[k],b[k]) ++g[p][c[k]];&#125;<span class="hljs-built_in">rep</span>(p,i,j) <span class="hljs-built_in">per</span>(k,cnt,<span class="hljs-number">1</span>) g[p][k]+=g[p][k+<span class="hljs-number">1</span>];lst[i][j][cnt+<span class="hljs-number">1</span>]=i, v[i][j][cnt+<span class="hljs-number">1</span>]=cnt;<span class="hljs-built_in">per</span>(k,cnt,<span class="hljs-number">1</span>) &#123;f[i][j][k]=f[i][j][k+<span class="hljs-number">1</span>];lst[i][j][k]=lst[i][j][k+<span class="hljs-number">1</span>];v[i][j][k]=v[i][j][k+<span class="hljs-number">1</span>];<span class="hljs-built_in">rep</span>(p,i,j) <span class="hljs-keyword">if</span>(f[i][p<span class="hljs-number">-1</span>][k]+f[p+<span class="hljs-number">1</span>][j][k]+g[p][k]*t[k]&gt;f[i][j][k]) &#123;f[i][j][k]=f[i][p<span class="hljs-number">-1</span>][k]+f[p+<span class="hljs-number">1</span>][j][k]+g[p][k]*t[k];lst[i][j][k]=p, v[i][j][k]=k;&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>]);<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>另外有类题<ahref="https://yozora0908.github.io/2022/lg4766-solution/">luogu4766Outer space invaders</a></p><h2 id="区间左右取数">区间左右取数</h2><p>这个就相对固定了。</p><h3 id="abc303g-bags-game">ABC303G Bags Game</h3><p>一类在区间左右选物品的博弈问题。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为只考虑区间 <spanclass="math inline">\([i,j]\)</span>，先手能得到的最大收益。</p><p>第一类操作，转移显然。</p><p>考虑第二三类操作。</p><p>以第二类操作为例，设 <spanclass="math inline">\(\beta=\min(B,len)\)</span>，枚举 <spanclass="math inline">\(x+y=\beta\)</span>，有转移 <spanclass="math display">\[f(i,j) \leftarrow \max_{x=0}^{\beta} \Big\{ \sum_{k=i}^{i+x-1} a_i +\sum_{j-y+1}^{j} a_i  - f (i+x,j-y) \Big\}\]</span> 式子变形一下就是 <span class="math display">\[\max_{x=0}^{\beta} \Bigg\{ sum(i,j) - \Big( f (i+x,j-y) + sum(i+x,j-y)\Big) \Bigg\}\]</span> 考虑优化。</p><p>能发现对于一个固定的 <spanclass="math inline">\(len=j-i+1\)</span>，所有决策区间的长度都是 <spanclass="math inline">\(j-y-(i+x)+1 = len-\beta\)</span>。</p><p>设 <span class="math inline">\(lb=len-\beta\)</span>。</p><p>当从 <span class="math inline">\([i-1,j-1]\)</span> 到 <spanclass="math inline">\([i,j]\)</span> 时，我们只会丢掉决策 <spanclass="math inline">\(f(i-1,i+lb-2)\)</span>，增加决策 <spanclass="math inline">\(f(j-lb+1,j)\)</span> 。</p><p>我们只需要用单调队列维护中间那个东西的最小值就行了。</p><p>实现细节颇多，具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: [ABC303G] Bags Game</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/AT_abc303_g</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 1 MB</span><span class="hljs-comment">// Time Limit: 2500 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3005</span>;<span class="hljs-type">int</span> n, A, B, C, D, a[N], s[N], f[N][N];<span class="hljs-type">int</span> q1[N], q2[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> s[j]-s[i<span class="hljs-number">-1</span>]; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>(), B=<span class="hljs-built_in">read</span>(), C=<span class="hljs-built_in">read</span>(), D=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();s[i]=s[i<span class="hljs-number">-1</span>]+a[i];f[i][i]=a[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;++len) &#123;<span class="hljs-type">int</span> l1=<span class="hljs-number">1</span>, r1=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> l2=<span class="hljs-number">1</span>, r2=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> lb=len-B, ld=len-D;f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(a[<span class="hljs-number">1</span>]-f[<span class="hljs-number">2</span>][len],a[len]-f[<span class="hljs-number">1</span>][len<span class="hljs-number">-1</span>]);<span class="hljs-keyword">if</span>(lb&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+lb<span class="hljs-number">-1</span>&lt;=len;++i) &#123;             <span class="hljs-type">int</span> ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;             <span class="hljs-comment">// 当前加入的区间是[i,i+lb-1]</span><span class="hljs-keyword">while</span>(l1&lt;=r1&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[i][i+lb<span class="hljs-number">-1</span>]+<span class="hljs-built_in">sum</span>(i,i+lb<span class="hljs-number">-1</span>)) &#123;--r1;ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;&#125;q1[++r1]=i;&#125;            <span class="hljs-comment">// 先把[1,len]中所有决策都扔进，注意边界</span><span class="hljs-type">int</span> ll=q1[l1], rr=q1[l1]+lb<span class="hljs-number">-1</span>;f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-A-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125; <span class="hljs-keyword">else</span> f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-A);<span class="hljs-keyword">if</span>(ld&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+ld<span class="hljs-number">-1</span>&lt;=len;++i) &#123;<span class="hljs-type">int</span> ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(l2&lt;=r2&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[i][i+ld<span class="hljs-number">-1</span>]+<span class="hljs-built_in">sum</span>(i,i+ld<span class="hljs-number">-1</span>)) &#123;--r2;ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;&#125;q2[++r2]=i;&#125;<span class="hljs-type">int</span> ll=q2[l2], rr=q2[l2]+ld<span class="hljs-number">-1</span>;f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-C-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125; <span class="hljs-keyword">else</span> f[<span class="hljs-number">1</span>][len]=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][len],<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,len)-C);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i+len<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;f[i][j]=<span class="hljs-built_in">max</span>(a[i]-f[i+<span class="hljs-number">1</span>][j],a[j]-f[i][j<span class="hljs-number">-1</span>]);<span class="hljs-keyword">if</span>(lb&lt;=<span class="hljs-number">0</span>) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-A);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(l1&lt;=r1&amp;&amp;q1[l1]&lt;i) ++l1;<span class="hljs-type">int</span> ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(l1&lt;=r1&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[j-lb+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">sum</span>(j-lb+<span class="hljs-number">1</span>,j)) &#123;--r1;ll=q1[r1], rr=q1[r1]+lb<span class="hljs-number">-1</span>;&#125;q1[++r1]=j-lb+<span class="hljs-number">1</span>;ll=q1[l1], rr=q1[l1]+lb<span class="hljs-number">-1</span>;                <span class="hljs-comment">// 注意顺序，我们刚才加入的是当前区间所带来的新决策，所以更新必须放到最后</span>f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-A-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125;<span class="hljs-keyword">if</span>(ld&lt;=<span class="hljs-number">0</span>) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-C);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(l2&lt;=r2&amp;&amp;q2[l2]&lt;i) ++l2;<span class="hljs-type">int</span> ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(l2&lt;=r2&amp;&amp;f[ll][rr]+<span class="hljs-built_in">sum</span>(ll,rr)&gt;=f[j-ld+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">sum</span>(j-ld+<span class="hljs-number">1</span>,j)) &#123;--r2;ll=q2[r2], rr=q2[r2]+ld<span class="hljs-number">-1</span>;&#125;q2[++r2]=j-ld+<span class="hljs-number">1</span>;ll=q2[l2], rr=q2[l2]+ld<span class="hljs-number">-1</span>;f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">sum</span>(i,j)-C-<span class="hljs-built_in">sum</span>(ll,rr)-f[ll][rr]);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="杂题">杂题</h2><h3 id="cf149d-coloring-brackets">CF149D Coloring Brackets</h3><p>先用栈求出点 <span class="math inline">\(i\)</span> 的匹配点 <spanclass="math inline">\(\text{match}(i)\)</span>。</p><p>设 <span class="math inline">\(f(i,j,a,b)\)</span> 为考虑区间 <spanclass="math inline">\([i,j]\)</span>，其中左端点的染色情况和为 <spanclass="math inline">\(a\)</span>，右端点的染色情况为 <spanclass="math inline">\(b\)</span> 的方案数。</p><p>分如下情况讨论。</p><ul><li><p><span class="math inline">\(\text{match}(i)=j\)</span>。</p><p>如果 <spanclass="math inline">\(i+1=j\)</span>，那么直接讨论就好了。否则枚举颜色，用<span class="math inline">\(f(i+1,j-1)\)</span> 转移。</p></li><li><p><span class="math inline">\(\text{match}(i) \neqj\)</span>。我们考虑把 <spanclass="math inline">\([i,\text{match}(i)]\)</span> 拼接到 <spanclass="math inline">\([\text{match}(i)+1,j]\)</span>上。枚举颜色讨论即可。</p></li><li><p>注意由于 <span class="math inline">\(\text{match}(i)\)</span>不一定在 <span class="math inline">\(i\)</span> 的右边，所以要判断所有<span class="math inline">\(i&gt;j\)</span> 的情况。</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">705</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, match[N], f[N][N][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<span class="hljs-type">int</span> tp, st[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span>==r) &#123;f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=f[l][r][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=f[l][r][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(match[l]==r) &#123;<span class="hljs-built_in">dfs</span>(l+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(j!=<span class="hljs-number">1</span>) (f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;<span class="hljs-keyword">if</span>(j!=<span class="hljs-number">2</span>) (f[l][r][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) (f[l][r][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">2</span>) (f[l][r][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][i][j])%=mod;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">dfs</span>(l,match[l]);<span class="hljs-built_in">dfs</span>(match[l]+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(p,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(q,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(j==p&amp;&amp;j) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(!i||!p) (f[l][r][i][q]+=f[l][match[l]][i][p]*f[match[l]+<span class="hljs-number">1</span>][r][j][q]%mod)%=mod;            <span class="hljs-comment">// 相邻不能相等，匹配的两边不能都染色</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) st[++tp]=i;<span class="hljs-keyword">else</span> &#123;match[i]=st[tp];match[st[tp]]=i;--tp;&#125;&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,n);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)  (ans+=f[<span class="hljs-number">1</span>][n][i][j])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu3147-usaco16open-262144">luogu3147 [USACO16OPEN]262144</h3><p>先考虑 <span class="math inline">\(O(n^3)\)</span> 怎么做。</p><p>这类整个区间合并成一个数的题都有一个套路：只考虑整个区间合并成一个数的情况。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span>能合成的数的最大值，转移枚举断点，再判断两边是否相等即可。</p><p>然后这题正解就和 DP 没关系了。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为从 <spanclass="math inline">\(j\)</span> 开始合并一串数得到 <spanclass="math inline">\(i\)</span>，这串数的个数。 <spanclass="math display">\[f(i,j) = f(i-1,j) + f\Big(i-1,j+f(i-1,j)\Big)\]</span> 类题是 <ahref="https://www.luogu.com.cn/problem/P4805">luogu4805 [CCC2016]合并饭团</a>，不过那题的主要部分是单调性优化，这里就不展开了。</p><h3 id="luogu2890-usaco07open-cheapest-palindrome">luogu2890[USACO07OPEN] Cheapest Palindrome</h3><p>设 <span class="math inline">\(f(i,j)\)</span> 为把区间 <spanclass="math inline">\([i,j]\)</span> 搞成回文的最小代价。</p><p>如果 <span class="math inline">\(S[i]=S[j]\)</span>，那么直接继承<span class="math inline">\(f(i+1,j-1)\)</span>。</p><p>否则就是 <span class="math inline">\(\min\Big(f(i+1,j)+cost_i,f(i,j-1)+cost_j \Big)\)</span></p><p>其中 <span class="math inline">\(cost_i\)</span> 表示增加或删去 <spanclass="math inline">\(S[i]\)</span> 的较小代价。</p><p>对于区间 <span class="math inline">\([i,j]\)</span>，如果 <spanclass="math inline">\(S[i] \neqS[j]\)</span>，那么要想形成回文串，总会拿出 <spanclass="math inline">\(S[i],S[j]\)</span>其中之一，删掉或添加一个一样的在另一边，剩下的部分也要形成回文串，这是一个子问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2890 [USACO07OPEN] Cheapest Palindrome G</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2890</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-type">int</span> n, m, f[N][N], c[<span class="hljs-number">100</span>][<span class="hljs-number">2</span>];<span class="hljs-type">char</span> s[N], o[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,o);c[o[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">read</span>(), c[o[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) f[i][i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=m;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=m;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(s[i]==s[j]) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==j) f[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);&#125;f[i][j]=<span class="hljs-built_in">min</span>(&#123;f[i][j],f[i+<span class="hljs-number">1</span>][j]+<span class="hljs-built_in">min</span>(c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>],c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>]),f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">min</span>(c[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>],c[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>])&#125;);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][m]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj2063.-haoi2016字符合并">LOJ#2063. 「HAOI2016」字符合并</h3><p>这里用 <span class="math inline">\(m\)</span> 代替题目中的 <spanclass="math inline">\(k\)</span>。</p><p>注意到任何区间合并后都一定是一个 <spanclass="math inline">\(m\)</span> 位二进制数，而 <spanclass="math inline">\(m\)</span> 很小，可以考虑状压。</p><p>设 <span class="math inline">\(f(i,j,S)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span> 合并为 <spanclass="math inline">\(S\)</span> 的最大收益。</p><p>考虑如何转移。先讨论如何得到 <spanclass="math inline">\(S\)</span>，再讨论合并成什么。</p><p>可以枚举 <span class="math inline">\(S\)</span>的最后一位是哪个区间合并而来，复杂度是 <spanclass="math inline">\(O(\frac{n}{m})\)</span> 的。</p><p>合并只能将整个串合并为 <span class="math inline">\(0\)</span> 或<span class="math inline">\(1\)</span>，不难发现这样做的充要条件是 <spanclass="math inline">\((m-1) \mid (len-1)\)</span>。</p><p>枚举 <span class="math inline">\(S\)</span>，对于转化成 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span> 分别取最大值，最后更新 <spanclass="math inline">\(f(i,j,0/1)\)</span> 即可。</p><p>时间复杂度是 <span class="math inline">\(O(n^22^m\frac{n}{m})\)</span>，勉强通过。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: #2063. 「HAOI2016」字符合并</span><span class="hljs-comment">// Contest: LibreOJ</span><span class="hljs-comment">// URL: https://loj.ac/p/2063</span><span class="hljs-comment">// author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, U, to[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>], w[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>], f[N][N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-0x3f</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][i][s[i]-<span class="hljs-string">&#x27;0&#x27;</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) to[S]=<span class="hljs-built_in">read</span>(), w[S]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j<span class="hljs-number">-1</span>;k&gt;=i;k-=m<span class="hljs-number">-1</span>) &#123;f[i][j][S]=<span class="hljs-built_in">max</span>(f[i][j][S],f[i][k][S&gt;&gt;<span class="hljs-number">1</span>]+f[k+<span class="hljs-number">1</span>][j][S&amp;<span class="hljs-number">1</span>]);                <span class="hljs-comment">// 注意枚举顺序</span>&#125;&#125;<span class="hljs-keyword">if</span>((l<span class="hljs-number">-1</span>)%(m<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> res0=<span class="hljs-number">0</span>, res1=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">if</span>(to[S]==<span class="hljs-number">0</span>) res0=<span class="hljs-built_in">max</span>(res0,f[i][j][S]+w[S]);<span class="hljs-keyword">else</span> res1=<span class="hljs-built_in">max</span>(res1,f[i][j][S]+w[S]);&#125;f[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">0</span>],res0), f[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">1</span>],res1);&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) ans=<span class="hljs-built_in">max</span>(ans,f[<span class="hljs-number">1</span>][n][S]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj2292.-thusc-2016成绩单">LOJ#2292. 「THUSC 2016」成绩单</h3><p>注意到 <span class="math inline">\(n\)</span> 只有 <spanclass="math inline">\(50\)</span>，可以先将 <spanclass="math inline">\(W_i\)</span> 离散化了。</p><p>注意到分发顺序不重要，我们钦定任何区间都是从左往右分发。</p><p>设 <span class="math inline">\(g(i,j,mx,mn)\)</span> 表示把 <spanclass="math inline">\([i,j]\)</span> 取到还剩下一段值域为 <spanclass="math inline">\([mn,mx]\)</span> 的区间的最小代价，<spanclass="math inline">\(f(i,j)\)</span> 表示取完 <spanclass="math inline">\([i,j]\)</span> 的最小代价。</p><p>首先我们可以让 <span class="math inline">\(j\)</span> 加入 <spanclass="math inline">\(g(i,j-1,mx,mn)\)</span>，注意 <spanclass="math inline">\(W_j\)</span> 对 <spanclass="math inline">\(mx\)</span> 与 <spanclass="math inline">\(mn\)</span> 的影响。</p><p>否则我们枚举和 <span class="math inline">\(j\)</span>一起消掉的一段。 <span class="math display">\[g(i,j,mx,mn) = \min_{k=i}^{j-1} \Big\{ g(i,k,mx,mn) + f(k+1,j) \Big\}\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P5336 [THUSC2016] 成绩单</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P5336</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 500 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-type">int</span> n, m, a, b, s[N], f[N][N], g[N][N][N][N], t[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-(t+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,s[i])-t;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=<span class="hljs-built_in">read</span>(), t[++m]=s[i];<span class="hljs-built_in">lsh</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>), <span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0x3f</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;f[i][i]=a;g[i][i][s[i]][s[i]]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>; <span class="hljs-built_in">rep</span>(mx,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(mn,<span class="hljs-number">1</span>,mx) &#123; <span class="hljs-type">int</span>&amp; x=g[i][j][<span class="hljs-built_in">max</span>(mx,s[j])][<span class="hljs-built_in">min</span>(mn,s[j])]; x=<span class="hljs-built_in">min</span>(x,g[i][j<span class="hljs-number">-1</span>][mx][mn]); <span class="hljs-built_in">rep</span>(k,i,j<span class="hljs-number">-1</span>) g[i][j][mx][mn]=<span class="hljs-built_in">min</span>(g[i][j][mx][mn],g[i][k][mx][mn]+f[k+<span class="hljs-number">1</span>][j]); &#125;<span class="hljs-built_in">rep</span>(mx,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(mn,<span class="hljs-number">1</span>,mx) &#123;f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],g[i][j][mx][mn]+a+b*(t[mx]-t[mn])*(t[mx]-t[mn]));&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="loj6092.-codeforces-round-418恋爱循环">LOJ#6092. 「CodeforcesRound #418」恋爱循环</h3><p>严格来说算是区间 DP 吗？</p><p>对于每个字符，把所有点提取成连续的，保留各自的下标用作距离。我们断言，最终的修改一定指挥让某一个区间的这个字符连成一片。</p><p>设 <span class="math inline">\(f_{\pi}(i,j)\)</span> 为考虑字符 <spanclass="math inline">\(\pi\)</span>，把区间 <spanclass="math inline">\([i,j]\)</span> 里的 <spanclass="math inline">\(\pi\)</span>，通过修改中间字符的方式搞成连续的所需要的最小代价。</p><p>那么每个询问等价于求一个区间 <spanclass="math inline">\([l,r]\)</span>，满足 <spanclass="math inline">\(f_c(l,r) \le m\)</span> 并且 <spanclass="math inline">\(\min\Big(n,r-l+1+m \Big)\)</span> 最大。</p><p>不难发现对于不断递增的 <span class="math inline">\(r\)</span>，<spanclass="math inline">\(l\)</span> 是有决策单调性的，直接双指针即可。</p><p>然而还是无法通过，考虑预处理答案。</p><p>能发现总复杂度是 <span class="math inline">\(O\Big(\sum_{i=1}^{26}cnt_i^2 + q\Big)\)</span>，其中 <spanclass="math inline">\(cnt_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个字符的数量。</p><p>后面那个东西在所有字符都相同时有上界，可以通过。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1505</span>;<span class="hljs-type">int</span> n, q, a[N], sum[<span class="hljs-number">30</span>][N], ans[<span class="hljs-number">30</span>][N];vector&lt;<span class="hljs-type">int</span>&gt; v[<span class="hljs-number">30</span>];vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; f[<span class="hljs-number">30</span>];<span class="hljs-type">char</span> s[N], cc[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;f[x].<span class="hljs-built_in">resize</span>(v[x].<span class="hljs-built_in">size</span>()+<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v[x].<span class="hljs-built_in">size</span>();++i) f[x][i].<span class="hljs-built_in">resize</span>(v[x].<span class="hljs-built_in">size</span>()+<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v[x].<span class="hljs-built_in">size</span>();++i) f[x][i][i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=v[x].<span class="hljs-built_in">size</span>();++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i+l<span class="hljs-number">-1</span>&lt;v[x].<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;f[x][i][j]=f[x][i][j<span class="hljs-number">-1</span>]+v[x][j]-v[x][j<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(r+<span class="hljs-number">1</span>&lt;v[x].<span class="hljs-built_in">size</span>()&amp;&amp;f[x][l][r+<span class="hljs-number">1</span>]&lt;=i) ++r;ans[x][i]=<span class="hljs-built_in">max</span>(ans[x][i],<span class="hljs-built_in">min</span>(r-l+<span class="hljs-number">1</span>+i,n));<span class="hljs-keyword">for</span>(;r&lt;v[x].<span class="hljs-built_in">size</span>();++r) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[x][l][r]&gt;i) ++l;<span class="hljs-keyword">if</span>(l&lt;=r) ans[x][i]=<span class="hljs-built_in">max</span>(ans[x][i],<span class="hljs-built_in">min</span>(r-l+<span class="hljs-number">1</span>+i,n));&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dp</span>(i);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">solve</span>(i);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;v[a[i]].<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-built_in">prework</span>();q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,cc);<span class="hljs-type">int</span> c=cc[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(v[c].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[c][m]); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,m);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>贪心</tag>
      
      <tag>计数</tag>
      
      <tag>状态压缩</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#17 二分图判定</title>
    <link href="/2023/noip-record-17/"/>
    <url>/2023/noip-record-17/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="二分图判定">二分图判定</h2><p>没啥技巧，最难的是把图论模型建起来。</p><h3 id="luogu1330-封锁阳光大学">luogu1330 封锁阳光大学</h3><p>相邻两个点只能封锁一个，但是要覆盖所有边。对应到二分图上就是左部右部点的数量取较小值。</p><p>图可能不连通，取的是每一张二分图的左右边的较小值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, c[N], deg[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">int</span> c1, c2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> col)</span> </span>&#123;c[x]=col;<span class="hljs-keyword">if</span>(col==<span class="hljs-number">1</span>) ++c1; <span class="hljs-keyword">else</span> ++c2;<span class="hljs-type">bool</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(!c[y]) res&amp;=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-col);<span class="hljs-keyword">else</span> res&amp;=(c[y]!=col);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];<span class="hljs-built_in">add</span>(x,y);&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!c[i]) &#123;c1=c2=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;ans+=<span class="hljs-built_in">min</span>(c1,c2);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu1155-noip2008-提高组-双栈排序">luogu1155 [NOIP2008 提高组]双栈排序</h3><p>考虑什么情况下，两个元素不能在用一个栈中。注意不一定是同时，先后进栈也算。</p><p>不难发现 <span class="math inline">\(i,j\)</span>不能在同一个栈中，当且仅当存在 <spanclass="math inline">\((i,j,k)\)</span>，满足 <spanclass="math inline">\(i&lt;j&lt;k\)</span>，<spanclass="math inline">\(a_k &lt;a_i &lt; a_j\)</span>。</p><p>考虑在 <span class="math inline">\(i,j\)</span>之间连边，表示二者不能用同一个栈，那么有解当且仅当这张图是二分图。</p><p>考虑如何构造方案。</p><p>对图黑白染色，编号小的点贪心染白色，同时规定第一个栈是白色栈。</p><p>维护一个全局变量 <span class="math inline">\(now\)</span>表示下一个应该放哪个元素，从 <span class="math inline">\(1\)</span> 到<span class="math inline">\(n\)</span> 扫一遍，对于一个将要加入的 <spanclass="math inline">\(a_i\)</span>，维护它所在颜色的栈中元素单调递增，同时判断栈顶是否是<spanclass="math inline">\(now\)</span>，如果不是就输出另一个栈的栈顶。</p><p>由于白色栈的操作优先级都要高于黑色栈，所以在加入 <spanclass="math inline">\(a_i\)</span> 之前，应该输出白栈的栈顶直到不是<span class="math inline">\(now\)</span>。</p><p>最后输出剩下的元素，贪心白色栈即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-type">int</span> n, now=<span class="hljs-number">1</span>, a[N], suf[N], c[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> col)</span> </span>&#123;c[x]=col;<span class="hljs-type">bool</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(!c[y]) res&amp;=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-col);<span class="hljs-keyword">else</span> res&amp;=(c[y]!=col);<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;stack&lt;<span class="hljs-type">int</span>&gt; s[<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> col)</span> </span>&#123;<span class="hljs-keyword">return</span> s[col].<span class="hljs-built_in">size</span>()&amp;&amp;s[col].<span class="hljs-built_in">top</span>()==now;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">int</span> col)</span> </span>&#123;s[col].<span class="hljs-built_in">pop</span>();++now;<span class="hljs-keyword">if</span>(col==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b &quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d &quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();suf[n]=a[n];<span class="hljs-built_in">per</span>(i,n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) suf[i]=<span class="hljs-built_in">min</span>(suf[i+<span class="hljs-number">1</span>],a[i]);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,i+<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(suf[j+<span class="hljs-number">1</span>]&lt;a[i]&amp;&amp;a[i]&lt;a[j]) <span class="hljs-built_in">add</span>(i,j);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!c[i]) &#123;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">while</span>(s[c[i]].<span class="hljs-built_in">size</span>()&amp;&amp;s[c[i]].<span class="hljs-built_in">top</span>()&lt;=a[i]) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(c[i])) <span class="hljs-built_in">out</span>(c[i]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">out</span>(<span class="hljs-number">3</span>-c[i]);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>)) <span class="hljs-built_in">out</span>(<span class="hljs-number">1</span>);s[c[i]].<span class="hljs-built_in">push</span>(a[i]);<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a &quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c &quot;</span>);&#125;<span class="hljs-keyword">while</span>(s[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()||s[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>)) <span class="hljs-built_in">out</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(<span class="hljs-number">2</span>)) <span class="hljs-built_in">out</span>(<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu1285-队员分组">luogu1285 队员分组</h3><p>老题，从其他 OJ 扒来的换皮题，但是质量意外的高啊。</p><p>预处理出所有不互相认识的人，他们一定不能在同一组。在他们之间连边，发现如果有解当且仅当连出的图是二分图。</p><p>题目要求最小化两组人数之差，但是多个连通块一起考虑显然很难做。这时候可以利用连通块之间相对独立的性质，对每个连通块单独考虑，同时只有单独一个连通块的分组方法是确定的。</p><p>这时候我们能发现，每个连通块有两种颜色，每个颜色的所有点都必须一起选择，但是不同连通块的不同颜色却可以分到同一组。因此问题转化为分组背包。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 个连通块，能否选择 <spanclass="math inline">\(j\)</span> 个点。转移是平凡的，同时记录到达 <spanclass="math inline">\(f(i,j)\)</span>的最后一个决策是选择的哪个颜色。</p><p>设连通块个数为 <span class="math inline">\(m\)</span>。</p><p>分成两组，必然有一组人数不超过 <span class="math inline">\(n /2\)</span>。找到 <span class="math inline">\(f(m,i)\)</span> 中满足<span class="math inline">\(j \le n/2\)</span> 且 <spanclass="math inline">\(f(n,j)=1\)</span> 的极大的 <spanclass="math inline">\(j\)</span>，这就是人数较少那组的人数了。</p><p>此时我们就可以利用记录的决策输出方案了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, a[N][N], col[N];<span class="hljs-type">int</span> cnt;vector&lt;<span class="hljs-type">int</span>&gt; p[N], con[N][<span class="hljs-number">2</span>], ans[<span class="hljs-number">2</span>];<span class="hljs-type">int</span> f[N][N], op[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> j;<span class="hljs-keyword">do</span> &#123;j=<span class="hljs-built_in">read</span>();a[i][j]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">while</span>(j);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i!=j) &#123;<span class="hljs-keyword">if</span>(!a[i][j]||!a[j][i]) <span class="hljs-built_in">add</span>(i,j);&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span> </span>&#123;col[x]=color;con[cnt][col[x]].<span class="hljs-built_in">pb</span>(x);<span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(~col[y]) res&amp;=(col[y]!=col[x]);<span class="hljs-keyword">else</span> res&amp;=<span class="hljs-built_in">dfs</span>(y,col[x]^<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(col,<span class="hljs-number">-1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(col[i]&lt;<span class="hljs-number">0</span>) &#123;++cnt;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No solution&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;&#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> sz(x) con[i][x].size()</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:con[i][op[i][j]]) ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">pb</span>(x);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:con[i][op[i][j]^<span class="hljs-number">1</span>]) ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(x);<span class="hljs-built_in">getans</span>(i<span class="hljs-number">-1</span>,j-<span class="hljs-built_in">sz</span>(op[i][j]));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,n) &#123;<span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-built_in">sz</span>(<span class="hljs-number">0</span>)&amp;&amp;f[i<span class="hljs-number">-1</span>][j-<span class="hljs-built_in">sz</span>(<span class="hljs-number">0</span>)]) f[i][j]=<span class="hljs-number">1</span>, op[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-built_in">sz</span>(<span class="hljs-number">1</span>)&amp;&amp;f[i<span class="hljs-number">-1</span>][j-<span class="hljs-built_in">sz</span>(<span class="hljs-number">1</span>)]) f[i][j]=<span class="hljs-number">1</span>, op[i][j]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 都可以的话0/1随便取一个</span>&#125;<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i;--i) <span class="hljs-keyword">if</span>(f[cnt][i]) &#123; j=i; <span class="hljs-keyword">break</span>; &#125;<span class="hljs-built_in">getans</span>(cnt,j);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(),ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>());<span class="hljs-built_in">sort</span>(ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(),ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 注意输出要排序</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,(<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans[<span class="hljs-number">0</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,x);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,(<span class="hljs-type">int</span>)ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans[<span class="hljs-number">1</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">input</span>();<span class="hljs-built_in">build</span>();<span class="hljs-built_in">getcol</span>();<span class="hljs-built_in">dp</span>();<span class="hljs-built_in">output</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#16 欧拉路径与拓扑排序</title>
    <link href="/2023/noip-record-16/"/>
    <url>/2023/noip-record-16/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="欧拉路径">欧拉路径</h2><h3 id="定义">定义</h3><p>从一个点出发，不重不漏地经过图中每一条边的一条路径，允许重复经过节点。</p><h3 id="无向图">无向图</h3><p>首先必须是连通图，其次是两种情况。</p><ol type="1"><li>所有点的度数是偶数。</li><li>恰好存在两个点的度数是奇数。</li></ol><h3 id="有向图">有向图</h3><p>要求连通。</p><ol type="1"><li>所有点的入度等于出度。</li><li>恰好存在一个节点入度比出度多 <spanclass="math inline">\(1\)</span>，一个节点入度比出度少 <spanclass="math inline">\(1\)</span>。</li></ol><h2 id="欧拉回路">欧拉回路</h2><h3 id="定义-1">定义</h3><p>起点和终点是一个点的欧拉路径。</p><h3 id="无向图-1">无向图</h3><p>连通，所有点的度数都是偶数。</p><h3 id="有向图-1">有向图</h3><p>连通，所有点的入度等于出度。</p><h2 id="hierholzer算法">Hierholzer算法</h2><p>这个 H 姓算法的实现有很多。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(x)     <span class="hljs-function"><span class="hljs-keyword">for</span> each <span class="hljs-title">edge</span> <span class="hljs-params">(x,y)</span> in E</span><span class="hljs-function">         <span class="hljs-keyword">if</span> vis[<span class="hljs-params">(x,y)</span>]</span>=<span class="hljs-number">0</span>             vis[(x,y)]=<span class="hljs-number">1</span>             <span class="hljs-built_in">dfs</span>(y)     push_front y to ans</code></pre></div><p>直接暴力跑是 <span class="math inline">\(O(nm)\)</span> 的。</p><p>使用邻接表存图的话，建完图后访问每个点连出边是有顺序的。</p><p>记录一下访问到了哪条边即可。</p><p>那么下面代码的复杂度就是 <spanclass="math inline">\(O(n+m)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, tot=<span class="hljs-number">1</span>, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">if</span>(!v[i&gt;&gt;<span class="hljs-number">1</span>]) &#123;v[i&gt;&gt;<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(to[i]);&#125;&#125;ans.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());&#125;</code></pre></div><p>另外还有模拟机器递归的实现，不会爆栈。但是我记不住。</p><h2 id="题">题</h2><p>这个算是冷门知识点了，但是大纲里有。</p><p>要么太难要么偏板。</p><h3 id="luogu2731-usaco3.3-骑马修栅栏">luogu2731 [USACO3.3]骑马修栅栏</h3><p>就是板子。</p><p>只不过两点之间可以有多条路径。</p><p>我们走一次干掉一条就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1145</span>;<span class="hljs-type">int</span> n, lim, deg[N], e[N][N];vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=lim;++y) <span class="hljs-keyword">if</span>(e[x][y]) &#123;--e[x][y], --e[y][x];<span class="hljs-built_in">dfs</span>(y);&#125;ans.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++e[x][y], ++e[y][x];++deg[x], ++deg[y];lim=<span class="hljs-built_in">max</span>(&#123;lim,x,y&#125;);&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, st=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,lim) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) &#123;++cnt;<span class="hljs-keyword">if</span>(!st) st=i;&#125;<span class="hljs-keyword">if</span>(!st) &#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,lim) <span class="hljs-keyword">if</span>(deg[i]) &#123; st=i; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">dfs</span>(st);<span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,x);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="uva10129-play-on-words">UVA10129 Play on Words</h3><p>其实问题就是二选一：</p><ol type="1"><li><p>单词为点。结尾为字母 <span class="math inline">\(\pi\)</span>的单词向开头为字母 <span class="math inline">\(\pi\)</span>的单词连边。</p></li><li><p>字母为点。每个单词的首字母向尾字母连边。</p></li></ol><p>很重要的一点是每个字母必须都出现一次且仅一次。</p><p>第一种方式，问题转化哈密顿回路，做不了。</p><p>第二种方式，问题转化为欧拉路径，可以做。</p><h3 id="cf547d-mike-and-fish">CF547D Mike and Fish</h3><p>个人感觉这题的建模方式就不太自然了。</p><p>对每行每列都建一个点，对于节点 <spanclass="math inline">\((x,y)\)</span>，在 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>之间连一条无向边，然后对边定向，使得每个点的入度出度只差不超过 <spanclass="math inline">\(1\)</span>。</p><p>然后连边后是个二分图。可以没用。</p><p>考虑简化版，所有点的度数都是偶数。</p><p>在图上跑欧拉回路，按照路径上经过点的顺序定向，就能得到一组合法解。</p><p>考虑原版。如果能将度数为奇数的点改为偶数，那么就能归约到弱化版了。</p><p>建一个虚点，把度数为奇数的点向虚点连双向边。奇度点一定有偶数个，所以此时包括虚点在内所有点的度数都是偶数，跑欧拉回路即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>, DLT=<span class="hljs-number">2e5</span>;<span class="hljs-type">int</span> n, deg[N], v[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> j=i&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-comment">// i&gt;&gt;1定位到i这条边对应的横坐标点的编号</span><span class="hljs-keyword">if</span>(!v[j]) &#123;v[j]=<span class="hljs-number">1</span>+(x&lt;=DLT);<span class="hljs-built_in">dfs</span>(to[i]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 注意</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y+DLT), <span class="hljs-built_in">add</span>(y+DLT,x);        <span class="hljs-comment">// [1,DLT]是横坐标域，[DLT+1,2*DLT]的是纵坐标域</span>++deg[x], ++deg[y+DLT];&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*DLT) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,i), <span class="hljs-built_in">add</span>(i,<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,DLT) <span class="hljs-built_in">dfs</span>(i);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>[v[i]<span class="hljs-number">-1</span>]);        <span class="hljs-comment">// 只需要考虑前n个横坐标点的连边情况</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="拓扑排序">拓扑排序</h2><p>随便放点题。</p><h3 id="luogu3243-hnoi2015-菜肴制作">luogu3243 [HNOI2015] 菜肴制作</h3><p>在满足限制的情况下，字典序小的数尽可能靠前。</p><p>用小根堆去贪显然是错的。</p><p>考虑较大的数在合法的范围内尽可能靠后是优秀的，所以建反图，用大根堆贪心求出反图的拓扑序，它的逆序就是答案。</p><h3 id="cf-gym104053c-customs-controls-2">CF gym104053C Customs Controls2</h3><p>设 <span class="math inline">\(d(x)\)</span> 为 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 的最长路。那么对于 <spanclass="math inline">\(n\)</span> 和它的入点集合 <spanclass="math inline">\(\{y\}\)</span>，应该满足所有 <spanclass="math inline">\(d(y)\)</span>都相等。归纳得到对于任意节点的入点集合 <spanclass="math inline">\(\{y\}\)</span>，都有所有 <spanclass="math inline">\(d(y)\)</span> 相等。</p><p>用并查集把所有点的入点缩成一个点，再此基础上连边。如果出现环，那么说明存在某个点的点权要求是<spanclass="math inline">\(0\)</span>，从而无解。否则对这张图拓扑排序求出到每个节点的最长路。最后用<strong>一个点所在连通块的最长路</strong>减掉<strong>它的入点集合所在连通块</strong>的最长路就是这个点的点权。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, in[N], f[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N], q[N];vector&lt;PII &gt; e;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y;&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) p[i].<span class="hljs-built_in">clear</span>(), q[i].<span class="hljs-built_in">clear</span>(), in[i]=f[i]=<span class="hljs-number">0</span>;e.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();q[y].<span class="hljs-built_in">pb</span>(x);e.<span class="hljs-built_in">pb</span>(&#123;x,y&#125;);&#125;dsu.<span class="hljs-built_in">init</span>();<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:q[x]) &#123;dsu.<span class="hljs-built_in">merge</span>(y,q[x][<span class="hljs-number">0</span>]);            <span class="hljs-comment">// 这里是与第一个入点合并了</span>&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:e) &#123;<span class="hljs-type">int</span> x=t.fi, y=t.se;x=dsu.<span class="hljs-built_in">get</span>(x), y=dsu.<span class="hljs-built_in">get</span>(y);p[x].<span class="hljs-built_in">pb</span>(y), ++in[y];&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-type">int</span>&gt; qu;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(i==dsu.<span class="hljs-built_in">get</span>(i)) &#123;++cnt;<span class="hljs-keyword">if</span>(!in[i]) f[i]=<span class="hljs-number">1</span>, qu.<span class="hljs-built_in">push</span>(i);&#125;&#125;<span class="hljs-keyword">while</span>(qu.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=qu.<span class="hljs-built_in">front</span>(); qu.<span class="hljs-built_in">pop</span>();--cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) qu.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">if</span>(cnt) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> ans=f[dsu.<span class="hljs-built_in">get</span>(i)];<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) ans-=f[dsu.<span class="hljs-built_in">get</span>(q[i][<span class="hljs-number">0</span>])];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>欧拉路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#15 数论题目选讲</title>
    <link href="/2023/noip-record-15/"/>
    <url>/2023/noip-record-15/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="hankson的趣味题">Hankson的趣味题</h2><p>从质因子的角度考虑。</p><p>把 <span class="math inline">\(a,b,c,d\)</span>都分解了，对于一个质因子 <spanclass="math inline">\(p_i\)</span>，题目给出的条件等价于 <spanclass="math display">\[\min \Big( e_{p_i} (x) ,e_{p_i} (a)\Big) =e_{p_i}(c)\]</span></p><p><span class="math display">\[\max \Big( e_{p_i}(x),e_{p_i}(b) \Big) = e_{p_i}(d)\]</span></p><p>讨论一下就能得到 <span class="math inline">\(e_{p_i}(x)\)</span>的取值范围，或者报告无解。</p><h2 id="cf1114c-trailing-loves-or-loeufs">CF1114C Trailing Loves (orL'oeufs?)</h2><p>把 <span class="math inline">\(k\)</span> 分解为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，设 <spanclass="math inline">\(E_i\)</span> 为 <spanclass="math inline">\(p_i\)</span> 在 <spanclass="math inline">\(N\)</span> 中的幂次。</p><p>则 <span class="math inline">\(N\)</span> 在 <spanclass="math inline">\(k\)</span> 进制下后导 <spanclass="math inline">\(0\)</span> 的个数就是 <spanclass="math inline">\(\min\Big(\Big\lfloor \frac{E_i}{e_i}\Big\rfloor\Big)\)</span>。</p><p>对于每个 <span class="math inline">\(p_i\)</span>，<spanclass="math inline">\(n!\)</span> 中质因子 <spanclass="math inline">\(p_i\)</span> 的个数为 <spanclass="math display">\[\sum_{k=1 \wedge p_i^k \le n} \Big\lfloor \frac{n}{p_i^k} \Big\rfloor\]</span> 解释一下上式。</p><blockquote><p><span class="math inline">\(n!\)</span> 中包含质因子 <spanclass="math inline">\(p_i\)</span> 的指数，等价于 <spanclass="math inline">\([1,n]\)</span> 中每个数中 <spanclass="math inline">\(p_i\)</span> 的指数之和。</p><p>指数至少为 <span class="math inline">\(1\)</span> 的数有 <spanclass="math inline">\(\Big\lfloor \frac{n}{p_i} \Big\rfloor\)</span>个，这里只统计第一个。指数至少为 <span class="math inline">\(2\)</span>的有 <span class="math inline">\(\Big\lfloor \frac{n}{p_i^2}\Big\rfloor\)</span> 个，这里只统计第二个，以此类推。</p></blockquote><h2 id="luogu1445-樱花">luogu1445 樱花</h2><p><span class="math display">\[\begin{aligned}\frac{1}{x} + \frac{1}{y} &amp;= \frac{1}{n!}\\\frac{x+y}{xy} &amp;=\frac{1}{n!}\\xn! + yn! &amp;= xy\\xy - xn! -yn! + (n!)^2 &amp;=  (n!)^2\\(x-n!)(y-n!) &amp;= (n!)^2\end{aligned}\]</span></p><p><span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 一一对应。</p><p>用上面的办法求出 <span class="math inline">\((n!)^2\)</span>的质因子指数，再求 <spanclass="math inline">\(\sigma_0\Big((n!)^2\Big)\)</span> 即可。</p><p><span class="math inline">\(\texttt{Bonus:}\)</span> 求出所有 <spanclass="math inline">\((x+y)\)</span> 的和。</p><p>求出 <span class="math inline">\(\sigma_1\Big((n!)^2\Big)\)</span>即可。</p><h2 id="luogu1069-noip2009-普及组-细胞分裂">luogu1069 [NOIP2009 普及组]细胞分裂</h2><p>先把 <span class="math inline">\(m_1\)</span> 分解了，对于 <spanclass="math inline">\(m_1\)</span> 的一个质因数 <spanclass="math inline">\(p_j\)</span>，如果 <spanclass="math inline">\(s_i\)</span> 中不存在 <spanclass="math inline">\(p_j\)</span> 则无解。</p><p>否则，设 <span class="math inline">\(p_j\)</span> 在 <spanclass="math inline">\(s_i\)</span> 中的指数为 <spanclass="math inline">\(E_j\)</span>，则 <spanclass="math inline">\(x\)</span> 至少为 <spanclass="math inline">\(\Big\lceil \frac{e_j \times m_2}{E_j}\Big\rceil\)</span>。</p><p>取最大值即可。</p><h2 id="cf1325e-ehabs-real-number-theory-problem">CF1325E Ehab's REALNumber Theory Problem</h2><p>每个数的约数个数不超过 <spanclass="math inline">\(7\)</span>，也就是每个数最多有 <spanclass="math inline">\(2\)</span> 个质因数。</p><p>首先我们判一下完全平方数。然后我们就可以不考虑次数为偶数的质因子，所以所有数一共可以分成两类。</p><ol type="1"><li>单个质数 <span class="math inline">\(p\)</span>。</li><li>两个质数 <span class="math inline">\(p,q\)</span> 的乘积 <spanclass="math inline">\(pq\)</span>。</li></ol><p>用这些数的乘积得到完全平方数，那么每一种质数应该都出现偶数次。</p><p>考虑经典的图论建模问题。我们把出现过的质数当作点，能表示为 <spanclass="math inline">\(pq\)</span> 的点，看作 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(q\)</span>之间连一条无向边。另外还要额外建立一个点 <spanclass="math inline">\(1\)</span>，对于单个质数 <spanclass="math inline">\(p\)</span>，在 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(p\)</span> 之间连一条无向边。</p><p>这样，任何合法解都是图中的一个环。问题转化为求这张图的最小环。</p><p>由于边权都为 <span class="math inline">\(1\)</span>，我们直接使用<span class="math inline">\(\text{BFS}\)</span> 找环。</p><p><span class="math inline">\(\text{BFS}\)</span>树上的每一条返祖边都对应着一个环。枚举起点，如果这个点在环里，那么找到的第一条返祖边就是它所在的最小环，并且两个端点到它的距离再加<span class="math inline">\(1\)</span> 就是环长。</p><p>如果一个点不在环里，那么如果有环，以它为起点搜到的环一定比答案更大；否则以它为起点一定不能搜到环。所以这样做不会有问题。</p><p>然而复杂度约是 <span class="math inline">\(O\Big(n \frac{n}{\lnn}\Big)\)</span>，无法通过。</p><p>注意到每条边至少有一个点小于等于 <spanclass="math inline">\(\sqrt{\max\{a_i\}}\)</span>，只枚举这部分点作为起点即可。复杂度 <spanclass="math inline">\(O\Big(n \sqrt{\max \{a_i\}}\Big)\)</span>。</p><h2 id="cf582a-gcd-table">CF582A GCD Table</h2><p>一个重要的性质是 <span class="math inline">\(\gcd(a,b) \le\min(a,b)\)</span>。</p><p>表中最大的数、次大的数一定都是原序列中最大和次大的数，但是其他的就不一定了。</p><p>可以这样做。找到表中最大的数 <spanclass="math inline">\(k\)</span>，它一定是序列元素。然后删掉 <spanclass="math inline">\(k\)</span>，在序列中加入 <spanclass="math inline">\(k\)</span>，然后扫一遍序列中的其他元素 <spanclass="math inline">\(j\)</span>，在表中删掉两个 <spanclass="math inline">\(\gcd(k,j)\)</span>。</p><p>使用<code>std::set</code>可以做到 <span class="math inline">\(O(n^2\log_2 n^2)\)</span>。</p><h2 id="cf1344a-hilberts-hotel">CF1344A Hilbert's Hotel</h2><p>注意到原本位置距离为 <span class="math inline">\(tn, t \in\mathbb{Z}\)</span> 的点，在移动后仍然会距离 <spanclass="math inline">\(tn\)</span>，所以就可以只考虑 <spanclass="math inline">\([0,n-1]\)</span> 的点。</p><p>然后 check 每个 <span class="math inline">\((i+a_i) \bmod n\)</span>是否唯一即可。</p><p>注意要把 <span class="math inline">\(i+a_i\)</span> 可能小于 <spanclass="math inline">\(0\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, a[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> ((x+a[x])%n+n)%n;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) a[i]=<span class="hljs-built_in">read</span>(), ++p[<span class="hljs-built_in">r</span>(i)];<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(p[<span class="hljs-built_in">r</span>(i)]&gt;<span class="hljs-number">1</span>) &#123; fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(fg) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="cf1342c-yet-another-counting-problem">CF1342C Yet AnotherCounting Problem</h2><p>容易看出这个是有循环节的，周期为 <spanclass="math inline">\(\operatorname{lcm}(a,b)\)</span>。</p><p>然后 <span class="math inline">\(a,b\)</span>都很小，可以直接暴力处理每个周期内的信息，最后即可 <spanclass="math inline">\(O(1)\)</span> 回答询问。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> T, a, b, q, c, d;<span class="hljs-type">int</span> s[<span class="hljs-number">50000</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> t=x/c;<span class="hljs-keyword">return</span> t*s[c]+s[x-t*c];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x/__gcd(x,y)*y; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();c=<span class="hljs-built_in">lcm</span>(a,b);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,c) s[i]=s[i<span class="hljs-number">-1</span>]+(i%a%b!=i%b%a);<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,<span class="hljs-built_in">calc</span>(r)-<span class="hljs-built_in">calc</span>(l<span class="hljs-number">-1</span>));&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="luogu1477-noi2008-假面舞会">luogu1477 [NOI2008] 假面舞会</h2><p><ahref="https://yozora0908.github.io/2023/lg1477-solution">link</a></p><h2 id="cf980d-perfect-groups">CF980D Perfect Groups</h2><p>该上那个经典套路了。。</p><p>乘积为完全平方数具有传递性，因此可以轻易划分成若干唯一确定的不相交集合。</p><p>题目要求最小化分组的数量，那么就要保证每个集合都是极大的。</p><p>枚举起点，每考虑一个数都贪心把它加入它所对应的集合，没有就新开一个。</p><p>应该注意的是， <span class="math inline">\(0\)</span>可以放到任何一个集合中，我们钦定所有 <spanclass="math inline">\(0\)</span>都放到第一个集合里。所以，只有以下两种情况才需要新开集合。</p><ol type="1"><li>序列中没有元素。</li><li><span class="math inline">\(a_i \neq 0\)</span>，<spanclass="math inline">\(a_i\)</span>所在集合还没有元素并且当前序列中不是全 <spanclass="math inline">\(0\)</span>。</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, k, a[N], l[N], ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> t=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(x*y);<span class="hljs-keyword">return</span> x*y==t*t;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">per</span>(j,i<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">squ</span>(a[i],a[j])) &#123; l[i]=j; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>, zero=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,i,n) &#123;<span class="hljs-keyword">if</span>(i==j||(a[j]!=<span class="hljs-number">0</span>&amp;&amp;zero&amp;&amp;l[j]&lt;i)) ++k;++ans[k];zero|=a[j]!=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="cf354c-vasya-and-beautiful-arrays">CF354C Vasya and BeautifulArrays</h2><p>考虑直接枚举答案。容易发现一个答案 <spanclass="math inline">\(d\)</span> 是整个序列的公约数，当且仅当 <spanclass="math inline">\({\forall} i \in [1,n], a_i \bmod d \lek\)</span>。</p><p>然而貌似无法优化了。</p><p>注意到答案不会超过 <span class="math inline">\(mn = \min_{i=1}^n\{a_i\}\)</span>。</p><p>如果 <span class="math inline">\(mn \le k+1\)</span>，那么 <spanclass="math inline">\(a_i \bmod mn \le k\)</span>。</p><p>如果 <span class="math inline">\(mn&gt; k+1\)</span>，那么令答案为<span class="math inline">\(k+1\)</span>，显然都可以满足。因此答案区间为<span class="math inline">\([k+1,mn]\)</span>。</p><p>考虑如果一个 <span class="math inline">\(d\)</span> 能成为答案，每个<span class="math inline">\(a_i\)</span> 一定都能写成 <spanclass="math inline">\(tk+r\)</span>，其中 <span class="math inline">\(r\in[0,k]\)</span>。</p><p>注意到值域不大，可以开一个桶，在桶上做前缀和，然后枚举 <spanclass="math inline">\(t\)</span>，对每个区间求和，最后检查是否等于 <spanclass="math inline">\(n\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, lim=<span class="hljs-number">1e6</span>;<span class="hljs-type">int</span> n, k, mx, mn=<span class="hljs-number">1e9</span>, a[N], c[M];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();mx=<span class="hljs-built_in">max</span>(mx,a[i]);mn=<span class="hljs-built_in">min</span>(mn,a[i]);++c[a[i]];&#125;<span class="hljs-keyword">if</span>(mn&lt;=k+<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mn); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mx+k,lim);++i) c[i]+=c[i<span class="hljs-number">-1</span>];<span class="hljs-built_in">per</span>(d,mn,k+<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mx/d;++i) &#123;cnt+=c[<span class="hljs-built_in">min</span>(i*d+k,lim)]-c[i*d<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">if</span>(cnt==n) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="cf1114f-please-another-queries-on-array">CF1114F Please, anotherQueries on Array?</h2><p>不要忘了欧拉函数最原始的式子 <span class="math display">\[\varphi(n) = n \prod_{i=1}^m \frac{1-p_i}{p_i}\]</span> 这个式子的优点在于只和 <span class="math inline">\(n\)</span>以及它的质因子有关，并且是个积式。</p><p>也就是说，对于一个区间 <spanclass="math inline">\([l,r]\)</span>，我们只需要知道区间积以及区间出现过的质因子集合即可。</p><p>而值域小得令人发指，并且对于乘法操作，能增加的质因子也不超过 <spanclass="math inline">\(300\)</span>。也就是说可能出现的质因子只有 <spanclass="math inline">\(62\)</span>个，正好能用<code>long long</code>状压。</p><p>用线段树维护区间乘积和区间质因子集合即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, q, a[N];<span class="hljs-type">int</span> cnt, v[N];<span class="hljs-type">int</span> p[N], inv[N], rev[N];<span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>], s[N&lt;&lt;<span class="hljs-number">2</span>], stag[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">300</span>;++i) &#123;inv[i]=(mod-mod/i)*inv[mod%i]%mod;<span class="hljs-keyword">if</span>(!v[i]) &#123;p[cnt]=i, rev[cnt]=(i<span class="hljs-number">-1</span>)*inv[i]%mod, ++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=<span class="hljs-number">300</span>;j+=i) v[j]=<span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-type">char</span> ss[<span class="hljs-number">14</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]*t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]%mod;s[x]=s[x&lt;&lt;<span class="hljs-number">1</span>]|s[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> s0)</span> </span>&#123;(t[x]*=<span class="hljs-built_in">fp</span>(d,len))%=mod;(tag[x]*=d)%=mod;s[x]|=s0;stag[x]|=s0;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]&gt;<span class="hljs-number">1</span>||stag[x]) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,mid-l+<span class="hljs-number">1</span>,tag[x],stag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,r-mid,tag[x],stag[x]);tag[x]=<span class="hljs-number">1</span>, stag[x]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;tag[x]=t[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l==r)  &#123;t[x]=a[l];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>(a[l]%p[i]==<span class="hljs-number">0</span>) s[x]|=<span class="hljs-number">1ll</span>&lt;&lt;i;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> s0,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,r-l+<span class="hljs-number">1</span>,d,s0); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">upd</span>(L,R,d,s0,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">upd</span>(L,R,d,s0,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function">PII <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">MP</span>(t[x],s[x]);&#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;PII res; res.fi=<span class="hljs-number">1</span>, res.se=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) &#123;PII tmp=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);(res.fi*=tmp.fi)%=mod, res.se|=tmp.se;&#125;<span class="hljs-keyword">if</span>(R&gt;mid) &#123;PII tmp=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);(res.fi*=tmp.fi)%=mod, res.se|=tmp.se;&#125;<span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-built_in">build</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ss);<span class="hljs-keyword">if</span>(ss[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;M&#x27;</span>) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> s0=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>(x%p[i]==<span class="hljs-number">0</span>) s0|=<span class="hljs-number">1ll</span>&lt;&lt;i;<span class="hljs-built_in">upd</span>(l,r,x,s0);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();PII a=<span class="hljs-built_in">query</span>(l,r);<span class="hljs-type">int</span> ans=a.fi, S=a.se;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i) <span class="hljs-keyword">if</span>((S&gt;&gt;i)&amp;<span class="hljs-number">1</span>) (ans*=rev[i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="cf632b-array-gcd">CF632B Array GCD</h2><p>首先将「整个序列的 <span class="math inline">\(\gcd\)</span>大于一」，转化成「整个序列存在公共质因子」。</p><p>一个重要的观察：任何一组合法解，整个序列的 <spanclass="math inline">\(\gcd\)</span> 一定是 <spanclass="math inline">\(a_1\)</span> 或 <spanclass="math inline">\(a_n\)</span> 的某个质因子的倍数。</p><p>然后 <span class="math inline">\(\omega(a_i)\)</span> 的最大值大概是<span class="math inline">\(10\)</span>的样子，所以可以枚举每个质因子。</p><p>能发现唯一的影响就是删掉的那一段。</p><p>设 <span class="math inline">\(f(i,0/1/2)\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 个数，删掉的段在位置 <spanclass="math inline">\(i\)</span>还没开始、开始了没结束、结束了的最小代价。</p><p>直接做就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">2e18</span>;<span class="hljs-type">int</span> n, ans, A, B, a[N][<span class="hljs-number">3</span>];vector&lt;<span class="hljs-type">int</span>&gt; tmp, v;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;tmp.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) tmp.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">divide</span>(a[<span class="hljs-number">1</span>][i]), <span class="hljs-built_in">divide</span>(a[n][i]);<span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> p=<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>())-tmp.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;++i) v.<span class="hljs-built_in">pb</span>(tmp[i]);&#125;<span class="hljs-type">int</span> f[N][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(i==n+<span class="hljs-number">1</span>) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];f[i][<span class="hljs-number">2</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);f[i][<span class="hljs-number">1</span>]=inf;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(a[i][<span class="hljs-number">1</span>]%x==<span class="hljs-number">0</span>) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+A;f[i][<span class="hljs-number">2</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][<span class="hljs-number">0</span>]%x==<span class="hljs-number">0</span>||a[i][<span class="hljs-number">2</span>]%x==<span class="hljs-number">0</span>) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+B;f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+A;f[i][<span class="hljs-number">2</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])+B;&#125; <span class="hljs-keyword">else</span> &#123;f[i][<span class="hljs-number">0</span>]=inf;f[i][<span class="hljs-number">2</span>]=inf;f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])+A;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(f[n+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[n+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>(), B=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>();a[i][<span class="hljs-number">0</span>]=a[i][<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;a[i][<span class="hljs-number">2</span>]=a[i][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">prework</span>();ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:v) &#123;<span class="hljs-type">int</span> res=<span class="hljs-built_in">solve</span>(x);ans=<span class="hljs-built_in">min</span>(ans,res);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2id="求区间中与给定数互质的数的个数">求区间中与给定数互质的数的个数</h2><p>最后我们关注一个小问题。</p><blockquote><p>给定 <span class="math inline">\(n,L,R\)</span>，求 <spanclass="math inline">\([L,R]\)</span> 中与 <spanclass="math inline">\(n\)</span> 互质的数的个数。</p></blockquote><p>怎么做？</p><p>转化医学，求 <span class="math inline">\([L,R]\)</span>中有多少个数和 <span class="math inline">\(n\)</span>含有相同质因子，先差分成 <span class="math inline">\([1,L-1]\)</span> 和<span class="math inline">\([1,R]\)</span>。</p><p>设当前区间为 <span class="math inline">\([1,R]\)</span>。我们把 <spanclass="math inline">\(n\)</span>分解了，暴力搜索所有质因数的组合方式，设其为 <spanclass="math inline">\(m\)</span>，那么就有 <spanclass="math inline">\(\Big\lfloor \frac{R}{m} \Big\rfloor\)</span>个数含有这个质因子集合。根据熟悉的集合容斥，容易知道集合 <spanclass="math inline">\(S\)</span> 的容斥系数就是 <spanclass="math inline">\((-1)^{|S|}\)</span>。</p><p>设质因子个数为 <spanclass="math inline">\(\omega(n)\)</span>，那么复杂度就是 <spanclass="math inline">\(O(\sqrt{n} + 2^{\omega(n)})\)</span>。</p><p>通过提前筛质数能做到 <span class="math inline">\(O(\log_2 n +2^{\omega(n)})\)</span>，实际上第一项常数较小，第二项小于 <spanclass="math inline">\(O(n)\)</span>。</p><h3 id="cf1750d-count-gcd">CF1750D Count GCD</h3><p>有解一定要有 <span class="math inline">\(a_i \mida_{i-1}\)</span>。</p><p>考虑 <span class="math inline">\(\gcd_{j=1}^{i-1} \{b_j\} =a_{i-1}\)</span>，<span class="math inline">\(\gcd_{j=1}^{i} \{b_j\} =a_{i}\)</span>，也就是说 <span class="math inline">\(b_i\)</span> 不能有<span class="math inline">\(\frac{a_{i-1}}{a_i}\)</span>的任何质因子。</p><p>由于 <span class="math inline">\(a_i \mid b_i\)</span>，所以 <spanclass="math inline">\(\frac{b_i}{a_i} \in [1,\lfloor \frac{m}{a_i}\rfloor]\)</span>。</p><p>求区间中与 <span class="math inline">\(\frac{a_{i-1}}{a_i}\)</span>互质的数的个数即可。</p><p>单次求解的复杂度已经到了 <spanclass="math inline">\(O(2^{\omega(m)})\)</span> 了，而 <spanclass="math inline">\(\omega(m)\)</span> 的上界大概是 <spanclass="math inline">\(10\)</span>。</p><p>注意到那个很重要的条件 <span class="math inline">\(a_i \mida_{i-1}\)</span>，也就是这玩意是 <spanclass="math inline">\(\log\)</span> 级别递减的，所以直接暴力做就行。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// LUOGU_RID: 121128333</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> T, n, m, a[N];vector&lt;<span class="hljs-type">int</span>&gt; p;map&lt;PII,<span class="hljs-type">int</span>&gt; mp;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;p.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;p.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) p.<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> lim)</span> </span>&#123;<span class="hljs-keyword">if</span>(i==p.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> lim/k;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -lim/k;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,k,lim)+<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>,k*p[i],lim);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> lim,<span class="hljs-type">int</span> r)</span> </span>&#123;PII t=&#123;lim,r&#125;;<span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(t)) <span class="hljs-keyword">return</span> mp[t];<span class="hljs-built_in">divide</span>(r);<span class="hljs-keyword">return</span> mp[t]=lim-<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,lim);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;a[i<span class="hljs-number">-1</span>]%a[i]) fg=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(fg) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;(ans*=<span class="hljs-built_in">calc</span>(m/a[i],a[i<span class="hljs-number">-1</span>]/a[i]))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1477 假面舞会 题解</title>
    <link href="/2023/lg1477-solution/"/>
    <url>/2023/lg1477-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>考虑如果 <span class="math inline">\(a\)</span> 能看见 <spanclass="math inline">\(b\)</span>，那么从 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 连边。</p><p>先从简单的图上开始分析。</p><p>考虑在 DAG 上的情况，发现还是不太容易确定。</p><h3 id="part1">Part1</h3><p>不妨先只考虑有向链，这个很简单，最大就是链长（超过 <spanclass="math inline">\(3\)</span> 的话），最小是 <spanclass="math inline">\(3\)</span>。然而当我们把若干形态的链拼成一张 DAG时，则会出现一个点到达另一个点的路径不止一条，从而导致很诡异的事情，似乎不太容易找到最大值了。然后我们能发现要是不存在这种情况，也就是DAG 是个有向树，那么答案就是最长链。</p><p>可以发现，链这种结构不会使原本合法的 <spanclass="math inline">\(k\)</span> 变小。</p><p>观察这种情况，设较长链长度为 <spanclass="math inline">\(l_1\)</span>，较短链长度为 <spanclass="math inline">\(l_2\)</span>，那么能发现答案就是 <spanclass="math inline">\(l_1-l_2\)</span>，更确切地说，合法环长是 <spanclass="math inline">\(l_1-l_2\)</span>的约数。那么根据上一段的结论，最大值是所有 <spanclass="math inline">\(l_1-l_2\)</span> 的 <spanclass="math inline">\(\gcd\)</span>。</p><p>如何找到这样的情况，是我们亟待解决的第一个问题。</p><h3 id="part2">Part2</h3><p>然后加入对环的讨论。设一个简单环环长为 <spanclass="math inline">\(len\)</span>，那么 <spanclass="math inline">\(len\)</span> 必须是 <spanclass="math inline">\(k\)</span> 的倍数。不难想到 <spanclass="math inline">\(k\)</span> 最大能取所有环长的 <spanclass="math inline">\(\gcd\)</span>。同时对于链来说 <spanclass="math inline">\(k\)</span> 是啥都无所谓，因此此时最大值就是环长<span class="math inline">\(\gcd\)</span>，最小值取 <spanclass="math inline">\(\gcd\)</span> 大于 <spanclass="math inline">\(3\)</span>的约数即可。然而这还是简单环，如何解决有公共边的环，这是我们亟待解决的第二个问题。</p><h3 id="part3">Part3</h3><p>下面不加推导地给出解决两个问题的办法：对于关系 <spanclass="math inline">\((a,b)\)</span>，从 <spanclass="math inline">\(a\)</span> 向 <spanclass="math inline">\(b\)</span> 连权值为 <spanclass="math inline">\(1\)</span> 的边，从 <spanclass="math inline">\(b\)</span> 向 <spanclass="math inline">\(a\)</span> 连权值为 <spanclass="math inline">\(-1\)</span>​ 的边。直接钦定一个连通块中的节点为<spanclass="math inline">\(0\)</span>，然后顺着边权求出每个点的权值。</p><ul><li>每个连通块的最大权值减掉最小权值再加上 <spanclass="math inline">\(1\)</span> 就是最长链长度。</li><li>重复访问到一个节点时，将两个值做差得到环的权值，取 <spanclass="math inline">\(\gcd\)</span> 即可。</li></ul><h3 id="part4">Part4</h3><p>首要明确连完反边之后就成了无向图，图中的每一个环，都对应着上述结构中的一个，即到一个点的两条路径、有或无公共边的环。</p><p>对于第一个问题，在无向图上搜完一圈回来得到的就是 <spanclass="math inline">\(l_1-l_2\)</span>。</p><p>对于第二个问题，取公共部分的末端为起点，公共部分的始端为重点，这就是第一个问题的情况又复合上了一条链，而链是不会对种类数产生限制的。因此，第二个问题规约到了第一个问题上。</p><p>设较长环长度为 <span class="math inline">\(x\)</span>，较短环长度为<span class="math inline">\(y\)</span>，二者公共部分长度为 <spanclass="math inline">\(z\)</span>。那么这个东西所对应的最大值是 <spanclass="math inline">\((x-z)-(y-z) = x-y\)</span>。这个结构的贡献是 <spanclass="math inline">\(\gcd(x,y)\)</span>。</p><p>假设已经搜完了较长环，进入环的时机以及走的路径不同，会导致上述做法得到的较短环的权值也不同。但是塔可以保证这个权值只会是<span class="math inline">\(y\)</span> 或 <spanclass="math inline">\(x-y\)</span>，并且 <spanclass="math inline">\(\gcd(x,y) = \gcd(x,x-y)\)</span>，所以是对的。</p><p>具体证明设计大量分类讨论，此处不予展开。</p><p>比较抽象，可以对着图理解。</p><p><imgsrc="https://cdn-us.imgs.moe/2023/08/19/64e0aacc8995b.png" srcset="/img/loading.gif" lazyload /></p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, t, mx, mn, ans, dis[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-type">int</span> tot, h[N], to[M], w[M], nxt[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(v[x]) &#123;ans=<span class="hljs-built_in">gcd</span>(ans,<span class="hljs-built_in">abs</span>(dis[x]-k));<span class="hljs-keyword">return</span>;&#125;v[x]=<span class="hljs-number">1</span>, dis[x]=k;mx=<span class="hljs-built_in">max</span>(mx,k), mn=<span class="hljs-built_in">min</span>(mn,k);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x,k+z);        <span class="hljs-comment">// 判一下不要往回搜是因为二元环是一种很没用的东西</span>        <span class="hljs-comment">// 搜不搜反正都是和1取gcd</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>);<span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">-1</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;mx=<span class="hljs-number">-1e9</span>, mn=<span class="hljs-number">1e9</span>;<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);t+=mx-mn+<span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!ans) ans=t, ans2=<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> &#123;ans2=<span class="hljs-number">3</span>;<span class="hljs-keyword">while</span>(ans2&lt;ans&amp;&amp;ans%ans2) ++ans2;&#125;<span class="hljs-keyword">if</span>(ans&lt;<span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,ans,ans2);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#14 基础数论（1）</title>
    <link href="/2023/noip-record-14/"/>
    <url>/2023/noip-record-14/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>本文主要放知识点。</p><h2 id="质数筛">质数筛</h2><h3 id="埃氏筛模板">埃氏筛模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prime</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=n;j+=i) v[j]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 优化：从i*i开始枚举</span>&#125;&#125;</code></pre></div><h3 id="线性筛模板">线性筛模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-comment">// p[j]是i*p[j]的最小质因子</span><span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></div><h3 id="区间筛">区间筛</h3><blockquote><p>求 <span class="math inline">\([a,b]\)</span> 中的所有质数。</p><p><span class="math inline">\(a,b \le 10^{12}\)</span>，<spanclass="math inline">\(b-a \le 10^6\)</span>。</p></blockquote><p>由于每个合数 <span class="math inline">\(x\)</span> 存在至少一个<span class="math inline">\(\le \sqrt{x}\)</span> 的质因数，所以先筛出<span class="math inline">\([2,\sqrt{b}]\)</span>中的质数，用这些质数再筛掉 <span class="math inline">\([a,b]\)</span>中的合数。</p><h2 id="约数相关">约数相关</h2><h3 id="质因数分解">质因数分解</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;++i) <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;p[++cnt]=i;<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i, ++e[cnt];&#125;<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) p[++cnt]=n, e[n]=<span class="hljs-number">1</span>;&#125;</code></pre></div><p>时间复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>，常数比较小。</p><p>还有 <span class="math inline">\(O(\log_2 n)\)</span>的做法。先用筛法处理出每个数的最小质因子。分解 <spanclass="math inline">\(n\)</span> 时就可以 <spanclass="math inline">\(O(1)\)</span> 除掉一个质因子了 。</p><h3 id="求约数集合">求约数集合</h3><h4 id="试除法">试除法</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fac</span><span class="hljs-params">()</span> </span>&#123;vector&lt;<span class="hljs-type">int</span>&gt; factor;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;++i)  <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;factor.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">if</span>(i*i!=n) factor.<span class="hljs-built_in">push_back</span>(n/i);&#125;&#125;</code></pre></div><p>求单个数的约数集合，时间复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>。</p><h4 id="倍数法">倍数法</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fac</span><span class="hljs-params">()</span> </span>&#123;vector&lt;<span class="hljs-type">int</span>&gt; factor[N];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*j&lt;=n;++j) &#123;factor[i*j].<span class="hljs-built_in">push_back</span>(i);&#125;&#125;</code></pre></div><p>求 <span class="math inline">\([1,n]\)</span>中所有数的约数集合，时间复杂度 <span class="math inline">\(O(n \lnn)\)</span>。</p><p>从中得到推论：</p><blockquote><p><span class="math display">\[\sum_{i=1}^n \sigma_0 (i) \approx n \ln n\]</span></p></blockquote><h3 id="约数个数函数">约数个数函数</h3><p>设 <span class="math inline">\(n\)</span> 分解后为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，则 <spanclass="math display">\[\sigma_0(n) = \prod_{i=1}^m (e_i+1)\]</span></p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\le\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^2\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^3\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^4\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^5\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^6\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^7\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^8\)</span></th><th style="text-align: center;"><spanclass="math inline">\(10^9\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sigma_0(n)\le\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4\)</span></td><td style="text-align: center;"><spanclass="math inline">\(12\)</span></td><td style="text-align: center;"><spanclass="math inline">\(32\)</span></td><td style="text-align: center;"><spanclass="math inline">\(64\)</span></td><td style="text-align: center;"><spanclass="math inline">\(128\)</span></td><td style="text-align: center;"><spanclass="math inline">\(240\)</span></td><td style="text-align: center;"><spanclass="math inline">\(448\)</span></td><td style="text-align: center;"><spanclass="math inline">\(768\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1344\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(n\le\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{10}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{11}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{12}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{13}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{14}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{15}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{16}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{17}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10^{18}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sigma_0(n)\le\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2304\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4032\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6720\)</span></td><td style="text-align: center;"><spanclass="math inline">\(10752\)</span></td><td style="text-align: center;"><spanclass="math inline">\(17280\)</span></td><td style="text-align: center;"><spanclass="math inline">\(26880\)</span></td><td style="text-align: center;"><spanclass="math inline">\(41472\)</span></td><td style="text-align: center;"><spanclass="math inline">\(64512\)</span></td><td style="text-align: center;"><spanclass="math inline">\(103680\)</span></td></tr></tbody></table><p><imgsrc="http://cdnjson.com/images/2023/08/11/screenshot20230811.png" srcset="/img/loading.gif" lazyload /></p><h3 id="约数和函数">约数和函数</h3><p>设 <span class="math inline">\(n\)</span> 分解后为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，则 <spanclass="math display">\[\begin{aligned}\sigma_1(n) &amp;= \prod_{i=1}^m \sum_{j=0}^{e_i} p_i^j\\&amp;= \prod_{i=1}^m \frac{p_i^{e_i+1}-1}{p_i-1}\end{aligned}\]</span> 然而这个一般要在模意义下进行，<spanclass="math inline">\(p_i-1\)</span>在可能是模数的倍数，否则直接求即可。</p><p>可以用分治法求 <span class="math inline">\(\sum_{j=0}^{e_i}p_i^j\)</span>，设 <span class="math inline">\(sum(a,b) =\sum_{i=0}^ba_i\)</span>。</p><p>若 <span class="math inline">\(b\)</span> 为奇数，记 <spanclass="math inline">\(c=\lfloor\frac{b}{2}\rfloor\)</span> <spanclass="math display">\[\begin{aligned}sum(a,b) &amp;= \sum_{i=0}^{c} a^i + \sum_{i=c+1}^b a^i\\&amp;= \sum_{i=0}^c a_i + a^{c+1} \sum_{i=0}^c a^i\\&amp;= (1+a^{c+1}) \times sum(a,c)\end{aligned}\]</span> 若 <span class="math inline">\(b\)</span> 为偶数，记 <spanclass="math inline">\(c=\frac{b}{2}\)</span> <spanclass="math display">\[\begin{aligned}sum(a,b) &amp;= \sum_{i=0}^{c-1} a^i + \sum_{i=c}^b a^i\\&amp;= \sum_{i=0}^{c-1} a_i + a^{c} \sum_{i=0}^{c-1} a^i + a^b\\&amp;= (1+a^{c}) \times sum(a,c-1) + a^b\end{aligned}\]</span> 这样每次分治后，问题规模都会缩小一半，加上快速幂，复杂度 <spanclass="math inline">\(O(\log b)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>+<span class="hljs-built_in">fp</span>(a,b/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))*<span class="hljs-built_in">sum</span>(a,b/<span class="hljs-number">2</span>)%mod;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> ((<span class="hljs-number">1</span>+<span class="hljs-built_in">fp</span>(a,b/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))*<span class="hljs-built_in">sum</span>(a,b/<span class="hljs-number">2</span><span class="hljs-number">-1</span>)%mod+<span class="hljs-built_in">fp</span>(a,b/<span class="hljs-number">2</span>))%mod;&#125;</code></pre></div><h2 id="gcd与lcm">GCD与LCM</h2><h3 id="定义与基本性质">定义与基本性质</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x/<span class="hljs-built_in">gcd</span>(x,y)*y; &#125;</code></pre></div><p><span class="math display">\[\operatorname{lcm}(x,y) = \frac{xy}{\gcd(x,y)}\]</span></p><p>设长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，所有 <spanclass="math inline">\(a_i\)</span> 分解后的质因数总共有 <spanclass="math inline">\(m\)</span> 个，记为序列 <spanclass="math inline">\(p\)</span>。设 <spanclass="math inline">\(e_{i,j}\)</span> 为 <spanclass="math inline">\(a_j\)</span> 分解后 <spanclass="math inline">\(p_i\)</span> 的指数。</p><p>记 <span class="math display">\[\alpha_i = \min_{j=1}^n \Big\langle e_{i,j} \Big\rangle\]</span></p><p><span class="math display">\[\beta_i = \max_{j=1}^n \Big\langle e_{i,j} \Big\rangle\]</span></p><p>则 <span class="math display">\[\gcd_{i=1}^n (a_i) = \prod_{i=1}^m p_i ^{\alpha_i}\]</span></p><p><span class="math display">\[\operatorname{lcm}_{i=1}^n (a_i) = \prod_{i=1}^m p_i^{\beta_i}\]</span></p><p><span class="math inline">\(\gcd\)</span> 与 <spanclass="math inline">\(\operatorname{lcm}\)</span>满足结合律，可以用区间数据结构维护。</p><h3 id="关于环">关于环</h3><p>还是结合题目吧。</p><h4 id="luogu6187-noi-online-1-提高组-最小环">luogu6187 [NOI Online #1提高组] 最小环</h4><p>考虑这样一个东西，<span class="math inline">\(x\)</span> 在一个下标为<span class="math inline">\([0,n-1]\)</span> 的序列上跳，起点是 <spanclass="math inline">\(0\)</span>，每次从 <spanclass="math inline">\(i\)</span> 跳到 <span class="math inline">\((i+L)\bmod n\)</span>，轨迹是个什么？</p><p>显然一定成环。</p><p>假设跳了 <span class="math inline">\(k\)</span> 次使得 <spanclass="math inline">\(x\)</span> 回到 <spanclass="math inline">\(0\)</span>，那么一定有 <spanclass="math inline">\(kL \bmod n =0\)</span>。</p><p><span class="math inline">\(kL\)</span> 最小是 <spanclass="math inline">\(\operatorname{lcm}(n,L)\)</span>，那么此时 <spanclass="math inline">\(k = \frac{\operatorname{lcm}(n,L)}{L} =\frac{n}{\gcd(n,L)}\)</span>。</p><p>也就是说此时环上节点有 <spanclass="math inline">\(\frac{n}{\gcd(n,L)}\)</span> 个。</p><ul><li><p>从不同的 <span class="math inline">\(n\)</span>个点开始跳，总共形成 <span class="math inline">\(n / k =\gcd(n,L)\)</span> 个不同的环。</p></li><li><p>从 <span class="math inline">\(0\)</span>开始跳，求经过的节点集。问题等价于 <span class="math inline">\(kL \bmodn\)</span> 有几个不同的值。可以转化为 <span class="math inline">\(kL +pn = A\)</span>，对哪些 <span class="math inline">\(A\)</span>有解，其中 <span class="math inline">\(A \in[0,n-1]\)</span>。答案是当且仅当 <span class="math inline">\(\gcd(n,L)\mid A\)</span>，因为只要有解，我们总能把 <spanclass="math inline">\(k\)</span> 调整成为一个正数。</p></li></ul><p>回到本题上。</p><p>我们知道环长为 <spanclass="math inline">\(\frac{n}{\gcd(n,k)}\)</span>，只管上来看，把最大的贪心塞进一个环里贡献最大。</p><p>设一个环内第 <span class="math inline">\(i\)</span> 大的数为 <spanclass="math inline">\(p_i\)</span>，那么最优排列方式是 <spanclass="math inline">\(p_1,p_3,p_5,\ldots\)</span> 与 <spanclass="math inline">\(p_2,p_4 ,\ldots\)</span>各形成两个半环，再将对应端点连接。</p><blockquote><p><span class="math inline">\(\text{Proof by Elegia}\)</span></p><p>我们考虑把乘积看成面积，那么第 <span class="math inline">\(i\)</span>个点就在 <span class="math inline">\((a_i,a_i)\)</span>上，我们要最小化所有走路扫过的以端点形成的正方形面积之和。容易分析得到通过直线<span class="math inline">\(x=a_i\)</span> 和 <spanclass="math inline">\(y=a_j\)</span>切出来的每一个小矩形被经过的次数都达到了下界。</p></blockquote><p>这样单次还是 <span class="math inline">\(O(n)\)</span>的。考虑到不同的环长只有 <spanclass="math inline">\(\sigma_0(n)\)</span> 种，因此记忆化即可。</p><p>复杂度 <span class="math inline">\(O\Big(n\sigma_0(n)\Big)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P6187 [NOI Online #1 提高组] 最小环</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P6187</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans0, a[N], rec[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), ans0+=a[i]*a[i];<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!k) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans0);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> len=n/__gcd(n,k);<span class="hljs-keyword">if</span>(rec[len]) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,rec[len]); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=len) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j+<span class="hljs-number">2</span>&lt;=i+len<span class="hljs-number">-1</span>;j+=<span class="hljs-number">2</span>) ans+=a[j]*a[j+<span class="hljs-number">2</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j+<span class="hljs-number">2</span>&lt;=i+len<span class="hljs-number">-1</span>;j+=<span class="hljs-number">2</span>) ans+=a[j]*a[j+<span class="hljs-number">2</span>];ans+=a[i]*a[i+<span class="hljs-number">1</span>]+a[i+len<span class="hljs-number">-1</span>]*a[i+len<span class="hljs-number">-2</span>];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,rec[len]=ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><h3 id="bézout定理">Bézout定理</h3><p>对于任意不全为 <span class="math inline">\(0\)</span> 的整数 <spanclass="math inline">\(a,b\)</span>，存在无穷多对整数 <spanclass="math inline">\(x,y\)</span>，满足 <span class="math inline">\(ax+ by = \gcd(a,b)\)</span>。</p><p>换言之，<span class="math inline">\(a,b\)</span>的整系数线性组合得到的是所有 <spanclass="math inline">\(\gcd(a,b)\)</span> 的倍数。</p><h3 id="模板">模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);y-=a/b*x;<span class="hljs-keyword">return</span> d;&#125;</code></pre></div><h3 id="求解不定方程与同余方程">求解不定方程与同余方程</h3><p>对于不定方程 <span class="math inline">\(ax+by =c\)</span>，其有整数解的充要条件是 <span class="math inline">\(\gcd(a,b)\mid c\)</span>。</p><p>先用扩展欧几里得算法求出 <spanclass="math inline">\(ax+by=\gcd(a,b)\)</span> 的一组特解 <spanclass="math inline">\((x_0,y_0)\)</span> 和 <spanclass="math inline">\(d = \gcd(a,b)\)</span>。</p><p><span class="math inline">\(ax+by=c\)</span> 的通解可以表示为 <spanclass="math display">\[\large \begin{cases}x= \frac{c}{d} x_0 + k \frac{b}{d}\\y=\frac{c}{d}y_0 - k \frac{a}{d}\end{cases}\]</span> 其中 <span class="math inline">\(k \in\mathbb{Z}\)</span>。</p><p>那么对于线性同余方程 <span class="math display">\[ax \equiv b \pmod{p}\]</span> 可以转化为 <span class="math display">\[ax + py = b\]</span> 这里钦定 <span class="math inline">\(b =\gcd(a,p)\)</span>。</p><p>用上述做法求出特解 <span class="math inline">\(x_0\)</span>之后，所有与 <span class="math inline">\(x_0\)</span> 在模 <spanclass="math inline">\(\frac{p}{\gcd(a,p)}\)</span>意义下同余的数构成的集合，就是这个方程的解集。</p><p>通过这一点可以得到最小正整数解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-type">int</span> x, y;    <span class="hljs-comment">// b=gcd(a,b)</span>    <span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(a,p,x,y);    p/=d;    x=(x%p+p)%p;&#125;</code></pre></div><h2 id="同余相关">同余相关</h2><p><span class="math display">\[a \bmod b = a - \lfloor \frac{a}{b} \rfloor \times b\]</span></p><p> </p><p><span class="math display">\[a \times (b \bmod c) = ab \bmod ac\]</span></p><p><span class="math display">\[x \equiv y \pmod{p} \Longrightarrow xz \equiv yz \pmod{p}\]</span></p><p>  <span class="math display">\[x \equiv y \pmod{p} \iff p \mid (x-y)\]</span></p><p>  <span class="math display">\[ax \equiv ay \pmod{p}\]</span></p><p>令 <span class="math inline">\(d=\gcd(a,p)\)</span>，则 <spanclass="math display">\[x \equiv y \pmod{\frac{p}{d}}\]</span></p><h3 id="费马小定理">费马小定理</h3><p>若 <span class="math inline">\(p\)</span> 为质数，则对于任意整数<span class="math inline">\(a\)</span>，都有 <spanclass="math display">\[a^p \equiv a \pmod{p}\]</span></p><p>或者说，若 <span class="math inline">\(p\)</span> 为质数，<spanclass="math inline">\(a,p\)</span> 互质，那么 <spanclass="math display">\[a^{p-1} \equiv 1 \pmod{p}\]</span></p><h3 id="威尔逊定理">威尔逊定理</h3><p>若 <span class="math inline">\(p\)</span> 为质数，那么 <spanclass="math display">\[(p-1)! \equiv -1 \pmod{p}\]</span></p><h3 id="乘法逆元">乘法逆元</h3><p>对于 <span class="math inline">\(x \in [0,p)\)</span>，如果 <spanclass="math inline">\(x\)</span> 在模 <spanclass="math inline">\(p\)</span>意义下的逆元存在，那么这个逆元唯一。</p><h4 id="费马小定理-1">费马小定理</h4><p>如果 <span class="math inline">\(p\)</span> 是质数，<spanclass="math inline">\(a\)</span> 不是 <spanclass="math inline">\(p\)</span> 的倍数，则 <spanclass="math display">\[a^{p-1} \equiv 1 \pmod{p}\]</span> 从而 <span class="math display">\[a \times a^{p-2} \equiv 1 \pmod{p}\]</span> <span class="math inline">\(a^{p-2}\)</span> 就是 <spanclass="math inline">\(a\)</span> 在模 <spanclass="math inline">\(p\)</span> 意义下的逆元。</p><p>复杂度 <span class="math inline">\(O(\log_2 p)\)</span>。</p><h4 id="扩展欧几里得算法-1">扩展欧几里得算法</h4><p><span class="math display">\[ax \equiv 1 \pmod{p}\]</span></p><p>等价于 <span class="math display">\[{\exists} y, ax + py = 1\]</span> 这个不定方程有解的充要条件是 <spanclass="math inline">\(\gcd(a,p)=1\)</span>，也就是 <spanclass="math inline">\(a \bot p\)</span>。</p><p>求出的 <span class="math inline">\(x_0\)</span> 就是 <spanclass="math inline">\(a\)</span> 在模 <spanclass="math inline">\(p\)</span> 意义下的逆元。</p><p>复杂度 <span class="math inline">\(O(\log_2 p)\)</span>。</p><h4 id="递推逆元">递推逆元</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getinv</span><span class="hljs-params">()</span> </span>&#123;    inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) inv[i]=(p-p/i)*inv[p%i]%p;&#125;</code></pre></div><p>复杂度 <span class="math inline">\(O(n)\)</span>。</p><h4 id="求阶乘逆元">求阶乘逆元</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getinv</span><span class="hljs-params">()</span> </span>&#123;    inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    inv[n]=<span class="hljs-built_in">fp</span>(fac[n],p<span class="hljs-number">-2</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%p;&#125;</code></pre></div><p>复杂度 <span class="math inline">\(O(n+\log_2 p)\)</span></p><h2 id="整除分块">整除分块</h2><p><span class="math display">\[\sum_{i=1}^n \Big \lfloor \frac{n}{i} \Big\rfloor\]</span></p><p>只有 <span class="math inline">\(O(\sqrt{n})\)</span>种不同的值，且每一种值对应的 <span class="math inline">\(i\)</span>连续。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;l&lt;=n;l=r+<span class="hljs-number">1</span>) &#123;        r=n/(n/l);        <span class="hljs-comment">// 值为n/l的区间是[l,r]</span>    &#125;&#125;</code></pre></div><h2 id="欧拉函数">欧拉函数</h2><h3 id="定义">定义</h3><p><span class="math inline">\(\varphi(n)\)</span> 表示 <spanclass="math inline">\([1,n]\)</span> 中与 <spanclass="math inline">\(n\)</span> 互质的数的个数。</p><p>设 <span class="math inline">\(n\)</span> 分解后为 <spanclass="math inline">\(\prod_{i=1}^m p_i^{e_i}\)</span>，则 <spanclass="math display">\[\varphi(n) = n \prod_{i=1}^m (1-\frac{1}{p_i})\]</span> 所以可以在分解质因数的过程中计算欧拉函数，复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getphi</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span> </span>&#123;<span class="hljs-type">int</span> phi=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;++i) <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;phi=phi/i*(i<span class="hljs-number">-1</span>);<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i;&#125;<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) phi=phi/n*(n<span class="hljs-number">-1</span>);&#125;</code></pre></div><p>可以用线性筛在 <span class="math inline">\(O(n)\)</span> 的时间里求出<span class="math inline">\([1,n]\)</span> 所有数的欧拉函数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getphi</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) v[i]=<span class="hljs-number">1</span>, p[++cnt]=i, phi[i]=i<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-comment">// p[j]是i*p[j]的最小质因子</span><span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) &#123;                phi[i*p[j]]=phi[i]*p[j];                <span class="hljs-keyword">break</span>;            &#125;            phi[i*p[j]]=phi[i]*phi[p[j]];&#125;&#125;&#125;</code></pre></div><h3 id="性质">性质</h3><p>积性函数。 <span class="math display">\[a \bot b \Longrightarrow \varphi(ab) = \varphi(a)\varphi(b)\]</span></p><p><span class="math display">\[\sum_{d \mid n} \varphi(d) = n\]</span></p><p><span class="math display">\[\sum_{i=1}^n [\gcd(i,n)=1]i = \frac{n \times \varphi(n)}{2}\]</span></p><p>另外线性筛求欧拉函数的过程中用了两个性质。</p><ol type="1"><li>若 <span class="math inline">\(p\)</span> 为质数，<spanclass="math inline">\(p \mid n\)</span>，<span class="math inline">\(p^2\nmid n\)</span>，那么 <spanclass="math inline">\(\varphi(n)=\varphi(n/p) \times\varphi(p)\)</span>。</li><li>若 <span class="math inline">\(p\)</span> 为质数，<spanclass="math inline">\(p \mid n\)</span>，<span class="math inline">\(p^2\nmid n\)</span>，那么 <span class="math inline">\(\varphi(n)=\varphi(n/p) \times p\)</span>。</li></ol><h3 id="欧拉定理">欧拉定理</h3><p>若 <span class="math inline">\(a \bot n\)</span>，则 <spanclass="math display">\[a^{\varphi(n)} \equiv 1 \pmod{n}\]</span></p><p>另外有结论，若 <span class="math inline">\(a \botn\)</span>，那么满足 <span class="math display">\[a^x \equiv 1 \pmod{n}\]</span> 最小的 <span class="math inline">\(x\)</span> 一定是 <spanclass="math inline">\(\varphi(n)\)</span> 的约数。</p><h3 id="扩展欧拉定理">扩展欧拉定理</h3><p>懒得打公式了。</p><p><imgsrc="http://cdnjson.com/images/2023/08/11/2018061415403415.png" srcset="/img/loading.gif" lazyload /></p><h2 id="进制转换">进制转换</h2><p>将 <span class="math inline">\(n\)</span> 位 <spanclass="math inline">\(a\)</span> 进制数转化为 <spanclass="math inline">\(m\)</span> 位 <spanclass="math inline">\(b\)</span> 进制数的做法如下。</p><p>如果这个十进制数存的下的话，</p><ul><li>将给定的 <span class="math inline">\(a\)</span>进制数从高位到低位扫一边，每次将当前结果乘 <spanclass="math inline">\(a\)</span> 再加上当前位的系数，这样就能转化成<span class="math inline">\(10\)</span> 进制。</li><li>从 <span class="math inline">\(10\)</span> 进制转化为 <spanclass="math inline">\(b\)</span>进制。先模再除，取最低位放进去，重复这个过程。</li></ul><p>复杂度是 <span class="math inline">\(O(n)\)</span> 的。</p><h2 id="excrt">exCRT</h2><p>CRT 完全可以被 exCRT 代替。</p><p><ahref="https://yozora0908.github.io/2022/notes-number-theory-1">link</a></p><h2 id="线性筛求常见积性函数">线性筛求常见积性函数</h2><h3 id="莫比乌斯函数">莫比乌斯函数</h3><p><imgsrc="https://cdn-us.imgs.moe/2023/08/11/64d5f860198f1.png" srcset="/img/loading.gif" lazyload /></p><h3 id="欧拉函数-1">欧拉函数</h3><p><imgsrc="https://cdn-us.imgs.moe/2023/08/11/64d5f8605cbef.png" srcset="/img/loading.gif" lazyload /></p><h3 id="约数个数函数-1">约数个数函数</h3><p><imgsrc="https://cdn-us.imgs.moe/2023/08/11/64d5f860541b2.png" srcset="/img/loading.gif" lazyload /></p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3940 分组 题解</title>
    <link href="/2023/lg3940-solution/"/>
    <url>/2023/lg3940-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>对于 <span class="math inline">\(K=1\)</span>的情况，每组里面都不能有冲突，所以从后往前尽可能划分，容易证明这样做是对的。</p><p>如何判断冲突？注意到值域不大，可以开一个桶，枚举一个完全平方数 <spanclass="math inline">\(k^2\)</span>，判断 <spanclass="math inline">\(k^2-x\)</span> 是否出现过即可。完全平方数的个数是<span class="math inline">\(O(\sqrt{n})\)</span> 的，所以复杂度为 <spanclass="math inline">\(O(n \sqrt{n})\)</span>。</p><p>对于 <span class="math inline">\(K=2\)</span>的情况，如果我们把有冲突的点连边，那么每一组的点都构成一张二分图。</p><p>可以像经典题「关押罪犯」中一样，用拆点并查集维护。</p><p>记 <span class="math inline">\(v(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 是否出现过，<spanclass="math inline">\(v_2(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 是否出现了超过 <spanclass="math inline">\(1\)</span> 次并且 <spanclass="math inline">\(2x\)</span> 是完全平方数。</p><p>如果 <span class="math inline">\(x\)</span> 没有出现过，<spanclass="math inline">\(v(k^2-x)=1\)</span>，分两种情况。</p><ol type="1"><li>如果 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(k^2-x\)</span>被合并进了同一个集合，并查集产生冲突，那么 <spanclass="math inline">\(x\)</span> 不能加入当前组。</li><li><span class="math inline">\(v_2(k^2-x)=1\)</span>，那么 <spanclass="math inline">\(x\)</span> 不能加入当前组。</li></ol><p>如果 <span class="math inline">\(x\)</span> 出现过，分两种情况。</p><ol type="1"><li>如果 <span class="math inline">\(2x\)</span> 不是完全平方数，由于<span class="math inline">\(x\)</span>与组内其他点能构成二分图，所以加入 <spanclass="math inline">\(x\)</span> 依然能。</li><li>如果 <span class="math inline">\(2x\)</span> 是完全平方数。令 <spanclass="math inline">\(v_2(x)=1\)</span>。枚举 <spanclass="math inline">\(k^2\)</span>，如果 <spanclass="math inline">\(v(k^2-x)=1\)</span> 并且 <spanclass="math inline">\(k^2\neq2x\)</span>，那么说明会产生冲突，<spanclass="math inline">\(x\)</span> 不能加入。注意如果一开始 <spanclass="math inline">\(v_2(x)\)</span> 的值就已经是 <spanclass="math inline">\(1\)</span>，就直接判掉。</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3940 分组</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3940</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">131075</span>, lim=<span class="hljs-number">131072</span>;<span class="hljs-type">int</span> n, m, K, a[N], ans[N], sqr[<span class="hljs-number">2</span>*N];<span class="hljs-type">bool</span> v[N], v2[N];<span class="hljs-keyword">namespace</span> sub1 &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=n;i;) &#123;<span class="hljs-keyword">for</span>(;j;--j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*k-a[j]&lt;N;++k) <span class="hljs-keyword">if</span>(a[j]&lt;=k*k) &#123;<span class="hljs-keyword">if</span>(v[k*k-a[j]]) <span class="hljs-keyword">goto</span> out;&#125;v[a[j]]=<span class="hljs-number">1</span>;&#125;out:;<span class="hljs-keyword">if</span>(!j) <span class="hljs-keyword">break</span>;ans[++m]=j;<span class="hljs-keyword">for</span>(;i&gt;j;--i) v[a[i]]=<span class="hljs-number">0</span>;&#125;&#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> f[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*lim;++i) f[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) f[x]=y;&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> x1=dsu.<span class="hljs-built_in">get</span>(x), x2=dsu.<span class="hljs-built_in">get</span>(x+lim);<span class="hljs-type">int</span> y1=dsu.<span class="hljs-built_in">get</span>(y), y2=dsu.<span class="hljs-built_in">get</span>(y+lim);<span class="hljs-keyword">if</span>(x1==y1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x2==y2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;dsu.<span class="hljs-built_in">merge</span>(x1,y2);dsu.<span class="hljs-built_in">merge</span>(x2,y1);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">namespace</span> sub2 &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;dsu.<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,j=n;i;) &#123;<span class="hljs-keyword">for</span>(;j;--j) &#123;<span class="hljs-keyword">if</span>(!v[a[j]]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*k-a[j]&lt;N;++k) <span class="hljs-keyword">if</span>(a[j]&lt;=k*k) &#123;<span class="hljs-keyword">if</span>(v[k*k-a[j]]) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(a[j],k*k-a[j])||v2[k*k-a[j]]) <span class="hljs-keyword">goto</span> out;&#125;&#125;v[a[j]]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(sqr[<span class="hljs-number">2</span>*a[j]]) &#123;<span class="hljs-keyword">if</span>(v2[a[j]]) <span class="hljs-keyword">goto</span> out;v2[a[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*k-a[j]&lt;N;++k) <span class="hljs-keyword">if</span>(a[j]&lt;=k*k) &#123;<span class="hljs-keyword">if</span>(v[k*k-a[j]]&amp;&amp;k*k!=<span class="hljs-number">2</span>*a[j])  <span class="hljs-keyword">goto</span> out;&#125;&#125;&#125;&#125;out:;<span class="hljs-keyword">if</span>(!j) <span class="hljs-keyword">break</span>;ans[++m]=j;<span class="hljs-keyword">for</span>(;i&gt;j;--i) v[a[i]]=v2[a[i]]=<span class="hljs-number">0</span>, dsu.f[a[i]]=a[i], dsu.f[a[i]+lim]=a[i]+lim;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">512</span>;++i) sqr[i*i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(K==<span class="hljs-number">1</span>) sub1::<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">else</span> sub2::<span class="hljs-built_in">solve</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,m+<span class="hljs-number">1</span>);<span class="hljs-built_in">per</span>(i,m,<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>并查集</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#13 树形DP（2）</title>
    <link href="/2023/noip-record-13/"/>
    <url>/2023/noip-record-13/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="arc101e-ribbons-on-tree">[ARC101E] Ribbons on Tree</h3><p>对于以 <span class="math inline">\(x\)</span> 为根的子树，如果 <spanclass="math inline">\((x,fa_x)\)</span>的边没有被覆盖，那么说明子树内没有任何一个点与子树外的点匹配。</p><p>把这些没有被覆盖的边看作特殊边，那么整棵树就被若干特殊边划分成了若干连通块。我们要求的是不含任何特殊边的匹配方案。</p><p>考虑容斥。钦定一个边集 <span class="math inline">\(S\)</span>，表示<span class="math inline">\(S\)</span>内的边一定是特殊边。根据<strong>子集反演</strong>，容斥系数为 <spanclass="math inline">\((-1)^{|S|}\)</span>。</p><p>用树形背包维护连通块，设 <spanclass="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，其中特殊边集大小为 <spanclass="math inline">\(j\)</span> 的方案数，容斥系数就是 <spanclass="math inline">\((-1)^j\)</span>。转移就是讨论 <spanclass="math inline">\((x,y)\)</span>这条边要不要加入特殊边集。如果加入，那么以 <spanclass="math inline">\(y\)</span>为根的连通块闭合，在这里可以计算任意两两匹配的方案数。</p><p>然而这样复杂度过高，瓶颈在于 <span class="math inline">\(j\)</span>这一维。一种解决方案只记录 <span class="math inline">\(j\)</span>的奇偶性，不过更好的做法则是把这个容斥系数放进 DP 值里面。具体地，对<span class="math inline">\(j\)</span> 这一维做前缀和，设 <spanclass="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>的方案数。每有一个连通块闭合，就有一条边没有被覆盖，要多乘一个 <spanclass="math inline">\(-1\)</span>，对应到实现就是这部分的方案做减法。</p><p><span class="math inline">\(2n\)</span> 个点两两匹配的方案是 <spanclass="math display">\[\frac{\binom{2n}{n}n!}{2^n}\]</span></p><p>或者说 <span class="math display">\[h_{2n} = h_{2n-2} \times (2n-1)\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, f[N][N], g[N], sz[N], h[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) &#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[y];++j) &#123;(g[i+j]+=f[x][i]*f[y][j]%mod)%=mod;(g[i]-=f[x][i]*f[y][j]%mod*h[j]%mod-mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;h[<span class="hljs-number">2</span>]=h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) h[i]=h[i<span class="hljs-number">-2</span>]*(i<span class="hljs-number">-1</span>)%mod;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) (ans+=f[<span class="hljs-number">1</span>][i]*h[i]%mod)%=mod;    <span class="hljs-comment">// 闭合最后一个连通块</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf-gym104160-e.-graph-completing">CF Gym104160 E. GraphCompleting</h3><p>最终的图是一张边双连通图，也就是不存在割边。</p><p>先把边双缩了，内部点随便连。</p><p>剩下的每一条树边都是割边。考虑容斥，设 <spanclass="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，子树中有 <spanclass="math inline">\(j\)</span> 条割边的方案。</p><p>与上一题相同，转移还是讨论边 <spanclass="math inline">\((x,y)\)</span>的情况。不同的是在连通块闭合时不太容易计算方案数，所以要在 <spanclass="math inline">\((x,y)\)</span> 加入以 <spanclass="math inline">\(x\)</span> 所在连通块时统计。具体地，选取 <spanclass="math inline">\((x,y)\)</span> 为基准点，设 <spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(j\)</span>，<span class="math inline">\(y\)</span>所在连通块大小为 <span class="math inline">\(k\)</span>，那么总共有<span class="math inline">\(j \times k -1\)</span> 条可以连的边能覆盖<span class="math inline">\((x,y)\)</span>，方案数 <spanclass="math inline">\(2^{\max(j \times k-1,0)}\)</span>。注意除了钦定的边集之外，并不需要保证连通块也是边双。</p><p>然后就是把容斥系数塞进 DP 值去。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: E. Graph Completing</span><span class="hljs-comment">// Contest: Codeforces - The 2022 ICPC Asia Shenyang Regional Contest (The 1st Universal Cup, Stage 1: Shenyang)</span><span class="hljs-comment">// URL: https://codeforc.es/gym/104160/problem/E</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-27 07:14:30</span><span class="hljs-comment">// Memory Limit: 512 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, M=<span class="hljs-number">2e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, num, dfn[N], low[N], sz[N], pw[N*N&gt;&gt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> f[N][N], g[N];<span class="hljs-type">int</span> tp, st[N];<span class="hljs-type">int</span> dcc, bel[N], ecnt[N];<span class="hljs-type">bool</span> v[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">G</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[M], nxt[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;&#125; G, T;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> lst)</span> </span>&#123;dfn[x]=low[x]=++num, st[++tp]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i];<span class="hljs-keyword">if</span>(i!=(lst^<span class="hljs-number">1</span>)) &#123;<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y,i);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>; ++dcc;<span class="hljs-keyword">do</span> y=st[tp--], ++sz[dcc], bel[y]=dcc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">suodian</span><span class="hljs-params">()</span> </span>&#123;T.tot=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=G.tot;++i) &#123;<span class="hljs-type">int</span> x=G.to[i^<span class="hljs-number">1</span>], y=G.to[i];<span class="hljs-keyword">if</span>(bel[x]==bel[y]) ++ecnt[bel[x]];<span class="hljs-keyword">if</span>(bel[x]==bel[y]||v[bel[x]][bel[y]]) <span class="hljs-keyword">continue</span>;v[bel[x]][bel[y]]=v[bel[y]][bel[x]]=<span class="hljs-number">1</span>;T.<span class="hljs-built_in">add</span>(bel[x],bel[y]), T.<span class="hljs-built_in">add</span>(bel[y],bel[x]);&#125;pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;++i) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][sz[x]]=pw[sz[x]*(sz[x]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-(ecnt[x]&gt;&gt;<span class="hljs-number">1</span>)];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=T.h[x];i;i=T.nxt[i]) &#123;<span class="hljs-type">int</span> y=T.to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j) &#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=sz[y];++k) &#123;(g[j+k]+=f[x][j]*f[y][k]%mod*pw[<span class="hljs-built_in">max</span>(j*k<span class="hljs-number">-1</span>,<span class="hljs-number">0ll</span>)]%mod)%=mod;(g[j]-=f[x][j]*f[y][k]%mod-mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j) f[x][j]=g[j], g[j]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();G.tot=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();G.<span class="hljs-built_in">add</span>(x,y), G.<span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">suodian</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) (ans+=f[<span class="hljs-number">1</span>][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf-gym103427-l.-perfect-matchings">CF Gym103427 L. PerfectMatchings</h3><p>怎么又是 ICPC shenyang。</p><p>转化一下题意，<span class="math inline">\(2n\)</span>个点完美匹配就是两两匹配，但是有 <spanclass="math inline">\(2n-1\)</span>条构成一棵树的边不允许使用。不妨只考虑树边。</p><p>和第一题很像，但也有不同，所以先子集反演一下。设 <spanclass="math inline">\(f(S)\)</span> 为至少使用了边集 <spanclass="math inline">\(S\)</span> 内的边的完美匹配数量，<spanclass="math inline">\(g(S)\)</span> 为恰好使用了边集 <spanclass="math inline">\(S\)</span> 内的边的完美匹配数量。 <spanclass="math display">\[g(\varnothing) = \sum_{S \in U} (-1)^{|S|} f(S)\]</span> 类比第一题，前者是求至少让边集 <spanclass="math inline">\(S\)</span>内的边没有被经过，从而划分成若干连通块，而后者则是至少让边集 <spanclass="math inline">\(S\)</span>的边被经过。对于「不被经过」，可以直接钦定，把匹配操作放到连通块闭合处进行。而对于「经过」操作，则必须通过匹配完成，因此设<span class="math inline">\(f_{x,i,j,0/1}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，匹配了 <spanclass="math inline">\(i\)</span> 对点，经过了<spanclass="math inline">\(j\)</span> 条边，其中 <spanclass="math inline">\(x\)</span> 有没有匹配的方案数。讨论是否匹配 <spanclass="math inline">\((x,y)\)</span> 即可转移。</p><p>依然是对 <span class="math inline">\(j\)</span>这一维做前缀和，在匹配 <span class="math inline">\((x,y)\)</span>处带上系数即可。</p><p> </p><p>有人可能会说，如果设 <span class="math inline">\(f(S)\)</span>至少为没有经过 <span class="math inline">\(S\)</span> 内的边，<spanclass="math inline">\(g(S)\)</span> 为恰好没有使用 <spanclass="math inline">\(S\)</span>内的树边，那么不就转化成了第一题的形式了吗？不能。因为本题中一条树边<span class="math inline">\((x,y)\)</span> 没有被使用的充要条件是 <spanclass="math inline">\(x\)</span> 没有匹配 <spanclass="math inline">\(y\)</span>，而不是第一题中的子树内没有和外部匹配的点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: L. Perfect Matchings</span><span class="hljs-comment">// Contest: Codeforces - The 2021 ICPC Asia Shenyang Regional Contest</span><span class="hljs-comment">// URL: https://codeforces.com/gym/103427/problem/L</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-28 09:17:48</span><span class="hljs-comment">// Memory Limit: 512 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4005</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, f[N][N/<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], g[N/<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], sz[N], h[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=sz[x]/<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[y]/<span class="hljs-number">2</span>;++j) &#123;(g[i+j][<span class="hljs-number">0</span>]+=f[x][i][<span class="hljs-number">0</span>]*(f[y][j][<span class="hljs-number">0</span>]+f[y][j][<span class="hljs-number">1</span>])%mod)%=mod;(g[i+j][<span class="hljs-number">1</span>]+=f[x][i][<span class="hljs-number">1</span>]*(f[y][j][<span class="hljs-number">0</span>]+f[y][j][<span class="hljs-number">1</span>])%mod)%=mod;(g[i+j+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-=f[x][i][<span class="hljs-number">0</span>]*f[y][j][<span class="hljs-number">0</span>]%mod-mod)%=mod;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=sz[x]/<span class="hljs-number">2</span>;++i) f[x][i][<span class="hljs-number">0</span>]=g[i][<span class="hljs-number">0</span>], f[x][i][<span class="hljs-number">1</span>]=g[i][<span class="hljs-number">1</span>], g[i][<span class="hljs-number">0</span>]=g[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>*n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2</span>*n;i+=<span class="hljs-number">2</span>) h[i]=h[i<span class="hljs-number">-2</span>]*(i<span class="hljs-number">-1</span>)%mod;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (ans+=(f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]+f[<span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>])%mod*h[<span class="hljs-number">2</span>*(n-i)]%mod)%=mod;    <span class="hljs-comment">// 还要乘上其他点任意匹配的方案数，才是子集反演中的f(S)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu4099-heoi2013-sao">luogu4099 [HEOI2013] SAO</h3><p>既有外向边，也有内向边，不是很好做。但是只有一种边就很容易了。</p><p>考虑容斥。钦定一个内向边集不满足，剩下的是否满足均可。</p><p><del>其实钦定内向外向都一样</del>。</p><p>设 <span class="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，其中 <spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，钦定了 <spanclass="math inline">\(j\)</span> 条内向边不满足的方案数，同样把 <spanclass="math inline">\(j\)</span> 压了。</p><p>在内向边 <span class="math inline">\((x,y)\)</span>加入连通块时带上容斥系数，统计这条边作为外向边的贡献即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P4099 [HEOI2013] SAO</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P4099</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-28 07:50:08</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, T, sz[N], C[N][N], f[N][N], g[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> fac[N], inv[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[x];++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) &#123;(g[j+k]+=f[x][j]*f[y][k]%mod*C[sz[x]+sz[y]][sz[x]]%mod)%=mod;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[x];++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) &#123;<span class="hljs-type">int</span> d=f[x][j]*f[y][k]%mod*C[sz[x]+sz[y]][sz[x]]%mod;(g[j+k]-=d-mod)%=mod;(g[j]+=d)%=mod;&#125;&#125;sz[x]+=sz[y];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) (f[x][i]*=fac[i<span class="hljs-number">-1</span>]*inv[i]%mod)%=mod;    <span class="hljs-comment">// x必须放在最后</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=sz[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) f[i][j]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;<span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-type">int</span> y=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&lt;&#x27;</span>) <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>); &#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=f[<span class="hljs-number">1</span>][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>) &#123;fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;C[i][<span class="hljs-number">0</span>]=C[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;inv[<span class="hljs-number">1000</span>]=<span class="hljs-built_in">fp</span>(fac[<span class="hljs-number">1000</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,<span class="hljs-number">999</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="loj2117.-hnoi2015实验比较">LOJ#2117. 「HNOI2015」实验比较</h3><p>能发现相等关系具有反身性和传递性，并且这些点必然放到质量序列的连续一段，所以可以先用并查集把相等的图片合并了。</p><p>然后 <span class="math inline">\(x&lt;y\)</span> 说明 <spanclass="math inline">\(x\)</span> 必须放到 <spanclass="math inline">\(y\)</span> 前面，连边 <spanclass="math inline">\((x \rightarrowy)\)</span>，约等于是内向树拓扑序计数，唯一的区别在于没有祖孙关系的两个节点可以通过相等链接。</p><p>为了解决这个问题，我们用状态刻画它。</p><p>设 <span class="math inline">\(f(x,i)\)</span> 表示以 <spanclass="math inline">\(x\)</span> 为根的子树形成的质量序列，其中存在<span class="math inline">\(i-1\)</span> 个小于号把序列划分成 <spanclass="math inline">\(i\)</span> 个相等段的方案数。</p><p>转移合并子树。 <span class="math display">\[g(i) = \sum_{j \le i \wedge  i \le j+k  } f(x,j) f(y,k)\binom{i-1}{j-1}\binom{j-1}{k-(i-j)}\]</span> 下面解释上式的含义。<span class="math inline">\(x\)</span>肯定要放到第一个位置单独一段，所以其实是 <spanclass="math inline">\(j-1\)</span> 段和 <spanclass="math inline">\(k\)</span> 段要放到 <spanclass="math inline">\(i-1\)</span> 段中。第一个二项式系数是给 <spanclass="math inline">\(f(x,j)\)</span> 重标号，然后 <spanclass="math inline">\(f(y,k)\)</span> 中的 <spanclass="math inline">\(k\)</span> 段去补剩下的 <spanclass="math inline">\((i-j)\)</span> 段，最后剩下的 <spanclass="math inline">\(k-(i-j)\)</span> 段则合并进 <spanclass="math inline">\(j-1\)</span>段中。每个段只合并一次，防止重复计数。</p><p>本题还有 <span class="math inline">\(O(n^2)\)</span>做法，先鸽着。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3240 [HNOI2015]实验比较</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3240</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-26 19:56:23</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, in[N], sz[N], f[N][N], c[N][N], g[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];vector&lt;PII &gt; v;<span class="hljs-type">char</span> ch[<span class="hljs-number">3</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> f[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) f[y]=x;&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">// printf(&quot;x=%lld\n&quot;,x);</span>f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs</span>(y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x]+sz[y];++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[x];++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) &#123;<span class="hljs-keyword">if</span>(k+j&lt;i||j&gt;i) <span class="hljs-keyword">continue</span>;(g[i]+=f[x][j]*f[y][k]%mod*c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]%mod*c[j<span class="hljs-number">-1</span>][k-(i-j)]%mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) dsu.f[i]=i;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x, y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%s%lld&quot;</span>,&amp;x,ch,&amp;y);<span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;=&#x27;</span>) dsu.<span class="hljs-built_in">merge</span>(x,y);<span class="hljs-keyword">else</span> v.<span class="hljs-built_in">pb</span>(&#123;x,y&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v) &#123;<span class="hljs-type">int</span> x=dsu.<span class="hljs-built_in">get</span>(t.fi), y=dsu.<span class="hljs-built_in">get</span>(t.se);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">continue</span>;++in[y];p[x].<span class="hljs-built_in">pb</span>(y);&#125;++n;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(dsu.f[i]==i&amp;&amp;!in[i]) p[n].<span class="hljs-built_in">pb</span>(i), fg=<span class="hljs-number">1</span>;<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">if</span>(!fg) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>), <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs</span>(n);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=f[n][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>计数</tag>
      
      <tag>组合数学</tag>
      
      <tag>容斥原理</tag>
      
      <tag>子集反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#12 并查集</title>
    <link href="/2023/noip-record-12/"/>
    <url>/2023/noip-record-12/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>并查集是一个森林，每棵树表示一个集合，并且这个集合根据某种具有传递性的关系构建起来。</p><p>普通并查集关心的信息只有 <span class="math inline">\(x\)</span>所在集合的根，<span class="math inline">\(fa_x\)</span>表示的仅仅是一个传递性关系，即 <span class="math inline">\(fa_x\)</span>与 <span class="math inline">\(x\)</span>所在集合的根相同。从任意节点往上跳，都能找到它所在集合的根。</p><p>使用路径压缩优化，在向上访问节点时，把路径上所有节点的 <spanclass="math inline">\(fa\)</span> 都改为根，那么就能做到单次查询均摊<span class="math inline">\(O(\log_2 n)\)</span>。</p><p>使用按秩合并优化，在合并两个连通块时，将较小的连通块合并到较大的连通块中，这样就能做到单次查询均摊<span class="math inline">\(O(\log_2n)\)</span>。为了避免大量修改，在可持久化并查集中，只使用按秩合并的并查集。</p><p>二者同时使用，单次查询均摊 <span class="math inline">\(O\Big(\alpha(n)\Big)\)</span>。</p><h2 id="维护具有传递性的关系">维护具有传递性的关系</h2><h3 id="cf28b-psort">CF28B pSort</h3><p>如果 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 能交换，<spanclass="math inline">\(b\)</span> 与 <spanclass="math inline">\(c\)</span> 能交换，那么 <spanclass="math inline">\(a,b,c\)</span>三者可以任意交换。这个关系具有传递性，用并查集维护。</p><p>最后一一检查需要交换的位置 <spanclass="math inline">\(p_i\)</span>，如果 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(p_i\)</span> 在同一个集合中，那么就可以交换。</p><h3 id="躲避拥挤">躲避拥挤</h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个景点，<spanclass="math inline">\(m\)</span> 条双向道路。每条道路有一个人气值 <spanclass="math inline">\(d\)</span>，表示这条道路的拥挤程度。小明不会经过那些人气值<span class="math inline">\(\ge x\)</span> 的道路，他想知道有多少对景点<span class="math inline">\((a,b)\)</span> 使得从 <spanclass="math inline">\(a\)</span> 出发可以到达 <spanclass="math inline">\(b\)</span> 景点。你需要处理多次询问，每次询问的<span class="math inline">\(x\)</span> 不同。 <spanclass="math inline">\(n, m, q \le 10^5\)</span>。</p></blockquote><p>把询问离线了，倒序加边，用并查集维护连通块大小。</p><p>如果加入了一条边 <span class="math inline">\((x,y)\)</span>第一次连接了两个连通块 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，那么答案增加 <spanclass="math inline">\(sz_A \times sz_B\)</span>。</p><h3 id="luogu1955-程序自动分析">luogu1955 程序自动分析</h3><p>相等具有传递性，不等不具有传递性。</p><p>并查集维护相等关系，最后 check 不等关系即可。</p><h3 id="uva1316-supermarket">UVA1316 Supermarket</h3><p>贪心。将商品按照价格递减排序，然后对于第 <spanclass="math inline">\(i\)</span> 天，维护最大的 <spanclass="math inline">\(rt(i)\)</span>，满足 <spanclass="math inline">\(rt(i) \le i\)</span> 并且第 <spanclass="math inline">\(rt(i)\)</span> 天空闲，不存在就是 <spanclass="math inline">\(0\)</span>。</p><p>对于一个商品 <span class="math inline">\(i\)</span>，查询 <spanclass="math inline">\(d_i\)</span> 所在集合的根 <spanclass="math inline">\(rt(d_i)\)</span> 是否大于 <spanclass="math inline">\(0\)</span>。如果是，那么就占用这一天，合并 <spanclass="math inline">\(rt(d_i)\)</span> 与 <spanclass="math inline">\(rt(d_i)-1\)</span> 即可。</p><h3 id="luogu2391-白雪皑皑">luogu2391 白雪皑皑</h3><p>倒着做。</p><p>用并查集维护每个点之前第一个没有被染色的点。点 <spanclass="math inline">\(i\)</span> 被染色了之后，就把 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(i-1\)</span> 合并。</p><p>对于一个操作 <span class="math inline">\([l,r]\)</span>，从 <spanclass="math inline">\(r\)</span>开始往前跳，这样每个点只会被染色一次，记录每个点被染的颜色就行。</p><h3 id="luogu6185-noi-online-1-提高组-序列">luogu6185 [NOI Online #1提高组] 序列</h3><p>只讲关于并查集的部分。</p><p>把每个点的点权都搞成 <span class="math inline">\(a_i -b_i\)</span>，问题转化为把所有节点权值都搞成 <spanclass="math inline">\(0\)</span>。</p><p>有两种思路。</p><ol type="1"><li><p>用并查集维护 <span class="math inline">\(1\)</span>操作，因为一个连通块内可以同加减。</p></li><li><p>用并查集维护 <span class="math inline">\(2\)</span>操作，因为一个连通块内可以多次使用，所以能让任意节点加<spanclass="math inline">\(1\)</span>，任意节点减 <spanclass="math inline">\(1\)</span>。</p></li></ol><p>虽然前者也具有传递性，但是对问题却没有帮助。</p><p>而后者隐藏着总和不变的信息——只有总和为 <spanclass="math inline">\(0\)</span> 时才有解。</p><p>同时连通块之间的 <span class="math inline">\(1\)</span>操作，就相当于在二者差不变的情况下任意加减。</p><p> </p><p>另外有时候还会用并查集把具有某些关系的点合并到一个等价类中。</p><h2 id="带权并查集">带权并查集</h2><p>有些时候这个带有传递性的关系需要具体的值来度量。</p><p>让 <span class="math inline">\((x,fa_x)\)</span>带上边权，在路径压缩时对路径上的权值求和，通过满足结合律和传递性的运算，得到<span class="math inline">\(x\)</span> 与根的之间的值。</p><h3 id="luogu1196-noi2002-银河英雄传说">luogu1196 [NOI2002]银河英雄传说</h3><p>用并查集维护第 <span class="math inline">\(i\)</span>个战舰所在列的前一个战舰 <spanclass="math inline">\(fa_i\)</span>，一个集合的根就是最前面的战舰。维护<span class="math inline">\(d_i\)</span> 表示 <spanclass="math inline">\((i,fa_i)\)</span> 的权值。</p><p>在合并 <span class="math inline">\(x,y\)</span> 时更新 <spanclass="math inline">\(d_{rt(x)}\)</span> 需要知道 <spanclass="math inline">\(sz_{rt(y)}\)</span>，还需要维护 <spanclass="math inline">\(sz\)</span>。</p><p>在查询 <span class="math inline">\((x,y)\)</span>时，先执行路径压缩并得到 <spanclass="math inline">\(rt(x),rt(y)\)</span>。如果二者相同，那么 <spanclass="math inline">\(|d_x-d_y|-1\)</span> 就是答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P1196 [NOI2002] 银河英雄传说</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P1196</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 128 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">30005</span>;<span class="hljs-type">int</span> T;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N], d[N], sz[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">30000</span>) fa[i]=i, sz[i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==fa[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-type">int</span> rt=<span class="hljs-built_in">get</span>(fa[x]);d[x]+=d[fa[x]];<span class="hljs-keyword">return</span> fa[x]=rt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);fa[x]=y, d[x]=sz[y];sz[y]+=sz[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> d[<span class="hljs-built_in">get</span>(x)];&#125;&#125; dsu;<span class="hljs-type">char</span> s[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;dsu.<span class="hljs-built_in">init</span>();T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;M&#x27;</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();dsu.<span class="hljs-built_in">merge</span>(x,y);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> fx=dsu.<span class="hljs-built_in">get</span>(x), fy=dsu.<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(fx!=fy) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">abs</span>(dsu.d[x]-dsu.d[y])<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="数列询问">数列询问</h3><blockquote><p>有一个长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，值域为 <spanclass="math inline">\([0,P-1]\)</span>。给出 <spanclass="math inline">\(m\)</span> 个条件，每个条件形如 <spanclass="math inline">\((l,r,x)\)</span>，表示 <spanclass="math inline">\(\sum_{i=l}^r a_i = x\)</span>。这 <spanclass="math inline">\(m\)</span> 个条件可能存在自相矛盾的情况。求最大的<span class="math inline">\(k\)</span>，满足前 <spanclass="math inline">\(k\)</span> 个条件自洽。</p><p><span class="math inline">\(n,m \le 10^6\)</span>，<spanclass="math inline">\(P \le 10^9\)</span>。</p></blockquote><p>区间和转化为前缀和的差，令 <span class="math inline">\(S_i =\sum_{j=1}^i a_i\)</span>。</p><p>当一个序列的前缀和序列确定时，这个序列也被确定了。</p><p>用带权并查集维护前缀和的每一项的差，<spanclass="math inline">\(d_i\)</span> 表示 <spanclass="math inline">\(S_{fa_i} + d_i =S_i\)</span>。同时每个集合的代表元素就是编号最小的元素。</p><p>加入一条边 <span class="math inline">\((l,r,x)\)</span> 时，对 <spanclass="math inline">\(l-1\)</span> 与 <spanclass="math inline">\(r\)</span>路径压缩，。如果它们在同一个集合内，那么如果 <spanclass="math inline">\(|d_{l-1} - d_r| \neqx\)</span>，那么说明冲突。</p><p>另外还要解决边权值域的问题。</p><p>有一个结论。</p><blockquote><p>如果 <span class="math inline">\([l,r]\)</span> 的权值和合法，<spanclass="math inline">\([l&#39;,r]\)</span> 的权值和合法，且 <spanclass="math inline">\(l&#39; &gt; l\)</span>，那么 <spanclass="math inline">\([l,l&#39;-1]\)</span> 的权值和也合法。</p></blockquote><blockquote><p>证明： <span class="math display">\[sum(l,r) = S_r - S_{l-1}  \le (r-l+1) \times P\]</span> <span class="math display">\[sum(l&#39;,r) = S_r - S_{l&#39;-1} \le (r-l&#39;+1) \times P\]</span></p><p><span class="math display">\[sum(l,l&#39;-1) = S_{l&#39;-1}-S_{l-1} = (l&#39;-l) \times P\]</span></p><p>证毕。</p></blockquote><p>这样我们只要单独<code>check</code>每条边即可。</p><h2 id="拆点并查集">拆点并查集</h2><p>有时候我们想要维护一些关于变量的信息，通过传递性的关系判断是否出现冲突。</p><p>具体地，把每个变量拆成若干个点，表示它的若干种情况。在合并时，如果两个变量的一些有冲突的组合在同一个集合中，那么就表示信息出现了冲突。否则将存在等价关系的集合合并。</p><h3 id="luogu1525-noip2010-提高组-关押罪犯">luogu1525 [NOIP2010 提高组]关押罪犯</h3><p>将关系按照影响力递减排序，然后维护一张二分图，即有冲突的两个犯人放在同一侧。如果加入一个关系后，图不再是二分图，那么这个关系的影响力就是答案。</p><p>具体地，<span class="math inline">\((x,y)\)</span> 拆成 <spanclass="math inline">\((\{x_1,x_2\},\{y_1,y_2\})\)</span>，分别表示二者在左侧还是右侧。</p><p><span class="math inline">\(x_1\)</span> 等价于 <spanclass="math inline">\(y_2\)</span>，<spanclass="math inline">\(x_2\)</span> 等价于 <spanclass="math inline">\(y_1\)</span>。如果 <spanclass="math inline">\(x_1\)</span> 与 <spanclass="math inline">\(y_1\)</span> 或者 <spanclass="math inline">\(x_2\)</span> 与 <spanclass="math inline">\(y_2\)</span> 在同一个集合，那么产生冲突。</p><h3 id="luogu3940-分组">luogu3940 分组</h3><p><ahref="https://yozora0908.github.io/2023/lg3940-solution">link</a></p><h3 id="luogu2024-noi2001-食物链">luogu2024 [NOI2001] 食物链</h3><p>一个点拆三个点，分别代表同类，捕食，被捕食。</p><p>任何一种关系，都能得到两个点之间三种情况的等价关系，不再展开。</p><h3 id="cf1615d-xor-mas-tree">CF1615D X(or)-mas Tree</h3><p>设 <span class="math inline">\(d_x\)</span> 为根到 <spanclass="math inline">\(x\)</span> 路径上边权异或和的 <spanclass="math inline">\(\operatorname{popcount}\)</span>的奇偶性，那么一个条件 <span class="math inline">\((x,y,z)\)</span>等价于 <span class="math inline">\(d_x\)</span> 是否与 <spanclass="math inline">\(d_y\)</span>相等。把每个点拆成奇偶两个，拆点并查集维护即可。</p><p>如何构造？能发现边权值只需要 <span class="math inline">\(0\)</span>和 <span class="math inline">\(1\)</span> 来调整奇偶。</p><p>这样我们根据 <span class="math inline">\(d_x\)</span> 与 <spanclass="math inline">\(d_y\)</span> 是否相等来确定 <spanclass="math inline">\((x,y)\)</span> 放 <spanclass="math inline">\(0\)</span> 还是 <spanclass="math inline">\(1\)</span>。</p><p>当然这题也可以用带权并查集来做，只不过比较胃疼。</p><h3 id="cf1290c-prefix-enlightenment">CF1290C Prefix Enlightenment</h3><p>任意三个子集的交集为空，说明任意下标至多存在于 <spanclass="math inline">\(2\)</span> 个子集中。</p><p>对于每个下标，求出包含它的子集。</p><ol type="1"><li><p>如果有两个，那么根据当前下标对应元素的值，可以知道它们是只能操作其中一个还是必须同时操作。</p></li><li><p>如果只有一个，那么可以知道它必须被操作或者必须不被操作。</p></li></ol><p>注意到一个子集需要操作，可能使得很多集合也被操作，且具有传递性，代价也有可加性。</p><p>我们把每个元素拆成操作和不操作两个点，一个连通块里的点所代表的信息必须被同时执行，代价就是点权和，然后让操作点的初始点权为<span class="math inline">\(1\)</span>。</p><p>对于第一种情况，我们将对应点合并，合并时累加点权。对于第二种，建一个虚点，从不需要执行的那种操纵往虚点连边，虚点权值为正无穷，表示必须不被选择。</p><p>从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 扫一遍，每次对新加入的点求贡献。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: C. Prefix Enlightenment</span><span class="hljs-comment">// Contest: Codeforces - Codeforces Round 616 (Div. 1)</span><span class="hljs-comment">// URL: https://codeforces.com/problemset/problem/1290/C</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k;<span class="hljs-type">char</span> s[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[<span class="hljs-number">2</span>*N], w[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*k) fa[i]=i;<span class="hljs-built_in">rep</span>(i,k+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*k) w[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// [1,k]对应不操作点</span>        <span class="hljs-comment">// [k+1,2*k]对应操作点</span>        <span class="hljs-comment">// 0是虚点</span>w[<span class="hljs-number">0</span>]=<span class="hljs-number">1e9</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y, w[y]+=w[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(w[<span class="hljs-built_in">get</span>(x)],w[<span class="hljs-built_in">get</span>(x+k)]);        <span class="hljs-comment">// 操作或不操作取较小值</span>&#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(cnt--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(i);&#125;&#125;dsu.<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(p[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> x=p[i][<span class="hljs-number">0</span>];ans-=dsu.<span class="hljs-built_in">getmin</span>(x);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) dsu.<span class="hljs-built_in">merge</span>(x+k,<span class="hljs-number">0</span>);<span class="hljs-keyword">else</span> dsu.<span class="hljs-built_in">merge</span>(x,<span class="hljs-number">0</span>);ans+=dsu.<span class="hljs-built_in">getmin</span>(x);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">2</span>)&#123;<span class="hljs-type">int</span> x=p[i][<span class="hljs-number">0</span>], y=p[i][<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(x)!=dsu.<span class="hljs-built_in">get</span>(y)&amp;&amp;dsu.<span class="hljs-built_in">get</span>(x)!=dsu.<span class="hljs-built_in">get</span>(y+k)) &#123;ans-=dsu.<span class="hljs-built_in">getmin</span>(x)+dsu.<span class="hljs-built_in">getmin</span>(y);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) dsu.<span class="hljs-built_in">merge</span>(x,y), dsu.<span class="hljs-built_in">merge</span>(x+k,y+k);<span class="hljs-keyword">else</span> dsu.<span class="hljs-built_in">merge</span>(x,y+k), dsu.<span class="hljs-built_in">merge</span>(x+k,y);ans+=dsu.<span class="hljs-built_in">getmin</span>(x);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="其他应用">其他应用</h2><h3 id="luogu3295-scoi2016-萌萌哒">luogu3295 [SCOI2016] 萌萌哒</h3><p>考虑一个暴力。对于每个限制，用并查集合并对应点，最后看对每一个连通块集体赋值求方案数。</p><p>考虑优化。我们可以用倍增的思路，开若干个并查集，第 <spanclass="math inline">\(k\)</span> 个并查集合并从两个点开始长度为 <spanclass="math inline">\(2^k\)</span> 的一段。对于每个限制，<spanclass="math inline">\(k\)</span> 从大到小尽可能合并一遍。</p><p>最后倒序枚举 <spanclass="math inline">\(k\)</span>，如果当前并查集合并了 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span>，那么就在第 <spanclass="math inline">\(k-1\)</span> 并查集里合并 <spanclass="math inline">\(i,j\)</span> 和 <spanclass="math inline">\(i+2^{k-1},j+2^{k-1}\)</span>。</p><p>最后只考虑 <span class="math inline">\(2^{0}\)</span>对应的并查集就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: #2014. 「SCOI2016」萌萌哒</span><span class="hljs-comment">// Contest: LibreOJ</span><span class="hljs-comment">// URL: https://loj.ac/p/2014</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, lgn;<span class="hljs-type">int</span> f[N][<span class="hljs-number">17</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x][k]? x:f[x][k]=<span class="hljs-built_in">get</span>(f[x][k],k); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> k)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x,k), y=<span class="hljs-built_in">get</span>(y,k);<span class="hljs-keyword">if</span>(x!=y) f[x][k]=y;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();lgn=<span class="hljs-built_in">log2</span>(n);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,lgn) f[i][j]=i;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> l1=<span class="hljs-built_in">read</span>(), r1=<span class="hljs-built_in">read</span>(), l2=<span class="hljs-built_in">read</span>(), r2=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lgn;~i;--i) &#123;<span class="hljs-keyword">if</span>(l1+(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">-1</span>&lt;=r1) &#123;<span class="hljs-built_in">merge</span>(l1,l2,i);l1+=<span class="hljs-number">1</span>&lt;&lt;i, l2+=<span class="hljs-number">1</span>&lt;&lt;i;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=lgn;k;--k) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=<span class="hljs-built_in">get</span>(i,k);<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">merge</span>(i,j,k<span class="hljs-number">-1</span>);<span class="hljs-built_in">merge</span>(i+(<span class="hljs-number">1</span>&lt;&lt;k<span class="hljs-number">-1</span>),j+(<span class="hljs-number">1</span>&lt;&lt;k<span class="hljs-number">-1</span>),k<span class="hljs-number">-1</span>);&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(f[i][<span class="hljs-number">0</span>]==i) &#123;<span class="hljs-keyword">if</span>(ans==<span class="hljs-number">1</span>) (ans*=<span class="hljs-number">9</span>)%=mod;<span class="hljs-keyword">else</span> (ans*=<span class="hljs-number">10</span>)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf1253f-cheap-robot">CF1253F Cheap Robot</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边的图，<spanclass="math inline">\(q\)</span>次询问两点间最短路径上边权的最大值。</p><p><span class="math inline">\(n \le 10^5\)</span>，<spanclass="math inline">\(m, q \le 3 \times 10^5\)</span>。</p></blockquote><p>离线，把询问挂在两个点上，所有边按照边权递增排序，依次加入。</p><p>如果当前边连接了 <span class="math inline">\((x,y)\)</span>，那么回答二者所在连通块较小的那个连通块里的询问。如果询问中的两个点此时连通，那么当前边的权值就是答案，否则就按秩合并进较大连通块。</p><h3 id="a">A</h3><blockquote><p><span class="math inline">\(n\)</span> 个孤立点，<spanclass="math inline">\(m\)</span> 次加边操作。<spanclass="math inline">\(q\)</span>次询问两个点最早在第几次操作后连通。</p></blockquote><p>OI-wiki 上的做法是建立并查集生成树。如果第 <spanclass="math inline">\(i\)</span>此操作的两个点在不同的树中，那么就连接两个点所在的子树，最终得到的一定是一棵树。此时两个点之间的最大边权就是答案。</p><p>其实用上面那种做法也可以。</p><h3 id="b">B</h3><blockquote><p>给定一颗 <span class="math inline">\(n\)</span> 个点的树，有 <spanclass="math inline">\(m\)</span> 次操作，两种类型。</p><ul><li>加边</li><li>询问两个点之间是否有至少两条不相交路径。</li></ul></blockquote><p>询问转化为两个点是否在一个简单环上。</p><p>加边操作转化为，树上两点之间的路径都被覆盖一次。如果两点树上路径都被覆盖过了，那么就一定在至少一个简单环上。</p><p>给树定根，用并查集维护每个点到根的路径上第一条没有被覆盖的边，然后加边时搞出<spanclass="math inline">\(\operatorname{LCA}\)</span>，暴力跳并查集。查询只需要看两个点到根的路径上第一条没有被覆盖的边的深度是否都大于等于<span class="math inline">\(\operatorname{LCA}\)</span> 即可。</p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树论</tag>
      
      <tag>倍增</tag>
      
      <tag>并查集</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#11 最短路和最小生成树</title>
    <link href="/2023/noip-record-11/"/>
    <url>/2023/noip-record-11/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>图论这一块内容比较多，而且题目涉及的 Trick 也很多，因此分若干篇。</p><p>本文略去所有算法本身性质的证明过程。</p><h2 id="最短路">最短路</h2><h3 id="dijkstra和spfa">Dijkstra和SPFA</h3><p><span class="math inline">\(\text{Dijkstra}\)</span>算法基于一个重要的性质：全局最小值不可能再被任何边更新。这样，在边权为非负数的最短路问题中显然满足，在存在负边时不满足。同时，保证了最多从每个节点处扩展<span class="math inline">\(1\)</span> 次，从而有了稳定的复杂度。</p><p>这也限制了 <span class="math inline">\(\text{Dijkstra}\)</span>在转移 DP 时的应用。</p><p>在某经典问题中，设 <span class="math inline">\(f(x)\)</span> 表示<span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span>的最小点权。全局最小值是可能在更新的过程中变小的，具体方法是绕一圈再经过权值更小的点。</p><p>再来看又一个经典问题。</p><h4 id="luogu4042-ahoi2014jsoi2014-骑士游戏">luogu4042[AHOI2014/JSOI2014] 骑士游戏</h4><p>设 <span class="math inline">\(f(x)\)</span> 为杀死怪物 <spanclass="math inline">\(x\)</span> 以及其他衍生物的最小代价。 <spanclass="math display">\[f(x) = \min \Big\{ K_x, S_x+\sum_{y \in to(x)} f(y) \Big\}\]</span> 这玩意有后效性。</p><p>当前全局最小值也是有可能会随着更新而变小的，因此不能使用 <spanclass="math inline">\(\text{Dijkstra}\)</span> 算法，必须使用SPFA。在更新完 <span class="math inline">\(f(x)\)</span>之后，把所有能生成 <span class="math inline">\(x\)</span>的点都扔到队列里面去更新。复杂度爆炸，但好在是 14年的题，好像做完了。</p><p>然而，真的不满足吗？</p><p>如果一个 <span class="math inline">\(f(x)\)</span>在更新其他点的时候把自己更新成更小的值，那么说明杀死中间那些怪物的代价为负数，这是不合理的，因此本题满足<span class="math inline">\(\text{Dijkstra}\)</span>的贪心性质。这也说明了，当一个点的代价确定时，就一定是其最优解。</p><p>因此本题的正解如下。</p><p>任何一个点的最终代价都依赖于它所生成的那些点，因此建一张反图，把所有点都扔到堆里面，初始值就是用魔法攻击干死的代价。</p><p>有了贪心性质，我们并不需要无脑迭代。对于一个 <spanclass="math inline">\(x\)</span>，当它被 <spanclass="math inline">\(to(x)\)</span> 中的每一个点都更新之后，就能得到<span class="math inline">\(S_x + \sum_{y \in to(x)} f(y)\)</span>，与<span class="math inline">\(K_x\)</span> 取较小值就能得到最小代价。</p><p>这样做的复杂度就是 <span class="math inline">\(O\Big((n+\sum_{i=1}^nR_i) \log_2 (\sum_{i=1}^n R_i )\Big)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P4042 [AHOI2014/JSOI2014] 骑士游戏</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P4042</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, c[N], d[N], to[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;priority_queue&lt;PII &gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) q.<span class="hljs-built_in">push</span>(&#123;-d[i],i&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;c[y]+=d[x];<span class="hljs-keyword">if</span>(--to[y]==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(d[y]&gt;c[y]) &#123;d[y]=c[y];q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) &#123;c[x]=<span class="hljs-built_in">read</span>(), d[x]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(cnt--) &#123;<span class="hljs-type">int</span> y=<span class="hljs-built_in">read</span>();p[y].<span class="hljs-built_in">pb</span>(x);++to[x];&#125;&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="luogu4745-cerc2017-gambling-guide">luogu4745 [CERC2017] GamblingGuide</h4><p>题目中要求最小化期望，指的是在有优劣之分的决策中，选择最优决策。</p><p>设 <span class="math inline">\(f(x)\)</span> 为从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(n\)</span> 的最小期望，有 <spanclass="math display">\[f(x) = 1 + \frac{1}{\operatorname{deg}_x}\sum_{(x,y) \in E}\min\Big(f(x),f(y)\Big)\]</span> 这个取 <span class="math inline">\(\min\)</span>操作很麻烦。考虑 <span class="math inline">\(f(y)\)</span> 对 <spanclass="math inline">\(f(x)\)</span> 有贡献，一定有 <spanclass="math inline">\(f(y) &lt;f(x)\)</span>。因此，考虑按照期望代价确定每个点的答案，第一次只能确定<span class="math inline">\(f(n) = 0\)</span>。</p><p>设满足 <span class="math inline">\(S_x\)</span> 表示 <spanclass="math inline">\(x\)</span>的相邻节点中，已经确定代价的点集，那么就有 <span class="math display">\[f&#39;(x) = 1 + \Big(1-\frac{|S_x|}{\operatorname{deg}_x} \Big) f_x  +\frac{1}{\operatorname{deg}_x} \sum_{y \in S_x} f(y)\]</span></p><p><span class="math display">\[f&#39;(x) = \frac{\operatorname{deg}_x + \sum_{y \in S_x} f(y)}{|S_x|}\]</span></p><p>最终的 <span class="math inline">\(f(x)\)</span> 就是 <spanclass="math inline">\(\min \{ f&#39;(x) \}\)</span>。</p><p>这样就能在图上迭代了，具体做法是取出一个确定了的 <spanclass="math inline">\(f(x)\)</span>，令 <spanclass="math inline">\(|S_y| := |S_y|+1\)</span>，然后那个和式加上 <spanclass="math inline">\(f(x)\)</span>，就能计算出 <spanclass="math inline">\(f&#39;(y)\)</span>。</p><p>考虑一个全局最小的 <span class="math inline">\(f(x)\)</span> 更新了<span class="math inline">\(f(y)\)</span> 得到 <spanclass="math inline">\(f&#39;(y)\)</span>，带入式子中可以有 <spanclass="math inline">\(f(x) &lt; f&#39;(y) &lt;f(y)\)</span>，具体过程略。</p><p>用 <span class="math inline">\(\text{Dijkstra}\)</span> 转移。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P4745 [CERC2017] Gambling Guide</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P4745</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 500 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-6</span>;<span class="hljs-type">int</span> n, m, c[N], v[N];<span class="hljs-type">double</span> f[N], g[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i]=<span class="hljs-number">1e10</span>;priority_queue&lt;pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; &gt; q;f[n]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0.0</span>,n&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) &#123;++c[y];g[y]+=f[x];<span class="hljs-keyword">if</span>(f[y]&gt;(p[y].<span class="hljs-built_in">size</span>()+g[y])/c[y]) &#123;    f[y]=(p[y].<span class="hljs-built_in">size</span>()+g[y])/c[y];    q.<span class="hljs-built_in">push</span>(&#123;-f[y],y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>,f[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>再提供一道关于 <span class="math inline">\(\text{Dijkstra}\)</span>算法的贪心性质的题目。</p><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边的图，边权值域是 <spanclass="math inline">\([0,10^9]\)</span>。求从每个点出发前 <spanclass="math inline">\(k\)</span> 近的点。</p><p><span class="math inline">\(n \le 10^5\)</span>，<spanclass="math inline">\(m \le \min(\frac{n(n-1)}{2},3 \times10^5)\)</span>，<span class="math inline">\(k \le 16\)</span>。</p></blockquote><p>由于 <span class="math inline">\(\text{Dijkstra}\)</span>算法取出的是全局最小值，所以对于每个点，只要取出 <spanclass="math inline">\(k\)</span> 个点扩展即可。而显然从每个点出发最多有<span class="math inline">\(k\)</span>条边有用，所以这样直接做就行了，复杂度 <spanclass="math inline">\(O(nk^2 \log_2 k^2)\)</span>。</p><p>注意清空数组的细节，否则复杂度就假了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-type">bool</span> lst=<span class="hljs-number">0</span>;priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;d[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-comment">//puts(&quot;doit&quot;);</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;++w) &#123;<span class="hljs-keyword">while</span>(v[q.<span class="hljs-built_in">top</span>().second]) q.<span class="hljs-built_in">pop</span>();<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second;v[x]=<span class="hljs-number">1</span>, link[w]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:p[x]) &#123;<span class="hljs-type">int</span> y=i.second, z=i.first;<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;<span class="hljs-keyword">if</span>(w) &#123;<span class="hljs-keyword">if</span>(lst) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);lst=<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,d[x]);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;++w) &#123;v[link[w]]=<span class="hljs-number">0</span>, d[link[w]]=<span class="hljs-number">1e15</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[link[w]]) d[y.second]=<span class="hljs-number">1e15</span>;&#125;&#125;</code></pre></div><h3 id="bfs及其扩展">0-1 BFS及其扩展</h3><p>在边权只有 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 的图上，我们可以用 0-1 BFS 在 <spanclass="math inline">\(O(n+m)\)</span>的时间里求解单源最短路。其原理是在普通队列中，维护队首的元素是全局最小值。可以当作一个退化了的<span class="math inline">\(\text{Dijkstra}\)</span> 算法来理解。</p><p>扩展：边权为 <span class="math inline">\(0,1,2,\cdots, w\)</span>时怎么做？</p><p>依然是维护单调性。开 <span class="math inline">\(w+1\)</span>个队列，当更新完 <span class="math inline">\(dis(y) = dis(x)+ z\)</span>时，将 <span class="math inline">\(dis(y)\)</span> 扔到第 <spanclass="math inline">\(z\)</span> 个队列里。由于每次取出的 <spanclass="math inline">\(dis(x)\)</span>单调不降，所以每个队列内部的大小都是单调的。</p><p>贪心从权值小的队列取点即可。</p><h3 id="最短路树">最短路树</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, pre[y]=i;        <span class="hljs-comment">// pre[y]就是最短路树上x与y之间的边</span>        q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;); &#125;&#125;</code></pre></div><p>性质就像它的名字，源点到每个点的最短路径构成的一棵树。</p><h3 id="次短路">次短路</h3><p>维护两个数组<code>dis1[]</code>和<code>dis2[]</code>。如果用当前点更新了到另一个点的最短路，那么把那个点的最短路和次短路都扔进堆里（因为二者都被更新过了）；如果只更新了另一个点的次短路，那么把次短路扔进堆里。</p><p>一个节点可能会更新和被更新多次，为了避免复杂度退化，要判断当前取出的节点对应的最短路长度，是否是最短路或次短路之一，或者说判断长度是否已经大于了次短路。</p><p>从网上找了份代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(re <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis1[i]=dis2[i]=<span class="hljs-number">1e9</span>;    dis1[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; q.<span class="hljs-built_in">push</span>((node)&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())    &#123;        <span class="hljs-type">int</span> dt,pt;        dt=q.<span class="hljs-built_in">top</span>().d; pt=q.<span class="hljs-built_in">top</span>().p; q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(dt!=dis1[pt]&amp;&amp;dt!=dis2[pt]) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// if(dt&gt;dis2[pt])</span>        <span class="hljs-keyword">for</span>(re <span class="hljs-type">int</span> i=last[pt];i;i=e[i].next)        &#123;            <span class="hljs-type">int</span> v=e[i].to; <span class="hljs-type">int</span> dis=dt+e[i].val;            <span class="hljs-keyword">if</span>(dis&lt;dis1[v])            &#123;                dis2[v]=dis1[v]; dis1[v]=dis;                q.<span class="hljs-built_in">push</span>((node)&#123;dis1[v],v&#125;);                 q.<span class="hljs-built_in">push</span>((node)&#123;dis2[v],v&#125;);            &#125;<span class="hljs-keyword">else</span>            <span class="hljs-keyword">if</span>(dis&gt;dis1[v]&amp;&amp;dis&lt;dis2[v])            &#123;                dis2[v]=dis;                q.<span class="hljs-built_in">push</span>((node)&#123;dis2[v],v&#125;);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="某道题">某道题</h3><blockquote><p>有向图，求从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 必须经过第 <spanclass="math inline">\(i\)</span> 个点的最短路以及必须经过第 <spanclass="math inline">\(j\)</span> 条边的最短路。</p></blockquote><p>以 <span class="math inline">\(1\)</span> 为源点，跑最短路。以 <spanclass="math inline">\(n\)</span> 为源点，在反图上跑最短路。</p><h3 id="luogu5304-gxoigzoi2019-旅行者">luogu5304 [GXOI/GZOI2019]旅行者</h3><p>从超级源点向 <span class="math inline">\(k\)</span> 个关键点都连<span class="math inline">\(0\)</span> 边，求出 <spanclass="math inline">\(dis_0(x)\)</span>，记录到达每个节点距离最小的关键点<span class="math inline">\(c_0(x)\)</span>。然后建反图再跑一次得到<span class="math inline">\(dis_1(x)\)</span> 和 <spanclass="math inline">\(c_1(x)\)</span>。</p><p>这样如果一条边 <span class="math inline">\((x,y,z)\)</span> 满足<span class="math inline">\(c_0(x) \neq c_1(y)\)</span>，那么说明从<span class="math inline">\(c_0(x)\)</span> 到 <spanclass="math inline">\(x\)</span> 的路径与 <spanclass="math inline">\(c_1(y)\)</span> 到 <spanclass="math inline">\(y\)</span> 无交，从而 <spanclass="math inline">\(dis_0(x)+z+dis_1(y)\)</span>可以作为一个决策。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-type">int</span> T, n, m, k, a[N], col[<span class="hljs-number">2</span>][N], dis[<span class="hljs-number">2</span>][N];<span class="hljs-type">int</span> X[M], Y[M], Z[M];<span class="hljs-type">bool</span> v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">G</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[M], nxt[M], w[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=<span class="hljs-number">0</span>;&#125;&#125; G;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span>* d,<span class="hljs-type">int</span>* c)</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=c[i]=<span class="hljs-number">0</span>, d[i]=inf;priority_queue&lt;PII &gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) d[a[i]]=<span class="hljs-number">0</span>, c[a[i]]=a[i], q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,a[i]&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i], z=G.w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;c[y]=c[x];q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;X[i]=<span class="hljs-built_in">read</span>(), Y[i]=<span class="hljs-built_in">read</span>(), Z[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(X[i]!=Y[i]) G.<span class="hljs-built_in">add</span>(X[i],Y[i],Z[i]);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">dijkstra</span>(dis[<span class="hljs-number">0</span>],col[<span class="hljs-number">0</span>]);G.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(X[i]!=Y[i]) G.<span class="hljs-built_in">add</span>(Y[i],X[i],Z[i]);<span class="hljs-built_in">dijkstra</span>(dis[<span class="hljs-number">1</span>],col[<span class="hljs-number">1</span>]);G.<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">1e15</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=X[i], y=Y[i], z=Z[i];<span class="hljs-keyword">if</span>(col[<span class="hljs-number">0</span>][x]&amp;&amp;col[<span class="hljs-number">1</span>][y]&amp;&amp;col[<span class="hljs-number">0</span>][x]!=col[<span class="hljs-number">1</span>][y])ans=<span class="hljs-built_in">min</span>(ans,dis[<span class="hljs-number">0</span>][x]+dis[<span class="hljs-number">1</span>][y]+z);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>不过这样的做法可能不是很好想到，所以有一种更劣但是思路更自然的做法，</p><p>如果我们使用超级源点和超级汇点，那么能够解决两个集合之间两两最短路的最小值，但是无法解决这个问题。如果我们有一种划分关键点的方式，使得划分若干次后任意两个点一定有至少一次不在同一个集合，就能做了。</p><p>考虑二进制分组。考虑二进制的每一位，把这一位是 <spanclass="math inline">\(0\)</span> 的与 <spanclass="math inline">\(S\)</span> 相连，否则与 <spanclass="math inline">\(T\)</span>相连，跑最短路。这样每次划分的两个集合都无交，并且满足任意两个关键点至少出现在一个不同的集合中。</p><p>这 <span class="math inline">\(O(\log_2 2\times 10^9)\)</span>次最短路中，从 <span class="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的最短路的最小值就是答案。</p><h3 id="luogu7473-noi-online-2021-入门组-重力球">luogu7473 [NOI Online2021 入门组] 重力球</h3><p>在经过至少一次操作之后，小球一定贴着墙壁或者障碍，也就是有用的状态数量只有<span class="math inline">\(O(n+m)\)</span>。</p><p>把有用的状态搞出来，建反边 <spanclass="math inline">\(\text{BFS}\)</span> 出 <spanclass="math inline">\(dis(x,y)\)</span> 表示状态 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>的两个小球，到达同一个点的最小步数。</p><p>对于一个询问，枚举第一步的操作，然后取最小值即可。</p><p>貌似代码有点难写。</p><h3 id="某道题-1">某道题</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边一张图，定义一条包含 <spanclass="math inline">\(l\)</span> 条边的路径的长度为 <spanclass="math inline">\(\max_{i=1}^l \{ i \times w_i \}\)</span>，求 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的最短路。</p><p><span class="math inline">\(n,m \le 3 \times 10^5\)</span>。</p></blockquote><p>二分最短路长度 <span class="math inline">\(mid\)</span>，则第 <spanclass="math inline">\(i\)</span> 条经过的边长度不超过 <spanclass="math inline">\(mid / i\)</span>，这样就变成了一个可达性问题，BFS即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, d[N];<span class="hljs-type">int</span> tot, h[N], to[N], nxt[N], w[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> D)</span> </span>&#123;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,(n+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-type">int</span> x=p.first, dd=p.second;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(z*(dd+<span class="hljs-number">1</span>)&lt;=D&amp;&amp;d[y]==<span class="hljs-number">-1</span>) &#123;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(&#123;y,dd+<span class="hljs-number">1</span>&#125;);&#125;&#125;&#125;<span class="hljs-keyword">if</span>(d[n]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z);&#125;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1e13</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">bfs</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div><h3 id="luogu2446-sdoi2010-大陆争霸">luogu2446 [SDOI2010] 大陆争霸</h3><p>设 <span class="math inline">\(dis(x)\)</span> 为到达节点 <spanclass="math inline">\(x\)</span> 的最短时间，<spanclass="math inline">\(des(x)\)</span> 为摧毁 <spanclass="math inline">\(x\)</span> 的最小时间。</p><p>然后 <span class="math inline">\(des(x) = \max_{y \in protect(x)} \{dis(y)\}\)</span>。</p><p>在完成对 <span class="math inline">\(x\)</span> 节点的扩展后去更新被<span class="math inline">\(x\)</span> 保护的节点。一个节点在被求出<span class="math inline">\(des(x)\)</span> 后再次入堆，这样 <spanclass="math inline">\(des(n)\)</span> 即为答案。</p><h3 id="luogu5663-csp-j2019-加工零件">luogu5663 [CSP-J2019]加工零件</h3><p>我们很容易做 <span class="math inline">\(n\)</span> 很小，<spanclass="math inline">\(m\)</span> 很大的问题，并且容易得到方案数。</p><p>然而那个做法和本题没有任何关系。既然本题只关心是否存在，那么不妨做个转化。任何<span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 经过 <spanclass="math inline">\(L\)</span>条边的路径，都能转化成走最短路，然后再一条边上左右横跳的路径。从奇偶性处下手即可证明。</p><p>那么求出从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span>经过奇数条边和偶数条边的最短路就能判断。</p><p>怎么做？一个点拆成奇点和偶点。</p><h3 id="cf938d-buy-a-ticket">CF938D Buy a Ticket</h3><p>建立超级源点 <span class="math inline">\(S\)</span>，从 <spanclass="math inline">\(S\)</span> 往 <spanclass="math inline">\(i\)</span> 连权值为 <spanclass="math inline">\(a_i\)</span> 的有向边，然后把原图中的边权都乘<span class="math inline">\(2\)</span>，这样到达 <spanclass="math inline">\(i\)</span> 点的最短路就是 <spanclass="math inline">\(i\)</span> 点的答案。</p><h3 id="cf1483d-useful-edges">CF1483D Useful Edges</h3><p>必经边。</p><p>记 <span class="math inline">\((u,v,l)\)</span> 为 <spanclass="math inline">\(a(u,v)=l\)</span>。</p><p><span class="math inline">\((x,y,z)\)</span> 满足条件就是看是否存在<span class="math inline">\((i,j)\)</span> 满足 <spanclass="math display">\[dis(i,x)+z+dis(y,j) \le a(i,j)\]</span> 直接做是 <span class="math inline">\(O(n^4)\)</span> 的。</p><p>设 <span class="math inline">\(b(y,i) = \max \{ a(i,j)-dis(y,j)\}\)</span>，于是就是 <span class="math display">\[dis(i,x) + z \le b(y,i)\]</span> 这样就是 <span class="math inline">\(O(n^3)\)</span> 的。</p><h3 id="luogu4366-code4-最短路">luogu4366 [Code+#4] 最短路</h3><p>就一个点。</p><p>事实上我们只需要保留 <span class="math inline">\((i \oplus j) = 2^k,k\in [0,\log_2n]\)</span> 的边。</p><p>把 <span class="math inline">\((i \oplus j)\)</span>拆成若干二进制位上的 <spanclass="math inline">\(1\)</span>，一个一个地走。这样做的权值依然是不变的。</p><h2 id="差分约束系统">差分约束系统</h2><p>分为两种。</p><ol type="1"><li><p>求最大值。</p><p>把式子整理为 <span class="math inline">\(X_i - X_j \lek\)</span>，连边 <span class="math inline">\((j \rightarrowi)\)</span>，权值为 <spanclass="math inline">\(k\)</span>，跑最短路。有负环无解。</p></li><li><p>求最小值。</p><p>把式子整理为 <span class="math inline">\(X_i -X_j \gek\)</span>，连边 <span class="math inline">\((j \rightarrowi)\)</span>，权值为 <spanclass="math inline">\(k\)</span>，跑最长路。有正环无解。</p></li></ol><p>如果关系要求相等，那么就是 <span class="math inline">\(X_i - X_j \lek \wedge X_i - X_j \ge k\)</span>。。</p><p>一般直接连出的图都不连通，所以需要虚拟源点，同时也可以起到各个变量限制初始值的作用。</p><h3 id="某经典题">某经典题。</h3><blockquote><p>现在有 <span class="math inline">\([1,m] \cap \mathbb{Z}\)</span>中的数，有 <span class="math inline">\(n\)</span> 个限制，第 <spanclass="math inline">\(i\)</span> 个限制表示 <spanclass="math inline">\([a_i,b_i]\)</span> 中至少要取 <spanclass="math inline">\(c_i\)</span> 个数。</p><p>求至少需要多少个整数。</p></blockquote><p>限制转化为 <span class="math inline">\([1,b_i]\)</span>中取数的数量至少比 <span class="math inline">\([1,a_i-1]\)</span> 中多<span class="math inline">\(c_i\)</span>，因此 <spanclass="math inline">\(X_{b_i} - X_{a_i -1} \ge c_i\)</span>。</p><p>直接跑差分约束系统也不对，因为还有隐式的限制，<spanclass="math inline">\(X_a \le X_{a+1} \le X_a + 1\)</span>。</p><p>还有一个问题，如果以 <span class="math inline">\(1\)</span>为起点跑，那么因该有 <span class="math inline">\(X_1 =0\)</span>，实际上并不是。因此必须要有一个虚拟点 <spanclass="math inline">\(s\)</span>，满足限制 <span class="math inline">\(0\le X_1 - X_S \le 1\)</span>。</p><h3 id="luogu3275-scoi2011-糖果">luogu3275 [SCOI2011] 糖果</h3><p>关于 SPFA，它死了。</p><p>差分约束建模之后，为了保证连通并且每个变量都是正整数，还要建立超级源点<span class="math inline">\(S\)</span>，满足关系 <spanclass="math inline">\(X_S - X_i \ge 1\)</span>。</p><p>然后 SPFA 就被卡掉了。</p><p>整张图的权值只有 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>。在一个 SCC 里面，如果 <spanclass="math inline">\((x \rightarrow y)\)</span> 权值是 <spanclass="math inline">\(1\)</span>，那么就一定存在一个正环，从而差分约束系统无解。再考虑SCC 的性质，能发现一个 SCC 中的点的取值都是相等的。缩点后求 DAG最长路即可。</p><h2 id="最小生成树">最小生成树</h2><div class="note note-primary">            <p>一张图的一棵最小生成树，也是这张图的一棵瓶颈生成树。</p>          </div><p>说人话就是对于任意点对 <spanclass="math inline">\((x,y)\)</span>，其最小生成树上的路径上的最大边权，就是原图二者所有路径中，最大边权最小的路径所对应的最大边权。</p><div class="note note-primary">            <p>次小生成树（无论严格与否）一定是在最小生成树的基础上更改一条边。</p><p>对于任何不在最小生成树中的边，该边两个端点在最小生成树上的路径的所有边的权值都小于等于该边。</p>          </div><p>所以严格次小生成树怎么做呢？枚举换进去非树边 <spanclass="math inline">\((x,y,z)\)</span>，然后在形成的那个环上找到最大值<span class="math inline">\(z_1\)</span> 和严格次大值 <spanclass="math inline">\(z_2\)</span>。如果 <span class="math inline">\(z_1\neq z\)</span>，那么换掉 <spanclass="math inline">\(z_1\)</span>，否则换掉 <spanclass="math inline">\(z_2\)</span>。</p><p>树上倍增即可。</p><p>不要求严格次小的话，只求最大值即可。</p><h3 id="luogu1991-无线通讯网">luogu1991 无线通讯网</h3><p>不妨先确定 <spanclass="math inline">\(D\)</span>，再选点。能发现只有当 <spanclass="math inline">\(D\)</span> 确定之后，连通块数量不超过 <spanclass="math inline">\(S\)</span> 时才有解。</p><p>问题转化为求出把一张完全图划分成不超过 <spanclass="math inline">\(S\)</span> 个连通块，使得最大边权最小。</p><p>在 <span class="math inline">\(\text{Kruskal}\)</span>的过程中，当整张图被合并为恰好 <span class="math inline">\(S\)</span>个连通块时，最后加入的边权就是最优的 <spanclass="math inline">\(D\)</span>。</p><p>或者说用 <span class="math inline">\(\text{Prim}\)</span>算法，可以做到 <span class="math inline">\(O(n^2)\)</span>，最后对 <spanclass="math inline">\(d\)</span> 数组排序即可。</p><h3 id="cf76a-gift">CF76A Gift</h3><p>先按照 <span class="math inline">\(g_i\)</span> 递增排序，枚举 <spanclass="math inline">\(\max\{g_i\}\)</span>，这样问题就变成了维护只使用<span class="math inline">\([1,i]\)</span> 中的边的生成树。</p><p>我们直接暴力加入这条边，排序后做最小生成树（其实要求出的是瓶颈生成树）最小化<span class="math inline">\(\max\{s_i\}\)</span>。</p><p>这样做的复杂度是 <span class="math inline">\(O(NM\log_2M)\)</span>，有点大。</p><p>不过考虑到每次做完最小生成树后，剩下的边都是有序的，并且新的最小生成树也不会加入上一次没有加入的边，所以可以手动做一次冒泡排序，使得集合内边的<span class="math inline">\(s_i\)</span> 有序，这样做就是 <spanclass="math inline">\(O(NM)\)</span> 了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: A. Gift</span><span class="hljs-comment">// Contest: Codeforces - All-Ukrainian School Olympiad in Informatics</span><span class="hljs-comment">// URL: https://codeforces.com/problemset/problem/76/A</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">50005</span>;<span class="hljs-type">int</span> n, m, G, S, cnt, ans=<span class="hljs-number">5e18</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, y, g, s;&#125; a[M], b[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Edge a,Edge b) &#123;<span class="hljs-keyword">return</span> a.g&lt;b.g;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dsu</span> &#123;<span class="hljs-type">int</span> f[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i]=i; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), G=<span class="hljs-built_in">read</span>(), S=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i].x=<span class="hljs-built_in">read</span>(), a[i].y=<span class="hljs-built_in">read</span>(), a[i].g=<span class="hljs-built_in">read</span>(), a[i].s=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;b[++cnt]=a[i];<span class="hljs-built_in">per</span>(j,cnt,<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(b[j].s&lt;b[j<span class="hljs-number">-1</span>].s) <span class="hljs-built_in">swap</span>(b[j],b[j<span class="hljs-number">-1</span>]);dsu.<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>, maxs=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123;<span class="hljs-type">int</span> x=b[j].x, y=b[j].y;x=dsu.<span class="hljs-built_in">get</span>(x), y=dsu.<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123;dsu.f[x]=y, b[++pos]=b[j];<span class="hljs-keyword">if</span>(pos==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(pos==n<span class="hljs-number">-1</span>) ans=<span class="hljs-built_in">min</span>(ans,G*a[i].g+S*b[pos].s);cnt=pos;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans==<span class="hljs-number">5e18</span>? <span class="hljs-number">-1</span>:ans));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf1468j-road-reform">CF1468J Road Reform</h3><p>先求出最小生成树。</p><p>如果 MST 中的存在权值大于 <span class="math inline">\(k\)</span>的边，那么把这些边调整了一定是最优的。根据上文结论即可证明。</p><p>如果 MST 中的边权值小于 <span class="math inline">\(k\)</span>呢？直接将最大边与 <span class="math inline">\(\min_{(x,y,z) \in G}\{|z_i - k|\}\)</span> 替换一下就好了。</p><h3 id="luogu8074-coci2009-20107-svemir">luogu8074 [COCI2009-2010#7]SVEMIR</h3><p>分别按照每个坐标排序，相邻点连边，那么边数就是 <spanclass="math inline">\(O(3n)\)</span> 的，并且一定不会漏掉 MST。</p><p>直接 <span class="math inline">\(\text{Kruskal}\)</span> 就行。</p><h3 id="cf1245d-shichikuji-and-power-grid">CF1245D Shichikuji and PowerGrid</h3><p>建立超级源点 <span class="math inline">\(S\)</span>，向 <spanclass="math inline">\(i\)</span> 连权值为 <spanclass="math inline">\(c_i\)</span> 的无向边。</p><p>求出 MST 即为答案。</p><p>使用 <span class="math inline">\(\text{Prim}\)</span> 算法更优。</p><h3 id="cf888g-xor-mst">CF888G Xor-MST</h3><p>考虑 <span class="math inline">\(\text{Boruvka}\)</span> 算法。</p><p>简介一下它的流程：</p><blockquote><p>对于每一个连通块，枚举其出边。取其最小出边，合并两个连通块。</p><p>每次做完一轮后连通块数量至少减半，最多重复 <spanclass="math inline">\(O(\log_2 n)\)</span> 次，所以复杂度就是 <spanclass="math inline">\(O\Big((n+m) \log_2 n\Big)\)</span>。</p></blockquote><p>考虑把所有 <span class="math inline">\(a_i\)</span> 都扔到 0-1 Trie中去，这样每个叶子节点就对应这原图中一个点。</p><p>我们一定是贪心连权值小的边,对应的在 Trie 上，一个点集的 <spanclass="math inline">\(\operatorname{LCA}\)</span>深度越大，它们之间的边权越小。根据 <spanclass="math inline">\(\text{B}\)</span>姓算法，我们能知道一定是一棵子树内所有的叶子节点连成一个连通块后，再向外扩展。所以0-1 Trie 就是这张完全图对于 <spanclass="math inline">\(\text{B}\)</span> 姓算法的分治树。</p><p>在Trie 上 <spanclass="math inline">\(\text{DFS}\)</span>，设<code>dfs(x,dep)</code>表示把深度为<span class="math inline">\(dep\)</span> 的节点 <spanclass="math inline">\(x\)</span>子树内，所有叶子节点连成一个连通块的最小代价。</p><p>如果存在 <span class="math inline">\(son_0(x)\)</span> 与 <spanclass="math inline">\(son_1(x)\)</span>，那么就枚举其中一个儿子对应的<spanclass="math inline">\(a_i\)</span>，在另一个儿子得子树内查询最小异或值即可，记这个值为<spanclass="math inline">\(res\)</span>，答案就是它再加上往分别往两个儿子搜的代价。这个枚举的过程可以启发式合并进行优化。不过如果我们按照<span class="math inline">\(a_i\)</span> 递增的顺序插入Trie，那么每个节点对应的 <span class="math inline">\(a_i\)</span>得下标都是连续的区间，这样直接枚举就够了。</p><p>否则就直接继承存在的那个儿子的值即可。</p><p>如果存在两个点权值相同怎么办？在完全图中，它们算是等价类。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: G. Xor-MST</span><span class="hljs-comment">// Contest: Codeforces - Educational Codeforces Round 32</span><span class="hljs-comment">// URL: https://codeforces.com/problemset/problem/888/G</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 256 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, a[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> trie[N*<span class="hljs-number">30</span>][<span class="hljs-number">2</span>], l[N*<span class="hljs-number">30</span>], r[N*<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> S,<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">29</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!l[x]) l[x]=id;r[x]=<span class="hljs-built_in">max</span>(r[x],id);<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> S,<span class="hljs-type">int</span> dep)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(dep&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=dep;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) x=trie[x][a^<span class="hljs-number">1</span>], res+=(<span class="hljs-number">1</span>&lt;&lt;i);<span class="hljs-keyword">else</span> x=trie[x][a];&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> dep)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> son0=trie[x][<span class="hljs-number">0</span>], son1=trie[x][<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(son0!=<span class="hljs-number">0</span>&amp;&amp;son1!=<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">1e15</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l[son0];i&lt;=r[son0];++i)ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(son1,a[i],dep<span class="hljs-number">-1</span>)+(<span class="hljs-number">1</span>&lt;&lt;dep));<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(son0,dep<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(son1,dep<span class="hljs-number">-1</span>)+ans;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(son0!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(son0,dep<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(son1!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(son1,dep<span class="hljs-number">-1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125; T;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) T.<span class="hljs-built_in">insert</span>(a[i],i);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,T.<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">29</span>));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf125e-mst-company">CF125E MST Company</h3><p>先对除了 <span class="math inline">\(1\)</span> 之外的 <spanclass="math inline">\(n-1\)</span> 个点做 MST，然后得到 <spanclass="math inline">\(d\)</span> 个连通块。</p><p>如果 <span class="math inline">\(d&gt;k\)</span>，那么无解。</p><p>如果 <span class="math inline">\(d&lt;k\)</span>，先从 <spanclass="math inline">\(1\)</span>往每个连通块连权值最小的那条边，连不完依然无解，然后枚举与 <spanclass="math inline">\(1\)</span>相连的剩下的边。每加入一条新边，就会形成一个环，这条边的代价就是它的权值减去环上的最小权值，注意不考虑<span class="math inline">\(1\)</span> 连出去的那条边。这样取代价前<span class="math inline">\(k-d\)</span> 小的就行。</p><p>找环上最小权值只需要 <span class="math inline">\(\text{DFS}\)</span>一遍。</p><p>复杂度 <span class="math inline">\(O(m \log_2 m + nk)\)</span>。</p><h3 id="cf1253f-cheap-robot">CF1253F Cheap Robot</h3><p>这题很难评价。</p><p>很缝合，但是思路比较自然。</p><p>注意到只有关键点有实际意义。从 <span class="math inline">\(a\)</span>走到 <spanclass="math inline">\(b\)</span>，要么是直接走两个关键点，要么是绕道其他关键点。</p><p>但是有电量的限制，对于边 <spanclass="math inline">\((x,y,z)\)</span>，从任何关键点走过来都需要满足<span class="math inline">\(c \ge dis(x) + dis(y) +z\)</span>，其中<span class="math inline">\(dis(x)\)</span> 表示距离 <spanclass="math inline">\(x\)</span> 最近的关键点，与 <spanclass="math inline">\(x\)</span> 的距离。</p><p>连边 <spanclass="math inline">\(\Big(k_x,k_y,dis(x)+dis(y)+z\Big)\)</span>，其中<span class="math inline">\(k_x\)</span> 是使取到 <spanclass="math inline">\(dis(x)\)</span> 的一个关键点。这样我们只要最小化<span class="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 路径上权值最大的边就行了。考虑 MST的一个性质，任意两点之间路径上的最大边权最小，所以连边之后求出MST，之后用倍增或者树剖做就行了。</p><p>还有一种做法。把询问离线了，枚举每条边的权值当作 <spanclass="math inline">\(c\)</span>，然后加边，用并查集判连通性，在连接两个连通块时回答一个连通块内的询问，启发式合并即可。</p><h3 id="cf1707c-dfs-trees">CF1707C DFS Trees</h3><p><ahref="https://yozora0908.github.io/2023/cf1707c-solution">link</a></p><h3 id="kruskal重构树">Kruskal重构树</h3><p>这个先鸽掉，等到以后有时间再写。</p><p><del>那时候估计已经退役了</del>。</p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>生成树</tag>
      
      <tag>Trie</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2167 [SDOI2009] Bill的挑战 题解</title>
    <link href="/2023/lg2167-solution/"/>
    <url>/2023/lg2167-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="状压dp做法">状压DP做法</h2><p>字符串长度不大，考虑刻画 <span class="math inline">\(T\)</span>的每一位。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 表示考虑了 <spanclass="math inline">\(T\)</span> 的前 <spanclass="math inline">\(i\)</span> 位，匹配了 <spanclass="math inline">\(S\)</span> 内的字符串的方案数。</p><p>枚举下一位的字符，然后把能匹配上的字符集合设为 <spanclass="math inline">\(S_0\)</span>，这样就能转移到 <spanclass="math inline">\(f(i+1,S \cap S_0)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>, mod=<span class="hljs-number">1000003</span>;<span class="hljs-type">int</span> T, n, m, k, U, f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>][<span class="hljs-number">55</span>], v[<span class="hljs-number">30</span>];<span class="hljs-type">char</span> s[N][<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ctz</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]);m=<span class="hljs-built_in">strlen</span>(s[<span class="hljs-number">0</span>]);<span class="hljs-keyword">if</span>(n&lt;k) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[U][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=U;S;--S) <span class="hljs-keyword">if</span>(f[S][i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;++j) &#123;<span class="hljs-type">int</span> S0=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k) <span class="hljs-keyword">if</span>(s[k][i]==<span class="hljs-string">&#x27;?&#x27;</span>||s[k][i]-<span class="hljs-string">&#x27;a&#x27;</span>==j) S0|=(<span class="hljs-number">1</span>&lt;&lt;k);(f[S&amp;S0][i+<span class="hljs-number">1</span>]+=f[S][i])%=mod;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ctz</span>(S)==k) (ans+=f[S][m])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="容斥做法">容斥做法</h2><p>考虑二项式反演。设 <span class="math inline">\(f(k)\)</span>为至少匹配了 <span class="math inline">\(k\)</span> 个串的方案数，<spanclass="math inline">\(g(k)\)</span> 为恰好匹配了 <spanclass="math inline">\(k\)</span> 个串的方案数，那么 <spanclass="math display">\[g(k)=\sum_{i=k}^n \binom{i}{k} (-1)^{i-k} f(i)\]</span> 对于 <spanclass="math inline">\(f(i)\)</span>，我们只需要搜索出任意 <spanclass="math inline">\(i\)</span> 个字符串的并，然后乘上 <spanclass="math inline">\(26^{m-i}\)</span> 即可。</p><p>其中 <span class="math inline">\(m\)</span> 是字符串长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>, mod=<span class="hljs-number">1000003</span>;<span class="hljs-type">int</span> T, n, m, k, U, f[N], pw[<span class="hljs-number">55</span>], C[N][N];<span class="hljs-type">int</span> cup, id[<span class="hljs-number">55</span>];<span class="hljs-type">char</span> s[N][<span class="hljs-number">55</span>], Ts[<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> cnt)</span> </span>&#123;<span class="hljs-keyword">if</span>(n-x+<span class="hljs-number">1</span>+cnt&lt;k) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(x&gt;n) &#123;(f[cnt]+=pw[m-cup])%=mod;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,cnt);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">if</span>(Ts[i]&amp;&amp;s[x][i]!=<span class="hljs-string">&#x27;?&#x27;</span>&amp;&amp;Ts[i]!=s[x][i]) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 有冲突，不能并</span>&#125;<span class="hljs-type">int</span> cc=cup;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!Ts[i]&amp;&amp;s[x][i]!=<span class="hljs-string">&#x27;?&#x27;</span>) Ts[i]=s[x][i], id[++cup]=i;<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,cnt+<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(cup&gt;cc) Ts[id[cup--]]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 撤销求并操作</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>), f[i]=f[i+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; m=<span class="hljs-built_in">strlen</span>(s[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(n&lt;k) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>((i-k)&amp;<span class="hljs-number">1</span>) (ans-=C[i][k]*f[i]%mod-mod)%=mod;<span class="hljs-keyword">else</span> (ans+=C[i][k]*f[i]%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">50</span>) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">26</span>%mod;C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">15</span>) &#123;C[i][<span class="hljs-number">0</span>]=C[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>计数</tag>
      
      <tag>搜索</tag>
      
      <tag>状态压缩</tag>
      
      <tag>二项式反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#10 单调性优化与双指针</title>
    <link href="/2023/noip-record-10/"/>
    <url>/2023/noip-record-10/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="luogu8551-bassline">luogu8551 Bassline</h3><p>题目的限制翻译过来就是 <span class="math inline">\([x,y]\)</span>中任意位置都被覆盖了相同次数。</p><p>用差分求出每个点被覆盖的次数，双指针求极长的满足条件的位置即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, ans, c[N], isl[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> L=<span class="hljs-number">1e15</span>, R=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();L=<span class="hljs-built_in">min</span>(L,l), R=<span class="hljs-built_in">max</span>(R,r);++c[l], --c[r+<span class="hljs-number">1</span>];isl[l]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(i,L,R) c[i]+=c[i<span class="hljs-number">-1</span>];<span class="hljs-type">int</span> l=L, r=L;<span class="hljs-keyword">while</span>(r&lt;=R) &#123;<span class="hljs-keyword">while</span>(r&lt;R&amp;&amp;c[r+<span class="hljs-number">1</span>]==c[r]&amp;&amp;!isl[r+<span class="hljs-number">1</span>]) ++r;ans=<span class="hljs-built_in">max</span>(ans,c[l]*(r-l));l=r=r+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu8587-新的家乡">luogu8587 新的家乡</h3><p>注意到值域不大，直接枚举柱子的高度，然后在值域上双指针匹配即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">6e3</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, mx, mn=<span class="hljs-number">1e5</span>, cnt, h[N], c[M];<span class="hljs-type">bool</span> v[N];<span class="hljs-type">int</span> hh[M], d[M];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> l=mn<span class="hljs-number">-1</span>, r=x-mn, res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=r) &#123;++l;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;!c[l]) ++l;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;!c[r]) --r;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;l+r&gt;x) --r;<span class="hljs-keyword">if</span>(l&lt;=r&amp;&amp;c[l]&amp;&amp;c[r]&amp;&amp;l+r==x) &#123;<span class="hljs-keyword">if</span>(l&lt;r) res+=<span class="hljs-built_in">min</span>(c[l],c[r]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l==r) res+=c[l]/<span class="hljs-number">2</span>;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=<span class="hljs-built_in">read</span>(), ++c[h[i]], mx=<span class="hljs-built_in">max</span>(mx,h[i]), mn=<span class="hljs-built_in">min</span>(mn,h[i]);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,mx) <span class="hljs-keyword">if</span>(c[i]) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,mx) <span class="hljs-keyword">if</span>(c[j]) &#123;<span class="hljs-keyword">if</span>(!v[i+j]) v[i+j]=<span class="hljs-number">1</span>, hh[++cnt]=i+j;&#125;&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;d[i]=<span class="hljs-built_in">solve</span>(hh[i]);res=<span class="hljs-built_in">max</span>(res,d[i]);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-keyword">if</span>(d[i]==res) ++ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,res,ans);&#125;</code></pre></div><h3 id="luogu8590-jroi-8这是新历的朝阳也是旧历的残阳">luogu8590『JROI-8』这是新历的朝阳，也是旧历的残阳</h3><p>最优方案一定是让负数尽可能小，正数尽可能大。因此所有正数必然都被划分进最后一个段，而负数则要在最后一段与第一段中取最大值。</p><p>设最后一个负数的位置是 <spanclass="math inline">\(p\)</span>，不难想到一定存在一个这样的临界位置<span class="math inline">\(p\)</span>，使得 <spanclass="math inline">\([1,p-1]\)</span> 在第 <spanclass="math inline">\(1\)</span> 段（序列单调不降），<spanclass="math inline">\([p,n]\)</span> 在最后一段。设当前分 <spanclass="math inline">\(m\)</span> 段，那就是 <spanclass="math inline">\(i\)</span> 是满足 <spanclass="math inline">\((a_p+1)^2 \le (a_p+m)^2\)</span>的第一个元素，并且随着 <span class="math inline">\(m\)</span>的增长，<span class="math inline">\(p\)</span> 单调不增。</p><p>考虑如何快速统计答案。设划分了 <span class="math inline">\(m\)</span>段，那么答案就是 <span class="math display">\[\sum_{i=1}^{p-1} (a_i+1)^2 + \sum_{i=p}^n (a_i+m)^2\]</span></p><p><span class="math display">\[\sum_{i=1}^{p-1} (a_i^2 + 2a_i+1) + \sum_{i=p}^n (a_i^2 + 2ma_i + m^2)\]</span></p><p><span class="math display">\[\sum_{i=1}^n a_i^2 + 2 \sum_{i=1}^{p-1} a_i + 2m \sum_{i=p}^n a_i +(n-p+1) \times m + p-1\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, k, a[N], s[N], s2[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=n;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">squ</span>(a[mid]+<span class="hljs-number">1</span>)&lt;<span class="hljs-built_in">squ</span>(a[mid]+x)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> l!=n? l:n+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();s[i]=(s[i<span class="hljs-number">-1</span>]+a[i])%mod, s2[i]=(s2[i<span class="hljs-number">-1</span>]+a[i]*a[i])%mod;(ans+=(a[i]+<span class="hljs-number">1</span>)*(a[i]+<span class="hljs-number">1</span>)%mod)%=mod;&#125;<span class="hljs-type">int</span> l=n+<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">2</span>,k) &#123;<span class="hljs-keyword">while</span>(l&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">squ</span>(a[l<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)&lt;=<span class="hljs-built_in">squ</span>(a[l<span class="hljs-number">-1</span>]+x)) --l;(ans+=(s2[l<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>*s[l<span class="hljs-number">-1</span>]%mod+(l<span class="hljs-number">-1</span>))%mod)%=mod;(ans+=(s2[n]-s2[l<span class="hljs-number">-1</span>]+mod)%mod)%=mod;(ans+=<span class="hljs-number">2</span>*(s[n]-s[l<span class="hljs-number">-1</span>]+mod)%mod*x%mod)%=mod;(ans+=(n-l+<span class="hljs-number">1</span>)*x%mod*x%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu8858-折线">luogu8858 折线</h3><p>手玩几下，发现答案只能是 <span class="math inline">\(2,3,4\)</span>其中之一。</p><p>答案是 <span class="math inline">\(2\)</span>的充要条件是把所有点按照 <span class="math inline">\(x\)</span> 或 <spanclass="math inline">\(y\)</span> 排序后，第 <spanclass="math inline">\(\frac{n}{2}\)</span> 和第 <spanclass="math inline">\(\frac{n}{2}+1\)</span> 个点对应的坐标不同。</p><p>而答案是 <span class="math inline">\(4\)</span>的情况不太好直接刻画，考虑从答案为 <spanclass="math inline">\(3\)</span> 下手。</p><p>不难发现如果答案是 <spanclass="math inline">\(3\)</span>，那么一定存在一个这样的结构</p><p><img src="https://i.imgtg.com/2023/07/15/Ozs731.png" srcset="/img/loading.gif" lazyload /></p><p><img src="https://i.imgtg.com/2023/07/15/OzsA2F.png" srcset="/img/loading.gif" lazyload /></p><p>如何求这个东西？</p><p>它最大的特征就是形成了一个横坐标或纵坐标反着的二维偏序。</p><p>对于第一张图的情况，考虑横坐标递减的过程，维护一个纵坐标 <spanclass="math inline">\(j\)</span>，表示能使这条折线下面的点数不小于 <spanclass="math inline">\(\frac{n}{2}\)</span>的折点纵坐标，这玩意也是单调减的。如果在递减的过程中找到了使得下面的点数为<span class="math inline">\(\frac{n}{2}\)</span> 的折点，那么答案就是<span class="math inline">\(3\)</span>。</p><p>对于第二张图的情况，按纵坐标递减，维护横坐标即可。</p><p>需要离散化，然后用树状数组维护点数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, ans, t[<span class="hljs-number">2</span>*N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, y;&#125; a[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a,node b)</span> </span>&#123;<span class="hljs-keyword">return</span> a.x==b.x? a.y&lt;b.y:a.x&lt;b.x;    <span class="hljs-comment">// 按照横坐标排序</span>&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(node a,node b)</span> </span>&#123;<span class="hljs-keyword">return</span> a.y==b.y? a.x&lt;b.x:a.y&lt;b.y;    <span class="hljs-comment">// 按照纵坐标排序</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-t<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].x=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,a[i].x)-t;a[i].y=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,a[i].y)-t;&#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=y;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;&#125; Tr;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();ans=<span class="hljs-number">4</span>, m=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].x=t[++m]=<span class="hljs-built_in">read</span>();a[i].y=t[++m]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">lsh</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp1);<span class="hljs-type">int</span> i=n, j=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(a[n/<span class="hljs-number">2</span>].x!=a[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].x) &#123; ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-number">2ll</span>); <span class="hljs-keyword">goto</span> out; &#125;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span>(a[i].x==a[i<span class="hljs-number">-1</span>].x) Tr.<span class="hljs-built_in">modify</span>(a[i].y,<span class="hljs-number">1</span>), --i;        <span class="hljs-comment">// 坐标相同的点就直接插进去</span>Tr.<span class="hljs-built_in">modify</span>(a[i].y,<span class="hljs-number">1</span>), --i;<span class="hljs-keyword">for</span>(;j&gt;<span class="hljs-number">1</span>&amp;&amp;Tr.<span class="hljs-built_in">query</span>(j<span class="hljs-number">-1</span>)&gt;=n/<span class="hljs-number">2</span>;) --j;<span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">1</span>&amp;&amp;Tr.<span class="hljs-built_in">query</span>(j<span class="hljs-number">-1</span>)&gt;=n/<span class="hljs-number">2</span>) --j;<span class="hljs-keyword">if</span>(Tr.<span class="hljs-built_in">query</span>(j)==n/<span class="hljs-number">2</span>) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-number">3ll</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) Tr.<span class="hljs-built_in">modify</span>(a[i].y,<span class="hljs-number">-1</span>);<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp2);<span class="hljs-keyword">if</span>(a[n/<span class="hljs-number">2</span>].y!=a[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].y) &#123; ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-number">2ll</span>); <span class="hljs-keyword">goto</span> out; &#125;i=n, j=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span>(a[i].y==a[i<span class="hljs-number">-1</span>].y) Tr.<span class="hljs-built_in">modify</span>(a[i].x,<span class="hljs-number">1</span>), --i;Tr.<span class="hljs-built_in">modify</span>(a[i].x,<span class="hljs-number">1</span>), --i;<span class="hljs-keyword">for</span>(;j&gt;<span class="hljs-number">1</span>&amp;&amp;Tr.<span class="hljs-built_in">query</span>(j<span class="hljs-number">-1</span>)&gt;=n/<span class="hljs-number">2</span>;) --j;<span class="hljs-keyword">if</span>(Tr.<span class="hljs-built_in">query</span>(j)==n/<span class="hljs-number">2</span>) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-number">3ll</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) Tr.<span class="hljs-built_in">modify</span>(a[i].x,<span class="hljs-number">-1</span>);out: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="luogu7514-省选联考-2021-ab-卷-卡牌游戏">luogu7514 [省选联考 2021A/B 卷] 卡牌游戏</h3><p>把正反卡牌都放到一起排序，那么一种方案的极差就是一个区间的左右端点之差。一个区间<span class="math inline">\([l,r]\)</span>是合法的，意味着区间内不存在相同的卡牌编号，以及出现反面不超过 <spanclass="math inline">\(m\)</span> 次，等价于 <spanclass="math inline">\([1,l-1]\)</span> 与 <spanclass="math inline">\([r+1,n]\)</span>不出现相同的卡牌编号，并且出现正面不超过 <spanclass="math inline">\(m\)</span> 次。</p><p>考虑右端点递增的过程，不难发现对应的 <spanclass="math inline">\(l\)</span>单调不降。因此只需要在一个初始区间上双指针维护即可。</p><p>如何找这个初始区间呢？我们考虑的是 <spanclass="math inline">\(r\)</span> 递增的过程，所以只要在最小化 <spanclass="math inline">\(r\)</span> 的基础上，找到最大的 <spanclass="math inline">\(l\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans=<span class="hljs-number">1e15</span>;<span class="hljs-type">bool</span> v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">cd</span> &#123;<span class="hljs-type">int</span> x, id, st;&#125; a[<span class="hljs-number">2</span>*N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(cd a,cd b) &#123;<span class="hljs-keyword">return</span> a.x&lt;b.x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i].x=<span class="hljs-built_in">read</span>(), a[i].id=i, a[i].st=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i+n].x=<span class="hljs-built_in">read</span>(), a[i+n].id=i, a[i+n].st=<span class="hljs-number">0</span>;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">2</span>*n, cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(cnt+a[r].st&lt;=m&amp;&amp;!v[a[r].id]) v[a[r].id]=<span class="hljs-number">1</span>, cnt+=a[r].st, --r;<span class="hljs-keyword">while</span>(cnt+a[l].st&lt;=m&amp;&amp;!v[a[l].id]) v[a[l].id]=<span class="hljs-number">1</span>, cnt+=a[l].st, ++l;ans=<span class="hljs-built_in">min</span>(ans,a[r].x-a[l].x);<span class="hljs-keyword">while</span>(r&lt;<span class="hljs-number">2</span>*n) &#123;v[a[r+<span class="hljs-number">1</span>].id]=<span class="hljs-number">0</span>, cnt-=a[r+<span class="hljs-number">1</span>].st, ++r;<span class="hljs-keyword">while</span>(cnt+a[l].st&lt;=m&amp;&amp;!v[a[l].id]) v[a[l].id]=<span class="hljs-number">1</span>, cnt+=a[l].st, ++l;ans=<span class="hljs-built_in">min</span>(ans,a[r].x-a[l].x);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu4805-ccc2016-合并饭团">luogu4805 [CCC2016] 合并饭团</h3><p>先转化一下题意。虽然不像石子合并一样需要把所有饭团合并成一个，但是直接当要求合并成一个来做就行，因为任何饭团都是由一个区间内所有饭团合并而来的。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 表示 <spanclass="math inline">\([i,j]\)</span>能合并成一个多大的饭团，那么只有第一种合并方式的情况就做完了。仔细想想合并满足结合律，如果一个区间能合并成一个，那么所有合并方式得到的结果都相同。</p><p>考虑第二种操作。一种直接做的方法是，对于每个 <spanclass="math inline">\(f(k,j)\)</span>，把它扔进值域桶里面，并记录对应的<span class="math inline">\(k\)</span>。然后枚举 <spanclass="math inline">\(f(i,k&#39;)\)</span>，找到桶里 <spanclass="math inline">\(f(i,k&#39;)\)</span> 这个值对应的 <spanclass="math inline">\(k\)</span>，并判断 <spanclass="math inline">\(f(k&#39;+1,k-1)\)</span>能否合并成一个，最后取最大值即可。这样做需要用到<code>std::unordered_map</code>，效率较低。</p><p>考虑直接维护中间那个饭团对应的区间 <spanclass="math inline">\([l,r]\)</span>，由于长度更大的区间能合并成的饭团更大，所以是有单调性的，用双指针匹配即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">405</span>;<span class="hljs-type">int</span> n, ans, f[N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][i]=<span class="hljs-built_in">read</span>(), ans=<span class="hljs-built_in">max</span>(ans,f[i][i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;++k) <span class="hljs-keyword">if</span>(f[i][k]&amp;&amp;f[k+<span class="hljs-number">1</span>][j]&amp;&amp;f[i][k]==f[k+<span class="hljs-number">1</span>][j]) &#123;f[i][j]=f[i][k]+f[k+<span class="hljs-number">1</span>][j];<span class="hljs-keyword">break</span>;&#125;<span class="hljs-type">int</span> L=i, R=j;<span class="hljs-keyword">while</span>(L&lt;=R<span class="hljs-number">-2</span>) &#123;<span class="hljs-keyword">while</span>(L&lt;=R<span class="hljs-number">-2</span>&amp;&amp;!f[i][L]) ++L;<span class="hljs-keyword">while</span>(L&lt;=R<span class="hljs-number">-2</span>&amp;&amp;!f[R][j]) --R;<span class="hljs-keyword">if</span>(f[i][L]&lt;f[R][j]) ++L;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[i][L]&gt;f[R][j]) --R;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!f[L+<span class="hljs-number">1</span>][R<span class="hljs-number">-1</span>]) ++L, --R;<span class="hljs-keyword">if</span>(L&lt;=R<span class="hljs-number">-2</span>&amp;&amp;f[i][L]&amp;&amp;f[L+<span class="hljs-number">1</span>][R<span class="hljs-number">-1</span>]&amp;&amp;f[R][j]&amp;&amp;f[i][L]==f[R][j]) &#123;f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][L]+f[L+<span class="hljs-number">1</span>][R<span class="hljs-number">-1</span>]+f[R][j]);<span class="hljs-keyword">break</span>;&#125;&#125;ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu3724-ahoi2017hnoi2017-大佬">luogu3724 [AHOI2017/HNOI2017]大佬</h3><p><ahref="https://yozora0908.github.io/2023/lg3724-solution">link</a></p><h3 id="luogu6563-sbcoi2020-一直在你身旁">luogu6563 [SBCOI2020]一直在你身旁</h3><p><ahref="https://yozora0908.github.io/2023/lg6563-solution">link</a></p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间DP</tag>
      
      <tag>树状数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3724 [AHOI2017/HNOI2017] 大佬 题解</title>
    <link href="/2023/lg3724-solution/"/>
    <url>/2023/lg3724-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>题意很复杂，我们要从中提取关键信息。</p><p>增加等级、嘲讽能力都是为了怼大佬服务，而怼大佬最多使用 <spanclass="math inline">\(2\)</span>次，我们尝试把这个操作单独拿出来，这样要考虑的就只剩下了还嘴和做水题。</p><p>考虑这样一个东西：由于我们保证自己不死，所以除了做水题回血之外，剩下的时间都可以空出来，在我们需要的时候手动添加具体操作。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 天，空出来了 <spanclass="math inline">\(j\)</span> 天，所剩下的最大体力。 <spanclass="math display">\[f_{i,j} = \max\begin{cases}\min(f_{i-1,j} - a_i + w_i,mc) &amp; f_{i-1,j} \ge a_i\\f_{i-1,j-1} - a_i &amp; f_{i-1,j-1} \ge a_i\end{cases}\]</span> 然后取 <span class="math inline">\(maxd\)</span> 为所有满足<span class="math inline">\(f_{i,j} \ge 0\)</span> 的最大的 <spanclass="math inline">\(j\)</span>，表示能空出的最大天数。</p><p>注意不一定要取 <spanclass="math inline">\(f_{n,j}\)</span>，因为如果在第 <spanclass="math inline">\(n\)</span>天之前把大佬干掉并且自己存活，那么也算胜利。因此如果 <spanclass="math inline">\(maxd\)</span> 不在 <spanclass="math inline">\(f_{n,j}\)</span> 处取得并且能在 <spanclass="math inline">\(maxd\)</span>天之内干掉大佬，那么无妨；如果干不死，那么取 <spanclass="math inline">\(f_{n,j}\)</span> 处的也干不掉。</p><p>如果 <span class="math inline">\(C \lemaxd\)</span>，那么每天还嘴就行，否则就需要在 <spanclass="math inline">\(maxd\)</span>天之内安排一次或两次怼大佬，但是怼大佬也不一定总是比还嘴优，不太好处理。</p><p>但是 <span class="math inline">\(maxd\)</span>并不大，考虑把所有合法的怼大佬方法都搜索出来。设 <spanclass="math inline">\((d,F,L)\)</span> 为用时 <spanclass="math inline">\(d\)</span> 天，能力为 <spanclass="math inline">\(F\)</span>，等级为 <spanclass="math inline">\(L\)</span> 的状态。</p><p>如果是怼一次大佬，那么直接枚举所有状态，找到 <spanclass="math inline">\(F+maxd-d \ge C\)</span> 的状态即可。</p><p>如果一次不够，那么我们就找两个满足 <spanclass="math inline">\(F_1+F_2+maxd-d_1-d_2 \ge C\)</span>的状态。注意到式子的值与 <span class="math inline">\(F\)</span>正相关，与 <span class="math inline">\(d\)</span> 负相关，那就按照 <spanclass="math inline">\(F\)</span> 递增为第一关键字，<spanclass="math inline">\(d\)</span> 递减为第二关键字排序。这样对于一个<span class="math inline">\((d_1,F_1,L_1)\)</span>，其最优决策就是满足<span class="math inline">\(F_1+F_2 \le C\)</span> 的编号最大的 <spanclass="math inline">\((d_2,F_2,L_2)\)</span>，同时 <spanclass="math inline">\(F_1\)</span>具有单调性，决策也就单调了，用双指针做就行。</p><p>最后是如何搜索的问题。虽然状态有三维，直观上数量不在少数，但是只有<span class="math inline">\((F,L)\)</span> 才有用，<spanclass="math inline">\(d\)</span> 这一维是要用最优化的。<spanclass="math inline">\(d\)</span> 每次只会增长 <spanclass="math inline">\(1\)</span>，用 <spanclass="math inline">\(\text{BFS}\)</span>即可。记录状态可以用<code>std::map&lt;pair&lt;int,int&gt;,bool&gt;</code>，但效率不高。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, m, mc, maxd, a[N], w[N];<span class="hljs-type">int</span> f[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> d, L, F;<span class="hljs-built_in">node</span>() &#123;&#125;;<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _d,<span class="hljs-type">int</span> _L,<span class="hljs-type">int</span> _F) &#123; d=_d, L=_L, F=_F; &#125;;&#125;;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123;<span class="hljs-keyword">if</span>(a.F!=b.F) <span class="hljs-keyword">return</span> a.F&lt;b.F;<span class="hljs-keyword">if</span>(a.d!=b.d) <span class="hljs-keyword">return</span> a.d&gt;b.d;<span class="hljs-keyword">return</span> a.L&lt;b.L;&#125;vector&lt;node&gt; st;map&lt;PII,<span class="hljs-type">bool</span>&gt; p;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;node&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), st.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));    <span class="hljs-comment">// 初始d设置为1，把怼大佬那一天提前算了</span>p[<span class="hljs-built_in">MP</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// pair要存(L,F)，否则TLE</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;node x=q.<span class="hljs-built_in">front</span>(), s; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(x.d&gt;=maxd) <span class="hljs-keyword">continue</span>;PII t=<span class="hljs-built_in">MP</span>(x.L+<span class="hljs-number">1</span>,x.F);<span class="hljs-keyword">if</span>(p[t]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(x.d&lt;maxd) &#123;p[t]=<span class="hljs-number">1</span>;s=<span class="hljs-built_in">node</span>(x.d+<span class="hljs-number">1</span>,x.L+<span class="hljs-number">1</span>,x.F);q.<span class="hljs-built_in">push</span>(s), st.<span class="hljs-built_in">pb</span>(s);&#125;t=<span class="hljs-built_in">MP</span>(x.L,x.F*x.L);<span class="hljs-keyword">if</span>(t.fi&lt;=<span class="hljs-number">1</span>||t.se&gt;<span class="hljs-number">1e8</span>||p[t]) <span class="hljs-keyword">continue</span>;p[t]=<span class="hljs-number">1</span>;s=<span class="hljs-built_in">node</span>(x.d+<span class="hljs-number">1</span>,x.L,x.F*x.L);q.<span class="hljs-built_in">push</span>(s), st.<span class="hljs-built_in">pb</span>(s);&#125;<span class="hljs-built_in">sort</span>(st.<span class="hljs-built_in">begin</span>(),st.<span class="hljs-built_in">end</span>());&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), mc=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=mc;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,i) &#123;<span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>][j]&gt;=a[i]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][j]-a[i]+w[i],mc));<span class="hljs-keyword">if</span>(j&amp;&amp;f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&gt;=a[i]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]-a[i]);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i) <span class="hljs-keyword">if</span>(f[i][j]&gt;=<span class="hljs-number">0</span>) maxd=<span class="hljs-built_in">max</span>(maxd,j);<span class="hljs-built_in">bfs</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> C=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(C&lt;=maxd) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=st.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;st.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">if</span>(st[i].F&lt;=C&amp;&amp;st[i].F+maxd-st[i].d&gt;=C) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">goto</span> qwq; &#125;&#125;<span class="hljs-keyword">for</span>(;l&lt;=r;++l) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;st[l].F+st[r].F&gt;C) --r;<span class="hljs-keyword">if</span>(l&lt;=r&amp;&amp;st[l].F+st[r].F+maxd-st[l].d-st[r].d&gt;=C) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">goto</span> qwq; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);qwq:;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>搜索</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3943 星空 题解</title>
    <link href="/2023/lg3943-solution/"/>
    <url>/2023/lg3943-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>注意到区间异或可以差分成端点异或，所以把序列差分了，并且能发现差分之后最多有<span class="math inline">\(2k\)</span> 个需要修改的位置。</p><p>又因为当一个序列的首项与差分序列确定时，这个序列也被唯一确定了，所以我们可以提取出那些需要修改的位置，压成一个整数<span class="math inline">\(S\)</span>，并且处理它们之间的距离。</p><p>反转长度为 <span class="math inline">\(b\)</span>的区间提供了两种在差分序列上的操作：</p><ol type="1"><li>干掉 <span class="math inline">\(S\)</span> 中距离为 <spanclass="math inline">\(b+1\)</span> 的两个 <spanclass="math inline">\(1\)</span>。</li><li>干掉 <span class="math inline">\(S\)</span> 中距离 <spanclass="math inline">\(n+1\)</span> 不超过 <spanclass="math inline">\(b+1\)</span> 的一个 <spanclass="math inline">\(1\)</span>。</li><li>让一个 <span class="math inline">\(1\)</span> 向左或向右移动 <spanclass="math inline">\(b+1\)</span> 位。</li></ol><p>如果我们多次使用三种操作，就能求出 <spanclass="math inline">\(g(i)\)</span> 表示消去距离为 <spanclass="math inline">\(i\)</span> 的两个 <spanclass="math inline">\(1\)</span> 的最小代价。这个可以用 <spanclass="math inline">\(\text{BFS}\)</span>处理。注意由于操作有重叠，所以只有第一次使用操作时距离才是 <spanclass="math inline">\(b+1\)</span>，否则都是 <spanclass="math inline">\(b\)</span>。</p><p>这样就可以 DP 了。设 <span class="math inline">\(f(S)\)</span>为从初始状态到达 <span class="math inline">\(S\)</span> 的最小代价。</p><p>按秩转移，钦定 <spanclass="math inline">\(\operatorname{lowbit}(S)\)</span>是最后一个被干掉的。枚举与它一起被干掉的 <spanclass="math inline">\(1\)</span> 或者直接扔到 <spanclass="math inline">\(n+1\)</span> 去，取最小值即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3943 星空</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3943</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-18 07:33:28</span><span class="hljs-comment">// Memory Limit: 250 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e4</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, k, m, st, p[N], c[N], a[<span class="hljs-number">20</span>], b[<span class="hljs-number">70</span>], d[<span class="hljs-number">20</span>];<span class="hljs-type">int</span> cnt, g[N], f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>], lg[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0x3f</span>);queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) q.<span class="hljs-built_in">push</span>(b[i]), g[b[i]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(x+b[i]<span class="hljs-number">-1</span>&lt;=n+<span class="hljs-number">1</span>&amp;&amp;g[x+b[i]<span class="hljs-number">-1</span>]==inf) g[x+b[i]<span class="hljs-number">-1</span>]=g[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(x+b[i]<span class="hljs-number">-1</span>);<span class="hljs-keyword">if</span>(x-b[i]+<span class="hljs-number">1</span>&gt;<span class="hljs-number">0</span>&amp;&amp;g[x-b[i]+<span class="hljs-number">1</span>]==inf) g[x-b[i]+<span class="hljs-number">1</span>]=g[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(x+b[i]<span class="hljs-number">-1</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(p[<span class="hljs-number">1</span>]) st=<span class="hljs-number">1</span>, ++cnt, d[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=p[i<span class="hljs-number">-1</span>]^p[i];<span class="hljs-keyword">if</span>(x) &#123;d[cnt]=i;st|=(<span class="hljs-number">1</span>&lt;&lt;cnt);++cnt;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;-x; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();p[x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) b[i]=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>; <span class="hljs-comment">// 注意这里+1了</span><span class="hljs-built_in">bfs</span>();<span class="hljs-built_in">init</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);f[st]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*k;++i) lg[<span class="hljs-number">1</span>&lt;&lt;i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=st;S;S=(S<span class="hljs-number">-1</span>)&amp;st) &#123;<span class="hljs-type">int</span> i=lg[<span class="hljs-built_in">lowbit</span>(S)];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S0=S-<span class="hljs-built_in">lowbit</span>(S);S0;S0-=<span class="hljs-built_in">lowbit</span>(S0)) &#123;<span class="hljs-type">int</span> j=lg[<span class="hljs-built_in">lowbit</span>(S0)];<span class="hljs-keyword">if</span>(g[d[j]-d[i]+<span class="hljs-number">1</span>]!=inf) f[S^(<span class="hljs-number">1</span>&lt;&lt;i)^(<span class="hljs-number">1</span>&lt;&lt;j)]=<span class="hljs-built_in">min</span>(f[S^(<span class="hljs-number">1</span>&lt;&lt;i)^(<span class="hljs-number">1</span>&lt;&lt;j)],f[S]+g[d[j]-d[i]+<span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span>(g[n+<span class="hljs-number">1</span>-d[i]+<span class="hljs-number">1</span>]!=inf) f[S^(<span class="hljs-number">1</span>&lt;&lt;i)]=<span class="hljs-built_in">min</span>(f[S^(<span class="hljs-number">1</span>&lt;&lt;i)],f[S]+g[n+<span class="hljs-number">1</span>-d[i]+<span class="hljs-number">1</span>]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>差分</tag>
      
      <tag>搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#9 状态压缩</title>
    <link href="/2023/noip-record-9/"/>
    <url>/2023/noip-record-9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>聊聊状态压缩。</p><p>顾名思义，就是把一个状态压成一个整数，从而使得问题的所有状态可以度量。</p><p>一般都是用二进制状态压缩来表示子集与全集的关系，对应着二进制每一位都是<span class="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span>。更高的进制能表示更多的信息，但状态的数量也会随之增加，并且实现的时候要自己手写位运算，较为复杂，本文不会涉及。</p><h2 id="信息的表示">信息的表示</h2><h3 id="luogu7076-csp-s2020-动物园">luogu7076 [CSP-S2020] 动物园</h3><p>题意比较绕。</p><p>一个 <span class="math inline">\((p_i,q_i)\)</span>相当于对二进制中第 <span class="math inline">\(p_i\)</span>位进行了限制。把所有 <span class="math inline">\(p_i\)</span>压成一个整数，如果这个数第 <span class="math inline">\(i\)</span> 位为<span class="math inline">\(1\)</span> 并且没有 <spanclass="math inline">\(a_j\)</span> 满足这一位是 <spanclass="math inline">\(1\)</span>，那么所有编号第 <spanclass="math inline">\(i\)</span> 位是 <spanclass="math inline">\(1\)</span> 的动物就不能选。</p><p>把不能选的位压成一个整数 <spanclass="math inline">\(t\)</span>，那么能选的动物的编号，在所有 <spanclass="math inline">\(t\)</span> 中为 <spanclass="math inline">\(1\)</span> 的数位上都是 <spanclass="math inline">\(0\)</span>，答案就是 <span class="math display">\[2^{k-\operatorname{popcount}(t)} - n\]</span> 注意可能会爆<code>unsigned long long</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function">uint <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;uint a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;uint n, m, c, k, a[N], p[N], q[N];uint h[<span class="hljs-number">70</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(uint x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;~i;--i) <span class="hljs-keyword">if</span>(x&amp;(<span class="hljs-number">1ull</span>&lt;&lt;i)) ++h[i];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(uint x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(a[i]);&#125;uint cc=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;p[i]=<span class="hljs-built_in">read</span>(), q[i]=<span class="hljs-built_in">read</span>();cc|=(<span class="hljs-number">1ull</span>&lt;&lt;p[i]);&#125;uint ng=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(h[i]==<span class="hljs-number">0</span>&amp;&amp;cc&amp;(<span class="hljs-number">1ull</span>&lt;&lt;i)) ng|=(<span class="hljs-number">1ull</span>&lt;&lt;i);&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-built_in">popcount</span>(ng);<span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k!=<span class="hljs-number">64</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,(<span class="hljs-number">1ull</span>&lt;&lt;(k-cnt))-n);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(cnt!=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,(<span class="hljs-number">1ull</span>&lt;&lt;(k-cnt))-n);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n!=<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,<span class="hljs-number">0</span>-n);&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;18446744073709551616&quot;</span>);&#125;&#125;</code></pre></div><h3 id="luogu1357-花园">luogu1357 花园</h3><p>把<code>P</code>看作 <spanclass="math inline">\(0\)</span>，<code>C</code>看作 <spanclass="math inline">\(1\)</span>，然后把 <spanclass="math inline">\(m\)</span> 个花圃的状态压成一个整数。</p><p>同时值域不大，可以用 <span class="math inline">\(\text{DFS}\)</span>搜出所有合法状态。</p><p>断环为链，则环等价于序列 <spanclass="math inline">\([1,n+m]\)</span>，同时要求 <spanclass="math inline">\([1,n]\)</span> 与 <spanclass="math inline">\([n,n+m-1]\)</span> 相同。任意相邻 <spanclass="math inline">\(m\)</span>个花圃不同，可以看作是在一个合法状态上删掉前面一位，加上后面一位，这样向前推进<span class="math inline">\(n\)</span>次。于是在上一步处理合法状态时，顺便处理状态之间的这样的转移。</p><p>这里用到一个Trick，对于这种环上状态压缩，可以用处理序列的方法做，最后让开头和结尾相同即可。</p><p><span class="math inline">\(n\)</span>很大，状态数很少且满足结合律，可以使用矩阵加速。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P1357 花园</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P1357</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-19 16:15:49</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, k, U, ok[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(m,<span class="hljs-number">0</span>); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,U) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; a, c;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=U;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=U;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=U;++j)(c.m[i][j]+=a.m[i][k]*b.m[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nbuna</span><span class="hljs-params">(<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> S)</span> </span>&#123;ok[S]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> S0=S&gt;&gt;<span class="hljs-number">1</span>;a.m[S0][S]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// S0是去掉第一位，最后一位不放1</span><span class="hljs-keyword">if</span>(j==k&amp;&amp;(S&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 如果已经放满k个1并且去掉的第一位不是1，说明还有k个1</span>a.m[S0|(<span class="hljs-number">1</span>&lt;&lt;(m<span class="hljs-number">-1</span>))][S]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 这里是最后一位放1</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-keyword">if</span>(i==m) &#123; <span class="hljs-built_in">nbuna</span>(j,S); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,S);<span class="hljs-keyword">if</span>(j&lt;k) <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>,S|(<span class="hljs-number">1</span>&lt;&lt;i));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);c=<span class="hljs-built_in">fp</span>(a,n);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,U) <span class="hljs-keyword">if</span>(ok[i]) (ans+=c.m[i][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="arc058e-和風いろはちゃん">ARC058E 和風いろはちゃん</h3><p>注意到只有和为 <span class="math inline">\(X+Y+Z\)</span>的那一段才有用，这一段的方案数可以直接插板出来。但是没什么用，因为如果把这一段与其他部分分开做，就会产生重复。</p><p>我们考虑 <span class="math inline">\(DP\)</span>。</p><p>直观上本题的非法方案要比合法方案更好求，这里选择求非法方案数。</p><div class="note note-success">            <p>事实上，求出合法方案也并不困难，不过为了去重，需要在第一次满足条件时统计贡献。</p>          </div><p>注意到 <span class="math inline">\(X+Y+Z\)</span>很小，我们希望有一种方式能够让我们知道一个位置总和恰好为 <spanclass="math inline">\(X+Y+Z\)</span>若干位置，是否能划分成合法的三段。</p><p>考虑把这个看成一个二进制数。二进制数中，每个 <spanclass="math inline">\(1\)</span> 代表一个元素，这个元素的值就是 <spanclass="math inline">\(1\)</span> 加上它与下一个 <spanclass="math inline">\(1\)</span> 之间 <spanclass="math inline">\(0\)</span> 的个数，也就是说 <spanclass="math inline">\(x\)</span> 被表示为 <spanclass="math inline">\(2^{x-1}\)</span>。这样任何和为 <spanclass="math inline">\(X+Y+Z\)</span>的情况，我们都能用一个二进制数表示，并且它的上界是 <spanclass="math inline">\(17\)</span> 个 <spanclass="math inline">\(1\)</span>，也就是 <spanclass="math inline">\(2^{18}-1\)</span>。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 为考虑了前 <spanclass="math inline">\(i\)</span> 位，其中 <spanclass="math inline">\(i\)</span> 前面和为 <spanclass="math inline">\(X+Y+Z\)</span> 的一段的情况为 <spanclass="math inline">\(S\)</span> 的方案数。</p><p>转移枚举下一个元素填什么，并且更新 <spanclass="math inline">\(S\)</span> 即可，细节见代码。注意任何时候 <spanclass="math inline">\(S\)</span> 都不能被分成合法的三段。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">42</span>, M=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, X, Y, Z;<span class="hljs-type">int</span> U, f[N][M];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-type">int</span> k1=(S&gt;&gt;(Z<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>;<span class="hljs-type">int</span> k2=(S&gt;&gt;(Y+Z<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>;<span class="hljs-type">int</span> k3=(S&gt;&gt;(X+Y+Z<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(k1&amp;&amp;k2&amp;&amp;k3) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当三者均为1时，就能划分出X+Y+Z</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), X=<span class="hljs-built_in">read</span>(), Y=<span class="hljs-built_in">read</span>(), Z=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;(X+Y+Z))<span class="hljs-number">-1</span>;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;++j) &#123;<span class="hljs-type">int</span> T=((S&lt;&lt;j)+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>)))&amp;U;            <span class="hljs-comment">//扔掉后面的j位，加上当前值</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">valid</span>(T)) (f[i][T]+=f[i<span class="hljs-number">-1</span>][S])%=mod;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-built_in">fp</span>(<span class="hljs-number">10</span>,n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) (ans-=f[n][S]-mod)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="状压-dp">状压 DP</h2><p>状态压缩使得状态可以度量，从而便于对复杂状态进行 DP。</p><p>有一个Trick，名叫按秩转移。本质上是根据集合的无序性钦定基准点，从而减少不必要的状态数。基准点一般选取<span class="math inline">\(\operatorname{lowbit}(S)\)</span>。</p><p>在下面的题目中会有所涉及。</p><h3 id="luogu3959-noip2017-提高组-宝藏">luogu3959 [NOIP2017 提高组]宝藏</h3><p>太经典了。</p><p>打通的一定是一棵生成树，不难想到对生成树树高进行状压。</p><p>设 <span class="math inline">\(f(x,S)\)</span> 为当前树高为 <spanclass="math inline">\(x\)</span>，已经打通的节点集合为 <spanclass="math inline">\(S\)</span> 的最小代价。 <spanclass="math display">\[f(x,S) = \min_{S_0 \subseteq S }\Big\{ f(x-1,S_0) + x \times d(S\setminus S_0,S_0) \Big\}\]</span> 其中 <span class="math inline">\(d(S,S_0)\)</span>表示已经打通 <span class="math inline">\(S\)</span> 中节点后，打通 <spanclass="math inline">\(S_0\)</span> 中节点的最小代价。</p><p>本题的瓶颈在于预处理 <span class="math inline">\(d\)</span>。</p><p>朴素的做法是枚举集合 <span class="math inline">\(S\)</span> 以及<span class="math inline">\(U-S\)</span> 的子集 <spanclass="math inline">\(T\)</span>，然后 <spanclass="math inline">\(O(n^2)\)</span> 算出从 <spanclass="math inline">\(S\)</span> 中任意节点到达 <spanclass="math inline">\(T\)</span> 中每个节点的最小代价，它们的和就是<span class="math inline">\(d(S,T)\)</span>。复杂度 <spanclass="math inline">\(O(n^2 2^n)\)</span>。</p><p>使用上述技巧按秩转移。在计算 <spanclass="math inline">\(d(S,T)\)</span> 时，我们已经算完了 <spanclass="math inline">\(d\Big(S,T-\operatorname{lowbit}(T)\Big)\)</span>，所以只需要额外对<span class="math inline">\(\operatorname{lowbit}(T)\)</span>求一边最小值即可。复杂度 <span class="math inline">\(O(n2^n)\)</span>。</p><p>然而我们常用的枚举子集的代码，子集是从大到小枚举的。因此可以先存下来再从小到大求。</p><p>使用 <span class="math inline">\(\text{DFS}\)</span>转移这个状态会跑得很快，不再赘述。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, U, ans=inf, dis[N][N], d[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>];<span class="hljs-type">int</span> f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>], nxt[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>], lg[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123; <span class="hljs-keyword">return</span> S&amp;-S; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) lg[<span class="hljs-number">1</span>&lt;&lt;i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">1</span>;S&lt;=U;++S) &#123;<span class="hljs-type">int</span> T=U^S, cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S0=T;S0;S0=(S0<span class="hljs-number">-1</span>)&amp;T) nxt[S0]=cnt, cnt=S0;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S0=cnt;S0;S0=nxt[S0]) &#123;<span class="hljs-type">int</span> x=lg[<span class="hljs-built_in">lowbit</span>(S0)], t=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;y&lt;n;++y) <span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;y)) t=<span class="hljs-built_in">min</span>(t,dis[x][y]);<span class="hljs-type">int</span> pre=d[S][S0^<span class="hljs-built_in">lowbit</span>(S0)];<span class="hljs-keyword">if</span>(t!=inf&amp;&amp;pre!=inf) d[S][S0]=pre+t;<span class="hljs-keyword">else</span> d[S][S0]=inf;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">SET</span>(dis,<span class="hljs-number">0x3f</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, z=<span class="hljs-built_in">read</span>();dis[x][y]=dis[y][x]=<span class="hljs-built_in">min</span>(dis[x][y],z);&#125;U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">prework</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>&lt;&lt;i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">1</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> T=S;T;T=(T<span class="hljs-number">-1</span>)&amp;S) <span class="hljs-keyword">if</span>(d[S^T][T]!=inf) f[i][S]=<span class="hljs-built_in">min</span>(f[i][S],f[i<span class="hljs-number">-1</span>][S^T]+i*d[S^T][T]);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n) ans=<span class="hljs-built_in">min</span>(ans,f[i][U]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="cf11d-a-simple-task">CF11D A Simple Task</h3><p>典题。</p><p>设 <span class="math inline">\(f(x,y,S)\)</span> 为只经过点集 <spanclass="math inline">\(S\)</span> 中的点，<spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 有多少路径，转移枚举中间点。</p><p>然而有很多环被重复统计了多次，而且数组开不下。</p><p>按秩转移。考虑让 <spanclass="math inline">\(y=\operatorname{lowbit}(S)\)</span>作为基准点，这样状态就成了 <spanclass="math inline">\(f(x,S)\)</span>，规模可以承受。</p><p>对于一个 <span class="math inline">\(f(x,S)\)</span>，枚举 <spanclass="math inline">\((x \rightarrow y)\)</span>，当 <spanclass="math inline">\(y=\operatorname{lowbit}(S)\)</span>说明找到了环，计入答案。否则只在 <span class="math inline">\(y\)</span>可能作为 <span class="math inline">\(S\)</span> 后继状态的基准点，也就是<span class="math inline">\(2^y \ge \operatorname{lowbit}(S)\)</span>时转移到 <span class="math inline">\(f(x,S \cup \{j\})\)</span>。</p><p>复杂度 <span class="math inline">\(O(n^2 2^n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">3092</span> [USACO13NOV] No Change G<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<span class="hljs-type">int</span> n, m, U, ans, a[N][N], f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123; <span class="hljs-keyword">return</span> S&amp;-S; &#125;;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;a[x][y]=a[y][x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) f[i][<span class="hljs-number">1</span>&lt;&lt;i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">1</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;<span class="hljs-keyword">if</span>(!f[i][S]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) <span class="hljs-keyword">if</span>(a[i][j]) &#123;<span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)&lt;<span class="hljs-built_in">lowbit</span>(S)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)==<span class="hljs-built_in">lowbit</span>(S)) ans+=f[i][S];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((S&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>) f[j][S|(<span class="hljs-number">1</span>&lt;&lt;j)]+=f[i][S];&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans-m)&gt;&gt;<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="luogu3092-usaco13nov-no-change-g">luogu3092 [USACO13NOV] NoChange G</h3><p>看得出来是一个区间划分类题目。</p><p>设 <span class="math inline">\(f(S)\)</span> 为集合 <spanclass="math inline">\(S\)</span>内的硬币能够买到的最多物品。这个和顺序有关，转移时枚举最后一个使用的硬币，二分即可。</p><p>设 <span class="math inline">\(g(S)\)</span>为在能买下所有物品的情况下，集合 <span class="math inline">\(S\)</span>内硬币的总价值。</p><p>枚举没有使用的硬币集合 <span class="math inline">\(S\)</span>，如果<span class="math inline">\(f(U \setminus S)=n\)</span>，那么就从 <spanclass="math inline">\(\operatorname{lowbit}\)</span> 处更新 <spanclass="math inline">\(g(S)\)</span>，同时更新答案。</p><div class="code-wrapper"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>, M=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> k, n, U, ans=<span class="hljs-number">-1</span>, c[N], s[M], f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>], g[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>], lg[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bs</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> l=L, r=n;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(s[mid]-s[L<span class="hljs-number">-1</span>]&lt;=x) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;-x; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;k=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) c[i]=<span class="hljs-built_in">read</span>(), lg[<span class="hljs-number">1</span>&lt;&lt;i]=i;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(S,<span class="hljs-number">1</span>,U) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;<span class="hljs-keyword">if</span>(f[S^(<span class="hljs-number">1</span>&lt;&lt;i)]==n) &#123; f[S]=n; <span class="hljs-keyword">break</span>; &#125;f[S]=<span class="hljs-built_in">max</span>(f[S],<span class="hljs-built_in">bs</span>(f[S^(<span class="hljs-number">1</span>&lt;&lt;i)]+<span class="hljs-number">1</span>,c[i]));&#125;<span class="hljs-keyword">if</span>(f[U]==n) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-number">0ll</span>);<span class="hljs-built_in">rep</span>(T,<span class="hljs-number">1</span>,U) &#123;<span class="hljs-keyword">if</span>(f[U^T]==n) ans=<span class="hljs-built_in">max</span>(ans,g[T]=g[T^<span class="hljs-built_in">lowbit</span>(T)]+c[lg[<span class="hljs-built_in">lowbit</span>(T)]]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu3694-邦邦的大合唱站队">luogu3694 邦邦的大合唱站队</h3><p>这题题面写得真的无语。</p><p>稍微转化一下，把所有乐队归队就是一个划分区间问题。如果一个乐队归队的区间确定了，那么这个区间里面的偶像就不用动，剩下的就一定要出列。</p><p>设 <span class="math inline">\(f(S)\)</span> 为把集合 <spanclass="math inline">\(S\)</span> 内的的乐队归队，所需要的最小代价。设<span class="math inline">\(p_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个乐队的人数。</p><p>枚举最后一个归队的乐队 <spanclass="math inline">\(i\)</span>，算出剩下的乐队一共排到了 <spanclass="math inline">\(cnt\)</span> ，这样让 <spanclass="math inline">\(i\)</span> 归队的代价就是 <spanclass="math inline">\(p_i\)</span> 减去在 <spanclass="math inline">\([cnt+1,cnt+p_i]\)</span>里这个乐队的偶像的数量。</p><p>前缀和预处理即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>, M=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, U, a[M], p[N], s[N][M], f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;++p[a[i]], ++s[a[i]][i];&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) s[i][j]+=s[i][j<span class="hljs-number">-1</span>];<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;U;++S) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) <span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) cnt+=p[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) <span class="hljs-keyword">continue</span>;f[S|(<span class="hljs-number">1</span>&lt;&lt;i)]=<span class="hljs-built_in">min</span>(f[S|(<span class="hljs-number">1</span>&lt;&lt;i)],f[S]+p[i]-(s[i][cnt+p[i]]-s[i][cnt]));&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[U]);&#125;</code></pre></div><h3 id="luogu2831-noip2016-提高组-愤怒的小鸟">luogu2831 [NOIP2016提高组] 愤怒的小鸟</h3><p>很无序，很状压。</p><p>设 <span class="math inline">\(f(S)\)</span> 表示把集合 <spanclass="math inline">\(S\)</span> 内的都干掉的最小代价。</p><p>转移枚举最后一个被干掉的，看它能不能和某一个一起被干掉，不能的话就自己来一发。</p><p>然后这个是 <span class="math inline">\(O(n^2 2^n)\)</span>。</p><p>还是把 <span class="math inline">\(\operatorname{lowbit}(S)\)</span>当作最后一个被干掉的，这样就做到 <span class="math inline">\(O(n2^n)\)</span>。</p><p>为了方便，预处理 <span class="math inline">\(p(i,j)\)</span> 表示<span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 确定的抛物线能干掉的集合。</p><p>需要解方程，式子比较好推，不再赘述。</p><p>还有就是注意精度问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2831 [NOIP2016 提高组] 愤怒的小鸟</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-17 20:25:53</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2831</span><span class="hljs-comment">// Memory Limit: 500 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-8</span>;<span class="hljs-type">int</span> T, n, m, U, p[N][N], f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>], lg[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>];<span class="hljs-type">double</span> x[N], y[N];<span class="hljs-function">pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">double</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">double</span> x1,<span class="hljs-type">double</span> y1,<span class="hljs-type">double</span> x2,<span class="hljs-type">double</span> y2)</span> </span>&#123;<span class="hljs-type">double</span> a=(y1*x2-y2*x1)/(x1*x2*(x1-x2));<span class="hljs-type">double</span> b=y2/x2-x2*a;<span class="hljs-keyword">return</span> <span class="hljs-built_in">MP</span>(a,b);&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> a*x*x+b*x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;-x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;x[i],&amp;y[i]);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) &#123;p[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i==j||<span class="hljs-built_in">fabs</span>(x[i]-x[j])&lt;eps) <span class="hljs-keyword">continue</span>;pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">double</span>&gt; gen=<span class="hljs-built_in">calc</span>(x[i],y[i],x[j],y[j]);<span class="hljs-keyword">if</span>(gen.fi&gt;-eps) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">F</span>(gen.fi,gen.se,x[k])-y[k])&lt;eps) p[i][j]|=(<span class="hljs-number">1</span>&lt;&lt;k);&#125;&#125;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">1</span>;S&lt;=U;++S) &#123;<span class="hljs-type">int</span> k=lg[<span class="hljs-built_in">lowbit</span>(S)], S0=S^(<span class="hljs-number">1</span>&lt;&lt;k);f[S]=<span class="hljs-built_in">min</span>(f[S],f[S0]+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(S0&amp;p[k][i]) f[S]=<span class="hljs-built_in">min</span>(f[S],f[S0^(S0&amp;p[k][i])]+<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[U]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">17</span>) lg[<span class="hljs-number">1</span>&lt;&lt;i]=i;<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu7098-yloi2020-凉凉">luogu7098 [yLOI2020] 凉凉</h3><p><ahref="https://www.luogu.com.cn/blog/yozora0908/solution-p7098">link</a></p><h3 id="luogu4923-mtoi2018-gcd人生赢家">luogu4923 [MtOI2018]gcd？人生赢家！</h3><p>乍一看挺复杂的，读入尤其恶心。</p><p>直接设 <span class="math inline">\(f(x,k,S)\)</span> 为当前在宝物<span class="math inline">\(x\)</span> 所在的节点，还剩下 <spanclass="math inline">\(k\)</span> 次传送机会，取得了集合 <spanclass="math inline">\(S\)</span> 内宝物的最小时间。</p><p>仔细想想发现还剩下 <span class="math inline">\(k\)</span>次传送机会不太好弄，可以改为已经传送了 <spanclass="math inline">\(k\)</span> 次。</p><p>先算出当前已经完成了的成就，然后再枚举下一个要到达的宝物所在点，传送或者直接过去，距离用<span class="math inline">\(\text{Floyd}\)</span> 算法处理。</p><p>用 <span class="math inline">\(\text{DFS}\)</span>转移，跑得很快。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, _k, s, e, U, st;<span class="hljs-type">int</span> ss[N], a[N], p[N], pre[N], d[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<span class="hljs-type">int</span> lg[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>], f[N][N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), _k=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">memset</span>(d[i],<span class="hljs-number">0x3f</span>,(n+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">2</span>), d[i][i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,s) &#123;<span class="hljs-type">int</span> num=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(num--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();ss[i]|=(<span class="hljs-number">1</span>&lt;&lt;(x<span class="hljs-number">-1</span>));&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,s) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>) p[i]=<span class="hljs-built_in">read</span>(), lg[<span class="hljs-number">1</span>&lt;&lt;i]=i;e=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,e) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();d[x][y]=d[y][x]=<span class="hljs-built_in">min</span>(d[x][y],z);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> num=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(num--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();pre[i]|=(<span class="hljs-number">1</span>&lt;&lt;(x<span class="hljs-number">-1</span>));&#125;&#125;st=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(d[i][k]!=inf) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(d[k][j]!=inf) d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;-x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> kk,<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-keyword">if</span>(f[x][kk][S]!=inf) <span class="hljs-keyword">return</span> f[x][kk][S];<span class="hljs-type">int</span>&amp; res=f[x][kk][S];<span class="hljs-keyword">if</span>(S==U) <span class="hljs-keyword">return</span> res=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ayano=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s;++i) <span class="hljs-keyword">if</span>((S&amp;ss[i])==ss[i]) ayano+=a[i];<span class="hljs-type">int</span> T=U^S;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;y&lt;m;++y) <span class="hljs-keyword">if</span>(T&amp;(<span class="hljs-number">1</span>&lt;&lt;y)) &#123;<span class="hljs-keyword">if</span>((S&amp;pre[y])!=pre[y]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(d[p[x]][p[y]]!=inf) res=<span class="hljs-built_in">min</span>(res,d[p[x]][p[y]]+<span class="hljs-built_in">dfs</span>(y,kk,S|(<span class="hljs-number">1</span>&lt;&lt;y)));<span class="hljs-keyword">if</span>(kk&lt;_k+ayano) res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">dfs</span>(y,kk+<span class="hljs-number">1</span>,S|(<span class="hljs-number">1</span>&lt;&lt;y)));&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">input</span>();<span class="hljs-built_in">floyd</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);<span class="hljs-type">int</span> ans=inf;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(pre[i]==<span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 起点是任意没有前置要求的宝物处。</span><span class="hljs-keyword">if</span>(d[st][p[i]]!=inf) ans=<span class="hljs-built_in">min</span>(ans,d[st][p[i]]+<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&lt;&lt;i));<span class="hljs-keyword">if</span>(_k) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;i));&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu3622-apio2007-动物园">luogu3622 [APIO2007] 动物园</h3><p>有了花园那题的铺垫，这题我们直接状压后面 <spanclass="math inline">\(5\)</span> 个格子的状态。</p><p>可以预处理出每个状态的高兴小朋友数量。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 表示考虑前 <spanclass="math inline">\(i\)</span> 个格子，<spanclass="math inline">\([i,i+4]\)</span> 的状态是 <spanclass="math inline">\(S\)</span> 的最大数量。</p><p>枚举初始状态 <spanclass="math inline">\(S&#39;\)</span>，每次往前推一位，后继状态就是最高位放不放<span class="math inline">\(1\)</span>。</p><p>警钟敲烂，使用刷表法的时候，一定记得清空整个数组。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3622 [APIO2007] 动物园</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3622</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-19 16:59:37</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, U=<span class="hljs-number">31</span>;<span class="hljs-type">int</span> n, m, f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>], w[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), c1=<span class="hljs-built_in">read</span>(), c2=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> f=<span class="hljs-number">0</span>, l=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(c1--) &#123;<span class="hljs-type">int</span> p=<span class="hljs-built_in">read</span>();p=(p-x+n)%n;f|=(<span class="hljs-number">1</span>&lt;&lt;p);&#125;<span class="hljs-keyword">while</span>(c2--) &#123;<span class="hljs-type">int</span> p=<span class="hljs-built_in">read</span>();p=(p-x+n)%n;l|=(<span class="hljs-number">1</span>&lt;&lt;p);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;<span class="hljs-keyword">if</span>(S&amp;l||f&amp;(~S)) ++w[x][S];&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=U;++i) &#123;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-0x3f</span>);        <span class="hljs-comment">// 清空整个数组</span>f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;            <span class="hljs-type">int</span> S0=S&gt;&gt;<span class="hljs-number">1</span>, S1=(S0|<span class="hljs-number">16</span>)&amp;<span class="hljs-number">31</span>;            f[j+<span class="hljs-number">1</span>][S0]=<span class="hljs-built_in">max</span>(f[j+<span class="hljs-number">1</span>][S0],f[j][S]+w[j+<span class="hljs-number">1</span>][S0]);f[j+<span class="hljs-number">1</span>][S1]=<span class="hljs-built_in">max</span>(f[j+<span class="hljs-number">1</span>][S1],f[j][S]+w[j+<span class="hljs-number">1</span>][S1]);&#125;ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>填表法代码</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">SET</span>(f[<span class="hljs-number">0</span>],<span class="hljs-number">-0x3f</span>);f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;f[j][S]=<span class="hljs-built_in">max</span>(f[j<span class="hljs-number">-1</span>][(S&amp;<span class="hljs-number">15</span>)&lt;&lt;<span class="hljs-number">1</span>],f[j<span class="hljs-number">-1</span>][((S&amp;<span class="hljs-number">15</span>)&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>])+w[j][S];&#125;</code></pre></div><h3 id="luogu2150-noi2015-寿司晚宴">luogu2150 [NOI2015] 寿司晚宴</h3><p>很显然是在质因子上做文章。</p><p>30 分怎么做？</p><p><span class="math inline">\(n \le 30\)</span>，质因子只有 <spanclass="math inline">\(10\)</span> 个，可以对其状压。设 <spanclass="math inline">\(f(x,S_1,S_2)\)</span> 为考虑了前 <spanclass="math inline">\(i\)</span> 个数，其中第一个人的质因子集合为 <spanclass="math inline">\(S_1\)</span>，另一个人是 <spanclass="math inline">\(S_2\)</span>的方案数。预处理每个数的质因子集合，转移的时候讨论每个数的 <spanclass="math inline">\(3\)</span> 种情况即可。</p><p>考虑 50 分做法。设 <span class="math inline">\(f(S)\)</span>为选出的质因子集合为 <span class="math inline">\(S\)</span>的方案数，<span class="math inline">\(g(S) = \sum_{T \subseteq S}f(T)\)</span>，那么答案就是 <span class="math display">\[\sum_{S \subseteq U} f(S) g(U \setminus S)\]</span> 然而 <span class="math inline">\(100\)</span> 以内的质数有<span class="math inline">\(25\)</span> 个。</p><p>考虑超过 <span class="math inline">\(50\)</span> 的质因数只能出现<span class="math inline">\(1\)</span> 次，因此可以只考虑 <spanclass="math inline">\(\le 50\)</span> 的 <spanclass="math inline">\(15\)</span> 个质数。超过 <spanclass="math inline">\(50\)</span> 的质数只有 <spanclass="math inline">\(3\)</span> 种方案，最后乘上一个 <spanclass="math inline">\(3\)</span> 的次幂即可。</p><p>考虑正解。</p><p><span class="math inline">\(\texttt{Observation}\)</span></p><p>超过 <span class="math inline">\(\sqrt n\)</span> 的质数最多选择<span class="math inline">\(1\)</span> 个。</p><p>因此我们就把不超过 <span class="math inline">\(\sqrt n\)</span>的最多 <span class="math inline">\(8\)</span> 个质数单拿出来。设超过<span class="math inline">\(\sqrt n\)</span> 的质数为 <spanclass="math inline">\(\{bp\}\)</span>，不超过 <spanclass="math inline">\(\sqrt n\)</span> 的为 <spanclass="math inline">\(\{sp\}\)</span>。含相同 <spanclass="math inline">\(bp\)</span> 的数构成一个等价类，把不含 <spanclass="math inline">\(bp\)</span> 的数看作大小为 <spanclass="math inline">\(1\)</span> 的等价类。排序后分段处理。</p><p>设 <span class="math inline">\(f(S_1,S_2)\)</span>为二者的质因数集合分别为 <span class="math inline">\(S_1,S_2\)</span>的方案数，<span class="math inline">\(g_1(S_1,S_2)\)</span> 和 <spanclass="math inline">\(g_2(S_1,S_2)\)</span> 是在当前等价类 <spanclass="math inline">\(i\)</span> 中，<spanclass="math inline">\(bp_i\)</span> 只能放到 <spanclass="math inline">\(S_1\)</span> 或 <spanclass="math inline">\(S_2\)</span> 的方案数。注意最终没有放 <spanclass="math inline">\(bp_i\)</span> 的方案在而这种都能统计到。</p><p>当做完一个等价类后，令 <span class="math inline">\(g_1(S_1,S_2) +g_2(S_1,S_2) - f(S_1,S_2) \rightarrow f(S_1,S_2)\)</span>。</p><p>复杂度是 <span class="math inline">\(\mathcal{O}(n2^{16})\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P2150 [NOI2015] 寿司晚宴</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P2150</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Date: 2023-07-15 11:13:46</span><span class="hljs-comment">// Memory Limit: 125 MB</span><span class="hljs-comment">// Time Limit: 1000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, M=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> pr[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>&#125;;<span class="hljs-type">int</span> n, mod;<span class="hljs-type">int</span> f[M][M], g1[M][M], g2[M][M];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> sp, bp;&#125; a[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123;<span class="hljs-keyword">return</span> a.bp&lt;b.bp;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), mod=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> t=i+<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>) <span class="hljs-keyword">if</span>(t%pr[j]==<span class="hljs-number">0</span>) &#123;a[i].sp|=<span class="hljs-number">1</span>&lt;&lt;j;<span class="hljs-keyword">while</span>(t%pr[j]==<span class="hljs-number">0</span>) t/=pr[j];&#125;<span class="hljs-keyword">if</span>(t&gt;<span class="hljs-number">1</span>) a[i].bp=t;&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(a[i].bp==<span class="hljs-number">0</span>||a[i].bp!=a[i<span class="hljs-number">-1</span>].bp) &#123;            <span class="hljs-comment">// 新的等价类</span><span class="hljs-built_in">per</span>(S1,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-built_in">per</span>(S2,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span>((S1&amp;S2)==<span class="hljs-number">0</span>) &#123; g1[S1][S2]=g2[S1][S2]=f[S1][S2];&#125;&#125;<span class="hljs-built_in">per</span>(S1,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-built_in">per</span>(S2,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span>((S1&amp;S2)==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>((S1&amp;a[i].sp)==<span class="hljs-number">0</span>) (g2[S1][S2|a[i].sp]+=g2[S1][S2])%=mod;<span class="hljs-keyword">if</span>((S2&amp;a[i].sp)==<span class="hljs-number">0</span>) (g1[S1|a[i].sp][S2]+=g1[S1][S2])%=mod;&#125;<span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>||a[i].bp==<span class="hljs-number">0</span>||a[i].bp!=a[i+<span class="hljs-number">1</span>].bp) &#123;            <span class="hljs-comment">// 下一个数是新的等价类</span><span class="hljs-built_in">per</span>(S1,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-built_in">per</span>(S2,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">if</span>((S1&amp;S2)==<span class="hljs-number">0</span>) &#123;f[S1][S2]=((g1[S1][S2]+g2[S1][S2])%mod-f[S1][S2]+mod)%mod;&#125;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(S1,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>) <span class="hljs-built_in">rep</span>(S2,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>) <span class="hljs-keyword">if</span>((S1&amp;S2)==<span class="hljs-number">0</span>) &#123;(ans+=f[S1][S2])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="luogu6239-jxoi2012-奇怪的道路">luogu6239 [JXOI2012]奇怪的道路</h3><p>设 <span class="math inline">\(f(i,j,S)\)</span> 为考虑了 <spanclass="math inline">\([1,i]\)</span> 中的点，连了 <spanclass="math inline">\(j\)</span> 条边，<spanclass="math inline">\([i-k,i]\)</span> 中点的奇偶性为 <spanclass="math inline">\(S\)</span> 的方案数。</p><p>貌似可以直接做了。</p><h3 id="luogu3943-星空">luogu3943 星空</h3><p>Starry Sky.</p><p><ahref="https://yozora0908.github.io/2023/lg3943-solution">link</a></p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#8 搜索剪枝与记忆化搜索</title>
    <link href="/2023/noip-record-8/"/>
    <url>/2023/noip-record-8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="搜索剪枝">搜索剪枝</h2><p>纯搜索剪枝题很少，早就融入各种搜索之中了。</p><p>但是在各种多项式时间的搜索里，剪枝仍然是重要的。</p><p>目前只有一道题，以后看情况加。</p><h3 id="luogu1120-小木棍">luogu1120 小木棍</h3><p>能注意到长度一定是所有木棍总和的倍数，并且至少是 <spanclass="math inline">\(\max\{a_i\}\)</span>，所以只对这部分搜索就行。</p><p>设<code>dfs(cnt,len,lst)</code>表示当前还剩下 <spanclass="math inline">\(cnt\)</span> 根木棍要拼接，当前木棍剩余长度为<span class="math inline">\(len\)</span> ，使用的上一根木棍长度为 <spanclass="math inline">\(lst\)</span> 的情况下，能否搜到答案。</p><p>枚举每根木棍选不选的复杂度过高，但是也没有其他好办法，所以尝试剪枝。</p><ol type="1"><li>如果使用长度为 <span class="math inline">\(a_i\)</span>的木棍搜不到答案，那么直接尝试另一种长度。</li><li>长度小的木棍更灵活，产生的状态数必然更多，也更容易在剩余长度小时找到答案，所以改变搜索顺序，优先搜索长度大的。</li><li>如果当前使用的木棍长度等于 <span class="math inline">\(len\)</span>且仍然搜不到答案，那么直接返回无解。</li></ol><p>这样就来到了一个玄学复杂度，能够通过。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> psb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">70</span>;<span class="hljs-type">int</span> n, len, s, a[N], c[N], pre[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cnt,<span class="hljs-type">int</span> le,<span class="hljs-type">int</span> st)</span> </span>&#123;<span class="hljs-keyword">if</span>(le==<span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(cnt<span class="hljs-number">-1</span>,len,a[n]); &#125;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;st=<span class="hljs-built_in">min</span>(st,le);  <span class="hljs-comment">// 长度不能大于le</span><span class="hljs-keyword">while</span>(st&amp;&amp;!c[st]) --st;<span class="hljs-keyword">while</span>(st) &#123;<span class="hljs-keyword">if</span>(c[st]) &#123;--c[st];<span class="hljs-type">int</span> fg=<span class="hljs-built_in">dfs</span>(cnt,le-st,st);++c[st];<span class="hljs-keyword">if</span>(((le==st)||(le==len))&amp;&amp;!fg) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            <span class="hljs-comment">// 3</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fg) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;st=pre[st];            <span class="hljs-comment">// 1</span>&#125; <span class="hljs-keyword">else</span> st=pre[st];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), ++c[a[i]], s+=a[i];<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>); <span class="hljs-comment">// 2</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(a[i]!=a[i<span class="hljs-number">-1</span>]) pre[a[i]]=a[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(len=a[n];<span class="hljs-number">2</span>*len&lt;=s;++len) <span class="hljs-keyword">if</span>(s%len==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(s/len,len,a[n])) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,len); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s);&#125;</code></pre></div><h2 id="记忆化搜索">记忆化搜索</h2><p>重点，适合用来打部分分。</p><p>用来转移状压 DP 也是好的，可以剪掉很多废状态。</p><p>记忆化搜索分为两种。</p><ol type="1"><li>用 DP的思想，记录自底向上某个状态的最优解或方案数。这样做就相当于用搜索实现DP，具有 DP 的那些性质，遇到一个已经访问过的状态便可以直接返回。</li><li>更接近于对一般搜索的优化，记录到从初始状态到达当前状态的搜索树上的边权和，这样只有当再次搜到这个状态时，当前边权和劣于记录的值，才能直接返回，否则就要更新记录的边权和。效率一般低于前者，且对搜索顺序要求较高。</li></ol><p>很多时候都是二者皆可用的，那为啥后者还存在呢？</p><p>用 DP的理论，前者要求记录的状态满足最优子结构性质，后者则只是提取出最优子结构一个子集。一般使用前者。</p><p>第 2种看起来挺没用的，不过它放宽了太多条件，根本不必考虑最优性，直接暴搜就行，在某些时候有奇效，比如可以应用搜索顺序优化。</p><h3 id="luogu3609-usaco17jan-hoof-paper-scissor-g">luogu3609[USACO17JAN] Hoof, Paper, Scissor G</h3><p>要把整个序列划分成至多 <span class="math inline">\(k\)</span>段，考虑到 <span class="math inline">\(k\)</span> 不大，<spanclass="math inline">\(O(nk)\)</span> 的 DP 是容易做的。</p><p>设 <span class="math inline">\(f(i,k,cur)\)</span> 表示当前在 <spanclass="math inline">\(i\)</span>，分了 <spanclass="math inline">\(k\)</span> 段，手势是 <spanclass="math inline">\(cur\)</span> 的最大值。</p><p>要么接在后面，要么新开一段。</p><p>这个满足最优子结构性质，可以使用第 1 种方法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, ans, s[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">22</span>][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">winwin</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>&amp;&amp;y==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>&amp;&amp;y==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> cur)</span> </span>&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(f[i][k][cur]) <span class="hljs-keyword">return</span> f[i][k][cur];<span class="hljs-type">int</span>&amp; res=f[i][k][cur];res=<span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,k,cur)+<span class="hljs-built_in">winwin</span>(cur,s[i]);<span class="hljs-keyword">if</span>(k) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(cur!=j) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>,j)+<span class="hljs-built_in">winwin</span>(cur,s[i]));&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">char</span> c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;c);<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;H&#x27;</span>) s[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;S&#x27;</span>) s[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;P&#x27;</span>) s[i]=<span class="hljs-number">2</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">dfs</span>(n,i,j));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu1278-单词游戏">luogu1278 单词游戏</h3><p><span class="math inline">\(n\)</span> 很小，考虑状压 <spanclass="math inline">\(n\)</span>。</p><p>设 <span class="math inline">\(f(S,pre)\)</span> 为选了集合 <spanclass="math inline">\(S\)</span> 中的串，上一个选的串是 <spanclass="math inline">\(pre\)</span> 的最大值。</p><p>然后就做完了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> psb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>;<span class="hljs-type">int</span> n, ans, f[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>)+<span class="hljs-number">5</span>][N];string s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S,<span class="hljs-type">int</span> pre)</span> </span>&#123;<span class="hljs-keyword">if</span>(f[S][pre]) <span class="hljs-keyword">return</span> f[S][pre];<span class="hljs-type">int</span>&amp; res=f[S][pre];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>((S&amp;(<span class="hljs-number">1</span>&lt;&lt;i))==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> l=s[pre].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(!pre||s[pre][l]==s[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(S|(<span class="hljs-number">1</span>&lt;&lt;i),i+<span class="hljs-number">1</span>)+(<span class="hljs-type">int</span>)s[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>());&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();s[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) cin&gt;&gt;s[i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));&#125;</code></pre></div><h3 id="luogu2476-scoi2008-着色方案">luogu2476 [SCOI2008] 着色方案</h3><p>注意到颜色只有 <span class="math inline">\(5\)</span>种，用典题乌龟棋的做法，记录上一个放的什么颜色即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> psb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">16</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> k, t[N], f[N][N][N][N][N][<span class="hljs-number">6</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> e,<span class="hljs-type">int</span> lst)</span> </span>&#123;<span class="hljs-keyword">if</span>(~f[a][b][c][d][e][lst]) <span class="hljs-keyword">return</span> f[a][b][c][d][e][lst];<span class="hljs-type">int</span>&amp; res=f[a][b][c][d][e][lst];res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a+b+c+d+e==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(a) (res+=(a-(lst==<span class="hljs-number">2</span>))*<span class="hljs-built_in">dfs</span>(a<span class="hljs-number">-1</span>,b,c,d,e,<span class="hljs-number">1</span>)%mod)%=mod;<span class="hljs-keyword">if</span>(b) (res+=(b-(lst==<span class="hljs-number">3</span>))*<span class="hljs-built_in">dfs</span>(a+<span class="hljs-number">1</span>,b<span class="hljs-number">-1</span>,c,d,e,<span class="hljs-number">2</span>)%mod)%=mod;<span class="hljs-keyword">if</span>(c) (res+=(c-(lst==<span class="hljs-number">4</span>))*<span class="hljs-built_in">dfs</span>(a,b+<span class="hljs-number">1</span>,c<span class="hljs-number">-1</span>,d,e,<span class="hljs-number">3</span>)%mod)%=mod;<span class="hljs-keyword">if</span>(d) (res+=(d-(lst==<span class="hljs-number">5</span>))*<span class="hljs-built_in">dfs</span>(a,b,c+<span class="hljs-number">1</span>,d<span class="hljs-number">-1</span>,e,<span class="hljs-number">4</span>)%mod)%=mod;<span class="hljs-keyword">if</span>(e) (res+=e*<span class="hljs-built_in">dfs</span>(a,b,c,d+<span class="hljs-number">1</span>,e<span class="hljs-number">-1</span>,<span class="hljs-number">5</span>)%mod)%=mod;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,k) ++t[<span class="hljs-built_in">read</span>()];<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(t[<span class="hljs-number">1</span>],t[<span class="hljs-number">2</span>],t[<span class="hljs-number">3</span>],t[<span class="hljs-number">4</span>],t[<span class="hljs-number">5</span>],<span class="hljs-number">0</span>));&#125;</code></pre></div><p> </p><p>另外的，本题相当于是 CF840C 的弱化弱化版。</p><h3 id="luogu8565-sultan-rage">luogu8565 Sultan Rage</h3><p>题目乍一看很可怕。</p><p>然而能发现 <span class="math inline">\(\text{Fibonacii}\)</span>序列应该是题目中序列的一个极小情况，但增长已经是指数级了。也就是说给出的序列在超过<span class="math inline">\(m\)</span>的部分里，有用的最多六十多项。</p><p>考虑记忆化搜索，设 <span class="math inline">\(f(k,x)\)</span> 为用前<span class="math inline">\(k\)</span> 项凑成 <spanclass="math inline">\(x\)</span> 的方案数，转移就是背包。</p><p><span class="math inline">\(x\)</span> 这一维很大，但 <spanclass="math inline">\(m\)</span>位之后能搞一个进位操作，直觉上数量不是很多，所以可以用<code>std::unordered_map</code>实现。对于前<span class="math inline">\(m\)</span>项直接用背包处理答案，这部分状态数不会太少。</p><p>可以做一些优化。</p><ol type="1"><li>如果 <span class="math inline">\(x&gt; \sum_{i=1}^ka_i\)</span>，那么直接返回 <span class="math inline">\(0\)</span>。</li><li>如果 <span class="math inline">\(x \le \sum_{i=1}^k a_i\)</span>并且 <span class="math inline">\(x &gt; \sum_{i=1}^{k-1}a_i\)</span>，那么 <span class="math inline">\(a_k\)</span>就必须选择。</li></ol><p>复杂度 <span class="math inline">\(\text{proof by AC}\)</span>。</p><p>可以就此了解一下 <span class="math inline">\(\text{Zeckendorf ’stheorem}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> psb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">233</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> T, n, m, q, a[N], s[N], f[N*<span class="hljs-number">100</span>];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; g[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;s[k]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(g[k].<span class="hljs-built_in">count</span>(x)) <span class="hljs-keyword">return</span> g[k][x];<span class="hljs-keyword">if</span>(k==n) <span class="hljs-keyword">return</span> g[k][x]=f[x];<span class="hljs-keyword">if</span>(x&gt;s[k<span class="hljs-number">-1</span>]) g[k][x]=<span class="hljs-built_in">dfs</span>(x-a[k],k<span class="hljs-number">-1</span>);<span class="hljs-keyword">return</span> g[k][x]=(<span class="hljs-built_in">dfs</span>(x-a[k],k<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(x,k<span class="hljs-number">-1</span>))%mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), s[i]=s[i<span class="hljs-number">-1</span>]+a[i], g[i].<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,(s[n]+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">per</span>(j,s[i],a[i]) &#123;<span class="hljs-keyword">if</span>(j&gt;=a[i]) (f[j]+=f[j-a[i]])%=mod;&#125;m=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;;++m) &#123;a[m]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[m]+=a[m-i];<span class="hljs-keyword">if</span>(a[m]&gt;<span class="hljs-number">1e18</span>) <span class="hljs-keyword">break</span>;&#125;--m;<span class="hljs-built_in">rep</span>(i,n+<span class="hljs-number">1</span>,m) s[i]=s[i<span class="hljs-number">-1</span>]+a[i], g[i].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(x,m));&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="luogu8658-蓝桥杯-2017-国-a-填字母游戏">luogu8658 [蓝桥杯 2017 国A] 填字母游戏</h3><p>我们用分别用 <span class="math inline">\(1\)</span>，<spanclass="math inline">\(-1\)</span>，<spanclass="math inline">\(0\)</span> 表示胜利、失败、平局。</p><p>对于一个状态 <spanclass="math inline">\(S\)</span>，它的胜负状态可以表示为 <spanclass="math display">\[f(S) = \max_{S \rightarrow S&#39; }\Big\{-f(S&#39;)\Big\}\]</span> 一旦 <span class="math inline">\(f(S)\)</span> 被更新为 <spanclass="math inline">\(1\)</span>，那就直接返回。</p><p>然而极限状态数还是 <spanclass="math inline">\(O(3^{len})\)</span>，无法承受，但是这种东西重叠状态数很大，记忆化的效果很好。状态是字符串，可以用<code>std::unordered_map&lt;string,int&gt;</code>实现。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">22</span>;<span class="hljs-type">int</span> T, n;string s;unordered_map&lt;string,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string st)</span> </span>&#123;<span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">count</span>(st)) <span class="hljs-keyword">return</span> p[st];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;st.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;++i) &#123;<span class="hljs-keyword">if</span>(st[i]==<span class="hljs-string">&#x27;L&#x27;</span>&amp;&amp;st[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>&amp;&amp;st[i+<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;L&#x27;</span>) &#123;<span class="hljs-keyword">return</span> p[st]=<span class="hljs-number">-1</span>;&#125;&#125;p[st]=<span class="hljs-number">-1</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;st.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">if</span>(st[i]==<span class="hljs-string">&#x27;*&#x27;</span>) &#123;string t=st;t[i]=<span class="hljs-string">&#x27;O&#x27;</span>;p[st]=<span class="hljs-built_in">max</span>(p[st],-<span class="hljs-built_in">dfs</span>(t));<span class="hljs-keyword">if</span>(p[st]==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;t[i]=<span class="hljs-string">&#x27;L&#x27;</span>;p[st]=<span class="hljs-built_in">max</span>(p[st],-<span class="hljs-built_in">dfs</span>(t));<span class="hljs-keyword">if</span>(p[st]==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;++cnt;&#125;&#125;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>) p[st]=<span class="hljs-built_in">max</span>(p[st],<span class="hljs-number">0ll</span>);<span class="hljs-keyword">return</span> p[st];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;cin&gt;&gt;s;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;++i) <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;L&#x27;</span>&amp;&amp;s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>&amp;&amp;s[i+<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;L&#x27;</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(s));p.<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="luogu3257-jloi2014-天天酷跑">luogu3257 [JLOI2014] 天天酷跑</h3><p>上古老题了，题面有很多叙述不严谨的地方。</p><p>首先能发现不管跳不跳，横坐标每次至少增加 <spanclass="math inline">\(1\)</span>，而跳跃过程是容易刻画的。并且 <spanclass="math inline">\(m\)</span> 和最多连跳数很小，可以直接枚举。</p><p>设 <span class="math inline">\(f(x,y,z)\)</span> 表示在 <spanclass="math inline">\((x,y)\)</span>，已经连跳了 <spanclass="math inline">\(j\)</span> 次的最大值。</p><p>有一些小细节：</p><ol type="1"><li>初始点是 <span class="math inline">\((0,1)\)</span>。</li><li>注意跳跃的最高点的贡献不要算重。</li></ol><p>用记忆化搜索相对容易实现。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> psb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, cnt, h, ans=<span class="hljs-number">-1e9</span>, cost1, cost2, a[N][<span class="hljs-number">22</span>];<span class="hljs-type">int</span> f[N][<span class="hljs-number">22</span>][<span class="hljs-number">7</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;n||y&gt;m||y&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[x][y]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1e9</span>;<span class="hljs-keyword">if</span>(~f[x][y][z]) <span class="hljs-keyword">return</span> f[x][y][z];<span class="hljs-type">int</span>&amp; res=f[x][y][z];res=<span class="hljs-number">-1e9</span>;<span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) z=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(z&lt;cnt&amp;&amp;y+h&lt;=m) &#123;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>, t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;h;++i) &#123;<span class="hljs-keyword">if</span>(a[x+i][y+i]==<span class="hljs-number">-1</span>) &#123; t=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;sum+=a[x+i][y+i]; &#125;<span class="hljs-keyword">if</span>(!t) res=<span class="hljs-built_in">max</span>(res,sum+<span class="hljs-built_in">dfs</span>(x+h,y+h,z+<span class="hljs-number">1</span>));        <span class="hljs-comment">// a[x][y]放到最后算了，所以这里只算前h-1个的贡献</span>        <span class="hljs-comment">// 而且在跳跃完成，下落之前，也是可以连跳的</span>&#125;<span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,y,z));<span class="hljs-keyword">else</span> res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,y<span class="hljs-number">-1</span>,z));<span class="hljs-keyword">return</span> res+=a[x][y];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), cost1=<span class="hljs-built_in">read</span>(), cost2=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ii=<span class="hljs-number">0</span>, hh=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(cnt=<span class="hljs-number">1</span>;cnt&lt;=<span class="hljs-number">5</span>;++cnt) &#123;<span class="hljs-keyword">for</span>(h=<span class="hljs-number">1</span>;h*cnt&lt;m;++h) &#123;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);<span class="hljs-type">int</span> res=<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)-(h<span class="hljs-number">-1</span>)*cost1-(cnt<span class="hljs-number">-1</span>)*cost2;<span class="hljs-keyword">if</span>(res&gt;ans) ans=res, ii=cnt, hh=h;&#125;&#125;<span class="hljs-keyword">if</span>(ans&gt;=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,ans,ii,hh);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;mission failed&quot;</span>);&#125;</code></pre></div><h3 id="luogu4962-朋也与光玉">luogu4962 朋也与光玉</h3><p><span class="math inline">\(k\)</span> 很小，考虑状压之。</p><p>并且在图上走过的路径长度不会超过 <spanclass="math inline">\(k\)</span>，所以直接枚举起点开搜就行。</p><p>设 <span class="math inline">\(f(x,S)\)</span> 表示到达节点 <spanclass="math inline">\(x\)</span>，已经收集的元素集合为 <spanclass="math inline">\(S\)</span> 时的最短路，可以直接通过。</p><p>然而本题重叠状态数不多，这时候如果使用上文提到的第二种记忆化方法，那么就能优化搜索顺序，优先搜索权值小的边，这样就能卡进400ms。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, m, k, U, res, ans=<span class="hljs-number">1e9</span>, id, a[N], f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">13</span>];vector&lt;PII &gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> S,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> dep)</span> </span>&#123;<span class="hljs-keyword">if</span>((f[x][S]&amp;&amp;f[x][S]&lt;=sum)) <span class="hljs-keyword">return</span>;f[x][S]=sum;<span class="hljs-keyword">if</span>(sum&gt;=ans) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(S==U) &#123; ans=sum; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(dep==k) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:p[x]) &#123;<span class="hljs-type">int</span> y=t.fi, z=t.se;<span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;a[y])) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,S|(<span class="hljs-number">1</span>&lt;&lt;a[y]),sum+z,dep+<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a,PII b)</span> </span>&#123;<span class="hljs-keyword">if</span>(a.se!=b.se) <span class="hljs-keyword">return</span> a.se&lt;b.se;<span class="hljs-keyword">return</span> a.fi&lt;b.fi;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(&#123;y,z&#125;);&#125;<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">sort</span>(p[x].<span class="hljs-built_in">begin</span>(),p[x].<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>&lt;&lt;a[i],<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(ans!=<span class="hljs-number">1e9</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Ushio!&quot;</span>);&#125;</code></pre></div><h3 id="luogu4796-balticoi-2018-路径">luogu4796 [BalticOI 2018]路径</h3><p>差不多一样的套路，<span class="math inline">\(k\)</span> 很小，设<span class="math inline">\(f(x,S)\)</span> 为到达节点 <spanclass="math inline">\(x\)</span>，颜色集合为 <spanclass="math inline">\(S\)</span>，还能够产生的路径条数。</p><p>注意当 <span class="math inline">\(|S|=1\)</span> 时 <spanclass="math inline">\(f(x,k)\)</span> 初始值为 <spanclass="math inline">\(0\)</span>，否则为 <spanclass="math inline">\(1\)</span>。</p><p>然后就直接做了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, k, U, a[N];ll ans, f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;-x; &#125;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-keyword">if</span>(f[x][S]) <span class="hljs-keyword">return</span> f[x][S];ll&amp; res=f[x][S];res=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(S==<span class="hljs-built_in">lowbit</span>(S)) res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(S==U) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;a[y])) <span class="hljs-keyword">continue</span>;res+=<span class="hljs-built_in">dfs</span>(y,S|(<span class="hljs-number">1</span>&lt;&lt;a[y]));&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans+=<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>&lt;&lt;a[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="部分分">部分分</h2><p>搜索主要的作用是拿部分分。</p><h3 id="luogu7961-noip2021-数列">luogu7961 [NOIP2021] 数列</h3><p>前 10 个点 <span class="math inline">\(m\)</span> 比较小，<spanclass="math inline">\(S\)</span> 的范围也不会很大，考虑直接设 <spanclass="math inline">\(f(x,S&#39;)\)</span> 表示已经确定了 <spanclass="math inline">\(\{a_i\}\)</span> 的前 <spanclass="math inline">\(x\)</span> 项，<spanclass="math inline">\(S=S&#39;\)</span>，还能产生的方案数。 <spanclass="math display">\[f(x,S&#39;) = \sum_{i=0}^m v_i \times f(x+1,S&#39;+2^i)\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">35</span>, M=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, k, v[M], f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-keyword">if</span>(~f[x][S]) <span class="hljs-keyword">return</span> f[x][S];<span class="hljs-keyword">if</span>(x==n) <span class="hljs-keyword">return</span> f[x][S]=<span class="hljs-built_in">popcount</span>(S)&lt;=k;<span class="hljs-type">int</span>&amp; res=f[x][S];res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;(res+=v[i]*<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,S+(<span class="hljs-number">1</span>&lt;&lt;i)))%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) v[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));&#125;</code></pre></div><h3 id="luogu8817-csp-s-2022-假期计划">luogu8817 [CSP-S 2022]假期计划</h3><p>这题官方数据过水，以洛谷数据为准。</p><p>用 <span class="math inline">\(n\)</span> 次 <spanclass="math inline">\(\text{BFS}\)</span> 求出多源最短路。</p><p>设 <span class="math inline">\(f(x,cnt)\)</span> 为以 <spanclass="math inline">\(x\)</span> 结尾，选择了 <spanclass="math inline">\(cnt\)</span>个点的最大值。这显然是不满足最优子结构性质的：无法知道已经选过了哪些点。使用第一种记忆化方法显然是错的，而第二种做法在选点情况不同时也无法保证到达<span class="math inline">\((x,cnt)\)</span> 且当前值小于 <spanclass="math inline">\(f(x,cnt)\)</span> 最终不会更新答案。</p><p>然而这个竟然能通过 <spanclass="math inline">\(\mathfrak{CCF}\)</span> 的数据。</p><p>事实上这个搜索加上乱搞做法然后极致卡时，就能通过所有数据。不过非正解就不细说了。</p><p>下面的代码可以通过官方数据，洛谷数据会 WA 一个。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) dis[s][i]=<span class="hljs-number">1e9</span>;dis[s][s]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(dis[s][y]!=<span class="hljs-number">1e9</span>) <span class="hljs-keyword">continue</span>;dis[s][y]=dis[s][x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> cnt,<span class="hljs-type">int</span> sum)</span> </span>&#123;<span class="hljs-keyword">if</span>(f[x][cnt]!=<span class="hljs-number">0</span>&amp;&amp;f[x][cnt]&gt;=sum) <span class="hljs-keyword">return</span>;<span class="hljs-type">int</span>&amp; res=f[x][cnt];res=sum;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">5</span>) &#123; ans=<span class="hljs-built_in">max</span>(ans,sum); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span>) &#123;<span class="hljs-keyword">if</span>(dis[<span class="hljs-number">1</span>][x]&lt;=k+<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,sum);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>;y&lt;=n;++y) <span class="hljs-keyword">if</span>(x!=y&amp;&amp;!v[y]&amp;&amp;dis[x][y]&lt;=k+<span class="hljs-number">1</span>) &#123;v[y]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(y,cnt+<span class="hljs-number">1</span>,sum+a[y]);v[y]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">bfs</span>(i);<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="loj539.-libreoj-noip-round-1旅游路线">LOJ#539. 「LibreOJ NOIPRound #1」旅游路线</h3><p>观察那张大表格。</p><p>考虑前 12 个点，发现有 <span class="math inline">\(q_i \le100\)</span> 和 <span class="math inline">\(C,c_i \le 10^3\)</span>，而<span class="math inline">\(d_i\)</span> 范围相对大。</p><p>设 <span class="math inline">\(f(x,qt,ct)\)</span> 表示到达节点 <spanclass="math inline">\(x\)</span>，还剩下 <spanclass="math inline">\(qt\)</span> 的钱，<spanclass="math inline">\(ct\)</span> 的油，还能走的最大距离。</p><p>这个状态是个 <spanclass="math inline">\(\text{DAG}\)</span>，所以用记忆化搜索转移 DP即可。 <span class="math display">\[f(x,qt,ct) = \max \begin{cases}f(y,qt,ct-1)+z  &amp;  ct &gt; 0\\f (x,qt-p_x,\min\{ c_x,C\}) &amp; qt \ge p_x \text{ and }  ct &lt; c_x\end{cases}\]</span> 对于一个询问 <spanclass="math inline">\((s_i,q_i,d_i)\)</span>，枚举剩下多少钱，判断是否满足<span class="math inline">\(d_i\)</span> 的条件即可。</p><p>显然具有单调性，可以二分答案优化，不过没必要。</p><p>官方题解说这个做法能得到 <span class="math inline">\(60 \text{pts}\)</span>，不过可能是因为数据不给力，实际得分 <spanclass="math inline">\(75 \text{ pts}\)</span>。</p><p>复杂度 <span class="math inline">\(\mathcal{O} \Big((n+m)C\max\{q_i\}+ Tq_i \Big)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, C, T, ww[N][N], p[N], c[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">505</span>][<span class="hljs-number">1005</span>];vector&lt;PII &gt; g[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> qt,<span class="hljs-type">int</span> ct)</span> </span>&#123;<span class="hljs-keyword">if</span>(~f[x][qt][ct]) <span class="hljs-keyword">return</span> f[x][qt][ct];<span class="hljs-type">int</span>&amp; res=f[x][qt][ct];res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ct&lt;c[x]&amp;&amp;qt&gt;=p[x]) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(x,qt-p[x],<span class="hljs-built_in">min</span>(c[x],C)));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<span class="hljs-type">int</span> y=t.fi, z=t.se;<span class="hljs-keyword">if</span>(ct) res=<span class="hljs-built_in">max</span>(res,z+<span class="hljs-built_in">dfs</span>(y,qt,ct<span class="hljs-number">-1</span>));&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), C=<span class="hljs-built_in">read</span>(), T=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) p[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();ww[x][y]=<span class="hljs-built_in">max</span>(ww[x][y],z);        <span class="hljs-comment">// 可能有重边，取最大边权。</span>&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(ww[i][j]) g[i].<span class="hljs-built_in">pb</span>(&#123;j,ww[i][j]&#125;);<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-type">int</span> s=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=q<span class="hljs-number">-1</span>;~i;--i) <span class="hljs-keyword">if</span>(q-i&gt;=p[s]) &#123;<span class="hljs-type">int</span> t=<span class="hljs-built_in">dfs</span>(s,q-i-p[s],<span class="hljs-built_in">min</span>(c[s],C));<span class="hljs-keyword">if</span>(t&gt;=d) &#123; ans=i; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;</code></pre></div><h3 id="luogu8163-joi-2022-final-铁路旅行-2">luogu8163 [JOI 2022 Final]铁路旅行 2</h3><p>使用单调队列，我们能求出从每个 <span class="math inline">\(i\)</span>出发能到达的最左点 <span class="math inline">\(tl_i\)</span> 与最右点<span class="math inline">\(tr_i\)</span>。</p><p>一个 <span class="math inline">\(\mathtt{Navie}\)</span>的结论：任何时候能到达的点都是一个区间，并且这个区间单调扩大。</p><p>我们把换乘作为边，边权都是 <spanclass="math inline">\(1\)</span>。在图上BFS时维护当前区间，维护全局左右端点 <spanclass="math inline">\(l,r\)</span>，对于节点 <spanclass="math inline">\(i\)</span>，将 <spanclass="math inline">\([\min(l,tl_i),\max(r,tr_i)]\)</span>中的节点入队，同时更新 <span class="math inline">\(l\)</span> 为 <spanclass="math inline">\(\min\{tl_i\}\)</span>，<spanclass="math inline">\(r\)</span> 为 <spanclass="math inline">\(\max\{tr_i\}\)</span>。当终点第一次被 <spanclass="math inline">\([l,r]\)</span> 包含时，路径长度就是答案。</p><p>这样做的复杂度是 <span class="math inline">\(O(n)\)</span>的，可以得到 <span class="math inline">\(27 \text{ pts}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, m, Q, a[N], b[N], tl[N], tr[N], tl1[N], tr1[N];<span class="hljs-type">int</span> q[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-number">0</span>;queue&lt;PII &gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">MP</span>(s,<span class="hljs-number">1</span>));<span class="hljs-type">int</span> l=s, r=s;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>().fi, y=q.<span class="hljs-built_in">front</span>().se; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(s&lt;t&amp;&amp;tr[x]&gt;=t) <span class="hljs-keyword">return</span> y;<span class="hljs-keyword">if</span>(s&gt;t&amp;&amp;tl[x]&lt;=t) <span class="hljs-keyword">return</span> y;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r+<span class="hljs-number">1</span>;i&lt;=tr[x];++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">MP</span>(i,y+<span class="hljs-number">1</span>));&#125;r=<span class="hljs-built_in">max</span>(r,tr[x]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>;i&gt;=tl[x];--i)<span class="hljs-keyword">if</span>(!v[i]) &#123;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">MP</span>(i,y+<span class="hljs-number">1</span>));&#125;l=<span class="hljs-built_in">min</span>(l,tl[x]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) tr[i]=tl[i]=tl1[i]=tr1[i]=i;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]&lt;b[i]) tr[a[i]]=tr1[a[i]]=<span class="hljs-built_in">max</span>(tr1[a[i]],b[i]);<span class="hljs-keyword">else</span> tl[a[i]]=tl1[a[i]]=<span class="hljs-built_in">min</span>(tl1[a[i]],b[i]);&#125;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;i-k+<span class="hljs-number">1</span>) ++l;<span class="hljs-keyword">if</span>(l&lt;=r) tr[i]=<span class="hljs-built_in">max</span>(tr[i],tr1[q[l]]);<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;tr1[q[r]]&lt;tr1[i]) --r;q[++r]=i;&#125;l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;i+k<span class="hljs-number">-1</span>) ++l;<span class="hljs-keyword">if</span>(l&lt;=r) tl[i]=<span class="hljs-built_in">min</span>(tl[i],tl1[q[l]]);<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;tl1[q[r]]&gt;tl1[i]) --r;q[++r]=i;&#125;Q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">bfs</span>(s,t));&#125;&#125;</code></pre></div><h3 id="luogu9375-droiround-2-划分">luogu9375 「DROI」Round 2 划分</h3><p>对于 <span class="math inline">\(\text{subtask1}\)</span>，只需要枚举每个数是接在前面还是新开一段，然后扫一遍统计答案，复杂度<span class="math inline">\(O(n2^n)\)</span>。</p><p>观察 <span class="math inline">\(\text{subtask 2}\)</span>，总的段数<span class="math inline">\(m\)</span> 不超过 <spanclass="math inline">\(20\)</span>，那么直接把它们状压了，把划分区间放置区间，从前往后放，同时预处理任意区间的答案，复杂度可以做到<span class="math inline">\(O(m2^m)\)</span>。</p><p>观察 <span class="math inline">\(\text{subtask3}\)</span>，区间长度最多只有 <span class="math inline">\(5\)</span>种，数量算一下也不会很多，仿照乌龟棋就能做了。</p><p>这就有了 <span class="math inline">\(50 \text{ pts}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P9375 「DROI」Round 2 划分</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P9375</span><span class="hljs-comment">// Author: KisaragiQwQ</span><span class="hljs-comment">// Date: 2023-06-25 15:20:38</span><span class="hljs-comment">// Memory Limit: 128 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">128</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, NN=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>;<span class="hljs-type">int</span> n, ans, m, mx, ss, a[N], c[N], bel[N];<span class="hljs-type">int</span> squ[<span class="hljs-number">20005</span>], v[N][N];<span class="hljs-keyword">namespace</span> sub3 &#123;<span class="hljs-type">int</span> U, g[NN];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-keyword">if</span>(~g[S]) <span class="hljs-keyword">return</span> g[S];g[S]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> T=U^S, sum=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) <span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) sum+=bel[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) <span class="hljs-keyword">if</span>(T&amp;(<span class="hljs-number">1</span>&lt;&lt;i)&amp;&amp;sum+bel[i]<span class="hljs-number">-1</span>&lt;=n) &#123;g[S]=<span class="hljs-built_in">max</span>(g[S],<span class="hljs-built_in">dfs</span>(S|(<span class="hljs-number">1</span>&lt;&lt;i))+v[sum][sum+bel[i]<span class="hljs-number">-1</span>]);&#125;<span class="hljs-keyword">return</span> g[S];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>));&#125;&#125;;<span class="hljs-keyword">namespace</span> sub4 &#123;<span class="hljs-type">int</span> g[<span class="hljs-number">55</span>][<span class="hljs-number">26</span>][<span class="hljs-number">18</span>][<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> c1,<span class="hljs-type">int</span> c2,<span class="hljs-type">int</span> c3,<span class="hljs-type">int</span> c4,<span class="hljs-type">int</span> c5)</span> </span>&#123;<span class="hljs-keyword">if</span>(~g[c1][c2][c3][c4][c5]) <span class="hljs-keyword">return</span> g[c1][c2][c3][c4][c5];<span class="hljs-type">int</span>&amp; res=g[c1][c2][c3][c4][c5];res=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> sum=c[<span class="hljs-number">1</span>]-c1+<span class="hljs-number">2</span>*(c[<span class="hljs-number">2</span>]-c2)+<span class="hljs-number">3</span>*(c[<span class="hljs-number">3</span>]-c3)+<span class="hljs-number">4</span>*(c[<span class="hljs-number">4</span>]-c4)+<span class="hljs-number">5</span>*(c[<span class="hljs-number">5</span>]-c5)+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(c1&gt;<span class="hljs-number">0</span>) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(c1<span class="hljs-number">-1</span>,c2,c3,c4,c5)+v[sum][sum]);<span class="hljs-keyword">if</span>(c2&gt;<span class="hljs-number">0</span>) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(c1,c2<span class="hljs-number">-1</span>,c3,c4,c5)+v[sum][sum+<span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span>(c3&gt;<span class="hljs-number">0</span>) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(c1,c2,c3<span class="hljs-number">-1</span>,c4,c5)+v[sum][sum+<span class="hljs-number">2</span>]);<span class="hljs-keyword">if</span>(c4&gt;<span class="hljs-number">0</span>) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(c1,c2,c3,c4<span class="hljs-number">-1</span>,c5)+v[sum][sum+<span class="hljs-number">3</span>]);<span class="hljs-keyword">if</span>(c5&gt;<span class="hljs-number">0</span>) res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(c1,c2,c3,c4,c5<span class="hljs-number">-1</span>)+v[sum][sum+<span class="hljs-number">4</span>]);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">-1</span>);g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(c[<span class="hljs-number">1</span>],c[<span class="hljs-number">2</span>],c[<span class="hljs-number">3</span>],c[<span class="hljs-number">4</span>],c[<span class="hljs-number">5</span>]));&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i*i&lt;=mx;++i) squ[i*i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;++j) &#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;++k) &#123;<span class="hljs-keyword">if</span>(squ[<span class="hljs-built_in">abs</span>(a[k]-a[i])]) ++x;<span class="hljs-keyword">if</span>(squ[<span class="hljs-built_in">abs</span>(a[j]-a[k])]) ++y;&#125;v[i][j]=x*y;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), mx=<span class="hljs-built_in">max</span>(mx,a[i]);<span class="hljs-type">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;c[i]=<span class="hljs-built_in">read</span>(), ss+=i*c[i];<span class="hljs-keyword">if</span>((i&gt;<span class="hljs-number">5</span>&amp;&amp;c[i]!=<span class="hljs-number">0</span>)) fg=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> t=c[i];<span class="hljs-keyword">while</span>(t--) bel[m++]=i;&#125;<span class="hljs-keyword">if</span>(ss!=n) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>), <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">if</span>(fg) sub4::<span class="hljs-built_in">solve</span>(); <span class="hljs-keyword">else</span> sub3::<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// sub3::solve();</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>然而正解就比较人类智慧了。</p><p>注意到所有 <span class="math inline">\(c_i\)</span>构成的一个集合，其中元素的总和是不断变小的，然后放置区间是一个很能 <spanclass="math inline">\(\text{DP}\)</span>的过程。假定我们有一种哈希方法能唯一表示一个集合的状态，状态的数量却不是很容易计算，如果数量过多，那么这种做法也就没有意义了。</p><p>教练用搜索剪枝和一些奇技淫巧，用时 5 min 跑出了 <spanclass="math inline">\(n=120\)</span> 的状态总数，我记得好像也就 <spanclass="math inline">\(10^6\)</span>？</p><p>貌似用 GF 算一下也行，但是手算有点逆天。</p><p>由于每个 <span class="math inline">\(c_i\)</span>单调不增，所以我们这样进行一个进制哈希。</p><div class="code-wrapper"><pre><code class="hljs cpp">pre[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pre[i]=pre[i<span class="hljs-number">-1</span>]*(q.c[i]+<span class="hljs-number">1</span>);<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> c[N]; &#125; q;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vary</span><span class="hljs-params">(node x)</span> </span>&#123;<span class="hljs-type">int</span> id=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) id+=x.c[i]*pre[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">return</span> id;&#125;</code></pre></div><p>记忆化搜索即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> sub2 &#123;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node x)</span> </span>&#123;<span class="hljs-type">int</span> S=<span class="hljs-built_in">vary</span>(x);<span class="hljs-keyword">if</span>(~f[S]) <span class="hljs-keyword">return</span> f[S];f[S]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum+=i*x.c[i];<span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(x.c[i]&gt;<span class="hljs-number">0</span>) &#123;node y=x;--y.c[i];f[S]=<span class="hljs-built_in">max</span>(f[S],<span class="hljs-built_in">dfs</span>(y)+v[sum-i+<span class="hljs-number">1</span>][sum]);&#125;<span class="hljs-keyword">return</span> f[S];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(q));&#125;&#125;;</code></pre></div><p>这部分未完待续。</p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>搜索</tag>
      
      <tag>状态压缩</tag>
      
      <tag>搜索剪枝</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6835 线形生物 题解</title>
    <link href="/2023/lg6835-solution/"/>
    <url>/2023/lg6835-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>上古时期写的，那时候竟然还会期望……</p><h2 id="分析">分析</h2><p>是上一题的加强版。</p><p>由于每个台阶都多了若干出边，所以不能采用上题第一种状态了。</p><p>参考了洛谷第一篇题解的推式子方式。</p><p>设 <span class="math inline">\(E(x,y)\)</span> 为线性生物从 <spanclass="math inline">\(x\)</span> 爬到 <spanclass="math inline">\(y\)</span> 的期望步数，<spanclass="math inline">\(\operatorname{deg}_x\)</span> 表示 <spanclass="math inline">\(x\)</span> 节点的入度，不包含 <spanclass="math inline">\((x-1 \rightarrow x)\)</span>。</p><p>此时有 <span class="math display">\[E(x,x+1) = \frac{1}{\operatorname{deg}_x+1} \cdot 1 +\frac{1}{\operatorname{deg}_x +1} \sum_{(x \rightarrow y)} 1 +E(y,x+1)\]</span> 含义：在 <span class="math inline">\(deg_x+1\)</span>种走法中，有一条正好是 <span class="math inline">\((x \rightarrowx+1)\)</span>，权值为 <spanclass="math inline">\(1\)</span>。对于其他每一条 <spanclass="math inline">\((x,y)\)</span>，都要从 <spanclass="math inline">\(y\)</span> 走到 <spanclass="math inline">\(x+1\)</span>，且还要加上走到 <spanclass="math inline">\(y\)</span> 的 <spanclass="math inline">\(1\)</span>。</p><p>化简原式。根据期望的线性性，有 <span class="math inline">\(E(y,x+1) =\sum_{i=y}^x E(i,i+1)\)</span>，带进去得到 <span class="math display">\[E(x,x+1) = 1 + \frac{1}{\operatorname{deg}_x+1} \cdot \sum_{(x\rightarrow y)} \sum_{i=y}^x E(i,i+1)\]</span>含义：不管走到哪里，肯定要走一步。后面的部分就是走到不同的点的不同权值。</p><p>此时所有代表状态都是从一个点到编号 <spanclass="math inline">\(+1\)</span> 的点。不妨设 <spanclass="math inline">\(f_x = E(x,x+1)\)</span>，<spanclass="math inline">\(g_x= \sum_{i=0}^x f_i\)</span> 则 <spanclass="math display">\[f_x = 1 + \frac{1}{\operatorname{deg}_x + 1} \cdot \sum_{(x \rightarrowy)} g_x - g_{y-1}\]</span> 注意到右边含有一个 <spanclass="math inline">\(\frac{\operatorname{deg}_x}{\operatorname{deg}_x+1}\cdot f_x\)</span>，化简得到 <span class="math display">\[f_x = \frac{\operatorname{deg}_x}{\operatorname{deg}_x +1} \cdot f_x + 1+ \frac{1}{\operatorname{deg}_x + 1} \cdot \sum_{(x \rightarrow y)}g_{x-1} - g_{y-1}\]</span></p><p><span class="math display">\[\frac{f_x}{\operatorname{deg}_x+1} = 1 + \frac{1}{\operatorname{deg}_x +1} \cdot \sum_{(x \rightarrow y)} g_{x-1} - g_{y-1}\]</span></p><p><span class="math display">\[f_x = \operatorname{deg}_x + 1 + \sum_{(x \rightarrow y)} g_{x-1} -g_{y-1}\]</span></p><p>由于 <span class="math inline">\(y=x+1\)</span> 时没有贡献，<spanclass="math inline">\(y \neq x+1\)</span> 时一定有 <spanclass="math inline">\(y \lex\)</span>，所以很容易按照编号从小到大的拓扑序求出 <spanclass="math inline">\(f_x\)</span> 和 <spanclass="math inline">\(g_x\)</span>。</p><p>最终答案为 <span class="math inline">\(g_n\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> id, n, m, f[N], g[N], deg[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;id=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), ++deg[x];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;f[x]=deg[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];(f[x]+=(g[x<span class="hljs-number">-1</span>]-g[y<span class="hljs-number">-1</span>]+mod)%mod)%=mod;&#125;g[x]=(g[x<span class="hljs-number">-1</span>]+f[x])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,g[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6772 美食家 题解</title>
    <link href="/2023/lg6772-solution/"/>
    <url>/2023/lg6772-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>上古时代写的题解了。</p><h2 id="分析">分析</h2><p>先不考虑美食节的影响。</p><p>考虑到节点数和边权都很小，不妨拆点。将每个点拆为 <spanclass="math inline">\(5\)</span> 个点，其中第 <spanclass="math inline">\(5\)</span> 个点是起始点，第 <spanclass="math inline">\(1\)</span>个点是终点。这样边权就变化为了经过的节点数。也就是说，到达节点 <spanclass="math inline">\(x\)</span> 转化为到达 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(5\)</span> 个节点，而从 <spanclass="math inline">\(x\)</span> 到达 <spanclass="math inline">\(y\)</span> 权值为 <spanclass="math inline">\(z\)</span>，转化为从 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(6-z\)</span> 个节点到达 <spanclass="math inline">\(y\)</span> 的第 <spanclass="math inline">\(5\)</span> 个节点，权值全部为 <spanclass="math inline">\(1\)</span>。同时，五个节点之间边权全部为 <spanclass="math inline">\(0\)</span>。</p><p>这样做的好处就是，所谓代价，也就是天数，就转化为了阶段。</p><p>设 <span class="math inline">\(f(i,x)\)</span> 表示第 <spanclass="math inline">\(i\)</span> 天在第 <spanclass="math inline">\(x\)</span> 个城市，所能获得的最大收益。 <spanclass="math display">\[f(i+1,x) = \max_{(x,y) \in E} \Big\{ f(i,y) + c_x \Big\}\]</span> 边界是 <spanclass="math inline">\(f(0,1)=c_1\)</span>，其余为负无穷。</p><p>其中 <span class="math inline">\(c_x\)</span> 表示到达节点 <spanclass="math inline">\(x\)</span> 的收益。转化过来就是到达 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(5\)</span> 个节点的收益。</p><p>设 <span class="math inline">\(id(i,x)\)</span> 为 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(i\)</span> 个节点，答案为 <spanclass="math inline">\(f \Big( T,id(5,1) \Big)\)</span>。</p><p>但是 <span class="math inline">\(T\)</span> 太大了，又因为 <spanclass="math inline">\((\max,+)\)</span>的运算满足结合律，考虑矩阵加速。常规操作是把要转移的这个东西搞成一个向量，做<span class="math inline">\(O(n^2)\)</span> 的矩阵向量乘法，但是由于<span class="math inline">\(T\)</span>的存在，数组是开不下的，只能用滚动数组优化，这样就不能封装成向量，必须手写一个广义矩阵向量乘法了。</p><p>考虑转移矩阵 <span class="math inline">\(A\)</span>，要满足 <spanclass="math display">\[f(i+1,x) = \max_{}\Big\{ f(i,y) + A_{y,x}  \Big\}\]</span> 所以 <span class="math inline">\(A_{y,x}\)</span> 必须表示从<span class="math inline">\(y\)</span> 到达 <spanclass="math inline">\(x\)</span> 的收益。</p><p>所以跑个 <span class="math inline">\(A\)</span> 的 <spanclass="math inline">\(T\)</span> 次幂再乘起来就行了。</p><p>这时候考虑存在美食节，不难发现美食节 <spanclass="math inline">\(i\)</span> 仅仅对 <spanclass="math inline">\(t_i\)</span> 天的 <spanclass="math inline">\(x_i\)</span> 有效。所以可以求出 <spanclass="math inline">\(i-1\)</span> 天的状态之后，手动给 <spanclass="math inline">\(f \Big(t_i,id(5,x_i) \Big)\)</span> 加上 <spanclass="math inline">\(y_i\)</span>，显然不会有更优的方案了。</p><p>于是将 <span class="math inline">\(t_i\)</span>递增排序，分段处理即可。和上题处理询问相同，预处理倍增次幂，对每一段进行二进制拆分优化，做复杂度为<span class="math inline">\(O(n^2)\)</span> 的矩阵向量乘法。</p><p>如果最后答案小于 <spanclass="math inline">\(0\)</span>，那么无解。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> n, m, T, k, lim, cur, ans, w[<span class="hljs-number">256</span>], f[<span class="hljs-number">2</span>][<span class="hljs-number">256</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Festival</span> &#123; <span class="hljs-type">int</span> t, x, y; &#125; fs[<span class="hljs-number">205</span>];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Festival a,Festival b) &#123; <span class="hljs-keyword">return</span> a.t&lt;b.t; &#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">256</span>][<span class="hljs-number">256</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(m)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lim;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; rec[<span class="hljs-number">35</span>];Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lim;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;lim;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;lim;++j)c.m[i][j]=<span class="hljs-built_in">max</span>(c.m[i][j],a.m[i][k]+b.m[k][j]);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;~i;--i) <span class="hljs-keyword">if</span>((x&gt;&gt;i)&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">memset</span>(f[cur^<span class="hljs-number">1</span>],<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f[cur^<span class="hljs-number">1</span>]));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;lim;++k) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;lim;++j)f[cur^<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">max</span>(f[cur^<span class="hljs-number">1</span>][j],f[cur][k]+rec[i].m[k][j]);        <span class="hljs-comment">// 广义矩阵向量乘法</span>cur^=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (i<span class="hljs-number">-1</span>)*n+j; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), T=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();lim=<span class="hljs-number">5</span>*n;rec[<span class="hljs-number">0</span>].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, z=<span class="hljs-built_in">read</span>();rec[<span class="hljs-number">0</span>].m[<span class="hljs-built_in">id</span>(<span class="hljs-number">6</span>-z,x)][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,y)]=w[y];        <span class="hljs-comment">// 一定要记清楚，自己的转移矩阵表示的是什么</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) fs[i].t=<span class="hljs-built_in">read</span>(), fs[i].x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, fs[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(fs+<span class="hljs-number">1</span>,fs+k+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) rec[<span class="hljs-number">0</span>].m[<span class="hljs-built_in">id</span>(i+<span class="hljs-number">1</span>,j)][<span class="hljs-built_in">id</span>(i,j)]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 拆开的点相互到达不计代价</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">30</span>;++i) rec[i]=rec[i<span class="hljs-number">-1</span>]*rec[i<span class="hljs-number">-1</span>];<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));f[cur][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)]=w[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-type">int</span> dlt=fs[i].t-fs[i<span class="hljs-number">-1</span>].t;<span class="hljs-built_in">trans</span>(dlt);f[cur][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,fs[i].x)]+=fs[i].y;&#125;<span class="hljs-keyword">if</span>(fs[k].t&lt;T) <span class="hljs-built_in">trans</span>(T-fs[k].t);    <span class="hljs-comment">// 如果还有时间就再变换</span>ans=f[cur][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans&gt;=<span class="hljs-number">0</span>? ans:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nameless Contest（1）</title>
    <link href="/2023/contest1/"/>
    <url>/2023/contest1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>22 年某模拟赛。</p><p>本人也没有参加，为了造福大众就公开题面了。</p><p><del>反正也没什么人看这个博客</del>。</p><p>会选择性略去一些部分分条件。</p><h2 id="简单题">简单题</h2><p><span class="math inline">\(\text{Time Limit: 2 s}\)</span></p><p><span class="math inline">\(\text{Memory Limit: 256 MB}\)</span></p><blockquote><p>给定 <span class="math inline">\(n,x,y\)</span> 和 <spanclass="math inline">\(a,b,c,d\)</span>，求有多少个长度为 <spanclass="math inline">\(n\)</span> 的正整数序列 <spanclass="math inline">\(\{s\}\)</span>，满足 <spanclass="math inline">\(\forall i \in [1,n] \cap\mathbb{Z}\)</span>，<span class="math inline">\(s_i \in[x,y]\)</span>，且 <span class="math inline">\(\sum_{i=1}^n s_i \in[a,b]\)</span>，<span class="math inline">\(\sum_{i=1}^n s_i^2 \in[c,d]\)</span>，对 <spanclass="math inline">\(\mathbf{998244353}\)</span> 取模。</p><p>对于 <span class="math inline">\(40 \%\)</span> 的数据，<spanclass="math inline">\(n \le 5\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n \le 28\)</span>，<span class="math inline">\(1\le x \le y &lt; 1000\)</span>，<span class="math inline">\(y-x \le9\)</span>，<span class="math inline">\(a,b,c,d \in[1,10^9]\)</span>。</p></blockquote><p>部分分就是直接暴搜 <span class="math inline">\(n\)</span>个数填什么。</p><p>注意到值域非常小，考虑搜索每个数用了多少次，方案数用多重集全排列算。</p><p>复杂度？</p><p>不限制物品个数的多重集组合数，方案数 <spanclass="math inline">\(\binom{n+m-1}{m-1}\)</span>，其中 <spanclass="math inline">\(m=y-x+1\)</span>。</p><p>是 <span class="math inline">\(10^7\)</span> 级别的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> num s-<span class="hljs-string">&#x27;0&#x27;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-type">int</span> x;    <span class="hljs-type">char</span> s;    x=<span class="hljs-number">0</span>;    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(s=<span class="hljs-built_in">getchar</span>()))        (s==<span class="hljs-string">&#x27;-&#x27;</span>)&amp;&amp;(flag=<span class="hljs-literal">true</span>);    <span class="hljs-keyword">for</span>(x=num;<span class="hljs-built_in">isdigit</span>(s=<span class="hljs-built_in">getchar</span>());x=x*<span class="hljs-number">10</span>+num);    (flag)&amp;&amp;(x=-x);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2333</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n;<span class="hljs-type">int</span> a,b,c,d,x,y;<span class="hljs-type">int</span> jc[maxn];<span class="hljs-type">int</span> ni[maxn];<span class="hljs-type">int</span> ak[maxn],ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(y)&#123;<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans *= x,ans %= mod;x *= x,x %= mod,y&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> q,<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> e,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> fn)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(q == y)&#123;ak[y] = n - w;e += y * ak[y];z += y * y * ak[y];<span class="hljs-keyword">if</span>(a &lt;= e &amp;&amp; e &lt;= b &amp;&amp; c &lt;= z &amp;&amp; z &lt;= d)&#123;ans += fn * ni[ak[y]] % mod;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;w+i&lt;=n;++i)&#123;<span class="hljs-built_in">dfs</span>(q+<span class="hljs-number">1</span>,w+i,e+i*q,z+i*q*q,fn * ni[i] % mod);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n = <span class="hljs-built_in">read</span>();x = <span class="hljs-built_in">read</span>(),y = <span class="hljs-built_in">read</span>();a = <span class="hljs-built_in">read</span>(),b = <span class="hljs-built_in">read</span>(),c = <span class="hljs-built_in">read</span>(),d = <span class="hljs-built_in">read</span>();jc[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) jc[i] = jc[i<span class="hljs-number">-1</span>] * i % mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ni[i] = <span class="hljs-built_in">ksm</span>(jc[i],mod<span class="hljs-number">-2</span>);ni[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,jc[n]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans % mod);&#125;</code></pre></div><h2 id="套路题">套路题</h2><p><span class="math inline">\(\text{Time Limit: 2 s}\)</span></p><p><span class="math inline">\(\text{Memory Limit: 512 MB}\)</span></p><blockquote><p>给出一个拓扑序为 <span class="math inline">\(1 \sim n\)</span> 的DAG，对于任意 <span class="math inline">\((i,j)\)</span> 且 <spanclass="math inline">\(i&lt;j\)</span>，满足存在一条从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的边，长度为 <spanclass="math inline">\(a_i \times (n-i) + b_j \times j + c \times \lfloor\frac{j}{i} \rfloor\)</span>。另外还有 <spanclass="math inline">\(m\)</span> 条特殊有向边，第 <spanclass="math inline">\(i\)</span> 条长度为 <spanclass="math inline">\(d_i\)</span>。</p><p>求 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的最短路。</p><p>对于 <span class="math inline">\(100 \%\)</span> 的数据，<spanclass="math inline">\(0 \le a_i,b_i,c_i \le 10^4\)</span>，<spanclass="math inline">\(1 \le d_i \le 10^9\)</span>。</p><p>对于 <span class="math inline">\(\frac{1}{6}\)</span> 的数据，<spanclass="math inline">\(n,m \le 300\)</span>，<spanclass="math inline">\(c \le 1000\)</span>。</p><p>对于 <span class="math inline">\(\frac{1}{3}\)</span> 的数据，<spanclass="math inline">\(n,m \le 6000\)</span>，<spanclass="math inline">\(c \le 1000\)</span>。</p><p>对于另外 <span class="math inline">\(\frac{1}{3}\)</span>的数据，<span class="math inline">\(c=0\)</span>.</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n,m \le 2 \times 10^5\)</span>，<spanclass="math inline">\(0 \le c \le 10000\)</span>。</p></blockquote><p>拓扑序为 <span class="math inline">\(1 \sim n\)</span>，那么设 <spanclass="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(i\)</span> 的最短路，之后用 <spanclass="math inline">\(f_i\)</span> 沿着从 <spanclass="math inline">\(i\)</span> 连出的特殊有向边更新其他点即可。</p><p>对于前两个 subtask 就直接暴力做。</p><p>对于 <span class="math inline">\(c=0\)</span> 的情况，<spanclass="math inline">\(j\)</span> 到任何点的代价都不会改变，维护 <spanclass="math inline">\(g_j = f_j + b_j \times (n-j)\)</span>的前缀最小值即可。</p><p>考虑扩展上述做法，当 <span class="math inline">\(i-1 \rightarrowi\)</span> 时，什么样的 <span class="math inline">\(j\)</span>的代价会改变呢？</p><p>当且仅当 <span class="math inline">\(\lfloor \frac{i-1}{j} \rfloor\neq \lfloor \frac{i}{j} \rfloor\)</span>，这样的 <spanclass="math inline">\(j\)</span> 一定是 <spanclass="math inline">\(i\)</span> 的约数。因此只需要枚举 <spanclass="math inline">\(i\)</span>的约数，暴力修改。再用线段树维护最小值。</p><p>枚举约数的过程是 <span class="math inline">\(O(\sqrt n)\)</span>的，使用倍数法可以在 <span class="math inline">\(O(n \log n)\)</span>的复杂度内求出 <span class="math inline">\(1 \sim n\)</span>所有数的倍数，所以复杂度大概是 <span class="math inline">\(O( n \log n +n \sigma_0 (n) \log_2 n + m)\)</span>。</p><p>常数挺小的，应该能卡过。但是 std 采用的是枚举约数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200005</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">stu</span>&#123;<span class="hljs-type">int</span> to,nxt,w;&#125;se[maxn];<span class="hljs-type">int</span> f[maxn],hd[maxn],cnt;<span class="hljs-type">int</span> a[maxn],b[maxn],c,m,n;<span class="hljs-meta">#<span class="hljs-keyword">define</span> num s-<span class="hljs-string">&#x27;0&#x27;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span></span>&#123;    <span class="hljs-type">char</span> s;    x=<span class="hljs-number">0</span>;    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(s=<span class="hljs-built_in">getchar</span>()))        (s==<span class="hljs-string">&#x27;-&#x27;</span>)&amp;&amp;(flag=<span class="hljs-literal">true</span>);    <span class="hljs-keyword">for</span>(x=num;<span class="hljs-built_in">isdigit</span>(s=<span class="hljs-built_in">getchar</span>());x=x*<span class="hljs-number">10</span>+num);    (flag)&amp;&amp;(x=-x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jia</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span>&#123;se[++cnt].to = y,se[cnt].nxt = hd[x],hd[x] = cnt,se[cnt].w = z;&#125;<span class="hljs-type">int</span> minn[maxn * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pu</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><span class="hljs-function"></span>&#123;minn[p] = <span class="hljs-built_in">min</span>(minn[p&lt;&lt;<span class="hljs-number">1</span>],minn[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(l == r)&#123;minn[p] = f[l] + a[l] * (n-l);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(l,mid,p&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,r,p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>),<span class="hljs-built_in">pu</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gai</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> v)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(l == r)&#123;minn[p] = v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">gai</span>(l,mid,p&lt;&lt;<span class="hljs-number">1</span>,pos,v);<span class="hljs-keyword">else</span> <span class="hljs-built_in">gai</span>(mid+<span class="hljs-number">1</span>,r,p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,pos,v);<span class="hljs-built_in">pu</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(m); <span class="hljs-built_in">read</span>(c);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">read</span>(a[i]),<span class="hljs-built_in">read</span>(b[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x,y,z; <span class="hljs-built_in">read</span>(x),<span class="hljs-built_in">read</span>(y),<span class="hljs-built_in">read</span>(z); <span class="hljs-built_in">jia</span>(x,y,z);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) f[i] = <span class="hljs-number">1e18</span>;<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<span class="hljs-keyword">if</span>(i != <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=i;++j)&#123;<span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">gai</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,j,f[j] + a[j]*(n-j) + c * (i/j));<span class="hljs-keyword">if</span>(j*j != i &amp;&amp; j!=<span class="hljs-number">1</span>)<span class="hljs-built_in">gai</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,i/j,f[i/j] + a[i/j]*(n-i/j) + c * j);&#125;&#125;&#125;f[i] = <span class="hljs-built_in">min</span>(f[i],minn[<span class="hljs-number">1</span>] + b[i] * i);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=hd[i];j;j=se[j].nxt)&#123;<span class="hljs-type">int</span> v = se[j].to;f[v] = <span class="hljs-built_in">min</span>(f[v],f[i] + se[j].w);&#125;<span class="hljs-built_in">gai</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,i,f[i] + a[i] * (n-i) + c);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div><h2 id="基础题">基础题</h2><p><span class="math inline">\(\text{Time Limit: 1 s}\)</span></p><p><span class="math inline">\(\text{Memory Limit: 256 MB}\)</span></p><blockquote><p>小曹和他的妹子玩取石子游戏，轮流取，小曹先手。 第一轮只能取 <spanclass="math inline">\(1\)</span> 个石子，若第 <spanclass="math inline">\(i-1\)</span> 轮取了 <spanclass="math inline">\(x\)</span> 个石子，则第 轮只能取 <spanclass="math inline">\(2x\)</span> 个或者 <spanclass="math inline">\(2x+1\)</span> 个石子，谁没法再取谁就输了。由于小曹非常调皮，想欺负他的妹子，于是他快速的计算出了假设初始有个石子，他有多少种方案(奇数轮取上一轮的两倍还是两倍多一个），使得他的妹子无论怎么取，他都能获得胜利。他想考考你，对于所有的 <span class="math inline">\(n \in[l,r]\)</span>，让他获得胜利的方案数的和。两种方案不同，当且仅当存在某一轮，小曹在一种方案中取了上一轮的两倍，而在另一种方案中取了上一轮的两倍多一个，与曹队的妹子怎么取无关。</p></blockquote><p>不会做。</p><p>看题解感觉还是比较人类智慧的。</p><p>咕咕咕。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">char</span> c; <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> f = <span class="hljs-number">1</span>;c = <span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;c = <span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;x = x * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;c = <span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> x * f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200005</span>;<span class="hljs-type">int</span> a[maxn];<span class="hljs-comment">//1 2 4 8</span><span class="hljs-comment">//1 3 6 12</span><span class="hljs-comment">//1 + 2 + 4 = 7</span><span class="hljs-comment">//1 3 7 15...</span><span class="hljs-type">int</span> gai[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jisuan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> qwq)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(qwq == <span class="hljs-number">1</span>)&#123;gai[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">18</span>;++i) gai[i] = (<span class="hljs-number">1ll</span>&lt;&lt;(<span class="hljs-number">2</span>*i<span class="hljs-number">-1</span>)) - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;gai[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">18</span>;++i) gai[i] = (<span class="hljs-number">1ll</span>&lt;&lt;(<span class="hljs-number">2</span>*i)) - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>);++j)&#123;<span class="hljs-type">int</span> aa = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">18</span>;++k)&#123;<span class="hljs-keyword">if</span>((j&gt;&gt;k)&amp;<span class="hljs-number">1</span>)&#123;aa += gai[k+<span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">if</span>(x &gt;= aa)ans += x - aa + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-type">int</span> ans = <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">38</span>;++i)&#123;<span class="hljs-keyword">if</span>(a[i] &gt; x) <span class="hljs-keyword">return</span> ans;<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>,z = <span class="hljs-number">1</span>,qwq;<span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j)&#123;<span class="hljs-keyword">if</span>(j%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) z = z * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> z *= <span class="hljs-number">2</span>;y += z;&#125;qwq = <span class="hljs-built_in">min</span>(a[i+<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>,x) - y + <span class="hljs-number">1</span>;qwq --;<span class="hljs-keyword">if</span>(qwq &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;ans += <span class="hljs-built_in">jisuan</span>(qwq,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j)&#123;<span class="hljs-keyword">if</span>(j%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) z *= <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> z *= <span class="hljs-number">2</span>,z +=<span class="hljs-number">1</span>;y += z;&#125;y --;qwq = y - a[i] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x &lt; y)&#123;ans -= <span class="hljs-built_in">jisuan</span>(y-x<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>);&#125;qwq --;<span class="hljs-keyword">if</span>(qwq &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;ans += <span class="hljs-built_in">jisuan</span>(qwq,<span class="hljs-number">2</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> l = <span class="hljs-built_in">read</span>(),r = <span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">38</span>;++i)&#123;x *= <span class="hljs-number">2</span>; a[i] = a[i<span class="hljs-number">-1</span>] + x;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-built_in">solve</span>(r) - <span class="hljs-built_in">solve</span>(l - <span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="不配压轴的题">不配压轴的题</h2><p><span class="math inline">\(\text{Time Limit: 1.5 s}\)</span></p><p><span class="math inline">\(\text{Memory Limit: 1 GB}\)</span></p><blockquote><p>给定一棵有 <span class="math inline">\(n\)</span> 节点的树，满足<span class="math inline">\(2 \midn\)</span>。定义两个点配对时，它们路径上的点都会被覆盖 <spanclass="math inline">\(1\)</span> 次。求将 <spanclass="math inline">\(n\)</span> 个点两两配对，且每条边都至少被覆盖过<span class="math inline">\(1\)</span> 次的方案数。对 <spanclass="math inline">\(P\)</span> 取模。</p><p>对于 <span class="math inline">\(25\%\)</span> 的数据，<spanclass="math inline">\(n \le 16\)</span>。</p><p>对于 <span class="math inline">\(50\%\)</span> 的数据，<spanclass="math inline">\(n \le 300\)</span>。</p><p>对于 <span class="math inline">\(75\%\)</span> 的数据，<spanclass="math inline">\(n \le 5000\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n \le 10000\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(P \le 1.1 \times 10^9\)</span>。</p></blockquote><p>原题是 <ahref="https://atcoder.jp/contests/arc101/tasks/arc101_c">ARC101E</a>。</p><p>对于 subtask 1，直接暴搜即可，总匹配方案数是 <spanclass="math inline">\(10^6\)</span> 级别的。</p><p><span class="math inline">\(\texttt{Observation}\)</span></p><p>一条边 <span class="math inline">\(\Big(x,fa(x) \Big)\)</span>没有被覆盖的充要条件是以 <span class="math inline">\(x\)</span>为根的子树中，没有点和外面的点匹配。</p><p>考虑一个暴力，设 <span class="math inline">\(f(x,i)\)</span> 为以<span class="math inline">\(x\)</span> 为根的子树中，有 <spanclass="math inline">\(i\)</span> 个点要和外面的点匹配的方案数。 <spanclass="math display">\[f(x,i) f(y,j) \binom{i}{k} \binom{j}{k} k! \rightarrow g_{i+j-2k}\]</span> 复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><p> </p><p>考虑正解。</p><p>把这些没有被覆盖的边看作特殊边，那么整棵树就被若干特殊边划分成了若干连通块。我们要求的是不含任何特殊边的匹配方案。</p><p>考虑容斥。钦定一个边集 <span class="math inline">\(S\)</span>，表示<span class="math inline">\(S\)</span>内的边一定是特殊边。根据<strong>子集反演</strong>，容斥系数为 <spanclass="math inline">\((-1)^{|S|}\)</span>。</p><p>用树形背包维护连通块，设 <spanclass="math inline">\(f_{x,i,j}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>，其中特殊边集大小为 <spanclass="math inline">\(j\)</span> 的方案数，容斥系数就是 <spanclass="math inline">\((-1)^j\)</span>。转移就是讨论 <spanclass="math inline">\((x,y)\)</span>这条边要不要加入特殊边集。如果加入，那么以 <spanclass="math inline">\(y\)</span>为根的连通块闭合，在这里可以计算任意两两匹配的方案数。</p><p>然而这样复杂度过高，瓶颈在于 <span class="math inline">\(j\)</span>这一维。一种解决方案只记录 <span class="math inline">\(j\)</span>的奇偶性，不过更好的做法则是把这个容斥系数放进 DP 值里面。具体地，对<span class="math inline">\(j\)</span> 这一维做前缀和，设 <spanclass="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span> 所在连通块大小为 <spanclass="math inline">\(i\)</span>的方案数。每有一个连通块闭合，就有一条边没有被覆盖，要多乘一个 <spanclass="math inline">\(-1\)</span>，对应到实现就是这部分的方案做减法。</p><p><span class="math inline">\(2n\)</span> 个点两两匹配的方案是 <spanclass="math display">\[\frac{\binom{2n}{n}n!}{2^n}\]</span></p><p>或者说 <span class="math display">\[h_{2n} = h_{2n-2} \times (2n-1)\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, f[N][N], g[N], sz[N], h[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">1</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) &#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=sz[y];++j) &#123;(g[i+j]+=f[x][i]*f[y][j]%mod)%=mod;(g[i]-=f[x][i]*f[y][j]%mod*h[j]%mod-mod)%=mod;&#125;&#125;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=sz[x];++i) f[x][i]=g[i], g[i]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;h[<span class="hljs-number">2</span>]=h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) h[i]=h[i<span class="hljs-number">-2</span>]*(i<span class="hljs-number">-1</span>)%mod;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) (ans+=f[<span class="hljs-number">1</span>][i]*h[i]%mod)%=mod;    <span class="hljs-comment">// 闭合最后一个连通块</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>模拟赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>线段树</tag>
      
      <tag>搜索</tag>
      
      <tag>容斥原理</tag>
      
      <tag>子集反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7386「EZEC-6」0-1 Trie 题解</title>
    <link href="/2023/lg7386-solution/"/>
    <url>/2023/lg7386-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>本文作于 2023 年 4 月。</p><p>作为一道生成函数的练习题。</p><p><del>不用生成函数推了好久还是错的。</del></p><p><del>以后遇到这类递推关系绝对首选 GF（能力范围内）</del>。</p><p>简单观察不难发现，如果 <spanclass="math inline">\(m&lt;n\)</span>，那么无解。如果 <spanclass="math inline">\(m=n\)</span>，那么只能是连续的 <spanclass="math inline">\(n\)</span> 个<code>01</code>。</p><p>考虑 <span class="math inline">\(m&gt;n\)</span>的情况，不难发现任何一个合法串都可以在一个初始串——连续的 <spanclass="math inline">\(n\)</span> 个<code>01</code>中插入 <spanclass="math inline">\(m-n\)</span> 个 <spanclass="math inline">\(0\)</span> 得到。</p><p>如果将每一对<code>01</code>看作相对封闭的块，那么往块内放不同个 <spanclass="math inline">\(0\)</span>就能得到不同的串。先观察第一块内的情况，如图是 <spanclass="math inline">\(n-m=3\)</span> 时，第一块的 Trie 树。</p><p><img src="https://i.imgtg.com/2023/06/20/OWGvRt.png" srcset="/img/loading.gif" lazyload /></p><p>由于<code>1</code>后面必然是<code>0</code>，所以用数对 <spanclass="math inline">\((n,m)\)</span> 表示从当前节点往下，还剩 <spanclass="math inline">\(n\)</span> 个<code>1</code>，<spanclass="math inline">\(m\)</span>个<code>0</code>的话，每一个<code>1</code>后面的<code>0</code>都对应着<span class="math inline">\((n-1,m-k)\)</span>，<spanclass="math inline">\(k \in [1,n-m+1]\)</span>。</p><p>划分子问题了。</p><p>于是乎设 <span class="math inline">\(f(n,m)\)</span>表示从这个<code>0</code>开始，后面还有 <spanclass="math inline">\(n\)</span> 个<code>1</code>，<spanclass="math inline">\(m\)</span> 个<code>0</code>，还需要的节点数。</p><p><span class="math display">\[f(n,m) = \sum_{k \in [1,n-m+1]} \Big(f(n-1,m-k)+2\Big)\]</span></p><p>其中当 <span class="math inline">\(n=1\)</span>时，所有<code>0</code>必须都塞进第一块，于是 <spanclass="math inline">\(f(1,0)=0\)</span>，<spanclass="math inline">\(f(1,m)=m+1\)</span>。</p><p>考虑解这个递推关系。</p><p>设 <span class="math inline">\(f\)</span> 的 <spanclass="math inline">\(OGF\)</span> 为 <spanclass="math inline">\(F_n(x)\)</span>，那么</p><p><span class="math display">\[F_1(x) = 2x+3x^2 + 4x^3 + \cdots = \frac{1}{(1-x)^2} - 1 =\frac{x(2-x)}{(1-x)^2}\]</span></p><p>根据那个递推式得到，<span class="math inline">\(F_{n-1} \rightarrowF_n\)</span> 是让所有满足 <span class="math inline">\(m \ge n-1\)</span>的 <span class="math inline">\(x_m\)</span> 加上 <spanclass="math inline">\(2\)</span> 然后再右移一位（原先 <spanclass="math inline">\(m\)</span> 个<code>1</code>对应着新的 <spanclass="math inline">\(m+1\)</span>个），最后做前缀和（这个说法不严谨，加上了<code>0</code>的数量少于<code>1</code>的数量的方案，尽管他们都是<span class="math inline">\(0\)</span>）。</p><p><span class="math display">\[F_n(x) = \Big(F_{n-1}(x) + \frac{2x^{n-1}}{1-x}\Big) \frac{x}{1-x}\]</span></p><p>又得到了一个递推式。</p><p>设 <span class="math inline">\(G_n(x) =\frac{F_n(x)}{x^n}\)</span>，那么</p><p><span class="math display">\[G_n(x) = \Big(G_{n-1}(x) + \frac{2}{1-x}\Big) \frac{1}{1-x}\]</span></p><p>由于我们知道首项 <span class="math inline">\(G_1(x)\)</span>的封闭形式 <spanclass="math inline">\(\frac{2-x}{(1-x)^2}\)</span>，所以有一种套路的方法。</p><p>考虑让左边变成 <span class="math inline">\(G_n(x) +\Delta\)</span>，满足右边是 <spanclass="math inline">\(\Big(G_{n-1}(x)+\Delta\Big)\frac{1}{1-x}\)</span>。得到 <span class="math display">\[\frac{1}{1-x} \Delta - \Delta = \frac{2}{(1-x)^2}\]</span></p><p>解得 <span class="math inline">\(\Delta =\frac{2}{x(1-x)}\)</span></p><p>因此</p><p><span class="math display">\[G_n(x) + \frac{2}{x(1-x)} = \Big(G_{n-1}(x) + \frac{2}{x(1-x)} \Big)\frac{1}{1-x}\]</span></p><p>代入 <span class="math inline">\(G_1=\frac{2-x}{(1-x)^2}\)</span></p><p><span class="math display">\[G_n(x) + \frac{2}{x(1-x)} = \Big(G_1(x) + \frac{2}{x(1-x)} \Big)\frac{1}{(1-x)^{n-1}}\]</span></p><p><span class="math display">\[G_n(x) + \frac{2}{x(1-x)} = \Big(\frac{2-x}{(1-x)^2} + \frac{2}{x(1-x)}\Big) \frac{1}{(1-x)^{n-1}}\]</span></p><p>这时候就能化简得到</p><p><span class="math display">\[G_n(x) = \frac{2-x^2}{x(1-x)^{n+1}}-\frac{2}{x(1-x)}\]</span></p><p>从而</p><p><span class="math display">\[F_n(x)=x^nG_n(x) = x^{n-1}\Big(\frac{2-x^2}{(1-x)^{n+1}}-\frac{2}{(1-x)} \Big)\]</span></p><p>然后愉快地展开</p><p><span class="math display">\[f(n,m)=[x^m]F_n(x) = [x^{m-n+1}]G_n(x)\]</span></p><p><span class="math display">\[[x^{m-n+1}]G_n(x) = [x^{m-n+1}] \left( 2\sum_{k=0}^{\infty}\binom{n+k}{k}x^k - x^2\sum_{k=0}^{\infty}\binom{n+k}{k}x^k -\sum_{k=0}^{\infty} 2x^k \right)\]</span></p><p><span class="math display">\[[x^{m-n+1}]G_n(x) = [x^{m-n+1}] \left( \sum_{k=0}^{\infty}2\binom{n+k}{k}x^k - \sum_{k=2}^{\infty}\binom{n+k-2}{k-2}x^k -\sum_{k=0}^{\infty} 2x^k \right)\]</span></p><p><span class="math display">\[[x^{m-n+1}]G_n(x) = 2\binom{m+1}{n} - \binom{m-1}{n} - 2\]</span></p><p>需要<code>Lucas</code>，然后求那个质数阶乘的逆元可以用威尔逊定理</p><p><span class="math display">\[(p-1)! \equiv -1 \pmod p\]</span> 结束。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>组合数学</tag>
      
      <tag>生成函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#7 计数杂题 (2)</title>
    <link href="/2023/noip-record-7/"/>
    <url>/2023/noip-record-7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>专门放一些不大可能会考的计数题，长期更新。</p><p>大约是输入的只有问题规模，输出的只有相应方案数。</p><h2 id="luogu6561-sbcoi2020-人">luogu6561 [SBCOI2020] 人</h2><p>两两不相邻这个条件不是很容易搞。</p><p>考虑把 <span class="math inline">\([1,2m]\)</span> 分成 <spanclass="math inline">\(m\)</span> 个数对，形如 <spanclass="math inline">\((\text{odd},\text{even})\)</span>，其中 $ +1 =$</p><p>把选择了 <span class="math inline">\(\text{odd}\)</span>的数对称为<code>A</code>，选择了 <spanclass="math inline">\(\text{even}\)</span>的数对称为<code>B</code>，没有选择的称为<code>C</code>。那么问题等价于有多少个只有<code>A</code>，<code>B</code>，<code>C</code>的字符串，满足有<span class="math inline">\(a\)</span> 个<code>A</code>，<spanclass="math inline">\(b\)</span> 个<code>B</code>和 <spanclass="math inline">\(m-a-b\)</span>个<code>C</code>，且不存在子串<code>BA</code>。</p><p>由于<code>B</code>与<code>C</code>没有限制，所以可以任意安排，只要在<span class="math inline">\(m-a\)</span> 个里面钦定 <spanclass="math inline">\(b\)</span> 个<code>B</code>即可，方案 <spanclass="math inline">\(\binom{m-a}{b}\)</span>。</p><p>接着要插入<code>A</code>，除了在 <spanclass="math inline">\(b\)</span>个<code>B</code>后面，其他位置均可，方案 <spanclass="math inline">\(\binom{m-b}{a}\)</span>。</p><p>因此答案为 <span class="math display">\[\binom{m-a}{b} \binom{m-b}{a}\]</span>其实映射到不允许子串<code>BA</code>这一步，就没有什么难的了。</p><p>而如果没有做到映射这一步，那么推理相当痛苦啊。</p><h2 id="luogu8594-kdoi-02一个仇的复">luogu8594「KDOI-02」一个仇的复</h2><p>能用到的只有 <span class="math inline">\(1 \times x\)</span> 与 <spanclass="math inline">\(2 \times 1\)</span> 的矩形。</p><p>先不关心后者，考虑只用前者的方案数。设一共用 <spanclass="math inline">\(k\)</span> 个举行铺满 <spanclass="math inline">\(2 \times m\)</span> 的网格。</p><p>枚举使用个数，如果第一行用了 <span class="math inline">\(i\)</span>个，那么第二行就要用 <span class="math inline">\(k-i\)</span>个，每一行内部都是一个经典问题 <span class="math display">\[\sum_{i=1}^{k-1} \binom{m-1}{i-1} \binom{m-1}{k-i-1} = \sum_{i=0}^{k-2}\binom{m-1}{i}\binom{m-1}{k-i-2}\]</span> 根据范德蒙德卷积可以知道这个就是 <span class="math display">\[\binom{2m-2}{k-2}\]</span> 然后就是用若干 <span class="math inline">\(2 \times 1\)</span>的矩形把原问题分割成若干上述问题。</p><p>枚举把 <span class="math inline">\(2 \times n\)</span> 的网格分成<span class="math inline">\(i\)</span> 段，使用了 <spanclass="math inline">\(j\)</span> 个 <span class="math inline">\(2 \times1\)</span> 的矩形</p><p>划分方式就是某问题，方案数 <span class="math display">\[\binom{j+1}{i}\]</span> 还有 <span class="math inline">\(n-j\)</span> 个位置分给 <spanclass="math inline">\(i\)</span> 段 <span class="math display">\[\binom{n-j-1}{i-1}\]</span> 最后是把 <span class="math inline">\(k-j\)</span> 个矩形填满<span class="math inline">\(i\)</span> 段，设第 <spanclass="math inline">\(l\)</span> 段大小为 <span class="math inline">\(2\times a_l\)</span>，用 <span class="math inline">\(b_l\)</span> 个矩形<span class="math display">\[\sum_{\sum_{l=1}^i b_l = k-j} \prod_{p=1}^i \binom{2a_p -2}{b_p - 2}\]</span> 发现是一个扩展后的范德蒙德卷积，根据组合意义得到上式即为 <spanclass="math display">\[\binom{2\sum_{p=1}^i a_p - 2i}{\sum_{p=1}^i b_p - 2i} =\binom{2(n-j)-2i}{k-j-2i}\]</span> 因此答案为 <span class="math display">\[\sum_{i=1}^k \sum_j^{r}\binom{j+1}{i}\binom{n-j-1}{i-1}\binom{2(n-j)-2i}{k-j-2i}\]</span></p><p>直接枚举 <span class="math inline">\(i,j\)</span>显然不能接受，注意到如果 <spanclass="math inline">\(k-j-2i&lt;0\)</span>，那么没有贡献，再综合一下其他的边界，对于每个<span class="math inline">\(i\)</span> 都能找到一个上界 <spanclass="math inline">\(r\)</span>，满足 <spanclass="math inline">\(r&lt;k\)</span>。所以复杂度为 <spanclass="math inline">\(O(n+k^2)\)</span></p><h2 id="abc242f-black-and-white-rooks">ABC242F Black and WhiteRooks</h2><p>看起来像是某经典问题的扩展（？</p><p>不是很容易直接做。</p><p>考虑每一种合法方案必然使得黑车与白车所占用的行与列无交，所以答案可以表示为<span class="math display">\[\sum_{i=1}^n \sum_{j=1}^{n-i}\sum_{k=1}^m\sum_{l=1}^{m-k}\binom{n}{i}\binom{n-i}{j}\binom{m}{k}\binom{m-k}{l} f_B(i,k)f_W(j,l)\]</span> 一开始的思路被局限到两重循环的枚举上了。</p><p>其中 <span class="math inline">\(f_k(i,j)\)</span> 表示用 <spanclass="math inline">\(k\)</span> 个车恰好放满 <spanclass="math inline">\(i\)</span> 行与 <spanclass="math inline">\(j\)</span> 列的方案数。</p><p>考虑如何求出。</p><p><span class="math inline">\(\texttt{solution 1}\)</span></p><p>显然可以容斥。</p><p>存在至少 <span class="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列上没有车的方案数显然是 <spanclass="math display">\[\binom{n}{i}\binom{m}{j}\binom{(n-i)(m-j)}{k}\]</span> 带上一个 <span class="math inline">\((-1)^{i+j}\)</span>的系数。</p><p><span class="math inline">\(\texttt{solution 2}\)</span></p><p>也可以换一种思路。 <span class="math display">\[f_k(n,m) = \binom{nm}{k} - \sum_{i=1}^n\sum_{j=1 \texttt{ and } (i,j)\neq (n,m)}^m \binom{n}{i}\binom{m}{j}f_k(i,j)\]</span></p><ul><li>容斥这个东西，尽量不要考虑在整体思路建立起来之前。</li><li>计数题，不要那么吝惜复杂度。毕竟有很多优化方法。适当地放宽计数的限制。</li><li>不要不经过思考就往自己知道的模型上靠。必须改掉这个习惯。</li></ul><h2 id="cf1342e-placing-rooks">CF1342E Placing Rooks</h2><p>同样是关于车的。</p><p>每个点都在车的攻击范围内，说明要么每一行都有车，要么每一列都有车。当<span class="math inline">\(k \neq 0\)</span> 时二者不能同时存在。</p><p>可以钦定每一行都有车，求出的方案数的 <spanclass="math inline">\(2\)</span> 倍即为答案。</p><p>设 <span class="math inline">\(f_i\)</span> 为恰好放 <spanclass="math inline">\(i\)</span> 个攻击型车的方案数，<spanclass="math inline">\(g_i\)</span> 为至少。</p><p>不难发现只要钦定所有车都在 <span class="math inline">\(n-i\)</span>列即可。 <span class="math display">\[g_i = \binom{n}{n-i}(n-i)^n\]</span></p><p><span class="math display">\[g_k = \sum_{i=k}^n \binom{i}{k} f_i\]</span></p><p><span class="math display">\[f_k = \sum_{i=k}^n (-1)^{i-k} \binom{i}{k} g_i\]</span></p><h2 id="cf1794d-counting-factorizations">CF1794D CountingFactorizations</h2><p>考虑这样一个事实：如果确定了 <span class="math inline">\(n\)</span>个质因数，那么方案数就是剩下 <span class="math inline">\(n\)</span>个指数做多重集全排列。</p><p>由于每个质因数只能出现一次，所以设 <spanclass="math inline">\(P\)</span> 为 <spanclass="math inline">\(A\)</span> 中的不同质数集合，<spanclass="math inline">\(|P|=m\)</span>。问题转化为求在 <spanclass="math inline">\(P\)</span> 中选择 <spanclass="math inline">\(n\)</span> 个数相对应的多重集全排列之和。</p><p>若 <spanclass="math inline">\(m&lt;n\)</span>，那么无解，因为必须满足有 <spanclass="math inline">\(n\)</span> 个质因数。</p><p>若 <span class="math inline">\(m=n\)</span>，那么答案就是</p><p><span class="math display">\[\frac{(2n-m)!}{\prod_{i=1}^{2n} (cnt_{A_i}!)}\]</span></p><p>其中 <span class="math inline">\(cnt_{A_i}\)</span> 表示 <spanclass="math inline">\(A_i\)</span> 在 <spanclass="math inline">\(A-P\)</span> 中出现的次数。</p><p>若 <span class="math inline">\(m&gt;n\)</span>，那么就是要把 <spanclass="math inline">\(m-n\)</span>个数放到指数集合中，由于放哪些数会影响全排列的值，所以考虑用 DP求所有合法的全排列的和。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 表示考虑前 <spanclass="math inline">\(i\)</span> 个数，已经选了 <spanclass="math inline">\(j\)</span> 个，<spanclass="math inline">\(f_{0,0}\)</span> 就是上面那个式子。</p><p>如果不选，直接继承 <spanclass="math inline">\(f_{i-1,j}\)</span>。如果选，就会让指数集合增大<span class="math inline">\(1\)</span>，且 <spanclass="math inline">\(P_i\)</span> 相应的集合增大 <spanclass="math inline">\(1\)</span>，因此</p><p><span class="math display">\[f_{i,j} = f_{i-1,j} + [j&gt;0] \Big(f_{i-1,j-1} \cdot\frac{2n-m+j}{cnt_{P_i}+1} \Big)\]</span></p><p>答案 <span class="math inline">\(f_{m,m-n}\)</span>。</p><p>貌似可以多项式优化。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4050</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, facn, nn, D, a[N], p[N], cnt[M], f[N][N/<span class="hljs-number">2</span>];<span class="hljs-type">int</span> tot, pr[M];<span class="hljs-type">bool</span> v[M], mp[M], mpp[M];<span class="hljs-type">int</span> fac[N], inv[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=<span class="hljs-number">1ll</span>*a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=<span class="hljs-number">1ll</span>*c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e6</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) pr[++tot]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot&amp;&amp;i*pr[j]&lt;=<span class="hljs-number">1e6</span>;++j) &#123;v[i*pr[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%pr[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) fac[i]=<span class="hljs-number">1ll</span>*fac[i<span class="hljs-number">-1</span>]*i%mod;inv[<span class="hljs-number">2</span>*n]=<span class="hljs-built_in">fp</span>(fac[<span class="hljs-number">2</span>*n],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;i;--i) inv[i]=<span class="hljs-number">1ll</span>*inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> fac[x<span class="hljs-number">-1</span>]*inv[x]%mod; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) a[i]=<span class="hljs-built_in">read</span>(), ++cnt[a[i]];<span class="hljs-built_in">init</span>();D=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">1</span>&amp;&amp;!v[a[i]]&amp;&amp;!mp[a[i]]) mp[a[i]]=<span class="hljs-number">1</span>, --cnt[a[i]], p[++m]=a[i];<span class="hljs-keyword">if</span>(cnt[a[i]]&amp;&amp;!mpp[a[i]]) mpp[a[i]]=<span class="hljs-number">1</span>, D=<span class="hljs-number">1ll</span>*D*inv[cnt[a[i]]]%mod;&#125;nn=<span class="hljs-number">2</span>*n-m, facn=fac[nn];<span class="hljs-keyword">if</span>(m&lt;n) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;<span class="hljs-keyword">if</span>(m==n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">1ll</span>*facn*D%mod);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1ll</span>*facn*D%mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m-n&amp;&amp;j&lt;=i;++j) &#123;<span class="hljs-keyword">if</span>(!j) f[i][j]=f[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">else</span> f[i][j]=(<span class="hljs-number">1ll</span>*f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]*(nn+j)%mod*<span class="hljs-built_in">rev</span>(cnt[p[i]]+<span class="hljs-number">1</span>)%mod+f[i<span class="hljs-number">-1</span>][j])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[m][m-n]);&#125;</code></pre></div><h2 id="cf1806d-dsu-master">CF1806D DSU Master</h2><p>注意题目中的「排列」是 <span class="math inline">\(\{a_i\}\)</span>的排列，而 <span class="math inline">\(\{a_i\}\)</span> 是决定 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+1\)</span> 所在弱连通分量的连边情况的。</p><p>容易知道如果从 <span class="math inline">\(1\)</span>连出去了任意一条边，后续的操作便不会产生贡献了。考虑到这是一个临界情况，递推之。</p><p>设 <span class="math inline">\(f_i\)</span> 为考虑操作序列 <spanclass="math inline">\([1,i]\)</span> 的排列，最终 <spanclass="math inline">\(1\)</span> 仍然没有出边的方案数。</p><p>若 <span class="math inline">\(a_i=0\)</span>，那么在 <spanclass="math inline">\(f_{i-1}\)</span> 中一定是从 <spanclass="math inline">\(i+1\)</span> 连向 <spanclass="math inline">\(1\)</span>，随便放即可。</p><p>否则 <span class="math inline">\(1\)</span> 一定不能是 <spanclass="math inline">\(i\)</span> 所在弱连通分量的无出边点，考虑在 <spanclass="math inline">\(f_{i-1}\)</span> 中，若 <spanclass="math inline">\(a_1\)</span> 在最后面，那么只要放到除了 <spanclass="math inline">\(a_1\)</span> 后面的 <spanclass="math inline">\(i-1\)</span> 个位置即可。</p><p>否则设 <span class="math inline">\(a_1\)</span> 的位置是 <spanclass="math inline">\(p\)</span>，在这之前的所有位置可以任选。考虑操作排列<span class="math inline">\([p,i-1]\)</span> 内一定不存在从 <spanclass="math inline">\(1\)</span> 所在弱连通分量 <spanclass="math inline">\(G&#39;\)</span> 连出去的边，因此要么是连入 <spanclass="math inline">\(G&#39;\)</span>的边，要么是相对孤立的两个点连边，此时证明 <spanclass="math inline">\(i-1 \notin G&#39;\)</span>。</p><blockquote><p>假设如此，那么如果 <span class="math inline">\(i-1\)</span> 连入了<span class="math inline">\(G&#39;\)</span>，那么一定有 <spanclass="math inline">\(i-2 \in G&#39;\)</span> 中，进而 <spanclass="math inline">\(i-3 \inG&#39;\)</span>。由此递归下去得到此时必须连完了所有边，与 <spanclass="math inline">\(p \neq i-1\)</span> 矛盾。</p></blockquote><p>由于 <span class="math inline">\(i-1 \notin G&#39;\)</span>，所以<span class="math inline">\(a_i\)</span> 不影响 <spanclass="math inline">\(1\)</span>，仅仅不能放在最后一个位置，方案仍然是<span class="math inline">\(i-1\)</span>。</p><p>于是</p><p><span class="math display">\[f_i=\begin{cases}f_{i-1} \cdot i &amp; a_i = 0\\f_{i-1} \cdot (i-1) &amp; a_i =1\end{cases}\]</span></p><p>考虑统计答案，设 <span class="math inline">\(ans_i\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 的贡献。考虑 <spanclass="math inline">\(ans_{i-1} \rightarrow ans_i\)</span>，首先把 <spanclass="math inline">\(a_i\)</span>扔到里面任何位置不会改变原有的贡献。其次如果 <spanclass="math inline">\(a_i = 0\)</span>，那么有 <spanclass="math inline">\(f_{i-1}\)</span> 种方法使得 <spanclass="math inline">\(ans_{i-1}\)</span> 贡献 <spanclass="math inline">\(f_{i-1}\)</span> 个 <spanclass="math inline">\(1\)</span> 出去；而当 <spanclass="math inline">\(a_i = 1\)</span> 时，无论如何都无法使得 <spanclass="math inline">\(1\)</span> 的入边增加。</p><p><span class="math display">\[ans_i = ans_{i-1} \cdot i + (1-a_i) \cdot f_{i-1}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>计数</tag>
      
      <tag>组合数学</tag>
      
      <tag>二项式反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#6 计数杂题 (1)</title>
    <link href="/2023/noip-record-6/"/>
    <url>/2023/noip-record-6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>计数杂题。</p><h2 id="cf840c-on-the-bench">CF840C On the Bench</h2><p>先进行一些基本的观察。</p><p><span class="math inline">\(\texttt{Observation}\)</span></p><p><span class="math inline">\(\{a_i\}\)</span>中乘积为完全平方数的数集，一定是相对封闭的。因此我们可以将 <spanclass="math inline">\(\{a_i\}\)</span>划分成若干个集合，满足其中两两乘积为完全平方数。</p><p><span class="math inline">\(\texttt{proof}\)</span></p><blockquote><p>考虑和 <span class="math inline">\(a_i\)</span>相乘为完全平方数的数集 <spanclass="math inline">\(\{a_j\}\)</span>。由于一个数是完全平方数的充要条件是所有质因子的次幂都是<span class="math inline">\(2\)</span> 的倍数，因此 <spanclass="math inline">\(\{a_j\}\)</span> 中任意数的质因子次数都和 <spanclass="math inline">\(a_i\)</span> 同奇偶，进而它们两两同奇偶。不在<span class="math inline">\(\{a_j\}\)</span>中的数则与集合内任何数相乘都不是完全平方数。</p></blockquote><p>有了这个性质，那么相邻两个元素乘积不为完全平方数的条件，等价于同一个集合的元素不能相邻。</p><p>考虑每个集合中编号最小的那个元素作为代表元素，排序，处理这个东西的所有排列。显然是个双射。</p><p>设 <span class="math inline">\(f_{i,j,k}\)</span> 为考虑 <spanclass="math inline">\([1,i]\)</span> 的排列，当前集合有 <spanclass="math inline">\(k\)</span> 对相邻，其他集合有 <spanclass="math inline">\(j\)</span> 对同集合且相邻的方案数。</p><p>设 <span class="math inline">\(b_i\)</span> 为 <spanclass="math inline">\(i\)</span> 位置上的代表元素，同时维护 <spanclass="math inline">\(cnt\)</span> 为当前集合放好了多少个元素。</p><p>如果 <span class="math inline">\(b_i = b_{i-1}\)</span>，枚举 <spanclass="math inline">\(j\)</span> 和 <spanclass="math inline">\(k\)</span></p><ul><li><p>放到本集合元素旁边。除了靠在一起的 <spanclass="math inline">\(k-1\)</span> 个位置，其他每个 <spanclass="math inline">\(b_i\)</span> 集合元素的位置都有两种方案。 <spanclass="math display">\[f_{i-1,j,k-1} \cdot (2cnt - k+1) \rightarrow f_{i,j,k}\]</span></p></li><li><p>放到其他集合元素旁边，干掉相邻同集合的。显然只能减少一个 <spanclass="math display">\[f_{i-1,j+1,k} \cdot (j+1) \rightarrow f_{i,j,k}\]</span></p></li><li><p>放到其他集合元素旁边，不干掉相邻同集合的。本集合元素两边都不能放，但是还要减去被相邻元素干掉的<span class="math inline">\(k\)</span> 与 <spanclass="math inline">\(j\)</span> 个位置。方案数 <spanclass="math inline">\(i-(2cnt-k) - j\)</span></p><p><span class="math display">\[f_{i-1,j,k} \cdot \Big(i-(2cnt-k)-j \Big) \rightarrow f_{i,j,k}\]</span></p></li></ul><p>否则 <span class="math inline">\(b_i \neqb_{i-1}\)</span>，说明换了下一个集合，令 <span class="math inline">\(cnt\leftarrow 0\)</span>。枚举 <span class="math inline">\(j\)</span>和上一个集合的 <span class="math inline">\(k\)</span></p><ul><li><p>不干掉相邻同集合的 <span class="math display">\[f_{i-1,k,j-k} \cdot (i-j) \rightarrow f_{i,j,0}\]</span></p></li><li><p>干掉相邻同集合的 <span class="math display">\[f_{i-1,k,j-k+1} \cdot (j+1) \rightarrow f_{i,j,0}\]</span></p></li></ul><p>答案是 <span class="math inline">\(f_{n,0,0}\)</span></p><p>复杂度 <spanclass="math inline">\(O(n^3)\)</span>，而且过程相当复杂啊。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, a[N], b[N], f[N][N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> t=<span class="hljs-built_in">sqrt</span>(x*y);<span class="hljs-keyword">if</span>(t*t==x*y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;b[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">squ</span>(a[i],a[j])) &#123;b[i]=j; <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(b[i]==b[i<span class="hljs-number">-1</span>]) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(k,<span class="hljs-number">0</span>,cnt) &#123;<span class="hljs-keyword">if</span>(k) (f[i][j][k]+=f[i<span class="hljs-number">-1</span>][j][k<span class="hljs-number">-1</span>]*(<span class="hljs-number">2</span>*cnt-k+<span class="hljs-number">1</span>)%mod)%=mod;(f[i][j][k]+=f[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>][k]*(j+<span class="hljs-number">1</span>)%mod)%=mod;(f[i][j][k]+=f[i<span class="hljs-number">-1</span>][j][k]*(i<span class="hljs-number">-2</span>*cnt+k-j)%mod)%=mod;&#125;&#125; <span class="hljs-keyword">else</span> &#123;cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(k,<span class="hljs-number">0</span>,j+<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(k&lt;=j) (f[i][j][<span class="hljs-number">0</span>]+=f[i<span class="hljs-number">-1</span>][k][j-k]*(i-j)%mod)%=mod;(f[i][j][<span class="hljs-number">0</span>]+=f[i<span class="hljs-number">-1</span>][k][j-k+<span class="hljs-number">1</span>]*(j+<span class="hljs-number">1</span>)%mod)%=mod;&#125;&#125;++cnt;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);&#125;</code></pre></div><p>   </p><p>有更优秀的容斥做法。</p><p>设一共有 <span class="math inline">\(m\)</span> 个集合，第 <spanclass="math inline">\(i\)</span> 个集合的大小是 <spanclass="math inline">\(s_i\)</span>，每个集合内部元素带标号。</p><p>先不考虑限制，设第 <span class="math inline">\(i\)</span> 个集合分成<span class="math inline">\(b_i\)</span> 段，<spanclass="math inline">\(B=\sum_{i=1}^mb_i\)</span>，那么所有集合全排列的方案是 <span class="math display">\[\frac{B!}{\prod_{i=1}^m (b_i !)} \prod_{i=1}^m s_i! \binom{s_i-1}{b_i-1}\]</span></p><p><span class="math display">\[\prod_{i=1}^m (s_i !) B!\prod_{i=1}^m \frac{1}{b_i!}\binom{s_i-1}{b_i-1}\]</span></p><p><span class="math inline">\(B\)</span> 可以枚举，但 <spanclass="math inline">\(\sum_{i=1}^m b_i = B\)</span> 是卷积。</p><p><span class="math inline">\(\texttt{Obervation}\)</span></p><p>考虑这样一个事情。</p><p>我们要求的是「对于每一个集合，其元素两两不相邻」的方案数。如果 <spanclass="math inline">\(B=n\)</span>，那么相当于至少有 <spanclass="math inline">\(0\)</span> 个和自己集合元素相邻的元素，<spanclass="math inline">\(B=n-1\)</span> 时则是至少有 <spanclass="math inline">\(1\)</span> 个。于是可以就此容斥。</p><p>枚举 <span class="math inline">\(B \in [m,n]\)</span>，如何处理 <spanclass="math inline">\(\prod_{i=1}^m\frac{1}{b_i!} \binom{s_i-1}{b_i-1}\)</span> 呢？</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 中的集合，划分的总段数不超过 <spanclass="math inline">\(j\)</span> 时候，上面式子的值。 <spanclass="math display">\[f_{i,j} = \sum_{k \in [1,\min(s_i,j)]} \binom{s_i-1}{k-1} f_{i-1,j-k}\cdot \frac{1}{k!}\]</span> 限制了 <span class="math inline">\(j \in [1,\sum_{i=1}^is_i]\)</span> 与 <span class="math inline">\(k \in[1,\min(s_i,j)]\)</span>，复杂度是 <spanclass="math inline">\(O(n^2)\)</span> 的。</p><p>然后上面式子带上个 <span class="math inline">\((-1)^{n-i}\)</span>的系数即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, ans, a[N], t[N], s[N], fac[N], inv[N], f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">300</span>) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[<span class="hljs-number">300</span>]=<span class="hljs-built_in">fp</span>(fac[<span class="hljs-number">300</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,<span class="hljs-number">299</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n==m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> t=<span class="hljs-built_in">sqrt</span>(x*y);<span class="hljs-keyword">if</span>(t*t==x*y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">squ</span>(a[i],t[j])) &#123; ++s[j], fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(!fg) t[++m]=a[i], s[m]=<span class="hljs-number">1</span>;&#125;    <span class="hljs-comment">// 预处理</span><span class="hljs-built_in">init</span>();f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;S+=s[i];<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,S) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i]&amp;&amp;k&lt;=j;++k) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j-k]*<span class="hljs-built_in">C</span>(s[i]<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>)%mod*inv[k]%mod)%=mod;&#125;<span class="hljs-built_in">rep</span>(i,m,n) &#123;<span class="hljs-keyword">if</span>((n-i)&amp;<span class="hljs-number">1</span>) (ans-=f[m][i]*fac[i]%mod-mod)%=mod; <span class="hljs-keyword">else</span> (ans+=f[m][i]*fac[i]%mod)%=mod;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) (ans*=fac[s[i]])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><p> </p><p> </p><p>另一种容斥。</p><p>设 <span class="math inline">\(f(i)\)</span> 为至少有 <spanclass="math inline">\(i\)</span> 个 <spanclass="math inline">\(k\)</span> 满足 <spanclass="math inline">\(a_k\)</span> 与 <spanclass="math inline">\(a_{k-1}\)</span> 在同一个等价类中，<spanclass="math inline">\(g(i)\)</span> 为恰好 <spanclass="math inline">\(i\)</span> 个，那么</p><p><span class="math display">\[f(k) = \sum_{i=k}^n \binom{i}{k} g(i)\]</span></p><p><span class="math display">\[g(k) = \sum_{i=k}^n (-1)^{i-k} \binom{i}{k} f(i)\]</span></p><p>答案是</p><p><span class="math display">\[g(0) = \sum_{i=0}^n (-1)^i f(i)\]</span></p><p>大力搞一下可以发现</p><p><span class="math display">\[f(k) = \sum_{k_1+k_2+ \cdots + k_m = k} \frac{(n-\sum_{i=1}^mk_i)!}{\prod_{i=1}^m \Big((s_i-k_i)!\Big)} \prod_{i=1}^m \binom{s_i -1}{k_i}\]</span></p><p>这是个卷积形式的式子，考虑到范围不大，可以暴力求，用类似背包的方法合并<span class="math inline">\(k_i\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">305</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, ans, a[N], t[N], s[N], fac[N], inv[N], f[<span class="hljs-number">2</span>][N], g[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">300</span>) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[<span class="hljs-number">300</span>]=<span class="hljs-built_in">fp</span>(fac[<span class="hljs-number">300</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,<span class="hljs-number">299</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n==m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> t=<span class="hljs-built_in">sqrt</span>(x*y);<span class="hljs-keyword">if</span>(t*t==x*y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">squ</span>(a[i],t[j])) &#123; ++s[j], fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(!fg) t[++m]=a[i], s[m]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">init</span>();f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,S) f[<span class="hljs-number">1</span>][j]=f[<span class="hljs-number">0</span>][j], f[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,s[i]<span class="hljs-number">-1</span>) &#123;g[j]=<span class="hljs-built_in">C</span>(s[i]<span class="hljs-number">-1</span>,j)*inv[s[i]-j]%mod;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">0</span>,S) (f[<span class="hljs-number">0</span>][j+k]+=g[j]*f[<span class="hljs-number">1</span>][k]%mod)%=mod;&#125;S+=s[i]<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n) &#123;<span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>) (ans-=f[<span class="hljs-number">0</span>][i]*fac[n-i]%mod-mod)%=mod;<span class="hljs-keyword">else</span> (ans+=f[<span class="hljs-number">0</span>][i]*fac[n-i]%mod)%=mod;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) (ans*=fac[s[i]])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><ul><li>有些映射还是可以大胆用的。</li><li>DP 外面也可以维护某些信息的，其实还是取决于 DP 的顺序。计数 DP可以选择映射到相对容易维护信息的顺序。</li></ul><h2 id="cf1400g-mercenaries">CF1400G Mercenaries</h2><p>注意到 <span class="math inline">\(m\)</span>很小，套路性地按照敌对关系容斥。</p><p>枚举集合 <span class="math inline">\(S\)</span> 表示至少满足存在<span class="math inline">\(S\)</span> 集合内所有敌对关系的方案数。</p><p>然后对于敌对关系内的每个人，能够求出他们条件区间的交。只要集合大小在这个交区间<span class="math inline">\([l,r]\)</span> 内就能满足条件。</p><p>注意到所谓条件区间，覆盖的其实是集合大小。</p><p>考虑差分求出所有条件区间的覆盖情况，设 <spanclass="math inline">\(d_j\)</span> 为大小为 <spanclass="math inline">\(j\)</span> 的集合能满足其条件区间的人数。</p><p>设 <span class="math inline">\(g_{i,j}\)</span> 表示选出钦定的 <spanclass="math inline">\(i\)</span> 个人后，至多选择 <spanclass="math inline">\(j\)</span> 个人的方案数。 <spanclass="math display">\[g_{i,j} = g_{i,j-1} + \binom{d_j-i}{j-i}\]</span> 然后设 <span class="math inline">\(c\)</span> 表示 <spanclass="math inline">\(S\)</span> 涉及的人的数量，的贡献是 <spanclass="math inline">\((g_{c,R}- g_{c,L-1})\)</span>，带上一个 <spanclass="math inline">\((-1)^{|S|}\)</span> 的容斥系数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, M=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, U, ans, l[N], r[N], d[N], g[<span class="hljs-number">45</span>][N];<span class="hljs-type">int</span> fac[N], inv[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span>PII p[<span class="hljs-number">25</span>]; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m||n&lt;<span class="hljs-number">0</span>||m&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[n]=<span class="hljs-built_in">fp</span>(fac[n],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*m) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) g[i][j]=(g[i][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">C</span>(d[j]-i,j-i)%mod);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;l[i]=<span class="hljs-built_in">read</span>(), r[i]=<span class="hljs-built_in">read</span>();++d[l[i]], --d[r[i]+<span class="hljs-number">1</span>];&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) p[i].x=<span class="hljs-built_in">read</span>(), p[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) d[i]+=d[i<span class="hljs-number">-1</span>];<span class="hljs-built_in">init</span>();U=(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(S,<span class="hljs-number">0</span>,U) &#123;set&lt;<span class="hljs-type">int</span>&gt; s;<span class="hljs-type">int</span> L=<span class="hljs-number">1</span>, R=n, dlt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(S&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;<span class="hljs-type">int</span> x=p[i+<span class="hljs-number">1</span>].x, y=p[i+<span class="hljs-number">1</span>].y;L=<span class="hljs-built_in">max</span>(L,<span class="hljs-built_in">max</span>(l[x],l[y])), R=<span class="hljs-built_in">min</span>(R,<span class="hljs-built_in">min</span>(r[x],r[y]));s.<span class="hljs-built_in">insert</span>(x), s.<span class="hljs-built_in">insert</span>(y);&#125;<span class="hljs-type">int</span> cnt=s.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span>(L&lt;=R) dlt=(g[cnt][R]-g[cnt][L<span class="hljs-number">-1</span>]+mod)%mod;<span class="hljs-type">int</span> pc=<span class="hljs-built_in">cc</span>(S);<span class="hljs-keyword">if</span>(pc&amp;<span class="hljs-number">1</span>) (ans-=dlt-mod)%=mod; <span class="hljs-keyword">else</span> (ans+=dlt)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="cf1542d-priority-queue">CF1542D Priority Queue</h2><p>首先将所谓 <span class="math inline">\(A\)</span>的子序列转化为每个操作可选可不选。</p><p><span class="math inline">\(f(B)\)</span> 不能直接计算，可以对每个<span class="math inline">\(x\)</span> 求贡献。具体地，计算每个 <spanclass="math inline">\(x\)</span> 存活到最后的方案数。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为考虑了 <spanclass="math inline">\([1,i]\)</span> 的操作，<spanclass="math inline">\(T\)</span> 中有 <spanclass="math inline">\(j\)</span> 个比 <spanclass="math inline">\(x\)</span> 小的数的方案数。</p><p>如果 <span class="math inline">\(i\)</span>是<code>-</code>操作，那么</p><ul><li><p>不选，方案数 <spanclass="math inline">\(f_{i-1,j}\)</span>。</p></li><li><p>选择此操作，删掉一个小于 <span class="math inline">\(x\)</span>的数，方案 <span class="math inline">\(f_{i-1,j+1}\)</span>。</p></li><li><p>一个问题：如果 <span class="math inline">\(x \notinT\)</span>，排名的问题如何解决？钦定当 <spanclass="math inline">\(j=0\)</span> 时，<spanclass="math inline">\(f_{i,0}\)</span> 可以由 <spanclass="math inline">\(f_{i-1,0}\)</span> 转移而来。</p></li></ul><p>如果 <span class="math inline">\(i\)</span>是<code>+ x</code>操作，那么</p><ul><li><p>不选，方案数 <spanclass="math inline">\(f_{i-1,j}\)</span>。</p></li><li><p>选择且 <span class="math inline">\(a_i &lt;x\)</span>，那么方案数 <spanclass="math inline">\(f_{i-1,j-1}\)</span>。</p></li><li><p>选择且 <span class="math inline">\(a_i &gt; x\)</span>，方案<span class="math inline">\(f_{i-1,j}\)</span>。</p></li><li><p>一个问题：如果 <span class="math inline">\(a_i = x\)</span>怎么办呢？如果 <span class="math inline">\(x \in T\)</span>，那么加入<span class="math inline">\(a_i\)</span> 之后不会使 <spanclass="math inline">\(j\)</span> 增加，按照 <spanclass="math inline">\(a_i &gt; x\)</span>的方法做显然是对的。否则呢？<span class="math inline">\(x \notinT\)</span> 时 <span class="math inline">\(T\)</span> 中等于 <spanclass="math inline">\(x\)</span> 的值，我们当然要让它们在 <spanclass="math inline">\(x\)</span> 之前被删掉，因此按照 <spanclass="math inline">\(a_i &lt; x\)</span> 的方法做。</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, a[N];<span class="hljs-type">char</span> s[N];ll f[N][N], ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;s[i]);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>) a[i]=<span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>;p&lt;=n;++p) &#123;<span class="hljs-type">int</span> x=a[p];<span class="hljs-keyword">if</span>(!~x) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(p==i) &#123; <span class="hljs-built_in">memcpy</span>(f[i],f[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">sizeof</span>(f[i])); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;++j) &#123;<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">-1</span>) &#123;f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>])%mod;<span class="hljs-keyword">if</span>(i&lt;p&amp;&amp;!j) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j])%=mod;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]&lt;x||(a[i]==x&amp;&amp;i&lt;p)) &#123;f[i][j]=f[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">if</span>(j) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%=mod;&#125; <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>][j]%mod;&#125;&#125;ll sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (sum+=f[n][i])%=mod;(ans+=sum*x%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="luogu-usaco20jancave-paintings-p">luogu [USACO20JAN]CavePaintings P</h2><p>难点在于如何合并两块空格子的信息。</p><p>不妨把连成一片的空格子称为一个连通块。对于一个连通块，初始贡献肯定是<span class="math inline">\(1\)</span>。</p><p>考虑对于一行的连通块，必然是先向左右下合并，合并后的方案数为两个连通块方案数之积。事实上，由于这一行的初始值是<spanclass="math inline">\(1\)</span>，所以相当于是把下面那一行中，能通过这一行互相到达的连通块合并了起来，由于它们是相对独立的，所以方案要做乘法。</p><p>然后呢？对于上面那一行，这一行的每个连通块必然是可选可不选，因此每一块的方案都加上<span class="math inline">\(1\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-type">int</span> n, m, ans=<span class="hljs-number">1</span>, f[N*N], g[N*N];<span class="hljs-type">char</span> s[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (i<span class="hljs-number">-1</span>)*m+j; &#125;<span class="hljs-keyword">namespace</span> dsu &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;++i) f[i]=i, g[i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123;(g[x]*=g[y])%=mod;f[y]=x;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>);dsu::<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">2</span>;--i) &#123;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=m<span class="hljs-number">-1</span>;++j) <span class="hljs-keyword">if</span>(s[i][j]!=<span class="hljs-string">&#x27;#&#x27;</span>) &#123;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> ii=i+dx[k], jj=j+dy[k];<span class="hljs-keyword">if</span>(s[ii][jj]==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;dsu::<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">id</span>(i,j),<span class="hljs-built_in">id</span>(ii,jj));&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=m<span class="hljs-number">-1</span>;++j) <span class="hljs-keyword">if</span>(s[i][j]!=<span class="hljs-string">&#x27;#&#x27;</span>) &#123;<span class="hljs-type">int</span> k=dsu::<span class="hljs-built_in">get</span>(<span class="hljs-built_in">id</span>(i,j));<span class="hljs-keyword">if</span>(!v[k]) ++g[k], v[k]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">2</span>,m<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(f[<span class="hljs-built_in">id</span>(i,j)]==<span class="hljs-built_in">id</span>(i,j)) (ans*=g[<span class="hljs-built_in">id</span>(i,j)])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><ul><li>计算顺序对于一个计数题来说，是相当重要，且是需要着重考虑的。</li><li>虽然是有关于连通块的计数，却忽略了最关键的合并环节，同时，没有搞清楚题目中水流这个条件所具备的相对独立性与相邻两行之间的关系，思路糊成一团，反复去琢磨“样例是怎么算出来的”而非主动寻找计数的方法。</li></ul><h2 id="luogu8974-groi-r1-古朴而优雅">luogu8974 『GROI-R1』古朴而优雅</h2><p>容易看出题面中的伪代码就是生成欧拉序的方法。</p><p>那么对于每个点 <spanclass="math inline">\(x\)</span>，其子节点可以任意排列，因此一棵树的答案为<span class="math display">\[\prod_{x} |son(x)|!\]</span>加上边后就可能成环。手动模拟不难发现，成环之后仅仅只会让一条边访问不到，这条边就是它们<span class="math inline">\(LCA\)</span>分别到达它们的路径上的第一条边。</p><p>设加入的边是 <span class="math inline">\((x,y)\)</span>，<spanclass="math inline">\(z=LCA(x,y)\)</span>，<spanclass="math inline">\(z\)</span> 到 <spanclass="math inline">\(x\)</span> 路径上第一个节点为 <spanclass="math inline">\(u\)</span>，另一个为 <spanclass="math inline">\(v\)</span>。</p><p>如果没走 <span class="math inline">\((z,u)\)</span>，那么相当于 <spanclass="math inline">\(z\)</span> 少了一个子节点，<spanclass="math inline">\(u\)</span> 少了一个子节点，<spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>都增加了一个子节点。另一种情况同理。分别统计两种情况，加起来即可。</p><p>如何找到 <span class="math inline">\(u\)</span> 与 <spanclass="math inline">\(v\)</span>？树上倍增即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, q, ans=<span class="hljs-number">1</span>, ss[N], dep[N], f[N][<span class="hljs-number">20</span>], fac[N], inv[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>, f[x][<span class="hljs-number">0</span>]=fa;ss[x]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">18</span>) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;++ss[x];<span class="hljs-built_in">dfs</span>(y,x); &#125;(ans*=fac[ss[x]])%=mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y])  x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];&#125;<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[n]=<span class="hljs-built_in">fp</span>(fac[n],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gett</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]+<span class="hljs-number">1</span>) x=f[x][i];<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">if</span>(x==z) <span class="hljs-keyword">return</span> &#123;y,<span class="hljs-built_in">gett</span>(y,x)&#125;;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">gett</span>(x,z),<span class="hljs-built_in">gett</span>(y,z)&#125;;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> d=ans*inv[ss[z]]%mod*inv[ss[u]]%mod*inv[ss[x]]%mod*inv[ss[y]]%mod;--ss[z], --ss[u], ++ss[x], ++ss[y];(d*=fac[ss[z]]*fac[ss[u]]%mod*fac[ss[x]]%mod*fac[ss[y]]%mod)%=mod;++ss[z], ++ss[u], --ss[x], --ss[y];<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">if</span>(dep[x]+dep[y]<span class="hljs-number">-2</span>*dep[z]==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span>;&#125;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p=<span class="hljs-built_in">get</span>(z,x,y);<span class="hljs-type">int</span> u=p.first, v=p.second;<span class="hljs-type">int</span> d1=<span class="hljs-built_in">getans</span>(z,u,x,y), d2=<span class="hljs-built_in">getans</span>(z,v,x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(d1+d2)%mod);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">init</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(q--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="luogu6803-ceoi2020-星际迷航">luogu6803 [CEOI2020] 星际迷航</h2><p>相当精妙的题目啊。</p><p>考虑到这 <span class="math inline">\(D+1\)</span>棵树是相同的，我们先把一棵树的必胜必败态求出来。</p><p>设白点为先手必胜，黑点为先手必败。</p><p>加上 rt- 的前缀表明是以它为根的树中它的颜色。</p><p><span class="math inline">\(\texttt{Observation}\)</span></p><p>如果一个点连接一个 rt-白点，那么这个点的胜负情况不会改变。</p><p>如果一个点连接一个rt-黑点，那么这个点的颜色可能改变（其实取决于对方能不能不让你走这条边）。</p><p>这个的证明是显然的。有了这个结论，<spanclass="math inline">\(D=1\)</span> 的情况就能做了。</p><blockquote><p>笔者自己在思考本题的时候，想法是对于先考虑一个点的颜色，再考虑连到什么样的点才必胜。这样做也不是不可以，但是有如下坏处</p><ul><li>分类讨论过细，一直在思考着必胜策略，导致做法根本无法推广到更大的<span class="math inline">\(D\)</span> 上。</li><li>将博弈的局面分的过细。比如很多时间花在了考虑什么样的黑点连2-黑点能够改变自己的胜负情况。</li><li>浪费了过多时间，结果也只能解决部分分。</li></ul><p>应该考虑连边的本质是换到另一个根上面，然后分连 rt-白点与rt-黑点讨论。而犯这样的错误很大程度上是因为一开始就把自己限制在了 <spanclass="math inline">\(D=1\)</span> 的部分分上，导致思路受到局限。</p><p>要注意从特殊到一般，整个过程的推广并不都是可以直接套用特殊做法的。</p></blockquote><p>设 <span class="math inline">\(st_i(x)\)</span> 为以 <spanclass="math inline">\(i\)</span> 为根的树中，<spanclass="math inline">\(x\)</span> 的颜色。</p><p>称「改变颜色」为连边后的胜负情况改变，相当于这个点的颜色改变。</p><p>下面来解决改变颜色的问题。</p><p>设 <span class="math inline">\(f_i(x)\)</span> 表示以 <spanclass="math inline">\(i\)</span> 为根的树，在以 <spanclass="math inline">\(x\)</span> 为根的子树中，有多少个点满足它们连接rt-黑点后，<span class="math inline">\(x\)</span> 的颜色改变。</p><p>先考虑以 <span class="math inline">\(1\)</span> 为根。</p><ol type="1"><li><p><span class="math inline">\(x\)</span> 的子节点全都是白点，那么<span class="math inline">\(x\)</span> 为黑点，此时如果 <spanclass="math inline">\(x\)</span> 连到 2-黑点，那么 <spanclass="math inline">\(x\)</span>就相当于改变成白点。否则如果任意子节点能改变为黑点，也能使 <spanclass="math inline">\(x\)</span> 变为白点，因此 <spanclass="math display">\[f_1(x) = 1 + \sum_{y \in son(x) \text{ and } st_1(y)=1} f_1(y)\]</span></p></li><li><p>如果 <span class="math inline">\(x\)</span>的子节点存在不止一个黑点，那么 <span class="math inline">\(x\)</span>为白点，从而从 <span class="math inline">\(x\)</span>连没有用。就算某个黑子节点变为白点，先手也总有其他选择，故不可能变成黑点，<spanclass="math inline">\(f_1(x)=0\)</span></p></li><li><p>如果 <span class="math inline">\(x\)</span>的子节点恰好有一个黑点，那么 <span class="math inline">\(x\)</span>为白点，从而从 <span class="math inline">\(x\)</span>连没有用。如果那个黑点变为白点，此时 <spanclass="math inline">\(x\)</span> 就变成了黑点 <spanclass="math display">\[f_1(x) = f_1(y) \quad y \in son(x) \text{ and } st_1(y) = 0\]</span></p></li></ol><p>维护每个颜色子节点 <span class="math inline">\(f\)</span>的和即可。</p><blockquote><p>犯过严重错误：没有设 <spanclass="math inline">\(f\)</span>，从整棵子树的角度考虑，导致得到正确的结论花了巨多时间，且不成体系。</p><p>而且有过逆天想法：万一 <span class="math inline">\(x\)</span>连了子树外的节点怎么办呢？</p><p>实际上，如果这个点能满足 <span class="math inline">\(f\)</span>的条件，那么连什么样的 2-黑点都相同且方案数是定值。而连接rt-黑点后颜色能否改变，取决于这棵子树能不能使得这条边一定被经过。</p><p>没有想到求这个东西，本质上是对题目还未理解清楚。</p><p>这种逆天的担心是拖慢我做题速度的重要因素之一。</p><p>真的是太降智了啊！</p></blockquote><p><span class="math inline">\(st\)</span> 与 <spanclass="math inline">\(f\)</span> 均可换根 DP 在 <spanclass="math inline">\(O(n)\)</span> 复杂度内求出。</p><p>下面考虑 <span class="math inline">\(D=1\)</span> 时的答案。</p><p>设原树中存在 <span class="math inline">\(m\)</span> 个 <spanclass="math inline">\(st_x(x)=0\)</span> 的点。如果 <spanclass="math inline">\(st_1(1)=1\)</span>，那么答案是 <spanclass="math inline">\(n \times (n-m) + \Big(n-f_1(1)\Big) \timesm\)</span>，否则就是 <span class="math inline">\(f_1(1) \timesm\)</span>。</p><p>当 <span class="math inline">\(D=2\)</span> 时，由于第 <spanclass="math inline">\(1\)</span> 棵树的结点颜色可以通过第 <spanclass="math inline">\(2\)</span> 棵树转化，设 <spanclass="math inline">\(F_0\)</span> 为 <spanclass="math inline">\(st_x(x)=0\)</span> 的 <spanclass="math inline">\(x\)</span> 的答案之和，<spanclass="math inline">\(F_1\)</span> 类似。那么如果 <spanclass="math inline">\(st_1(1)=1\)</span>，答案是 <spanclass="math inline">\(n \times F_1 + \Big(n-f_1(1)\Big) \timesF_0\)</span>，否则就是 <span class="math inline">\(f_1(1) \timesF_0\)</span>。</p><p>对于 <span class="math inline">\(D &gt;2\)</span>，是完全一样的问题。</p><p>考虑 <span class="math inline">\(F_0\)</span> 与 <spanclass="math inline">\(F_1\)</span>的求法。前者要么是白点转化而来，要么是黑点不变，后者类似，因此</p><p><span class="math display">\[F_0 = \sum_{st_x(x)=0} \Big(n-f_x(x)\Big)m + \sum_{st_x(x)=1} f_x(x)m +\sum_{st_x(x)=0} n(n-m)\]</span></p><p><span class="math display">\[F_1 = \sum_{st_x(x)=1} \Big(n-f_x(x)\Big)m + \sum_{st_x(x)=0} f_x(x)m +\sum_{st_x(x)=1} n(n-m)\]</span></p><p>发现是一个矩阵去变换 <span class="math inline">\(\begin{bmatrix} m \\n-m\end{bmatrix}\)</span> 这个向量 <spanclass="math inline">\(D-1\)</span> 次。矩阵快速幂优化即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, D, st[N], s0[N], f[N], sf[N][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> st2[N], g[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);s0[x]+=!st[y];sf[x][st[y]]+=f[y];&#125;st[x]=(s0[x]&gt;<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(s0[x]==<span class="hljs-number">1</span>) f[x]=sf[x][<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s0[x]==<span class="hljs-number">0</span>) f[x]=sf[x][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;    <span class="hljs-comment">// 换根</span><span class="hljs-keyword">if</span>(!st[x]) ++m;st2[x]=st[x], g[x]=f[x];<span class="hljs-type">int</span> s0x=s0[x], stx=st[x], fx=f[x], sfx0=sf[x][<span class="hljs-number">0</span>], sfx1=sf[x][<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> s0y=s0[y], sty=st[y], fy=f[y], sfy0=sf[y][<span class="hljs-number">0</span>], sfy1=sf[y][<span class="hljs-number">1</span>];s0[x]-=!st[y];st[x]=(s0[x]&gt;<span class="hljs-number">0</span>);sf[x][st[y]]-=f[y];<span class="hljs-keyword">if</span>(s0[x]==<span class="hljs-number">1</span>) f[x]=sf[x][<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s0[x]==<span class="hljs-number">0</span>) f[x]=sf[x][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> f[x]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!st[x]) st[y]=<span class="hljs-number">1</span>, ++s0[y];sf[y][st[x]]+=f[x];<span class="hljs-keyword">if</span>(s0[y]==<span class="hljs-number">1</span>) f[y]=sf[y][<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s0[y]==<span class="hljs-number">0</span>) f[y]=sf[y][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> f[y]=<span class="hljs-number">0</span>;<span class="hljs-built_in">dfs2</span>(y,x);s0[x]=s0x, st[x]=stx, f[x]=fx, sf[x][<span class="hljs-number">0</span>]=sfx0, sf[x][<span class="hljs-number">1</span>]=sfx1;s0[y]=s0y, st[y]=sty, f[y]=fy, sf[y][<span class="hljs-number">0</span>]=sfy0, sf[y][<span class="hljs-number">1</span>]=sfy1;&#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">SET</span>(m,<span class="hljs-number">0</span>); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; &#125; &#125; base, ans;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;++j)(c.m[i][j]+=a.m[i][k]*b.m[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), D=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;<span class="hljs-keyword">if</span>(!st2[x]) &#123;(base.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+=n-g[x])%=mod;(base.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=n)%=mod;(base.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=g[x])%=mod;&#125; <span class="hljs-keyword">else</span> &#123;(base.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+=g[x])%=mod;(base.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=n-g[x])%=mod;(base.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+=n)%=mod;&#125;&#125;ans.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=m, ans.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=n-m;ans=<span class="hljs-built_in">fp</span>(base,D<span class="hljs-number">-1</span>)*ans;<span class="hljs-type">int</span> f0=ans.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], f1=ans.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span>(st[<span class="hljs-number">1</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,((n-g[<span class="hljs-number">1</span>]+mod)*f0%mod+n*f1%mod)%mod);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,g[<span class="hljs-number">1</span>]*f0%mod);&#125;</code></pre></div><h2 id="luogu8971-groi-r1-虹色的彼岸花">luogu8971 『GROI-R1』虹色的彼岸花</h2><p>对于题目中没有点权的那些边，显然是没有用的，删掉。</p><p>一条边 <span class="math inline">\((x,y,z)\)</span> 实际上是 <spanclass="math inline">\(a_x + a_y =z\)</span>这样的一个限制。由于原图是一棵树，又删掉了若干边，得到的一定是一个森林。不难发现对于一棵树，钦定一个点为根，其他所有节点的值都能通过它来表示出来。这样就只需要考虑<span class="math inline">\(a_{root}\)</span> 的取值了。</p><p>由于每棵树之间没有关系，所以分别求方案即可。设 <spanclass="math inline">\(root\)</span> 为当前树的根，节点 <spanclass="math inline">\(x\)</span> 的值为 <span class="math inline">\(a_x= a_{root} + \Delta\)</span>，根据 <spanclass="math inline">\(\Delta\)</span> 的正负取值能得到一个区间，然后与<span class="math inline">\([l,r]\)</span> 取交即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> T, n, l, r, cnt, v[N], dep[N], c[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];vector&lt;<span class="hljs-type">int</span>&gt; zh[N], fu[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> d)</span> </span>&#123;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;dep[y]=dep[x]+<span class="hljs-number">1</span>; <span class="hljs-keyword">if</span>(dep[y]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) fu[cnt].<span class="hljs-built_in">push_back</span>(z-d);<span class="hljs-keyword">else</span> zh[cnt].<span class="hljs-built_in">push_back</span>(z-d);<span class="hljs-built_in">dfs</span>(y,x,root,z-d);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();tot=cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=c[i]=dep[i]=v[i]=<span class="hljs-number">0</span>, zh[i].<span class="hljs-built_in">clear</span>(), fu[i].<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!op) <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;++cnt;dep[i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>,i,<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;<span class="hljs-keyword">if</span>(fu[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) &#123;c[i]=r-l+<span class="hljs-number">1</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> mx1=<span class="hljs-number">-1e18</span>, mx2=<span class="hljs-number">-1e18</span>, mn1=<span class="hljs-number">1e18</span>, mn2=<span class="hljs-number">1e18</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:zh[i]) mx1=<span class="hljs-built_in">max</span>(mx1,x), mn1=<span class="hljs-built_in">min</span>(mn1,x);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:fu[i]) mx2=<span class="hljs-built_in">max</span>(mx2,x), mn2=<span class="hljs-built_in">min</span>(mn2,x);<span class="hljs-keyword">if</span>(!zh[i].<span class="hljs-built_in">size</span>()) mx1=mn1=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> L=<span class="hljs-built_in">max</span>(mx2-r,l-mn1), R=<span class="hljs-built_in">min</span>(mn2-l,r-mx1);<span class="hljs-keyword">if</span>(R&lt;L||R&lt;l||L&gt;r) c[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&lt;=L&amp;&amp;R&lt;=r) c[i]=(R-L+<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L&lt;l&amp;&amp;R&lt;=r) c[i]=(R-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(R&gt;r&amp;&amp;l&lt;=L) c[i]=(r-L+<span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) (ans*=c[i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="luogu7717-ezec-10序列">luogu7717 「EZEC-10」序列</h2><p>这次由和变成了异或。</p><p>仍然是会构成若干连通块，对于每个连通块分别考虑。</p><p>随便钦定一个点为根，进行 DFS 得到每个点 <spanclass="math inline">\(x\)</span> 与根的关系 <spanclass="math inline">\(d_x\)</span>，满足 <spanclass="math inline">\(a_{root} \oplus a_x = d_x\)</span>。</p><p>将 <span class="math inline">\(d_x\)</span>插入<code>Trie</code>，先把存在环且不合法的情况判掉。</p><p>考虑<code>Trie</code>树上 DFS，设 <spanclass="math inline">\(f(x,\delta,kk)\)</span> 为在节点 <spanclass="math inline">\(x\)</span>，第 <spanclass="math inline">\(\delta\)</span> 位，此时最大值为 <spanclass="math inline">\(kk\)</span> 的合法方案数。</p><p>唯一的限制在于每个数必须在 <span class="math inline">\([0,k]\)</span>之间。</p><p>在 DFS 的过程中记录当前树中的最大值。</p><p>规定左儿子为 <span class="math inline">\(0\)</span> 儿子，右儿子为<span class="math inline">\(1\)</span> 儿子。</p><p>如果节点 <span class="math inline">\(x\)</span>同时存在左右儿子，那么无论根取什么值，最大值一定会加上 <spanclass="math inline">\(2^{\delta}\)</span>，那么 <spanclass="math display">\[f(x,\delta,kk) = f\Big(son_0(x),\delta-1,kk+2^{\delta}\Big) +f\Big(son_1(x),\delta-1,kk+2^{\delta}\Big)\]</span> 如果只有左儿子或右儿子，那么</p><ul><li>只有左儿子且 <span class="math inline">\(kk+2^{\delta} \lek\)</span>。那么如果这一位放 <spanclass="math inline">\(1\)</span>，那么方案就是 <spanclass="math inline">\(f\Big(son_0(x),\delta-1,kk+2^{\delta}\Big)\)</span>，否则无论后面放什么都不会超过<span class="math inline">\(k\)</span>，方案数 <spanclass="math inline">\(2^{\delta}\)</span>。</li><li>只有左儿子且 <span class="math inline">\(kk+2^{\delta} &gt;k\)</span>。那么只能放 <span class="math inline">\(1\)</span>，方案<spanclass="math inline">\(f\Big(son_0(x),\delta-1,kk\Big)\)</span></li></ul><p>只有右儿子的情况类似。</p><p>特判孤点，方案是 <spanclass="math inline">\(k+1\)</span>，直接乘起来。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, k, ans=<span class="hljs-number">1</span>, d[N], vis[N], deg[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gr</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;&#125; G;<span class="hljs-keyword">namespace</span> Trie &#123;<span class="hljs-type">int</span> cnt, t[N*<span class="hljs-number">30</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,cnt) t[i][<span class="hljs-number">0</span>]=t[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;cnt=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!t[x][a]) t[x][a]=++cnt;x=t[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> kk)</span> </span>&#123;<span class="hljs-keyword">if</span>(kk&gt;k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!t[x][<span class="hljs-number">0</span>]&amp;&amp;!t[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(t[x][<span class="hljs-number">0</span>]&amp;&amp;t[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">0</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d))+<span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">1</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d));<span class="hljs-keyword">if</span>(t[x][<span class="hljs-number">0</span>]) &#123;<span class="hljs-keyword">if</span>(kk+(<span class="hljs-number">1</span>&lt;&lt;d)&lt;=k) <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;d)+<span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">0</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d));<span class="hljs-keyword">return</span> <span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">0</span>],d<span class="hljs-number">-1</span>,kk);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(kk+(<span class="hljs-number">1</span>&lt;&lt;d)&lt;=k) <span class="hljs-built_in">return</span> (<span class="hljs-number">1</span>&lt;&lt;d)+<span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">1</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d));<span class="hljs-keyword">return</span> <span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">1</span>],d<span class="hljs-number">-1</span>,kk);&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;vis[x]=<span class="hljs-number">1</span>;Trie::<span class="hljs-built_in">insert</span>(d[x]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i], z=G.w[i];<span class="hljs-keyword">if</span>(d[y]!=<span class="hljs-number">-1</span>&amp;&amp;(d[x]^z^d[y])!=<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;d[y]=d[x]^z;<span class="hljs-keyword">if</span>(!vis[y]) <span class="hljs-built_in">dfs</span>(y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();G.<span class="hljs-built_in">add</span>(x,y,z), G.<span class="hljs-built_in">add</span>(y,x,z);++deg[x], ++deg[y];&#125;<span class="hljs-built_in">SET</span>(d,<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(!deg[i]) &#123; (ans*=k+<span class="hljs-number">1</span>)%=mod; <span class="hljs-keyword">continue</span>; &#125;Trie::<span class="hljs-built_in">init</span>();d[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(i);(ans*=Trie::<span class="hljs-built_in">Dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">30</span>,<span class="hljs-number">0</span>))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><p>题面中的</p><blockquote><p>精准的解析刻画，是应该首先尝试的突破口。</p><p>​ ——command_block 《考前小贴士》</p></blockquote><p>分类讨论题。</p><h2 id="luogu4063-jxoi2017数列">luogu4063 [JXOI2017]数列</h2><p>设 <span class="math inline">\(L_i\)</span> 为第 <spanclass="math inline">\(i+1\)</span> 个数的左边界，<spanclass="math inline">\(R_i\)</span> 为第 <spanclass="math inline">\(i+1\)</span> 个数的右边界。</p><p><span class="math inline">\(\texttt{Observation}\)</span></p><p>假定 <span class="math inline">\(L_{i-1} \neq -\infty \texttt{ and }R_{i-1} \neq \infty\)</span>。</p><p>如果 <span class="math inline">\(A_i \in[L_{i-1},A_{i-1}]\)</span>，那么将有 <span class="math inline">\(R_i =A_{i-1}\)</span>；如果 <span class="math inline">\(A_i \in[A_{i-1},R_{i-1}]\)</span>，那么将有 <span class="math inline">\(L_i =A_i\)</span>。</p><p>总之，合法取值区间必然是不断减小的。</p><p>并且取值区间的大小变化只能是边界或者上一个填的数，非常有限，但是需要分类讨论。</p><p><span class="math inline">\(\texttt{Solution}\)</span></p><p>用 <span class="math inline">\(rr_i\)</span> 代替题目中的 <spanclass="math inline">\(r_i\)</span>。</p><p>考虑到 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(rr_i\)</span> 都很小，设 <spanclass="math inline">\(f(i,l,r,k)\)</span> 为考虑到了第 <spanclass="math inline">\(i\)</span> 个数，<span class="math inline">\(L_i =l\)</span>，<span class="math inline">\(R_i = r\)</span> 且 <spanclass="math inline">\(A_i = k\)</span> 的方案数。</p><p>首先要解决取值区间边界为正无穷或负无穷的问题。令 <spanclass="math inline">\(-\infty \rightarrow 0\)</span>，<spanclass="math inline">\(\infty \rightarrow \max_{i=1}^n\{rr_i\} +1\)</span>。这两种情况，会随着取值区间缩小而消亡。</p><p>状态很多，选择使用刷表法。</p><p>对于一个 <spanclass="math inline">\(f(i-1,l,r,k)\)</span>，分如下几种情况讨论</p><ul><li>取值区间缩减到 <span class="math inline">\([l,l]\)</span>，那么<span class="math inline">\(A_i \in[\max(1,l),\min(l,rr_i)]\)</span>。</li><li>取值区间缩减到 <span class="math inline">\([l,k]\)</span>，那么<span class="math inline">\(A_i \in [l+1,\min(k-1,rr_i)]\)</span>。</li><li>取值区间缩减到 <span class="math inline">\([k,k]\)</span>，那么要求<span class="math inline">\(A_i = A_{i-1}\)</span>，即 <spanclass="math inline">\(k&gt;l\)</span>，此时 <spanclass="math inline">\(A_i \in [k,\min(k,rr_i)]\)</span>。</li><li>取值区间缩减到 <span class="math inline">\([k,r]\)</span>，那么<span class="math inline">\(A_i \in [k+1,\min(r-1,rr_i)]\)</span>。</li><li>取值区间缩减到 <span class="math inline">\([r,r]\)</span>，那么<span class="math inline">\(k&lt;r\)</span>，此时 <spanclass="math inline">\(A_i \in [r,\min(r,rr_i)]\)</span>。</li></ul><p>以上转移在满足 <span class="math inline">\(A_i\)</span>区间合法时，对于每个取值都加上 <spanclass="math inline">\(f(i-1,l,r,k)\)</span>。区间加法，差分即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">155</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, ans, inf, rr[N], f[<span class="hljs-number">2</span>][N][N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) rr[i]=<span class="hljs-built_in">read</span>(), inf=<span class="hljs-built_in">max</span>(inf,rr[i]);++inf;<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;f[p][<span class="hljs-number">0</span>][inf][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, f[p][<span class="hljs-number">0</span>][inf][rr[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]=<span class="hljs-number">-1</span>+mod;    <span class="hljs-comment">// 初始值</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-built_in">memset</span>(f[p^<span class="hljs-number">1</span>],<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f[p^<span class="hljs-number">1</span>]));<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">0</span>,inf) <span class="hljs-built_in">rep</span>(r,l,inf) <span class="hljs-built_in">rep</span>(k,l,r) <span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) (f[p][l][r][k]+=f[p][l][r][k<span class="hljs-number">-1</span>])%=mod;<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">0</span>,inf) <span class="hljs-built_in">rep</span>(r,l,inf) <span class="hljs-built_in">rep</span>(k,l,r) <span class="hljs-keyword">if</span>(f[p][l][r][k]) &#123;<span class="hljs-type">int</span> L=<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,l), R=<span class="hljs-built_in">min</span>(l,rr[i]);<span class="hljs-type">int</span> d=f[p][l][r][k];<span class="hljs-keyword">if</span>(L&lt;=R)(f[p^<span class="hljs-number">1</span>][l][l][L]+=d)%=mod, (f[p^<span class="hljs-number">1</span>][l][l][R+<span class="hljs-number">1</span>]-=d-mod)%=mod;<span class="hljs-comment">// [l,l]</span>L=l+<span class="hljs-number">1</span>, R=<span class="hljs-built_in">min</span>(k<span class="hljs-number">-1</span>,rr[i]);<span class="hljs-keyword">if</span>(L&lt;=R) (f[p^<span class="hljs-number">1</span>][l][k][L]+=d)%=mod, (f[p^<span class="hljs-number">1</span>][l][k][R+<span class="hljs-number">1</span>]-=d-mod)%=mod;<span class="hljs-comment">// [l+1,k-1]</span><span class="hljs-keyword">if</span>(k&gt;l) &#123;L=<span class="hljs-built_in">max</span>(k,<span class="hljs-number">1ll</span>), R=<span class="hljs-built_in">min</span>(k,rr[i]);<span class="hljs-keyword">if</span>(L&lt;=R) (f[p^<span class="hljs-number">1</span>][k][k][L]+=d)%=mod, (f[p^<span class="hljs-number">1</span>][k][k][R+<span class="hljs-number">1</span>]-=d-mod)%=mod;&#125;<span class="hljs-comment">// a[i]=a[i-1] [k,k];</span>L=k+<span class="hljs-number">1</span>, R=<span class="hljs-built_in">min</span>(r<span class="hljs-number">-1</span>,rr[i]);<span class="hljs-keyword">if</span>(L&lt;=R) (f[p^<span class="hljs-number">1</span>][k][r][L]+=d)%=mod, (f[p^<span class="hljs-number">1</span>][k][r][R+<span class="hljs-number">1</span>]-=d-mod)%=mod;<span class="hljs-comment">// [k+1,r-1]</span><span class="hljs-keyword">if</span>(k&lt;r) &#123;L=<span class="hljs-built_in">max</span>(r,<span class="hljs-number">1ll</span>), R=<span class="hljs-built_in">min</span>(r,rr[i]);<span class="hljs-keyword">if</span>(L&lt;=R) (f[p^<span class="hljs-number">1</span>][r][r][L]+=d)%=mod, (f[p^<span class="hljs-number">1</span>][r][r][R+<span class="hljs-number">1</span>]-=d-mod)%=mod;&#125;<span class="hljs-comment">// [r,r]</span>&#125;p^=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">0</span>,inf) <span class="hljs-built_in">rep</span>(r,l,inf) <span class="hljs-built_in">rep</span>(k,l,r) &#123;(f[p][l][r][k]+=f[p][l][r][k<span class="hljs-number">-1</span>])%=mod;(ans+=f[p][l][r][k])%=mod;<span class="hljs-comment">// printf(&quot;%lld\n&quot;,f[n][l][r][k]);</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>计数</tag>
      
      <tag>矩阵</tag>
      
      <tag>组合数学</tag>
      
      <tag>Trie</tag>
      
      <tag>容斥原理</tag>
      
      <tag>博弈论</tag>
      
      <tag>二项式反演</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#5 倍增</title>
    <link href="/2023/noip-record-5/"/>
    <url>/2023/noip-record-5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2id="倍增处理的是满足结合律的静态信息">倍增处理的是满足「结合律」的静态信息</h2><h3 id="cf1175e-minimal-segment-cover">CF1175E Minimal SegmentCover</h3><p>预处理 <span class="math inline">\(rt_x\)</span> 表示点 <spanclass="math inline">\(x\)</span> 经过一条线段能到达的最右边的点。</p><p>跳区间显然是满足结合律的，可以倍增之，复杂度 <spanclass="math inline">\(O(n \log_2 n)\)</span>。</p><p>这类题目有一个重要的小技巧：为了满足最优性，倍增时跳到不能到达 <spanclass="math inline">\(y\)</span> 的最远的点 <spanclass="math inline">\(p\)</span>，然后判断能一次跳过 <spanclass="math inline">\(y\)</span>。如果不能则误解，否则这就是最优解。</p><p>证明是平凡的。如果能到达 <spanclass="math inline">\(r\)</span>，那么一定能到达位置 <spanclass="math inline">\(p\)</span>，否则一定找不到。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, L=<span class="hljs-number">1e15</span>, R, f[N][<span class="hljs-number">22</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">21</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[l][i]&amp;&amp;f[l][i]&lt;r) l=f[l][i], t|=<span class="hljs-number">1</span>&lt;&lt;i;        <span class="hljs-comment">// f[l][i]!=0，特判跳出去的情况</span>&#125;<span class="hljs-keyword">if</span>(f[l][<span class="hljs-number">0</span>]&gt;=r) <span class="hljs-keyword">return</span> t+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();f[l][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[l][<span class="hljs-number">0</span>],r);L=<span class="hljs-built_in">min</span>(L,l), R=<span class="hljs-built_in">max</span>(R,r);&#125;<span class="hljs-built_in">rep</span>(i,L,R) f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);    <span class="hljs-comment">// 预处理：先处理每个左端点的情况，再求前缀max</span><span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">21</span>) <span class="hljs-built_in">rep</span>(i,L,R) f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">calc</span>(l,r));&#125;&#125;</code></pre></div><h3 id="luogu4155-scoi2015国旗计划">luogu4155 [SCOI2015]国旗计划</h3><p><ahref="https://yozora0908.github.io/2022/lg4155-solution">link</a></p><h3 id="luogu3509-poi2010zab-frog">luogu3509 [POI2010]ZAB-Frog</h3><p>处理出距离每个点第 <span class="math inline">\(k\)</span>近的点后，就可以倍增了。</p><p>如何处理？发现 <span class="math inline">\(h_i\)</span>单调增，那么对于一个 <spanclass="math inline">\(i\)</span>，距离它最近的点一定是它前后一共 <spanclass="math inline">\(k\)</span> 个其他元素中的一个。</p><p>观察性质，显然对于这个长度为 <span class="math inline">\(k+1\)</span>的滑动窗口 <span class="math inline">\([l,r]\)</span>，<spanclass="math inline">\([l,i)\)</span> 与 <spanclass="math inline">\((i,r]\)</span>的内部分别是单调减与单调增的，因此第 <spanclass="math inline">\(k\)</span> 近的点必然是左端点或者右端点。</p><p>但问题在于如何维护正确的滑动窗口。如果 <spanclass="math inline">\([l,r]\)</span> 在 <spanclass="math inline">\(i\)</span> 处求得错误答案，那么一定有 <spanclass="math inline">\(dis(l,i) &gt;dis(i,r+1)\)</span>，即往右移动更能逼近 <spanclass="math inline">\(i\)</span>（滑动窗口的移动具有滞后性），不断这样往右移动<span class="math inline">\(l\)</span> 与 <spanclass="math inline">\(r\)</span> 直到收敛一定是不劣的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, m, a[N], f[N][<span class="hljs-number">62</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">60</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(t+(<span class="hljs-number">1ll</span>&lt;&lt;i)&lt;=m) x=f[x][i], t+=(<span class="hljs-number">1ll</span>&lt;&lt;i);&#125;    <span class="hljs-comment">// 使用1ll</span><span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=k+<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;    <span class="hljs-keyword">while</span>(i!=<span class="hljs-number">1</span>&amp;&amp;r&lt;n&amp;&amp;a[i]-a[l]&gt;a[r+<span class="hljs-number">1</span>]-a[i]) ++l, ++r;<span class="hljs-keyword">if</span>(a[i]-a[l]&gt;=a[r]-a[i]) f[i][<span class="hljs-number">0</span>]=l; <span class="hljs-keyword">else</span> f[i][<span class="hljs-number">0</span>]=r;&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">60</span>) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n)  f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,<span class="hljs-built_in">calc</span>(i));&#125;</code></pre></div><h3 id="nowcoder51190-count-the-repetitions">Nowcoder51190 Count theRepetitions</h3><p>首先可以把 <span class="math inline">\(s_2\)</span> 重复 <spanclass="math inline">\(n_2 \times m\)</span> 次的条件干掉，求最大的 <spanclass="math inline">\(n\)</span> 使能满足条件即可。</p><p><span class="math inline">\(s_2\)</span> 重复 <spanclass="math inline">\(n\)</span> 次依然是 <spanclass="math inline">\(s_1\)</span> 重复 <spanclass="math inline">\(n_1\)</span>次的子序列，那么就可以套路地进行匹配了。</p><p>设 <span class="math inline">\(f(i)\)</span> 表示从 <spanclass="math inline">\(s_1[i]\)</span> 开始匹配完一遍 <spanclass="math inline">\(s_2\)</span> 需要从 <spanclass="math inline">\(s_1\)</span> 中走多少步。这里认为 <spanclass="math inline">\(s_1\)</span> 是一个环形字符串。</p><p>发现这玩意满足结合律，倍增优化。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n1, n2, l1, l2, f[M][<span class="hljs-number">50</span>];<span class="hljs-type">char</span> s1[M], s2[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;l1=<span class="hljs-built_in">strlen</span>(s1), l2=<span class="hljs-built_in">strlen</span>(s2);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l1;++i) &#123;<span class="hljs-type">int</span> pos=i;f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;l2;++j) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(s1[pos]!=s2[j]) &#123;(++pos)%=l1, ++cnt;<span class="hljs-keyword">if</span>(s1[pos]!=s2[j]&amp;&amp;cnt&gt;=l1) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;(++pos)%=l1;f[i][<span class="hljs-number">0</span>]+=cnt+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">30</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l1;++i) &#123;f[i][j]=f[i][j<span class="hljs-number">-1</span>]+f[(i+f[i][j<span class="hljs-number">-1</span>])%l1][j<span class="hljs-number">-1</span>];&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>, pos=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(pos+f[pos%l1][i]&lt;=l1*n1)  pos+=f[pos%l1][i], ans+=<span class="hljs-number">1</span>&lt;&lt;i;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/n2);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(cin&gt;&gt;s2&gt;&gt;n2&gt;&gt;s1&gt;&gt;n1) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="cf1142b-lynyrd-skynyrd">CF1142B Lynyrd Skynyrd</h3><p>乍一看就能想出 <span class="math inline">\(O(n^2)\)</span>的倍增做法，但是貌似无法优化了。</p><p><span class="math inline">\(\texttt{Observation}\)</span></p><p>把循环移位转化为环形结构。</p><p>设 <span class="math inline">\(pre_{i}\)</span> 为 <spanclass="math inline">\(p\)</span> 中满足 <spanclass="math inline">\(p_k=j\)</span> 的<spanclass="math inline">\(p_{j-1}\)</span> 的值，特别地 <spanclass="math inline">\(pre_1 = p_n\)</span>。</p><p>对于一个 <spanclass="math inline">\(a_i\)</span>，它要么自己开一段子序列，要么接到<span class="math inline">\(a[1,i-1]\)</span> 中满足 <spanclass="math inline">\(a_j=pre_{a_i}\)</span> 的最靠右的 <spanclass="math inline">\(j\)</span> 后面。</p><p>这样往前找是满足结合律的，可以倍增。</p><p>如果能从 <span class="math inline">\(r\)</span> 往前跳 <spanclass="math inline">\(n-1\)</span> 次到达 <spanclass="math inline">\(l\)</span>，那么说明以 <spanclass="math inline">\(r\)</span> 为右端点，满足条件的最短的区间是 <spanclass="math inline">\([l,r]\)</span>。然后对 <spanclass="math inline">\(ans_r\)</span>求前缀最大值，就能得到满足条件的最大的 <spanclass="math inline">\(l\)</span>，直接判断即可。</p><p>有 <span class="math inline">\(O(n)\)</span>的内向树做法，但是咕了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, Q, a[N], b[N], pre[N], pos[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">18</span>], ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> d=n<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">17</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(d&gt;=<span class="hljs-number">1</span>&lt;&lt;i) d-=<span class="hljs-number">1</span>&lt;&lt;i, x=f[x][i];&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), pre[a[i]]=a[i<span class="hljs-number">-1</span>];pre[a[<span class="hljs-number">1</span>]]=a[n];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;b[i]=<span class="hljs-built_in">read</span>();f[i][<span class="hljs-number">0</span>]=pos[pre[b[i]]];pos[b[i]]=i;&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">17</span>) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) ans[i]=<span class="hljs-built_in">max</span>(ans[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">calc</span>(i));<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(l&lt;=ans[r]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);&#125;&#125;</code></pre></div><h2 id="能不能干点别的">能不能干点别的？</h2><h3 id="nowcoder50943-genius-acm">Nowcoder50943 Genius ACM</h3><p>最优解一定是若干极长段，贪心划分即可。对于一个确定的左边界 <spanclass="math inline">\(l\)</span>，得到右边界 <spanclass="math inline">\(r\)</span> 后求“校验值”至少是带着 <spanclass="math inline">\(\log\)</span> 的。如果二分求 <spanclass="math inline">\(r\)</span>，那么要是一直判定失败，那么复杂度就会上天，同时<span class="math inline">\(r\)</span> 也会很小，效率很低。如果枚举<span class="math inline">\(r\)</span>，上界也是 <spanclass="math inline">\(O(n^2\log_2 n)\)</span> 的。</p><p>这时候可以考虑让右端点倍增前进，这种倍增和本文中其他倍增不太相同。</p><ul><li>初始化 <span class="math inline">\(p=1\)</span>，<spanclass="math inline">\(r=l\)</span>。</li><li>如果 <span class="math inline">\([l,r+p]\)</span> 合法，那么令 <spanclass="math inline">\(r \leftarrow r+p\)</span>，<spanclass="math inline">\(p \leftarrow 2 \times p\)</span>。</li><li>否则 <span class="math inline">\(p \leftarrow p / 2\)</span>。</li></ul><p>这样做的好处是无论失败多少次，复杂度都是 <spanclass="math inline">\(O(n \log_2 n)\)</span>的，但是带着相对大的常数。</p><p>还有一个问题——排序。如果每次对 <spanclass="math inline">\([l,r+p]\)</span> 排序，那么复杂度就假了。应该将<span class="math inline">\([r,r+p]\)</span> 排序，然后与 <spanclass="math inline">\([l,r]\)</span> 归并。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, k, a[N], b[N], c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> i=l, j=mid+<span class="hljs-number">1</span>, pos=l;<span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r) &#123;<span class="hljs-keyword">if</span>(b[i]&lt;=b[j]) c[pos++]=b[i++];<span class="hljs-keyword">else</span> c[pos++]=b[j++];&#125;<span class="hljs-keyword">while</span>(i&lt;=mid) c[pos++]=b[i++];<span class="hljs-keyword">while</span>(j&lt;=r) c[pos++]=b[j++];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> R)</span> </span>&#123;<span class="hljs-keyword">if</span>(R&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=R;++i) b[i]=a[i];<span class="hljs-built_in">sort</span>(b+mid+<span class="hljs-number">1</span>,b+R+<span class="hljs-number">1</span>);<span class="hljs-built_in">merge</span>(L,mid,R);<span class="hljs-type">int</span> p=L, q=R, cnt=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;p&lt;q&amp;&amp;cnt&lt;m;) &#123;res+=(c[q]-c[p])*(c[q]-c[p]);++p, --q, ++cnt;<span class="hljs-keyword">if</span>(res&gt;k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-built_in">rep</span>(i,L,R) b[i]=c[i];<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> L=<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(L&lt;=n) &#123;<span class="hljs-type">int</span> d=<span class="hljs-number">1</span>, R=L;b[L]=a[L];<span class="hljs-keyword">while</span>(d) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">solve</span>(L,R,R+d)) &#123;R+=d; d&lt;&lt;=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> d&gt;&gt;=<span class="hljs-number">1</span>;&#125;++ans;L=R+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="luogu1081-noip2012-提高组-开车旅行">luogu1081 [NOIP2012 提高组]开车旅行</h3><p>预处理小 A 与小 B 从 <span class="math inline">\(i\)</span>开始驾驶的时候会到达的点。具体的，对于每个 <spanclass="math inline">\(i\)</span>，找 <span class="math inline">\(j_0,j_1\neq i\)</span>，满足 <span class="math inline">\(h_i\)</span> 与 <spanclass="math inline">\(h_{j_0},h_{j_1}\)</span>分别做差取绝对值后，分别是最小、次小值。</p><p>由于 <span class="math inline">\(h_i\)</span>两两不同，所以用<code>std::set</code>容易维护，写的比较丑。</p><p>然后就是设 <span class="math inline">\(F(i,j,0/1)\)</span> 为小 A/B先从 <span class="math inline">\(i\)</span> 开车，两人交替行驶 <spanclass="math inline">\(2^j\)</span>次能够到达的城市。上面预处理的信息就是边界值。转移有一个细节，当 <spanclass="math inline">\(j&gt;1\)</span> 时，<spanclass="math inline">\(2^{j-1}\)</span>也就是两次行驶的距离是偶数，因此小 A 和小 B 都要合并自己的 <spanclass="math inline">\(2^{j-1}\)</span> 的信息。当 <spanclass="math inline">\(j=1\)</span> 时，则是从对方的信息合并而来。</p><p>如何求二者分别的路程？笔者一开始设 <spanclass="math inline">\(G(i,j,0/1)\)</span> 表示轮到小 A/B开车，两人交替行驶 <span class="math inline">\(2^j\)</span>次后走过的路程。但这样就假掉了，因为先手不同时，走过的路径不一定相同，且对于<span class="math inline">\(G(i,j,1)\)</span>，行驶的次数就不是 <spanclass="math inline">\(2^j\)</span> 了。</p><p>所以加一维，<spanclass="math inline">\(G_{0/1}(i,j,0/1)\)</span>，下标一维表示最开始谁开车。转移类似。</p><p>尽管如此，我们却用不到小 B 先开车的情况，作用在于 <spanclass="math inline">\(j=1\)</span> 时的转移。</p><p>细节较多，见代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, h[N], to[N][<span class="hljs-number">2</span>]; <span class="hljs-comment">// to[i][0]表示最近，to[i][1]表示第二近</span><span class="hljs-type">int</span> f[N][<span class="hljs-number">20</span>][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> x0, ga[N][<span class="hljs-number">20</span>][<span class="hljs-number">2</span>], gb[N][<span class="hljs-number">20</span>][<span class="hljs-number">2</span>];set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; s;<span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span>(h[i]==s.<span class="hljs-built_in">begin</span>()-&gt;x) &#123;            <span class="hljs-comment">// 最小值</span><span class="hljs-keyword">auto</span> p=s.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-built_in">mp</span>(h[i],i));<span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">end</span>()) &#123;to[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> to[i][<span class="hljs-number">0</span>]=p-&gt;y;++p;<span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">end</span>()) to[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> to[i][<span class="hljs-number">1</span>]=p-&gt;y;s.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">mp</span>(h[i],i));&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h[i]==s.<span class="hljs-built_in">rbegin</span>()-&gt;x) &#123;<span class="hljs-comment">// 最大值</span><span class="hljs-keyword">auto</span> p=s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">mp</span>(h[i],i));<span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">begin</span>()) &#123;to[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> --p, to[i][<span class="hljs-number">0</span>]=p-&gt;second;<span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">begin</span>()) to[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> --p, to[i][<span class="hljs-number">1</span>]=p-&gt;y;s.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">mp</span>(h[i],i));&#125; <span class="hljs-keyword">else</span> &#123;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii=<span class="hljs-built_in">mp</span>(h[i],i);<span class="hljs-keyword">auto</span> p0=s.<span class="hljs-built_in">upper_bound</span>(pii);<span class="hljs-keyword">auto</span> p1=--s.<span class="hljs-built_in">lower_bound</span>(pii);            <span class="hljs-type">int</span> h0=p0-&gt;x, id0=p0-&gt;y;<span class="hljs-type">int</span> h1=p1-&gt;x, id1=p1-&gt;y;<span class="hljs-type">int</span> t0=<span class="hljs-built_in">abs</span>(h0-h[i]), t1=<span class="hljs-built_in">abs</span>(h1-h[i]);<span class="hljs-keyword">if</span>(t0&lt;t1) to[i][<span class="hljs-number">0</span>]=id0;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t0==t1) &#123;<span class="hljs-keyword">if</span>(h[id0]&lt;h[id1]) to[i][<span class="hljs-number">0</span>]=id0;<span class="hljs-keyword">else</span> to[i][<span class="hljs-number">0</span>]=id1;&#125; <span class="hljs-keyword">else</span> to[i][<span class="hljs-number">0</span>]=id1;<span class="hljs-comment">// 做两遍</span>s.<span class="hljs-built_in">erase</span>(pii);<span class="hljs-keyword">if</span>(to[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;pii=<span class="hljs-built_in">mp</span>(h[to[i][<span class="hljs-number">0</span>]],to[i][<span class="hljs-number">0</span>]);p0=s.<span class="hljs-built_in">upper_bound</span>(pii);p1=s.<span class="hljs-built_in">lower_bound</span>(pii);<span class="hljs-keyword">if</span>(p0==s.<span class="hljs-built_in">end</span>()&amp;&amp;p1==s.<span class="hljs-built_in">begin</span>()) to[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p0==s.<span class="hljs-built_in">end</span>()) --p1, to[i][<span class="hljs-number">1</span>]=p1-&gt;y;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p1==s.<span class="hljs-built_in">begin</span>()) to[i][<span class="hljs-number">1</span>]=p0-&gt;y;<span class="hljs-keyword">else</span> &#123;--p1;<span class="hljs-type">int</span> h0=p0-&gt;x, id0=p0-&gt;y;<span class="hljs-type">int</span> h1=p1-&gt;x, id1=p1-&gt;y;<span class="hljs-type">int</span> t0=<span class="hljs-built_in">abs</span>(h0-h[i]), t1=<span class="hljs-built_in">abs</span>(h1-h[i]);<span class="hljs-keyword">if</span>(t0&lt;t1) to[i][<span class="hljs-number">1</span>]=id0;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t0==t1) &#123;<span class="hljs-keyword">if</span>(h[id0]&lt;h[id1]) to[i][<span class="hljs-number">1</span>]=id0;<span class="hljs-keyword">else</span> to[i][<span class="hljs-number">1</span>]=id1;&#125; <span class="hljs-keyword">else</span> to[i][<span class="hljs-number">1</span>]=id1;&#125;&#125;f[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=to[i][<span class="hljs-number">1</span>], f[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=to[i][<span class="hljs-number">0</span>];ga[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">abs</span>(h[to[i][<span class="hljs-number">1</span>]]-h[i]);gb[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">abs</span>(h[to[i][<span class="hljs-number">0</span>]]-h[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">18</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">rep</span>(k,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>) &#123;f[i][j][k]=f[f[i][j<span class="hljs-number">-1</span>][k]][j<span class="hljs-number">-1</span>][k^<span class="hljs-number">1</span>];ga[i][j][k]=ga[i][j<span class="hljs-number">-1</span>][k]+ga[f[i][j<span class="hljs-number">-1</span>][k]][j<span class="hljs-number">-1</span>][k^<span class="hljs-number">1</span>];gb[i][j][k]=gb[i][j<span class="hljs-number">-1</span>][k]+gb[f[i][j<span class="hljs-number">-1</span>][k]][j<span class="hljs-number">-1</span>][k^<span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">else</span> &#123;f[i][j][k]=f[f[i][j<span class="hljs-number">-1</span>][k]][j<span class="hljs-number">-1</span>][k];ga[i][j][k]=ga[i][j<span class="hljs-number">-1</span>][k]+ga[f[i][j<span class="hljs-number">-1</span>][k]][j<span class="hljs-number">-1</span>][k];gb[i][j][k]=gb[i][j<span class="hljs-number">-1</span>][k]+gb[f[i][j<span class="hljs-number">-1</span>][k]][j<span class="hljs-number">-1</span>][k];&#125;&#125;&#125;<span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> X)</span> </span>&#123;<span class="hljs-type">int</span> Ta=<span class="hljs-number">0</span>, Tb=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) &#123;<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>&lt;&lt;i;<span class="hljs-keyword">if</span>(f[p][i][<span class="hljs-number">0</span>]!=<span class="hljs-number">0</span>&amp;&amp;(ll)Ta+ga[p][i][<span class="hljs-number">0</span>]+Tb+gb[p][i][<span class="hljs-number">0</span>]&lt;=X) &#123;Ta+=ga[p][i][<span class="hljs-number">0</span>], Tb+=gb[p][i][<span class="hljs-number">0</span>], p=f[p][i][<span class="hljs-number">0</span>];            <span class="hljs-comment">// 当i=0时，p=f[p][i][0]后下次就轮到小B了</span>            <span class="hljs-comment">// 可惜没有下次了。</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">mp</span>(Ta,Tb);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span> </span>&#123;<span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>((ll)x*q&lt;(ll)p*y) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x*q==p*y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 分数比较</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve1</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>, q=<span class="hljs-number">0</span>, ans1=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; T=<span class="hljs-built_in">calc</span>(i,x0);<span class="hljs-type">int</span> fg=<span class="hljs-built_in">cmp</span>(T.x,T.y,p,q);<span class="hljs-keyword">if</span>(fg==<span class="hljs-number">2</span>||(fg==<span class="hljs-number">1</span>&amp;&amp;h[i]&gt;h[ans1])) p=T.x, q=T.y, ans1=i;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans1);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=<span class="hljs-built_in">read</span>(), s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(h[i],i));<span class="hljs-built_in">prework</span>();x0=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve1</span>();m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> s=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p=<span class="hljs-built_in">calc</span>(s,x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,p.x,p.y);&#125;&#125;</code></pre></div><h3 id="luogu9019-usaco23jan-tractor-paths-p">luogu9019 [USACO23JAN]Tractor Paths P</h3><p>预处理每个点经过一条边能到达的最远点，倍增即可解决第一问。</p><p>设第一问求出的答案为 <span class="math inline">\(d\)</span>，从 <spanclass="math inline">\(i\)</span> 出发，往右走 <spanclass="math inline">\(2^j\)</span> 次能到达的最远点是 <spanclass="math inline">\(f(i,j)\)</span>，往左走 <spanclass="math inline">\(j\)</span> 次能到达的最远点是 <spanclass="math inline">\(g(i,j)\)</span>。从两端往中间走总和为 <spanclass="math inline">\(d\)</span>的步数，二者的交错便是可能在最短路径上的点。</p><p>因此答案为 <span class="math display">\[cnt_a + cnt_b + \sum_{j=1}^{d-1} cnt \Big( g(b,d-j),f(a,j) \Big)\]</span> 这种 meet in the middle 的想法还是很巧妙的。</p><p>发现和式是个区间和的形式，前缀和优化之。</p><p>发现 <span class="math inline">\(j\)</span> 这个东西是 <spanclass="math inline">\(d-1\)</span> 的二进制中若干个 <spanclass="math inline">\(1\)</span> 自由组合，而且对于每一个 <spanclass="math inline">\(1\)</span> 的位，其它每多选一个 <spanclass="math inline">\(1\)</span>，就会在没有选这个 <spanclass="math inline">\(1\)</span> 的 <spanclass="math inline">\(d-j\)</span> 中被差分掉。因此可以把 <spanclass="math inline">\(d-1\)</span> 二进制拆分，倍增求值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, Q, lt[N], rt[N], ss[N];<span class="hljs-type">int</span> f[N][<span class="hljs-number">18</span>], g[N][<span class="hljs-number">18</span>], fs[N][<span class="hljs-number">18</span>], gs[N][<span class="hljs-number">18</span>];<span class="hljs-type">char</span> s[<span class="hljs-number">2</span>*N], t[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>, now=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;L&#x27;</span>) ++p;<span class="hljs-keyword">else</span> rt[now]=p, ++now;&#125;p=n+<span class="hljs-number">1</span>, now=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>*n;i;--i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;R&#x27;</span>) --p;<span class="hljs-keyword">else</span> lt[now]=p, --now;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ss[i]=ss[i<span class="hljs-number">-1</span>]+t[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;f[i][<span class="hljs-number">0</span>]=rt[i], g[i][<span class="hljs-number">0</span>]=lt[i];fs[i][<span class="hljs-number">0</span>]=ss[rt[i]], gs[i][<span class="hljs-number">0</span>]=ss[lt[i]<span class="hljs-number">-1</span>];&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">17</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];fs[i][j]=fs[i][j<span class="hljs-number">-1</span>]+fs[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];        g[i][j]=g[g[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];gs[i][j]=gs[i][j<span class="hljs-number">-1</span>]+gs[g[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">17</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[l][i]&amp;&amp;f[l][i]&lt;r) res|=(<span class="hljs-number">1</span>&lt;&lt;i), l=f[l][i];&#125;<span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,s+<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>);<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans1=<span class="hljs-built_in">calc</span>(a,b), ans2=t[a]-<span class="hljs-string">&#x27;0&#x27;</span>+t[b]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">17</span>;~i;--i) <span class="hljs-keyword">if</span>((ans1<span class="hljs-number">-1</span>)&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) ans2+=fs[a][i], a=f[a][i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">17</span>;~i;--i) <span class="hljs-keyword">if</span>((ans1<span class="hljs-number">-1</span>)&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) ans2-=gs[b][i], b=g[b][i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,ans1,ans2);&#125;&#125;</code></pre></div><h3 id="cf1516d-cut">CF1516D Cut</h3><p>容易发现一个区间合法当且仅当区间的数两两互质。</p><p>发现如果预处理完从 <span class="math inline">\(i\)</span>开始能分组的最右端点，就可以倍增了。</p><p>对质因子开一个桶。</p><p>如何预处理呢？如果从 <span class="math inline">\(l\)</span>开始，到了 <span class="math inline">\(r\)</span>第一次产生重复质因子，那么从 <span class="math inline">\(l\)</span>开始往后直到不存在重复的质因子，<span class="math inline">\(r-1\)</span>都是他们的答案。</p><p>存在这样的单调性，就可以双指针求解了。</p><p>分解质因子可能带着不小的常数（比如说分解一个质数），但值域不大，一个优化的方法是用线性筛得到每个数的最小质因子，这样就可以<span class="math inline">\(O(1)\)</span> 除去一个因子，因此上界就是<span class="math inline">\(O(\log_2 \max\{a_i\})\)</span>。</p><p>为了避免一些边界错误，使用左闭右开。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, Q, mx, a[N], f[N][<span class="hljs-number">17</span>];<span class="hljs-type">int</span> cnt, p[N], g[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=mx;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i, g[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=mx;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;g[i*p[j]]=p[j];<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;;<span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>) --c[g[x]], x/=g[x];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">ora</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(r&lt;=n) &#123;<span class="hljs-type">int</span> x=a[r];<span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">while</span>(c[g[x]]) f[l][<span class="hljs-number">0</span>]=r, <span class="hljs-built_in">del</span>(a[l++]);<span class="hljs-comment">// [) 左闭右开防止一些奇怪的错误</span>x/=g[x];&#125;x=a[r];<span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>) ++c[g[x]], x/=g[x];++r;&#125;<span class="hljs-keyword">while</span>(l&lt;=n) f[l++][<span class="hljs-number">0</span>]=n+<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">16</span>) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[l][i]&amp;&amp;f[l][i]&lt;=r) res|=(<span class="hljs-number">1</span>&lt;&lt;i), l=f[l][i];&#125;<span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), Q=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), mx=<span class="hljs-built_in">max</span>(mx,a[i]);<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">calc</span>(l,r));&#125;&#125;</code></pre></div><p>左闭右闭写法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">ora</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(r&lt;=n) &#123;<span class="hljs-type">int</span> x=a[r];<span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">while</span>(c[g[x]]) f[l][<span class="hljs-number">0</span>]=r<span class="hljs-number">-1</span>, <span class="hljs-built_in">del</span>(a[l++]);x/=g[x];&#125;x=a[r];<span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>) ++c[g[x]], x/=g[x];++r;&#125;<span class="hljs-keyword">while</span>(l&lt;=n) f[l++][<span class="hljs-number">0</span>]=n;f[n][<span class="hljs-number">0</span>]=n;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">16</span>) f[n][j]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">16</span>) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) f[i][j]=f[<span class="hljs-built_in">min</span>(f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>,n)][j<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[l][i]&amp;&amp;f[l][i]+<span class="hljs-number">1</span>&lt;=r) res|=(<span class="hljs-number">1</span>&lt;&lt;i), l=f[l][i]+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;&#125;</code></pre></div><ul><li>“区间覆盖”最好左闭右闭，“区间划分”最好左闭右开。</li></ul><h3 id="luogu9275-agm-2023-资格赛-drahsort">luogu9275 [AGM 2023 资格赛]DrahSort</h3><p>姑且看了一下网络上巨多的冒泡排序文章。不同于它们，冒泡排序还有另外一种理解方式，就是依次干掉以每个数较大数的逆序对。在本题中使用两者分析均可。</p><p>对于一个 <spanclass="math inline">\(a_l\)</span>，如果能找到它右边第一个大于等于它的元素<span class="math inline">\(a_r\)</span>，那么 <spanclass="math inline">\(l\)</span> 的决策区间就是 <spanclass="math inline">\([l,r-1]\)</span>，它的贡献就是 <spanclass="math inline">\(a_l \times \max_{i=l+1}^{r-1}\{a_i\}\)</span>。后面即使有小于它的数，<spanclass="math inline">\(a_r\)</span> 都不劣于 <spanclass="math inline">\(a_l\)</span>。</p><p>所以就可以对这个倍增了，从 <span class="math inline">\(l\)</span> 往<span class="math inline">\(r\)</span> 跳即可，途中记录最大值。</p><p>如果最终仍满足 <spanclass="math inline">\(l&lt;r\)</span>，那么说明找不到大于等于 <spanclass="math inline">\(a_l\)</span> 的元素了，取 <spanclass="math inline">\(a_l \times \max_{i=l+1}^r a_i\)</span> 即可。</p><p>这题仍然以使用左闭右开为上策。</p><h3 id="loj3496.-joisc-2021活动参观-2">LOJ#3496. 「JOISC 2021」活动参观2</h3><p>自己做的时候不会搞这个字典序……</p><p>考虑一个暴力，从小到大考虑每个区间是否能加入。由于字典序的贪心性质，编号小的区间一定优于任何编号更大的区间，所以维护一个区间集合，枚举到<span class="math inline">\(i\)</span> 就判断强制选择区间集合中的区间和<span class="math inline">\(i\)</span> 后，剩下的区间还能不能选到 <spanclass="math inline">\(k\)</span> 个。</p><p>怎么做？在枚举之前我们可以按照右端点排序然后贪心选择最多无交区间，如果不到<span class="math inline">\(k\)</span>个就无解。考虑把区间左右端点离散化了，这样选择一个区间就是干掉两个坐标中间的所有点。暴力把所有这样的点标记出来，整个序列被划分为了若干段，我们只要知道这些段总共能被塞进多少区间即可。</p><p>但这样还是不够优。我们能发现 <span class="math inline">\(i\)</span>阶段与上一个阶段相比，仅仅多了 <span class="math inline">\(i\)</span>这个区间。如果 <span class="math inline">\(i\)</span>与已经选择的区间有冲突，那么直接跳过。否则就不能选择与 <spanclass="math inline">\([L_i,R_i]\)</span> 有交的区间。</p><p>然后设 <span class="math inline">\([lt,rt]\)</span>为已经选择的区间给 <span class="math inline">\([L_i,R_i]\)</span>留下的那个段，我们就要在 <span class="math inline">\([lt,rt]\)</span>尽可能多放的前提下，最大化 <span class="math inline">\([lt,L_i]\)</span>与 <span class="math inline">\([R_i,rt]\)</span> 能放的区间数量，最小化<span class="math inline">\([L_i,R_i]\)</span> 能放的区间数量。由于这些<span class="math inline">\([lt,rt]\)</span>中必然没有选过的区间，所以就是个静态问题。</p><p><span class="math inline">\(O(n)\)</span> 求出 <spanclass="math inline">\([lt,rt]\)</span> 最优解和 <spanclass="math inline">\([lt,L_i]\)</span> 与 <spanclass="math inline">\([R_i,rt]\)</span>最优解就能得到所有信息。这样就能利用上一个阶段得到答案，判断是否不小于<span class="math inline">\(k\)</span> 即可。</p><p>考虑优化。选不相交区间的过程是相当重复的，同时满足结合律，预处理每个右端点往左第一个左端点即可倍增答案，当区间个数一定时能得到放的最近距离，这个比较显然。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, ans, f[<span class="hljs-number">2</span>*N][<span class="hljs-number">21</span>];<span class="hljs-type">int</span> m, tmp[<span class="hljs-number">2</span>*N];PII a[N], b[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a,PII b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.se!=b.se? a.se&lt;b.se:a.fi&lt;b.fi; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(tmp+<span class="hljs-number">1</span>,tmp+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(tmp+<span class="hljs-number">1</span>,tmp+m+<span class="hljs-number">1</span>)-tmp<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].fi=<span class="hljs-built_in">lower_bound</span>(tmp+<span class="hljs-number">1</span>,tmp+m+<span class="hljs-number">1</span>,a[i].fi)-tmp;a[i].se=<span class="hljs-built_in">lower_bound</span>(tmp+<span class="hljs-number">1</span>,tmp+m+<span class="hljs-number">1</span>,a[i].se)-tmp;b[i]=a[i];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;f[i][<span class="hljs-number">0</span>]=f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<span class="hljs-keyword">while</span>(p&lt;n&amp;&amp;a[p+<span class="hljs-number">1</span>].se==i) &#123;++p;f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],a[p].fi);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">20</span>&amp;&amp;f[i][j<span class="hljs-number">-1</span>];++j) f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[r][i]&gt;=l) r=f[r][i], res|=<span class="hljs-number">1</span>&lt;&lt;i;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].fi=tmp[++m]=<span class="hljs-built_in">read</span>();a[i].se=tmp[++m]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">lsh</span>();<span class="hljs-built_in">prework</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-built_in">calc</span>(<span class="hljs-number">1</span>,m);<span class="hljs-keyword">if</span>(cnt&lt;k) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>), <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);set&lt;PII&gt; s;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">auto</span> p=s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">MP</span>(b[i].se,<span class="hljs-number">0</span>));<span class="hljs-type">int</span> tl=<span class="hljs-number">0</span>, tr=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">end</span>()) tr=m;<span class="hljs-keyword">else</span> tr=p-&gt;fi;<span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">begin</span>()) tl=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> --p, tl=b[p-&gt;se].se;<span class="hljs-keyword">if</span>(tl&gt;b[i].fi) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> k0=<span class="hljs-built_in">calc</span>(tl,tr), k1=<span class="hljs-built_in">calc</span>(tl,b[i].fi), k2=<span class="hljs-built_in">calc</span>(b[i].se,tr);<span class="hljs-keyword">if</span>(cnt-k0+<span class="hljs-number">1</span>+k1+k2&gt;=k) &#123;cnt=cnt-k0+<span class="hljs-number">1</span>+k1+k2;s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">MP</span>(b[i].fi,i));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,i);<span class="hljs-keyword">if</span>(++ans==k) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></div><p> </p><h2 id="一些更深的思考">一些更深的思考</h2><p>所谓「结合律」究竟是什么？</p><ul><li>一些数学运算天生满足结合律，可以改变运算顺序。</li><li>跳到若干“关键点”，从哪里开始跳与跳的过程无关，可以将路径合并。</li><li>二进制拆分，本质上是求和的结合律。</li><li>信息的合并，群论的说法叫<strong>半群</strong>。</li></ul><p>这些维护的都是「已知」的东西，或者说是显式的倍增结构。</p><p>但很多时候并没有这个显式的结构。比如本文第一题，为什么倍增找 <spanclass="math inline">\(p\)</span> 就是最优的，而倍增 <spanclass="math inline">\(r\)</span> 则不是呢？</p><p>考虑一种新的思想——<strong>倍增答案</strong>。</p><p><del>自己起的名字</del>。</p><p>如果说<strong>二分答案</strong>是利用了答案的单调性然后将最优化问题转化为判定问题，那么<strong>倍增答案</strong>则是利用了答案可以由若干满足结合律的局部答案合并而成，从而将全局最优化问题转化为「答案一定时若干最优局面的并」。</p><p><span class="math inline">\(p\)</span>并不是显式存在的，但它一定严格小于 <spanclass="math inline">\(r\)</span>且满足结合律。这个最优解又因为代价已经确定而容易求得。因此倍增 <spanclass="math inline">\(p\)</span> 能得到正确答案，而倍增 <spanclass="math inline">\(r\)</span> 则是难以确定的。</p><p>似乎是很 <span class="math inline">\(\texttt{Navie}\)</span>的东西。</p><p> </p><h3 id="loj3665.-joi-2022-final铁路旅行-2">LOJ#3665. 「JOI 2022Final」铁路旅行 2</h3><p>使用倍增答案的思想，这题其实并不难。</p><p>容易处理出从每个点出发能够到达的左右边界，在这个区间之内的任何位置都能到达。</p><p>可达性容易处理，最优化不好搞。对于前几个subtask，可以采用构图然后<code>BFS</code>的方式求解，但是一定要搞清楚细节（比如可以反走）。</p><p>仍然具有结合律，考虑使用倍增答案，而且能发现依然是那种跳区间的形式。设<span class="math inline">\(rt(i,j)\)</span> 为从 <spanclass="math inline">\(i\)</span> 出发走 <spanclass="math inline">\(2^j\)</span> 步能到达的最右位置，左边 <spanclass="math inline">\(lt(i,j)\)</span> 类似。 <spanclass="math display">\[rt(i,j) = \max_{k=lt(i,j-1)}^{rt(i,j-1)}\Big\{rt(k,j-1)\Big\}\]</span></p><p><span class="math display">\[lt(i,j) = \min_{k=lt(i,j-1)}^{rt(i,j-1)}\Big\{lt(k,j-1)\Big\}\]</span></p><p>是个 RMQ 问题。</p><p>只有这个还不够，有时候我们中途下车更优，而中途下车一定是某个位置能在代价相同时走得更远，所以不能只看最值，要在倍增过程中维护当前区间的最大最小值。线段树即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, m, Q, lt[N][<span class="hljs-number">17</span>], rt[N][<span class="hljs-number">17</span>];PII q[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Segment_Tree</span> &#123;<span class="hljs-type">int</span> k, t[N&lt;&lt;<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; t[x][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(t[x&lt;&lt;<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]); t[x][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(t[x&lt;&lt;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) &#123; t[x][<span class="hljs-number">1</span>]=rt[l][k], t[x][<span class="hljs-number">0</span>]=lt[l][k]; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x][type];<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(type==<span class="hljs-number">0</span>) ans=n;<span class="hljs-keyword">if</span>(L&lt;=mid) &#123;<span class="hljs-keyword">if</span>(type==<span class="hljs-number">0</span>) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(L,R,type,x&lt;&lt;<span class="hljs-number">1</span>,l,mid));<span class="hljs-keyword">else</span> ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">query</span>(L,R,type,x&lt;&lt;<span class="hljs-number">1</span>,l,mid));&#125;<span class="hljs-keyword">if</span>(R&gt;mid) &#123;<span class="hljs-keyword">if</span>(type==<span class="hljs-number">0</span>) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(L,R,type,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r));<span class="hljs-keyword">else</span> ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">query</span>(L,R,type,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r));&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125; T[<span class="hljs-number">17</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l].fi&lt;i-k+<span class="hljs-number">1</span>) ++l;<span class="hljs-type">int</span> x=rt[i][<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(l&lt;=r) rt[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(rt[i][<span class="hljs-number">0</span>],q[l].se);<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[r].se&lt;x) --r;q[++r]=<span class="hljs-built_in">MP</span>(i,x);&#125;l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l].fi&gt;i+k<span class="hljs-number">-1</span>) ++l;<span class="hljs-type">int</span> x=lt[i][<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(l&lt;=r) lt[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(lt[i][<span class="hljs-number">0</span>],q[l].se);<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[r].se&gt;x) --r;q[++r]=<span class="hljs-built_in">MP</span>(i,x);&#125;T[<span class="hljs-number">0</span>].k=<span class="hljs-number">0</span>;T[<span class="hljs-number">0</span>].<span class="hljs-built_in">build</span>();<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">16</span>) &#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;lt[i][j]=T[j<span class="hljs-number">-1</span>].<span class="hljs-built_in">query</span>(lt[i][j<span class="hljs-number">-1</span>],rt[i][j<span class="hljs-number">-1</span>],<span class="hljs-number">0</span>);rt[i][j]=T[j<span class="hljs-number">-1</span>].<span class="hljs-built_in">query</span>(lt[i][j<span class="hljs-number">-1</span>],rt[i][j<span class="hljs-number">-1</span>],<span class="hljs-number">1</span>);&#125;T[j].k=j;T[j].<span class="hljs-built_in">build</span>();&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span> </span>&#123;<span class="hljs-type">int</span> l=s, r=s, res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">16</span>;~i;--i) &#123;<span class="hljs-type">int</span> L=T[i].<span class="hljs-built_in">query</span>(l,r,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> R=T[i].<span class="hljs-built_in">query</span>(l,r,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(L&lt;=t&amp;&amp;t&lt;=R) <span class="hljs-keyword">continue</span>;l=L, r=R, res|=(<span class="hljs-number">1</span>&lt;&lt;i);&#125;<span class="hljs-keyword">if</span>(T[<span class="hljs-number">0</span>].<span class="hljs-built_in">query</span>(l,r,<span class="hljs-number">0</span>)&lt;=t&amp;&amp;t&lt;=T[<span class="hljs-number">0</span>].<span class="hljs-built_in">query</span>(l,r,<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) rt[i][<span class="hljs-number">0</span>]=lt[i][<span class="hljs-number">0</span>]=i;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a&lt;b) rt[a][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(rt[a][<span class="hljs-number">0</span>],b);<span class="hljs-keyword">else</span> lt[a][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(lt[a][<span class="hljs-number">0</span>],b);&#125;<span class="hljs-built_in">init</span>();Q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(Q--) &#123;<span class="hljs-type">int</span> s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">calc</span>(s,t));&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#4 多项式哈希与异或哈希</title>
    <link href="/2023/noip-record-4/"/>
    <url>/2023/noip-record-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="多项式哈希">多项式哈希</h2><p>把元素看作数字，把哈希对象看作关于 <spanclass="math inline">\(P\)</span>的多项式，得到多项式哈希，亦称为进制哈希。</p><p>主要用于有序对象的哈希。</p><p>一般使用<code>unsigned long long</code>自然溢出，相当于对 <spanclass="math inline">\(2^{64}\)</span> 取模。</p><p>关于 <span class="math inline">\(P\)</span>的选取，尽量避免常用的大质数。下文统一使用<code>1610612741</code>，其在<span class="math inline">\([2^{30},2^{31}]\)</span> 中。</p><p>单哈希的话很简单。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">geth</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) h[i]=h[i<span class="hljs-number">-1</span>]*P+S[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="区间哈希">区间哈希</h3><p><span class="math inline">\(h_r\)</span> 为 <spanclass="math inline">\([1,r]\)</span> 的哈希值。如何得到 <spanclass="math inline">\([l,r]\)</span> 的哈希值？在 <spanclass="math inline">\(h_r\)</span> 中，<spanclass="math inline">\(h_{l-1}\)</span> 乘了 <spanclass="math inline">\(r-l+1\)</span> 个 <spanclass="math inline">\(P\)</span> 且与 <spanclass="math inline">\([l,r]\)</span> 中的元素无关，因此 <spanclass="math display">\[h_{l,r} = h_r - h_{l-1} \cdot P^{r-l+1}\]</span> 预处理 <span class="math inline">\(P\)</span> 的幂次即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">uint <span class="hljs-title">getlr</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*PP[r-l+<span class="hljs-number">1</span>];&#125;</code></pre></div><h3 id="删除操作">删除操作</h3><p>询问 <span class="math inline">\([l,r]\)</span> 中删去位置 <spanclass="math inline">\(k\)</span> 上的字符后，<spanclass="math inline">\([l,r]\)</span> 的哈希值。</p><p>删掉 <span class="math inline">\(k\)</span>，那么 <spanclass="math inline">\([k+1,r]\)</span> 的字符就会向左移动一位。</p><p>考虑两个子串拼凑成的串的哈希值如何由它们二者得到。只要把 <spanclass="math inline">\([l,k-1]\)</span> 右移到 <spanclass="math inline">\(r\)</span> 的位置，做加法即可。移动的距离是 <spanclass="math inline">\(r-1-(k-1)=r-k\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">uint <span class="hljs-title">getdel</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">getlr</span>(l,k<span class="hljs-number">-1</span>)*P[r-k]+<span class="hljs-built_in">getlr</span>(k+<span class="hljs-number">1</span>,r);&#125;</code></pre></div><h3 id="应用">应用</h3><p>这个能干啥呢？</p><p>可以求 <spanclass="math inline">\(\texttt{palindrome}\)</span>，<spanclass="math inline">\(\texttt{border}\)</span>，<spanclass="math inline">\(\texttt{LCP}\)</span>啥的小东西，复杂度一般接近那些算法，也就是一定程度上代替部分字符串算法。</p><p>但是不展开讲了。</p><h3 id="luogu7469-noi-online-2021-提高组-积木小赛">luogu7469 [NOI Online2021 提高组] 积木小赛</h3><blockquote><p>给定两个长度为 <span class="math inline">\(n\)</span> 的字符串 <spanclass="math inline">\(S,T\)</span>，求 <spanclass="math inline">\(T\)</span> 中一段区间与 <spanclass="math inline">\(S\)</span>的任意子序列的匹配数量。两个匹配不同当且仅当字符串本质不同。</p><p><span class="math inline">\(n \le 3000\)</span>。</p></blockquote><p>预处理一个东西，<span class="math inline">\(nxt_{i,j}\)</span> 表示<span class="math inline">\(S[i+1,n]\)</span> 中最靠左的字符 <spanclass="math inline">\(j\)</span> 的下标。</p><p>枚举 <span class="math inline">\(T\)</span> 中的区间左端点 <spanclass="math inline">\(i\)</span>，按照 <spanclass="math inline">\(nxt_{i,j}\)</span>扩展右端点即可。如果找不到要匹配的字符，就结束匹配。</p><p>对于去重，使用区间哈希即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3005</span>, P=<span class="hljs-number">1610612741</span>;<span class="hljs-type">int</span> n, nxt[N][<span class="hljs-number">30</span>];uint h[N], PP[N];<span class="hljs-type">char</span> s[N], t[N];vector&lt;uint&gt; ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">geth</span><span class="hljs-params">()</span> </span>&#123;PP[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) PP[i]=PP[i<span class="hljs-number">-1</span>]*P, h[i]=h[i<span class="hljs-number">-1</span>]*P+<span class="hljs-built_in">id</span>(t[i]);&#125;<span class="hljs-function">uint <span class="hljs-title">getlr</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*PP[r-l+<span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,s+<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>);<span class="hljs-built_in">geth</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) nxt[n][i]=<span class="hljs-number">-1</span>;nxt[n][<span class="hljs-built_in">id</span>(s[n])]=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">26</span>) nxt[i][j]=nxt[i+<span class="hljs-number">1</span>][j];nxt[i][<span class="hljs-built_in">id</span>(s[i])]=i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>, cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(nxt[pos][<span class="hljs-built_in">id</span>(t[j])]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;pos=nxt[pos][<span class="hljs-built_in">id</span>(t[j])]+<span class="hljs-number">1</span>;ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">getlr</span>(i,j));++cnt;<span class="hljs-keyword">if</span>(pos&gt;n) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ans.<span class="hljs-built_in">size</span>();++i) <span class="hljs-keyword">if</span>(ans[i]!=ans[i<span class="hljs-number">-1</span>]) ++cnt;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,cnt);&#125;</code></pre></div><h3 id="luogu7114-noip2020-字符串匹配">luogu7114 [NOIP2020]字符串匹配</h3><p>NOIP 多少年来第一道字符串题。<del>也希望是最后一道</del>。</p><p>这里采用哈希做法。</p><p>枚举 <span class="math inline">\(i\)</span>，表示 <spanclass="math inline">\(AB = S[1,i]\)</span>。然后倍增地找到最大的 <spanclass="math inline">\(k\)</span>，满足 <spanclass="math inline">\((AB)^q\)</span> 合法，设 <spanclass="math inline">\((AB)^q = S[1,p]\)</span>。</p><p>那么 <span class="math inline">\(C\)</span> 一定是 <spanclass="math inline">\(S[p+1,n]\)</span> 前面有奇数个或偶数个 <spanclass="math inline">\(AB\)</span>。不难发现有偶数个 <spanclass="math inline">\(AB\)</span> 时，其 <spanclass="math inline">\(F\)</span>值必然相同，因此只需要多考虑奇数个的情况，取 <spanclass="math inline">\(S[p-i+1,n]\)</span> 即可。</p><p>对于一个 <span class="math inline">\((p,q)\)</span>，放偶数个 <spanclass="math inline">\(AB\)</span> 的情况有 <spanclass="math inline">\(c_0=\lceil \frac{q}{2} \rceil\)</span>种，奇数个有 <span class="math inline">\(c_1=q-c_0\)</span> 种。注意特判<span class="math inline">\(p=n\)</span> 时，不能放 <spanclass="math inline">\(0\)</span> 个 <spanclass="math inline">\(AB\)</span>，所以此时 <spanclass="math inline">\(c_0\)</span> 减去 <spanclass="math inline">\(1\)</span>，后缀需要取 <spanclass="math inline">\(S[p-2i+1]\)</span>。还可能存在 <spanclass="math inline">\(p-2i+1&lt;i\)</span>，这是不合法的。</p><p>设放偶数个 <span class="math inline">\(AB\)</span> 对应的 <spanclass="math inline">\(F\)</span> 值为 <spanclass="math inline">\(p_0\)</span>，奇数个为 <spanclass="math inline">\(p_1\)</span>。贡献就是 <spanclass="math display">\[c_0 \times \sum_{j=1}^{i-1} [F(S[1,j])\le p_0] + c_1 \times\sum_{j=1}^{i-1}[F(S[1,j]) \le p_1]\]</span> 树状数组维护即可。复杂度 <span class="math inline">\(O(n\log_2 n)\)</span>。</p><p>比 <span class="math inline">\(z\)</span>函数做法慢很多，但是好想且不容易写错。另外还存在哈希+调和级数枚举做法，但是笔者把这份倍增代码改为上述做法后，在洛谷上TLE 了。可能是人傻常数大吧。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1048580</span>;<span class="hljs-type">const</span> uint P=<span class="hljs-number">1610612741</span>;<span class="hljs-type">int</span> T, n, ans, c[<span class="hljs-number">30</span>], pre[N], suf[N], pos[N];uint h[N], PP[N], f[N][<span class="hljs-number">21</span>];<span class="hljs-type">char</span> s[N];<span class="hljs-function">uint <span class="hljs-title">getlr</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*PP[r-l+<span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;++x;<span class="hljs-keyword">for</span>(;x&lt;=n+<span class="hljs-number">1</span>;x+=x&amp;-x) c[x]+=y;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;++x;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;&#125; Tr;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">iinit</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>);pre[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, ++c[s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];h[<span class="hljs-number">1</span>]=s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;PP[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, PP[<span class="hljs-number">1</span>]=P;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;h[i]=h[i<span class="hljs-number">-1</span>]*P+(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>);PP[i]=PP[i<span class="hljs-number">-1</span>]*P;<span class="hljs-keyword">if</span>(c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) pre[i]=pre[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> pre[i]=pre[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;++c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];&#125;<span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>);suf[n]=<span class="hljs-number">1</span>, ++c[s[n]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) &#123;<span class="hljs-keyword">if</span>(c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) suf[i]=suf[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> suf[i]=suf[i+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;++c[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>];f[i][<span class="hljs-number">0</span>]=h[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;++j) &#123;f[i][j]=f[i][j<span class="hljs-number">-1</span>]*(PP[i*(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(i*(<span class="hljs-number">1</span>&lt;&lt;(j+<span class="hljs-number">1</span>))&gt;n) pos[i]=j;&#125;&#125;&#125;<span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>, q=<span class="hljs-number">0</span>, j=pos[i];<span class="hljs-keyword">for</span>(;~j;--j) &#123;<span class="hljs-type">int</span> t=i*(<span class="hljs-number">1</span>&lt;&lt;j);<span class="hljs-keyword">if</span>(p+t&gt;n) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(f[i][j]==<span class="hljs-built_in">getlr</span>(p+<span class="hljs-number">1</span>,p+t)) p+=t, q|=<span class="hljs-number">1</span>&lt;&lt;j;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(p,q);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">memset</span>(Tr.c,<span class="hljs-number">0</span>,(n+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-built_in">iinit</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n<span class="hljs-number">-1</span>) &#123;Tr.<span class="hljs-built_in">insert</span>(pre[i<span class="hljs-number">-1</span>],<span class="hljs-number">1</span>);pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; t=<span class="hljs-built_in">calc</span>(i);<span class="hljs-type">int</span> p=t.first, q=t.second;<span class="hljs-type">int</span> c0=(q+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, c1=q-c0;<span class="hljs-type">int</span> p0=suf[p+<span class="hljs-number">1</span>], p1=suf[p-i+<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(p==n) &#123;--c0;<span class="hljs-keyword">if</span>(p<span class="hljs-number">-2</span>*i&gt;=i) p0=suf[p<span class="hljs-number">-2</span>*i+<span class="hljs-number">1</span>];<span class="hljs-keyword">else</span> p0=<span class="hljs-number">0</span>;&#125;ans+=c0*Tr.<span class="hljs-built_in">query</span>(p0)+c1*Tr.<span class="hljs-built_in">query</span>(p1);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="luogu9399-dboiround-1-人生如树">luogu9399 「DBOI」Round 1人生如树</h3><p>由于多项式哈希基于多项式，所以它满足多项式运算的性质，且它基于有序结构，能保证元素的顺序。</p><p>对于一个询问，如果我们能把路径上的点的哈希值搞出来，那么就能判断<span class="math inline">\(H(b) - H(a)\)</span> 与 <spanclass="math inline">\(H(\{1,2,\ldots \})\)</span>是否相等，进而回答询问。直接都弄出来是做不了的，可以二分长度。</p><p>考虑到效率问题，我们要用倍增维护树上哈希值。对于一个 <spanclass="math inline">\(x\)</span>，如果只维护倍增时以它为 <spanclass="math inline">\(0\)</span> 次项的信息，那么我们很难把到 <spanclass="math inline">\(\operatorname{LCA}\)</span>的两条路径接起来，因此要额外维护一个以 <spanclass="math inline">\(x\)</span>为最高次项的时候的信息。最高此项可以在倍增合并时往后推。</p><p>有一个问题，如果把起点 <span class="math inline">\(x\)</span> 当作<span class="math inline">\(0\)</span> 次项，那么在从 <spanclass="math inline">\(y\)</span>那一条链上倍增时必须让这条链上的次数从下往上递减，这又会造成 <spanclass="math inline">\(z=\operatorname{LCA}(x,y)\)</span>下面那个点的次数比 <span class="math inline">\(z\)</span>的次数大，从而涉及除法。</p><p>解决方案是把 <span class="math inline">\(x\)</span>当作最后一项，这样 <span class="math inline">\(z\)</span>下面那个点的次数一定是 <span class="math inline">\(1\)</span>。</p><p>同时自然数序列的哈希值 <span class="math display">\[h_n = \sum_{i=1}^n i \times P^{n-i}\]</span> <del>这是个卷积</del>。</p><p>考虑 <span class="math inline">\(h_n\)</span> 的生成函数 <spanclass="math inline">\(H(n)\)</span>， 能发现 <spanclass="math display">\[H(n) = \frac{1}{(1-x)^2} \frac{x}{1-Px}\]</span> 对 <span class="math inline">\(\Big \langle 0,1,P,P^2,P^3\ldots \Big\rangle\)</span> 做两遍前缀和即可。</p><p>注意到修改只会添加叶子，对询问没有影响，直接离线。</p><p>注意查询的细节。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">const</span> uint BASE=<span class="hljs-number">1610612741</span>;<span class="hljs-type">int</span> n, m, s, idx, w[N], dep[N], f[N][<span class="hljs-number">20</span>];<span class="hljs-type">int</span> x1, y11, x2, y2, z1, z2;vector&lt;<span class="hljs-type">int</span>&gt; p[N];uint g[<span class="hljs-number">2</span>][N][<span class="hljs-number">20</span>], pw[N], res[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Q</span> &#123;<span class="hljs-type">int</span> x1, y1, x2, y2;&#125;;vector&lt;Q&gt; q;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;pw[<span class="hljs-number">0</span>]=res[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, res[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,s) pw[i]=pw[i<span class="hljs-number">-1</span>]*BASE;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,s) res[i]=res[i<span class="hljs-number">-1</span>]+pw[i<span class="hljs-number">-1</span>];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,s) res[i]+=res[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">0</span>]=fa, dep[x]=dep[fa]+<span class="hljs-number">1</span>;g[<span class="hljs-number">0</span>][x][<span class="hljs-number">0</span>]=g[<span class="hljs-number">1</span>][x][<span class="hljs-number">0</span>]=w[x];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">18</span>&amp;&amp;f[x][i<span class="hljs-number">-1</span>];++i) &#123;f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];g[<span class="hljs-number">0</span>][x][i]=g[<span class="hljs-number">0</span>][x][i<span class="hljs-number">-1</span>]*pw[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)]+g[<span class="hljs-number">0</span>][f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];        <span class="hljs-comment">// x在(2^i-1)次项</span>g[<span class="hljs-number">1</span>][x][i]=g[<span class="hljs-number">1</span>][x][i<span class="hljs-number">-1</span>]+g[<span class="hljs-number">1</span>][f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]*pw[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)];        <span class="hljs-comment">// x在0次项</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">uint <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> d)</span> </span>&#123;uint ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(d&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)&amp;&amp;dep[x]-dep[z]+<span class="hljs-number">1</span>&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;ans=g[<span class="hljs-number">0</span>][x][i]+ans*pw[<span class="hljs-number">1</span>&lt;&lt;i];d-=(<span class="hljs-number">1</span>&lt;&lt;i), x=f[x][i];&#125;<span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[y]-dep[z]&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)+d) y=f[y][i];        <span class="hljs-comment">// 跳到足够高的位置</span>vector&lt;PII&gt; v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(d&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)&amp;&amp;dep[y]-dep[z]&gt;=(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;            <span class="hljs-comment">// 这条链的开头是z在y这条链的儿子处</span>    d-=(<span class="hljs-number">1</span>&lt;&lt;i);v.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">MP</span>(g[<span class="hljs-number">1</span>][y][i],<span class="hljs-number">1</span>&lt;&lt;i)), y=f[y][i];&#125;<span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v) ans=t.fi+ans*pw[t.se];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x2,y2,z2,x)-<span class="hljs-built_in">get</span>(x1,y11,z1,x)!=res[x]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=s=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), idx=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> x1=<span class="hljs-built_in">read</span>(), y1=<span class="hljs-built_in">read</span>(), x2=<span class="hljs-built_in">read</span>(), y2=<span class="hljs-built_in">read</span>();q.<span class="hljs-built_in">pb</span>((Q)&#123;x1,y1,x2,y2&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> u=<span class="hljs-built_in">read</span>(), ww=<span class="hljs-built_in">read</span>();++s, w[s]=ww, p[u].<span class="hljs-built_in">pb</span>(s), p[s].<span class="hljs-built_in">pb</span>(u);&#125;&#125;<span class="hljs-built_in">init</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:q) &#123;x1=t.x1, y11=t.y1, x2=t.x2, y2=t.y2;z1=<span class="hljs-built_in">lca</span>(x1,y11), z2=<span class="hljs-built_in">lca</span>(x2,y2);<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-built_in">min</span>(dep[x1]+dep[y11]<span class="hljs-number">-2</span>*dep[z1],dep[x2]+dep[y2]<span class="hljs-number">-2</span>*dep[z2])+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;&#125;</code></pre></div><h2 id="异或哈希">异或哈希</h2><p>异或哈希，一种 Trick。</p><p>主要用于无序对象的哈希。</p><p>异或哈希一般使用随机权值，同时用异或运算作为链接不同哈希结构之间的桥梁。</p><p>相比于按位与、按位或运算，异或运算有着如下优势。</p><ol type="1"><li>大规模与运算后 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 的数量比接近 <spanclass="math inline">\(1 : 3\)</span>，或运算反之。而异或运算接近 <spanclass="math inline">\(1 : 1\)</span>。</li><li>异或运算的逆运算是异或运算，这意味着容易得到若干子段的信息。</li></ol><p>相比于多项式哈希，它更不容易被卡，且其本身的碰撞概率也相当小。</p><p>异或本身能做关于奇偶的一些东西以及「截取子段操作」，而异或哈希的主要作用是解决<strong>无序</strong>元素的<strong>存在性问题</strong>。</p><h3 id="abc250e-prefix-equality">ABC250E Prefix Equality</h3><blockquote><p>给定长度为 <span class="math inline">\(n\)</span> 的两个序列 <spanclass="math inline">\(a,b\)</span>，<spanclass="math inline">\(q\)</span> 个询问。每次询问 <spanclass="math inline">\(a\)</span> 的前 <spanclass="math inline">\(x\)</span> 项与 <spanclass="math inline">\(b\)</span> 的前 <spanclass="math inline">\(y\)</span>项，扔进两个不可重集合中后，两个集合是否相同。</p><p><span class="math inline">\(n,q \le 2 \times 10^5\)</span>，<spanclass="math inline">\(a_i,b_i \in [1,10^9]\)</span>。</p></blockquote><p>给每个元素 <span class="math inline">\(k\)</span> 一个随机权值 <spanclass="math inline">\(h_k\)</span>。然后对于每个 <spanclass="math inline">\([1,i]\)</span>，求出 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span>中，只出现了一次的数的权值异或和。这样就能 <spanclass="math inline">\(O(1)\)</span> 回答询问了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, BASE=<span class="hljs-number">13331</span>;<span class="hljs-type">int</span> n, m, q, cnt, a[N], b[N], t[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">unsigned</span> aa[N], bb[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p, pa, pb;<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(p[a[i]]==<span class="hljs-number">0</span>) p[a[i]]=<span class="hljs-built_in">rd</span>();&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(p[b[i]]==<span class="hljs-number">0</span>) p[b[i]]=<span class="hljs-built_in">rd</span>();&#125;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sa=<span class="hljs-number">0</span>, sb=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(++pa[a[i]]==<span class="hljs-number">1</span>) pa[a[i]]=<span class="hljs-number">1</span>, sa^=p[a[i]];<span class="hljs-keyword">if</span>(++pb[b[i]]==<span class="hljs-number">1</span>) pb[b[i]]=<span class="hljs-number">1</span>, sb^=p[b[i]];aa[i]=sa, bb[i]=sb;&#125;q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">puts</span>(aa[x]==bb[y]? <span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>);&#125;&#125;</code></pre></div><h3 id="某模拟赛题">某模拟赛题</h3><blockquote><p>给定一棵 <span class="math inline">\(n\)</span>个点的树，带边权。对于一个点对 <spanclass="math inline">\((u,v)\)</span>，可以生成如下游戏：提取二者路径上的所有边权到一个可重集合<span class="math inline">\(S\)</span>，执行两个步骤。</p><ol type="1"><li><p>先手第一次取走一个数。</p></li><li><p>记上一个人取走的数的值为 <spanclass="math inline">\(x\)</span>，当前的人需要从 <spanclass="math inline">\(S\)</span> 中取走一个不大于 <spanclass="math inline">\(x\)</span> 的数。不能进行操作的人输。</p></li></ol><p>问有多少无序点对满足先手必胜。</p><p><span class="math inline">\(n \le 5 \times 10^5\)</span>。</p></blockquote><p>先手必胜的充要条件是存在一种边权出现了奇数次，容易归纳证明。</p><p>给每个边权一个随机权值，求出根到 <spanclass="math inline">\(x\)</span> 的路径异或和 <spanclass="math inline">\(d_x\)</span>，这样就能把两点之间的路径拆成从根出发的两条路径，如果<span class="math inline">\(d_x \neq d_y\)</span>，那么 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 路径上一定存在出现奇数次的边权。</p><p>直接随机数竟然过不去……</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, BASE=<span class="hljs-number">13331</span>;<span class="hljs-type">int</span> T, n, cnt;<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w[N&lt;&lt;<span class="hljs-number">1</span>], d[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp, p;<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], w[tot]=z, h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v)</span> </span>&#123;d[x]=d[fa]^v;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x,w[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=cnt=<span class="hljs-number">0</span>;p.<span class="hljs-built_in">clear</span>(), mp.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(z)) z=mp[z];<span class="hljs-keyword">else</span> mp[z]=<span class="hljs-built_in">rd</span>()*(z+BASE), z=mp[z];<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ++p[d[i]];<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans+=n-p[d[i]];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/<span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="nc51463-graph-games">NC51463 Graph Games</h3><p>给每个点一个随机权值 <spanclass="math inline">\(w_x\)</span>，然后就能得到与点 <spanclass="math inline">\(x\)</span> 相邻的点的异或和 <spanclass="math inline">\(v_x\)</span>。</p><p>区间改不好搞，考虑分块。设 <spanclass="math inline">\(d(i,x)\)</span> 为第 <spanclass="math inline">\(i\)</span> 块内关于 <spanclass="math inline">\(x\)</span> 的异或和，整块对 <spanclass="math inline">\(d\)</span> 打 tag，散块改 <spanclass="math inline">\(v\)</span>，过程是平凡的。</p><p>最终 <span class="math inline">\(x\)</span> 的信息就是 <spanclass="math inline">\(v_x\)</span> 异或上所有有 tag 的 <spanclass="math inline">\(d(i,x)\)</span>。</p><p>正确性显然。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, q, a[M];<span class="hljs-type">int</span> t, block, pos[M], L[<span class="hljs-number">450</span>], R[<span class="hljs-number">450</span>], tag[<span class="hljs-number">450</span>];uint v[N], w[N], d[<span class="hljs-number">450</span>][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<span class="hljs-type">int</span> x, y;&#125; e[M];<span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> p=pos[l], q=pos[r];<span class="hljs-keyword">if</span>(p==q) &#123;<span class="hljs-built_in">rep</span>(i,l,r) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;v[x]^=w[y], v[y]^=w[x];&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">rep</span>(i,p+<span class="hljs-number">1</span>,q<span class="hljs-number">-1</span>) tag[i]^=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,l,R[p]) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;v[x]^=w[y], v[y]^=w[x];&#125;<span class="hljs-built_in">rep</span>(i,L[q],r) &#123;<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;v[x]^=w[y], v[y]^=w[x];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();block=<span class="hljs-built_in">sqrt</span>(m);t=m/block;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,t) L[i]=R[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>, R[i]=i*block;<span class="hljs-keyword">if</span>(R[t]&lt;m) ++t, L[t]=R[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>, R[t]=m;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,t) &#123;tag[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) d[i][j]=<span class="hljs-number">0</span>;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) w[i]=<span class="hljs-built_in">rd</span>(), v[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;e[i].x=<span class="hljs-built_in">read</span>(), e[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> x=e[i].x, y=e[i].y;v[x]^=w[y];v[y]^=w[x];pos[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;d[pos[i]][x]^=w[y];d[pos[i]][y]^=w[x];&#125; q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) <span class="hljs-built_in">modify</span>(l,r);<span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> vx=v[l], vy=v[r];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,t) &#123;<span class="hljs-keyword">if</span>(tag[i]) vx^=d[i][l], vy^=d[i][r];&#125;<span class="hljs-built_in">printf</span>(vx==vy? <span class="hljs-string">&quot;1&quot;</span>:<span class="hljs-string">&quot;0&quot;</span>);&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h3 id="cf1175f-the-number-of-subpermutations">CF1175F The Number ofSubpermutations</h3><blockquote><p>给定一个序列，求这个序列中有多少区间 <spanclass="math inline">\([l,r]\)</span> 是 <span class="math inline">\(1\sim r-l+1\)</span> 的一个排列。</p><p><span class="math inline">\(n \le 3 \times 10^5\)</span>。</p></blockquote><p>给每个 <span class="math inline">\(i\)</span> 分配一个随机权值 <spanclass="math inline">\(h_i\)</span>，得到 <spanclass="math inline">\(base_i = \bigoplus_{j=1}^i h_i\)</span>，那么<span class="math inline">\(base_i\)</span> 就是 <spanclass="math inline">\(1 \sim i\)</span> 的排列的哈希值。</p><p>一个排列中一定包含一个 <span class="math inline">\(1\)</span>。设<span class="math inline">\(j\)</span> 为从上一个 <spanclass="math inline">\(1\)</span> 的位置到 <spanclass="math inline">\(i\)</span> 中的最大值，初始或遇到 <spanclass="math inline">\(a_i=1\)</span> 时，<spanclass="math inline">\(j=1\)</span>。如果 <span class="math inline">\(i\ge j\)</span> 并且 <span class="math inline">\(\bigoplus_{k=i-j+1}^ih_{a_k} = base_j\)</span>，那么说明 <spanclass="math inline">\([i-j+1,i]\)</span> 是一个排列。</p><p>这样只得到了排列的最大值在 <span class="math inline">\(1\)</span>右边的情况。反过来再枚举一遍即可。</p><p>注意如果 <span class="math inline">\(a_i=1\)</span>，那么 <spanclass="math inline">\([i,i]\)</span> 也是排列。</p><h3 id="cf1746f-kazaee">CF1746F Kazaee</h3><blockquote><p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(q\)</span>个操作。</p><ol type="1"><li>单点修改</li><li>询问区间 <span class="math inline">\([l,r]\)</span>中每个数出现的次数是否都是 <span class="math inline">\(k\)</span>的倍数。</li></ol><p><span class="math inline">\(n,q \le 3 \times 10^5\)</span>，<spanclass="math inline">\(a_i \in [1,10^9]\)</span>。</p></blockquote><p>先把 <span class="math inline">\(a\)</span> 离散化了，然后考虑给<span class="math inline">\(a_i\)</span> 一个随机权值 <spanclass="math inline">\(h_{a_i}\)</span>。</p><p>设 <span class="math inline">\(S=\sum_{i=l}^rh_{a_i}\)</span>，那么也有 <span class="math inline">\(S = \sum_{x \ina[l,r]} cnt_x \times h_x\)</span>。根据一点数论知识，能得到 <spanclass="math inline">\(k \mid S\)</span>是答案为<code>YES</code>的一个必要条件为什么不充分呢？因为如果存在一个<span class="math inline">\(x\)</span> 满足 <spanclass="math inline">\(k \mid h_x\)</span>，其他的都是 <spanclass="math inline">\(k \mid cnt_x\)</span>，那么也能使得 <spanclass="math inline">\(k \midS\)</span>。这是由于哈希的不稳定性导致的。</p><p>解决方法是把询问离线了然后多哈希几次。</p><h3 id="cf869e-the-untended-antiquity">CF869E The UntendedAntiquity</h3><blockquote><p>给定一个 <span class="math inline">\(n \times m\)</span> 的网格图，有<span class="math inline">\(q\)</span> 次操作。</p><ol type="1"><li>在左上角为 <span class="math inline">\((x_1,y_1)\)</span>，右下角为<span class="math inline">\((x_2,y_2)\)</span>的矩形四边上修建围墙。</li><li>删除左上角为 <spanclass="math inline">\((x_1,y_1)\)</span>，右下角为 <spanclass="math inline">\((x_2,y_2)\)</span>的矩形四边上修建围墙。保证此围墙存在。</li><li>查询从 <span class="math inline">\((x_1,y_1)\)</span>出发是否存在路径，满足不跨越任何围墙就能到达 <spanclass="math inline">\((x_2,y_2)\)</span>。</li></ol><p><strong>保证围墙无重合处。</strong></p><p><span class="math inline">\(n,m \le 2500\)</span>，<spanclass="math inline">\(q \le 10^5\)</span>。</p></blockquote><p>如果能够到达，那么 <span class="math inline">\((x_1,y_1)\)</span> 与<span class="math inline">\((x_2,y_2)\)</span>一定在同一个围墙内（把整个网格图外围也看做有围墙），否则一定不能。</p><p>对于一个围墙，给它一个随机权值，用二维差分的方式做区间异或。只要查询<span class="math inline">\((x_1,y_1)\)</span> 与 <spanclass="math inline">\((x_2,y_2)\)</span>的前缀异或值是否相等，就能判断是否有围墙包含了二者其中之一。</p><h3 id="luogu4065-jxoi2017颜色">luogu4065 [JXOI2017]颜色</h3><p>对于一种颜色 <span class="math inline">\(c\)</span>，将所有 <spanclass="math inline">\(a_i=c\)</span> 的位置 <spanclass="math inline">\(i\)</span> 都随机映射一个权值，特别地，最靠右的<span class="math inline">\(i\)</span> 的权值是前面的异或和。</p><p>这样直接扫一遍，记录当前 <span class="math inline">\(i\)</span>的异或和 <span class="math inline">\(S\)</span>，如果之前也存在异或和为<span class="math inline">\(S\)</span> 的一个 <spanclass="math inline">\(j\)</span>，那么 <spanclass="math inline">\([j+1,i]\)</span> 就是一段异或和为 <spanclass="math inline">\(0\)</span>的区间。根据上文的讨论可知，如果异或和为 <spanclass="math inline">\(0\)</span>，那么这一段中的颜色 <spanclass="math inline">\(c\)</span> 一定满足不存在 <spanclass="math inline">\(a_k=c\)</span> 使得 <spanclass="math inline">\(k\le j\)</span> 或 <span class="math inline">\(k&gt; i\)</span>，是满足条件的。</p><p>维护一个<code>std::unordered_map</code>即可。</p><p>与上题相同，是利用异或差分与异或前缀和来完成类似区间覆盖的操作。</p><h3 id="luogu8819-csp-s-2022-星战">luogu8819 [CSP-S 2022] 星战</h3><blockquote><p>给定一个 <span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span> 边的有向图，有 <spanclass="math inline">\(q\)</span> 次操作。</p><ol type="1"><li>删掉一条边 <spanclass="math inline">\((u,v)\)</span>，保证这条边存在。</li><li>删掉 <span class="math inline">\(u\)</span> 所有的入边。</li><li>添加一条边 <spanclass="math inline">\((u,v)\)</span>，保证这条边是曾经存在且被删掉的。</li><li>添加 <span class="math inline">\(u\)</span>所有被删掉且此时不存在的入边。</li></ol><p>每次操作后，询问这张图是不是一个内向树森林。</p><p><span class="math inline">\(n,m,q \le 5 \times 10^5\)</span>。</p></blockquote><p>考虑什么时候一张图是内向树森林。</p><p>发现这玩意没啥强力的性质……</p><ol type="1"><li><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(n\)</span> 边。</li><li>每个点有且仅有一条出边。</li><li>满足上述两个条件的有向图必然是内向树森林，证明是平凡的。也就是说这两个性质同时成立就充要了，可以考虑从这里下手。</li></ol><p>第一个条件容易维护，考虑第二个。</p><p>直接做会干到 <span class="math inline">\(O(nq)\)</span>。</p><p>深入思考，我们能发现如果满足第二个条件，那么每个点的入点集合 <spanclass="math inline">\(in_x\)</span> 之并就是 <spanclass="math inline">\(1 \sim n\)</span>所有节点。而由于我们维护了第一个条件，所以这个条件只需要判掉一种情况：<spanclass="math inline">\(n\)</span> 点 <spanclass="math inline">\(n\)</span>边，但是有节点没有出边。没有出边，这个点就一定不在 <spanclass="math inline">\(in_x\)</span> 的并里面。</p><p>如何快速维护这个东西？对每个点随即映射，使用异或哈希即可完成 <spanclass="math inline">\(O(1)\)</span> 改查。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, q;uint U, S, base[N], in[N], icnt[N], cui[N], ccnt[N];<span class="hljs-comment">// base是随机权值，in是入点集合，icnt是入边数量</span><span class="hljs-comment">// cui是被摧毁的入点集合，ccnt是其数量</span><span class="hljs-function">mt19937 <span class="hljs-title">rd</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) base[i]=(uint)<span class="hljs-built_in">rd</span>()*(i+<span class="hljs-built_in">rd</span>()), U^=base[i];    <span class="hljs-comment">// U是1~n之并</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();in[y]^=base[x], S^=base[x];++icnt[y];&#125;q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>(), u=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>||op==<span class="hljs-number">3</span>) &#123;<span class="hljs-type">int</span> v=<span class="hljs-built_in">read</span>();in[v]^=base[u], cui[v]^=base[u], S^=base[u];<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) --icnt[v], ++ccnt[v], --m; <span class="hljs-keyword">else</span> ++icnt[v], --ccnt[v], ++m;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) m-=icnt[u], cui[u]^=in[u], ccnt[u]+=icnt[u], S^=in[u], in[u]=<span class="hljs-number">0</span>, icnt[u]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> m+=ccnt[u], icnt[u]+=ccnt[u], in[u]^=cui[u], S^=cui[u], cui[u]=<span class="hljs-number">0</span>, ccnt[u]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(m==n&amp;&amp;S==U) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树论</tag>
      
      <tag>树上倍增</tag>
      
      <tag>多项式哈希</tag>
      
      <tag>异或哈希</tag>
      
      <tag>分块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#3 Trie</title>
    <link href="/2023/noip-record-3/"/>
    <url>/2023/noip-record-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>Trie</p><h3 id="luogu2922-usaco08decsecret-message-g">luogu2922[USACO08DEC]Secret Message G</h3><blockquote><p>给定两个字符串序列 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span>，对于 <spanclass="math inline">\(b\)</span> 中每个字符串 <spanclass="math inline">\(t\)</span>，求 <spanclass="math inline">\(a\)</span> 中有多少个字符串 <spanclass="math inline">\(s\)</span>，满足以下两个条件之一</p><ol type="1"><li><span class="math inline">\(s\)</span> 是 <spanclass="math inline">\(t\)</span> 的前缀。</li><li><span class="math inline">\(t\)</span> 是 <spanclass="math inline">\(s\)</span> 的前缀。</li></ol><p>两个字符串序列中所有字符串长度之和不超过 <spanclass="math inline">\(500000\)</span>。</p></blockquote><p>把 <span class="math inline">\(a\)</span> 中所有字符串插入Trie，记录每个节点处结尾的字符串数量 <spanclass="math inline">\(end_x\)</span>。对于第 1 种，答案就是 <spanclass="math inline">\(t\)</span> 路径上的 <spanclass="math inline">\(end_x\)</span> 之和。</p><p>对于第 2 种，在 Trie 上 DFS 求出以 <spanclass="math inline">\(x\)</span> 为根的子树内有多少字符串的结尾位置<span class="math inline">\(sz_x\)</span>，然后顺着 <spanclass="math inline">\(t\)</span> 走，如果走不完 <spanclass="math inline">\(t\)</span> 就是 <spanclass="math inline">\(0\)</span>，否则就是 <spanclass="math inline">\(t\)</span> 结尾那个节点的 <spanclass="math inline">\(sz_x\)</span>。</p><p>注意算第一种要忽略 <span class="math inline">\(t\)</span>结尾那个节点的 <spanclass="math inline">\(end_x\)</span>，否则会重复。</p><h3 id="uva1401-remember-the-word">UVA1401 Remember the Word</h3><blockquote><p>给定一个由 <span class="math inline">\(s\)</span>个不同单词组成的字典 <span class="math inline">\(D\)</span> 和一个长度为<span class="math inline">\(n\)</span> 的字符串 <spanclass="math inline">\(S\)</span>，求把这个字符串按照字典划分为若干单词有多少种方法。</p><p><span class="math inline">\(s \le 4000\)</span>，<spanclass="math inline">\(n \le 300000\)</span>。</p><p>单个字典中的单词长度不超过 <spanclass="math inline">\(100\)</span>。</p></blockquote><p>朴素 DP，设 <span class="math inline">\(f_i\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 的划分方案数，则 <spanclass="math display">\[f_i = \sum_{j=0}^i f_j \big[S[j+1,i] \in D\big]\]</span> 或者 <span class="math display">\[f_i = \sum_{s \in D \texttt{ and } s \text{ is a suffix of } S[1,i]}f_{i-|s|-1}\]</span> 不太能优化。</p><p>尝试另外一种状态，设 <span class="math inline">\(f_{i}\)</span>为后缀 <span class="math inline">\([i,n]\)</span> 的划分方案数 <spanclass="math display">\[f_i = \sum_{s \in D \texttt{ and } s \text{ is a prefix of } S[i,n] }f_{i+|s|+1}\]</span> 注意到字典中单词长度不超过 <spanclass="math inline">\(100\)</span>，所以可以从 <spanclass="math inline">\(i\)</span> 暴力枚举，通过 hash快速判断是否可以转移。</p><p>但是这篇文章写 Trie，考虑一些 Trie 做法。</p><p>将 <span class="math inline">\(D\)</span> 中字符串插入 Trie，搜一下<spanclass="math inline">\(S[i,n]\)</span>，找一下路径上的结束节点即可。</p><h3 id="luogu7537.-coci2016-20174-rima">luogu7537. [COCI2016-2017#4]Rima</h3><blockquote><p>设字符串 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 的最长公共后缀的长度为 <spanclass="math inline">\(\operatorname{LCS}(A,B)\)</span>。</p><p>称两个字符串 <span class="math inline">\(A,B\)</span> 合法，当且仅当<span class="math inline">\(\operatorname{LCS}(A,B) \ge\max(|A|,|B|)-1\)</span>。</p><p>给定 <span class="math inline">\(n\)</span>个字符串，要求组合出一个长度最长的字符串序列，满足相邻两个字符串合法。输出序列长度。</p><p><span class="math inline">\(n \le 5 \cdot10^5\)</span>，字符串总长度不超过 <span class="math inline">\(3 \cdot10^6\)</span>。</p></blockquote><p>后缀不好做，可以转化成前缀插入Trie，记录在每个节点结束的串的个数。</p><p>这样就转化成了 <span class="math inline">\(A,B\)</span>合法，当且仅当在 Trie 树上，二者结束节点的LCA，距离深度较大的那个结束节点不超过一条边。</p><p>还能继续发现性质。合法的字符串序列，相邻两个串的 <spanclass="math inline">\(\operatorname{LCS}\)</span>可以是先递减后递增的。这样一定最优。</p><p>因此在 Trie 上 DFS，枚举中间这个最小的 <spanclass="math inline">\(\operatorname{LCS}\)</span>。</p><p>设 <span class="math inline">\(f_x\)</span>为最长公共后缀长度单调不增，最后两个串的最长公共后缀是 <spanclass="math inline">\(x\)</span>对应的字符串的最长序列。相当于时求了最优序列的一般。</p><p>节点 <span class="math inline">\(x\)</span> 是所有子节点的 <spanclass="math inline">\(\operatorname{LCS}\)</span>，所以它的所有子节点都能加入序列，以<span class="math inline">\(x\)</span>为结尾的串放到中间。而序列两边还能接上以 <spanclass="math inline">\(x\)</span> 的某两个子节点的 <spanclass="math inline">\(f\)</span> 值，取最大和次大即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n;<span class="hljs-type">int</span> tot, ans, trie[N][<span class="hljs-number">26</span>], cnt[N], f[N];<span class="hljs-type">char</span> s[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-built_in">per</span>(i,len<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> a=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;++cnt[x];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;f[x]=cnt[x];<span class="hljs-type">int</span> sz=<span class="hljs-number">0</span>, fr=<span class="hljs-number">0</span>, sc=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>) <span class="hljs-keyword">if</span>(trie[x][i]) &#123;<span class="hljs-type">int</span> y=trie[x][i];<span class="hljs-built_in">dfs</span>(y);<span class="hljs-keyword">if</span>(cnt[y]) &#123;++sz;<span class="hljs-keyword">if</span>(f[y]&gt;fr) sc=fr, fr=f[y];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[y]&gt;sc) sc=f[y];&#125;&#125;f[x]+=fr+<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,sz<span class="hljs-number">-1</span>);ans=<span class="hljs-built_in">max</span>(ans,fr+sc+cnt[x]+<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,sz<span class="hljs-number">-2</span>));&#125;&#125; tr;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);tr.<span class="hljs-built_in">insert</span>(s);&#125;tr.<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu9218-taoi-1apollo">luogu9218 「TAOI-1」Apollo</h3><p>如果 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 的整数部分不同，那么一定能找到一个整数<span class="math inline">\(c\)</span> 使得 <spanclass="math inline">\(f(c) = 0\)</span>，从而 <spanclass="math inline">\(g(a,b)=0\)</span>。</p><p>如果 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span>的整数部分相同，小数部分不同，那么能找到一个 <spanclass="math inline">\(c\)</span> 是的 <spanclass="math inline">\(f(c)\)</span> 是它们小数部分 <spanclass="math inline">\(\operatorname{LCP}\)</span> 的长度 <spanclass="math inline">\(len+1\)</span>，这也是 <spanclass="math inline">\(g(a,b)\)</span> 的最小值。</p><p>比如</p><div class="code-wrapper"><pre><code class="hljs cpp">a=<span class="hljs-number">11.4514</span>b=<span class="hljs-number">11.4523</span>c=<span class="hljs-number">11.452</span>, <span class="hljs-built_in">g</span>(a,b)=<span class="hljs-number">3</span></code></pre></div><p>而当 <span class="math inline">\(a=b\)</span> 时，<spanclass="math inline">\(g(a,b)\)</span> 是 <spanclass="math inline">\(a\)</span> 小数部分 <spanclass="math inline">\(\operatorname{LCP}\)</span> 的长度，这个显然。</p><p>考虑用 Trie 维护前缀信息，把 <spanclass="math inline">\(\operatorname{LCP}\)</span>长度拆成每个节点被经过的次数。</p><p>问题在于对于每一个 <span class="math inline">\(i\)</span> 求 <spanclass="math inline">\(\sum_{j=1}^n g(a_i,a_j)\)</span>。</p><p>由上述分析知道 <span class="math inline">\(g(a_i,a_j)\)</span>有贡献的必要条件是 <span class="math inline">\(a_i\)</span> 与 <spanclass="math inline">\(b_i\)</span> 整数部分相同。我们可以将所有 <spanclass="math inline">\(a_i\)</span>按照整数部分排序，一次处理整数部分相同的一块 <spanclass="math inline">\([l,r]\)</span>，这些数肯定共用一棵Trie。然后用每个 <span class="math inline">\(a_i\)</span>的小数部分去匹配这棵 Trie，将这些贡献加入 <spanclass="math inline">\(ans_i\)</span>。</p><p>匹配的过程中到达了节点 <spanclass="math inline">\(x\)</span>，无论子节点是什么都会产生贡献，所以在记录每个点被经过的次数时，直接加到它的父亲节点即可。这样同时避免了<span class="math inline">\(a_i\)</span> 匹配 <spanclass="math inline">\(a_i\)</span> 时特判最后一位。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">3e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, ans[N];<span class="hljs-type">int</span> tot, trie[M][<span class="hljs-number">10</span>], cnt[M];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">qwq</span> &#123;<span class="hljs-type">int</span> it, id;string s;&#125; e[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(qwq a,qwq b) &#123;<span class="hljs-keyword">return</span> a.it&lt;b.it;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string S,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=S.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;cnt[x]+=d;        <span class="hljs-comment">// 在父节点处修改</span><span class="hljs-type">int</span> a=S[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string S)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>, len=S.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;res+=cnt[x];        <span class="hljs-comment">// 在父节点处统计</span><span class="hljs-type">int</span> a=S[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) <span class="hljs-keyword">break</span>;x=trie[x][a];&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) <span class="hljs-built_in">insert</span>(e[i].s,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) ans[e[i].id]+=<span class="hljs-built_in">query</span>(e[i].s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) <span class="hljs-built_in">insert</span>(e[i].s,<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld.&quot;</span>,&amp;e[i].it);cin&gt;&gt;e[i].s;e[i].id=i;&#125;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> lst=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(e[i].it!=e[i+<span class="hljs-number">1</span>].it) <span class="hljs-built_in">solve</span>(lst,i), lst=i+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(lst!=n) <span class="hljs-built_in">solve</span>(lst,n);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;</code></pre></div><h3 id="某模拟赛题">某模拟赛题</h3><blockquote><p>小 F 正在写一个磁盘搜索系统。磁盘中共有 <spanclass="math inline">\(n\)</span> 个文件，它们的文件名 <spanclass="math inline">\(s_i\)</span> 由小写字母组成，两两不同。小 F想快速知道 <span class="math inline">\(m\)</span> 个问题的答案：第 <spanclass="math inline">\(i\)</span> 次给定 <spanclass="math inline">\(t_i\)</span>，求以 <spanclass="math inline">\(t_i\)</span> 为文件名的文件是否存在。</p><p>这个问题很快被小 F 解决了。但是小 F 遇到了一个新的问题：他记不清<span class="math inline">\(t_i\)</span>具体是什么，只记得它的开头一部分和结尾一部分，中间部分用一个<code>*</code>代替。小F 想知道满足这个条件的文件有多少个。</p><p>对于 <span class="math inline">\(20\%\)</span> 的数据，<spanclass="math inline">\(\sum |S_i|,\sum |T_i|\le 100\)</span>。</p><p>对于另外 <span class="math inline">\(40\%\)</span>的数据，<code>*</code>出现在开头或结尾。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(1\le |S_i|\)</span>，<spanclass="math inline">\(1\le \sum |S_i|,\sum |T_i|\le 10^6\)</span>。</p></blockquote><p>正反建两棵 Trie。</p><p>设 <span class="math inline">\(t_{i,0}\)</span> 为 <spanclass="math inline">\(t_i\)</span>中<code>*</code>之前的部分最后一个字符在 Trie 上对应的节点，<spanclass="math inline">\(t_{i,1}\)</span> 为后面的部分的。</p><p>如果匹配 <span class="math inline">\(t_i\)</span> 时在正 Trie 匹配到<span class="math inline">\(x_0\)</span>，在反 Trie 匹配到 <spanclass="math inline">\(x_1\)</span>，<spanclass="math inline">\(t_{i,0}\)</span> 必须在 <spanclass="math inline">\(x_0\)</span> 子树内，<spanclass="math inline">\(t_{i,1}\)</span> 必须在 <spanclass="math inline">\(x_1\)</span> 子树内。</p><p>暴力做法：对于每个 <span class="math inline">\(t_i\)</span>，在正Trie 上 DFS。匹配完 <span class="math inline">\(t_{i,0}\)</span>之后，对其子树内所有点都加上 <span class="math inline">\(1\)</span>的权值，然后是反 Trie 上的 <spanclass="math inline">\(t_{i,1}\)</span>，其子树权值和即为答案。子树内<span class="math inline">\(dfn\)</span>连续，只涉及区间加区间查，可以用树状数组维护。</p><p>正解：把询问离线了。在 DFS 到 <spanclass="math inline">\(t_{i,0}\)</span> 时，求出此时 <spanclass="math inline">\(t_{i,1}\)</span> 的子树权值和；DFS结束后再统计一次，做差即可。</p><p>可以只保存 Trie 上的 <span class="math inline">\(t_{i,0/1}\)</span>节点，重新建图。</p><p>给出 std。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO(x) freopen(x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin),freopen(x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-keyword">using</span> std::reverse;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n,m;<span class="hljs-type">char</span> s[N];<span class="hljs-type">int</span> ans[N];<span class="hljs-type">int</span> trieTotal,linkTotal,dfsCount;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;<span class="hljs-type">int</span> d[N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">for</span>(; p&lt;=dfsCount; p+=p&amp;-p)++d[p];&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> r;<span class="hljs-keyword">for</span>(r=<span class="hljs-number">0</span>; p; p-=p&amp;-p)r+=d[p];<span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">querySum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(r)-<span class="hljs-built_in">query</span>(l<span class="hljs-number">-1</span>);&#125;&#125; b;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">queryNode</span> &#123;<span class="hljs-type">int</span> to,nt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> n)</span> </span>&#123;to=t,nt=n;&#125;&#125; q[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">linkNode</span> &#123;<span class="hljs-type">int</span> to,nt,lp,rp;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;to=t,nt=n,lp=l,rp=r;&#125;&#125; l[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">trieNode</span> &#123;<span class="hljs-type">int</span> h,v1,v2;<span class="hljs-meta">#<span class="hljs-keyword">define</span> siz v1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> dfn v2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> lnk v1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fir v2</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addQuery</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> t)</span> </span>&#123;q[i].<span class="hljs-built_in">set</span>(t,fir),fir=i;&#125;&#125; a[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> flg=<span class="hljs-number">1</span>)</span> </span>&#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> tmp;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[pos].fir; i; i=q[i].nt) &#123;tmp=q[i].to;ans[i]+=flg*b.<span class="hljs-built_in">querySum</span>(a[tmp].dfn,a[tmp].dfn+a[tmp].siz<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">newTrieNode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ++trieTotal;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">newLinkNode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ++linkTotal;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">trie</span> &#123;<span class="hljs-type">int</span> root,cur;<span class="hljs-type">char</span> buf[N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">trie</span><span class="hljs-params">()</span>:root(newTrieNode()) &#123;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">addLink</span><span class="hljs-params">(<span class="hljs-type">int</span> src,<span class="hljs-type">int</span> dst,<span class="hljs-type">char</span>*&amp;s)</span> </span>&#123;<span class="hljs-type">int</span> tmp=<span class="hljs-built_in">newLinkNode</span>(),old=cur;<span class="hljs-keyword">while</span>(*s)buf[cur++]=*(s++);l[tmp].<span class="hljs-built_in">set</span>(dst,a[src].h,old,cur),a[src].h=tmp;<span class="hljs-keyword">return</span> dst;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">findLink</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">char</span>*&amp;s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[pos].h,p; i; i=l[i].nt)&#123;<span class="hljs-keyword">for</span>(p=l[i].lp;p&lt;l[i].rp&amp;&amp;buf[p]==*s;++p)++s;<span class="hljs-keyword">if</span>(p==l[i].lp)<span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(p==l[i].rp)<span class="hljs-keyword">return</span> l[i].to;pos=<span class="hljs-built_in">newTrieNode</span>();<span class="hljs-type">int</span> tmp=<span class="hljs-built_in">newLinkNode</span>();l[tmp].<span class="hljs-built_in">set</span>(l[i].to,<span class="hljs-number">0</span>,p,l[i].rp),a[pos].h=tmp;l[i].to=pos,l[i].rp=p;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">addLink</span>(pos,<span class="hljs-built_in">newTrieNode</span>(),s);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getLink</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">char</span>*&amp;s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[pos].h,p; i; i=l[i].nt)&#123;<span class="hljs-keyword">for</span>(p=l[i].lp;p&lt;l[i].rp&amp;&amp;buf[p]==*s;++p)++s;<span class="hljs-keyword">if</span>(p==l[i].lp)<span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(p==l[i].rp||*s==<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-keyword">return</span> l[i].to;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> pos=root;<span class="hljs-keyword">while</span>(*s)pos=<span class="hljs-built_in">findLink</span>(pos,s);<span class="hljs-keyword">return</span> pos;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">travel</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> pos=root;<span class="hljs-keyword">while</span>(pos&amp;&amp;*s!=<span class="hljs-string">&#x27;*&#x27;</span>)pos=<span class="hljs-built_in">getLink</span>(pos,s);<span class="hljs-keyword">return</span> pos;&#125;&#125; t[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;a[pos].siz=<span class="hljs-number">1</span>,a[pos].dfn=++dfsCount;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[pos].h; i; i=l[i].nt)a[pos].siz+=<span class="hljs-built_in">dfs1</span>(l[i].to);<span class="hljs-keyword">return</span> a[pos].siz;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<span class="hljs-built_in">update</span>(pos,<span class="hljs-number">-1</span>);<span class="hljs-keyword">if</span>(a[pos].lnk)b.<span class="hljs-built_in">update</span>(a[a[pos].lnk].dfn);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[pos].h; i; i=l[i].nt)<span class="hljs-built_in">dfs2</span>(l[i].to);<span class="hljs-built_in">update</span>(pos,<span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> len,t0,t1;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">funcS</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);len=<span class="hljs-built_in">strlen</span>(s),t0=t[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(s);<span class="hljs-built_in">reverse</span>(s,s+len),t1=t[<span class="hljs-number">1</span>].<span class="hljs-built_in">insert</span>(s);a[t0].lnk=t1;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">funcT</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);len=<span class="hljs-built_in">strlen</span>(s),t0=t[<span class="hljs-number">0</span>].<span class="hljs-built_in">travel</span>(s);<span class="hljs-built_in">reverse</span>(s,s+len),t1=t[<span class="hljs-number">1</span>].<span class="hljs-built_in">travel</span>(s);<span class="hljs-keyword">if</span>(t0&amp;&amp;t1)a[t0].<span class="hljs-built_in">addQuery</span>(i,t1);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<span class="hljs-built_in">funcS</span>();<span class="hljs-built_in">dfs1</span>(t[<span class="hljs-number">1</span>].root);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i)<span class="hljs-built_in">funcT</span>(i);<span class="hljs-built_in">dfs2</span>(t[<span class="hljs-number">0</span>].root);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[i]);&#125;</code></pre></div><p>下面把焦点给到<code>0-1 Trie</code>。</p><h3 id="luogu4592-tjoi2018-异或">luogu4592 [TJOI2018] 异或</h3><blockquote><p>一棵 <span class="math inline">\(n\)</span> 个点的树，带点权，<spanclass="math inline">\(q\)</span> 个询问。</p><p>每次询问给出 <span class="math inline">\(op\)</span>，若 <spanclass="math inline">\(op=1\)</span>，给定 <spanclass="math inline">\(x,z\)</span>，询问 <spanclass="math inline">\(x\)</span> 子树内的点权与 <spanclass="math inline">\(z\)</span> 的最大异或和；若 <spanclass="math inline">\(op=2\)</span>，给定 <spanclass="math inline">\(x,y,z\)</span>，询问 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 路径上的点权与 <spanclass="math inline">\(z\)</span> 的最大异或和。</p><p><span class="math inline">\(n,q \le 10^5\)</span>，<spanclass="math inline">\(z &lt; 2^{30}\)</span>。</p></blockquote><p>树剖之后转成序列问题，询问给定区间内的数与给定值的最大异或值。</p><p><del>每条重链开可持久化 Trie</del>。</p><p>把询问离线了，然后按照右端点排序，处理完一个区间 <spanclass="math inline">\([l,r]\)</span> 后插入新数即可。但 <spanclass="math inline">\(l\)</span> 不是单调的，可以给 Trie上每个节点维护一个 tag，表示经过这个点的数，所对应下标的最大值。根据 tag是否大于等于当前 <span class="math inline">\(l\)</span>来判断是否能贪心走。</p><h3 id="luogu5283-十二省联考-2019-异或粽子">luogu5283 [十二省联考 2019]异或粽子</h3><blockquote><p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span> 和整数 <spanclass="math inline">\(k\)</span>，求异或和最大的 <spanclass="math inline">\(k\)</span> 个不同区间的异或和之和。</p><p><span class="math inline">\(n \le 5 \cdot 10^5\)</span>，$ k {,2 ^5}<span class="math inline">\(，\)</span>a_i $。</p></blockquote><p>求前缀异或和 <span class="math inline">\(s\)</span>，问题转化为求<span class="math inline">\(k\)</span> 个点对 <spanclass="math inline">\((i,j)\)</span>，满足 <spanclass="math inline">\(s_j \oplus s_i\)</span> 是前 <spanclass="math inline">\(k\)</span> 大的。</p><p>考虑用 Trie。由于 Trie是无序的而点对有序，所以一个点对会被找到两次，这样求出答案再除以 <spanclass="math inline">\(2\)</span> 即可。</p><p>暴力插入显然是不行的。但是对于 <spanclass="math inline">\((i,j_0)\)</span> 与 <spanclass="math inline">\((i,j_1)\)</span>，若 <spanclass="math inline">\(s_i \oplus s_{j_0} &gt; s_i \opluss_{j_1}\)</span>，那么 <span class="math inline">\(j_0\)</span>一定优先于 <spanclass="math inline">\(j_1\)</span>。所以开一个大根堆，维护三元组 <spanclass="math inline">\((x,id,rk)\)</span> 表示与 <spanclass="math inline">\(s_{id}\)</span> 异或结果从大到小排名为 <spanclass="math inline">\(rk\)</span> 的异或值 <spanclass="math inline">\(x\)</span>，贪心选择，然后再加入 <spanclass="math inline">\((x&#39;,id,rk+1)\)</span>。在 Trie 上实现 <spanclass="math inline">\(\operatorname{kth xor}\)</span> 很容易。</p><p>虽然 <span class="math inline">\((i,i)\)</span> 不合法且能被选到，但<span class="math inline">\(s_i \oplus s_i=0\)</span>，所以没有影响。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, ans, s[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> x, id, rk;&#125;;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123;<span class="hljs-keyword">return</span> a.x&lt;b.x;&#125;priority_queue&lt;node&gt; q;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">int</span> tot, trie[N*<span class="hljs-number">31</span>][<span class="hljs-number">2</span>], cnt[N*<span class="hljs-number">31</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(s&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];++cnt[x];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(s&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(cnt[trie[x][a^<span class="hljs-number">1</span>]]&gt;=k) &#123;ans|=<span class="hljs-number">1ll</span>&lt;&lt;i;                <span class="hljs-comment">// 注意用1ll</span>x=trie[x][a^<span class="hljs-number">1</span>];&#125; <span class="hljs-keyword">else</span> &#123;k-=cnt[trie[x][a^<span class="hljs-number">1</span>]];x=trie[x][a];&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125; T;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) s[i]=s[i<span class="hljs-number">-1</span>]^<span class="hljs-built_in">read</span>(), T.<span class="hljs-built_in">insert</span>(s[i]);T.<span class="hljs-built_in">insert</span>(s[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// 插入s[0]</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,n) &#123;<span class="hljs-type">int</span> x=T.<span class="hljs-built_in">query</span>(s[i],<span class="hljs-number">1</span>);q.<span class="hljs-built_in">push</span>(&#123;x,i,<span class="hljs-number">1</span>&#125;);&#125;k&lt;&lt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(k--) &#123;node t=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();ans+=t.x;<span class="hljs-type">int</span> x=T.<span class="hljs-built_in">query</span>(s[t.id],t.rk+<span class="hljs-number">1</span>);q.<span class="hljs-built_in">push</span>(&#123;x,t.id,t.rk+<span class="hljs-number">1</span>&#125;);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans&gt;&gt;<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="luogu6824-ezec-4可乐">luogu6824 「EZEC-4」可乐</h3><p>把 <span class="math inline">\(a_i\)</span> 插入Trie，记录结束节点。</p><p>设 <span class="math inline">\(f_y\)</span> 为以 <spanclass="math inline">\(y\)</span> 为根的子树所能得到的最大值。</p><p>但是这样会有两个问题。</p><ol type="1"><li>不是所有情况下都能知道 <span class="math inline">\(a_i \oplusx\)</span> 与 <span class="math inline">\(k\)</span> 的大小关系。</li><li>只有叶子节点能产生贡献，且只能贡献 <spanclass="math inline">\(1\)</span> 次。</li></ol><p>进一步地，只有 <span class="math inline">\(a_i\)</span> 与 <spanclass="math inline">\(x\)</span> 这一位同号且 <spanclass="math inline">\(k\)</span> 这一位为 <spanclass="math inline">\(1\)</span> 时才能让以 <spanclass="math inline">\(y\)</span> 为根的子树中所有叶子节点的贡献转移到<span class="math inline">\(f_y\)</span>。</p><p>因此当 <span class="math inline">\(k\)</span> 这一位是 <spanclass="math inline">\(1\)</span> 时，有 <span class="math display">\[f_y = \max(f_{son_0(y)}+cnt_{son_1(y)}, f_{son_1(y)}+cnt_{son_0(y)})\]</span> 否则只继承状态 <span class="math display">\[f_y = \max(f_{son_0(y)},f_{rson_1(y)})\]</span></p><p>其中 <span class="math inline">\(cnt_y\)</span> 表示以 <spanclass="math inline">\(y\)</span>为根的子树中叶子节点的数量。这样就能解决上述两个问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, f[N*<span class="hljs-number">20</span>], cnt[N*<span class="hljs-number">20</span>];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, trie[N*<span class="hljs-number">20</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;++cnt[x];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ddfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">if</span>(!trie[x][<span class="hljs-number">0</span>]&amp;&amp;!trie[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(trie[x][i]) <span class="hljs-built_in">ddfs</span>(trie[x][i],d<span class="hljs-number">-1</span>), cnt[x]+=cnt[trie[x][i]];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">if</span>(!trie[x][<span class="hljs-number">0</span>]&amp;&amp;!trie[x][<span class="hljs-number">1</span>]) &#123; f[x]=cnt[x]; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(trie[x][i]) <span class="hljs-built_in">dfs</span>(trie[x][i],d<span class="hljs-number">-1</span>);&#125;<span class="hljs-type">int</span> x0=trie[x][<span class="hljs-number">0</span>], x1=trie[x][<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>((k&gt;&gt;d)&amp;<span class="hljs-number">1</span>) f[x]=<span class="hljs-built_in">max</span>(cnt[trie[x][<span class="hljs-number">0</span>]]+f[trie[x][<span class="hljs-number">1</span>]],cnt[trie[x][<span class="hljs-number">1</span>]]+f[trie[x][<span class="hljs-number">0</span>]]);<span class="hljs-keyword">else</span> f[x]=<span class="hljs-built_in">max</span>(f[trie[x][<span class="hljs-number">0</span>]],f[trie[x][<span class="hljs-number">1</span>]]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">read</span>());<span class="hljs-built_in">ddfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>);<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>]);&#125;</code></pre></div><h3 id="luogu7717-ezec-10序列">luogu7717 「EZEC-10」序列</h3><p>本题在之前的文章中已经讲过，这里着重于有关 Trie 的部分。</p><p>首先按照限制 <span class="math inline">\((x_i,y_i,z_i)\)</span> 连边<span class="math inline">\((x_i, y_i)\)</span>，权值为 <spanclass="math inline">\(z_i\)</span>，表示二者点权的异或值为 <spanclass="math inline">\(z_i\)</span>。然后从一个连通块上任意一点 <spanclass="math inline">\(root\)</span> 开始DFS，得到其他所有点与这个点权值的关系，把无解的情况判掉。设 <spanclass="math inline">\(d_x = a_{root} \oplusa_x\)</span>。这样问题就是问一个数 <spanclass="math inline">\(\Delta\)</span> 有多少种取值，使得 <spanclass="math inline">\(\Delta\)</span> 与 <spanclass="math inline">\(\Delta \oplus d_x\)</span> 都不超过 <spanclass="math inline">\(k\)</span>。</p><p>将 <span class="math inline">\(d_x\)</span> 插入 Trie，在 Trie 上DFS。过程中维护当前深度与连通块出现过的最大值，讨论放 <spanclass="math inline">\(1\)</span> 还是放 <spanclass="math inline">\(0\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, k, ans=<span class="hljs-number">1</span>, d[N], vis[N], deg[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gr</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;&#125; G;<span class="hljs-keyword">namespace</span> Trie &#123;<span class="hljs-type">int</span> cnt, t[N*<span class="hljs-number">30</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,cnt) t[i][<span class="hljs-number">0</span>]=t[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;cnt=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!t[x][a]) t[x][a]=++cnt;x=t[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> kk)</span> </span>&#123;<span class="hljs-keyword">if</span>(!t[x][<span class="hljs-number">0</span>]&amp;&amp;!t[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(t[x][<span class="hljs-number">0</span>]&amp;&amp;t[x][<span class="hljs-number">1</span>]) &#123;<span class="hljs-keyword">if</span>(kk+(<span class="hljs-number">1</span>&lt;&lt;d)&lt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">0</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d))+<span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">1</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d));<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(t[x][<span class="hljs-number">0</span>]) &#123;<span class="hljs-keyword">if</span>(kk+(<span class="hljs-number">1</span>&lt;&lt;d)&lt;=k) <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;d)+<span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">0</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d));<span class="hljs-keyword">return</span> <span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">0</span>],d<span class="hljs-number">-1</span>,kk);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(kk+(<span class="hljs-number">1</span>&lt;&lt;d)&lt;=k) <span class="hljs-built_in">return</span> (<span class="hljs-number">1</span>&lt;&lt;d)+<span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">1</span>],d<span class="hljs-number">-1</span>,kk+(<span class="hljs-number">1</span>&lt;&lt;d));<span class="hljs-keyword">return</span> <span class="hljs-built_in">Dfs</span>(t[x][<span class="hljs-number">1</span>],d<span class="hljs-number">-1</span>,kk);&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;vis[x]=<span class="hljs-number">1</span>;Trie::<span class="hljs-built_in">insert</span>(d[x]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i], z=G.w[i];<span class="hljs-keyword">if</span>(d[y]!=<span class="hljs-number">-1</span>&amp;&amp;(d[x]^z^d[y])!=<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;d[y]=d[x]^z;<span class="hljs-keyword">if</span>(!vis[y]) <span class="hljs-built_in">dfs</span>(y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();G.<span class="hljs-built_in">add</span>(x,y,z), G.<span class="hljs-built_in">add</span>(y,x,z);++deg[x], ++deg[y];&#125;<span class="hljs-built_in">SET</span>(d,<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(!deg[i]) &#123; (ans*=k+<span class="hljs-number">1</span>)%=mod; <span class="hljs-keyword">continue</span>; &#125;Trie::<span class="hljs-built_in">init</span>();d[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(i);(ans*=Trie::<span class="hljs-built_in">Dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">30</span>,<span class="hljs-number">0</span>))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树论</tag>
      
      <tag>Trie</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#2 基环树</title>
    <link href="/2023/noip-record-2/"/>
    <url>/2023/noip-record-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>突破口永远在环上。</p><p> </p><p>找环是常用操作，但是并没有一个合适的模板。</p><p>笔者在写这篇文章之前就做过一些基环树的简单题，但是每一次写的找环都不尽相同。仅仅用<code>dfs</code>的回溯模拟一个栈，显然是不够公式化的，且容易出bug，因此我们需要确定一种可靠的写法。</p><p>关于<code>dfn</code>的那套理论再合适不过了。</p><p>当然这玩意只能找一个环。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt, num, fa[N], dfn[N], cir[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_cir</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    dfn[x]=++num;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa[x]) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(dfn[y]) &#123;            <span class="hljs-keyword">if</span>(dfn[y]&lt;dfn[x]) <span class="hljs-keyword">continue</span>;            cir[++cnt]=y;            <span class="hljs-keyword">while</span>(y!=x) &#123;                cir[++cnt]=fa[y];                y=fa[x];            &#125;        &#125; <span class="hljs-keyword">else</span> fa[y]=x, <span class="hljs-built_in">get_cir</span>(y);    &#125;&#125;</code></pre></div><p>还可以使用拓扑排序。</p><p>最终没有入队的就是环上节点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 基环树</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort1</span><span class="hljs-params">()</span></span>&#123;     queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i];            <span class="hljs-keyword">if</span>(in[y]&gt;<span class="hljs-number">1</span>)&#123;                <span class="hljs-comment">// do sth.</span>                <span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// 内向树</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort2</span><span class="hljs-params">()</span></span>&#123;     queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i];            <span class="hljs-comment">// do sth.</span>            <span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);        &#125;    &#125;&#125;</code></pre></div><h3 id="luogu2607-zjoi2008-骑士">luogu2607 [ZJOI2008] 骑士</h3><blockquote><p>基环树森林， <span class="math inline">\(n\)</span>个点。求带权最大独立集。</p><p><span class="math inline">\(n \le 10^6\)</span></p></blockquote><p>树的情况是平凡的。</p><p>基环树的本质是若干树挂在一个环上，因此对于环上每个节点为根都跑一遍。然后断环为链，钦定一个元素选还是不选，做两遍即可。</p><h3 id="luogu4381-ioi2008-island">luogu4381 [IOI2008] Island</h3><blockquote><p>求 <span class="math inline">\(n\)</span> 个点的基环树直径。</p><p><span class="math inline">\(n \le 10^6\)</span></p></blockquote><p>答案一定是环上两点连接它们子树的直径。</p><p>断环为链，这里采用复制一遍的方法。</p><p>答案就是 <span class="math display">\[\max_{i \le j} \{d_i + d_j + dis(i,j)\}\]</span> 把 <span class="math inline">\(dis(i,j)\)</span>拆成前缀和相减的形式，发现对于一个 <spanclass="math inline">\(j\)</span>，最优策略是前面距离不超过 <spanclass="math inline">\(n\)</span> 的最大值，单调队列维护。</p><h3 id="cf835f-roads-in-the-kingdom">CF835F Roads in the Kingdom</h3><blockquote><p><span class="math inline">\(n\)</span>个结点的基环树，边有边权。需要从删去一条边，保证连通且最小化直径。</p></blockquote><p>首先删掉的边一定是环上的，否则不连通。</p><p>断开环上一边 <spanclass="math inline">\((x,y)\)</span>，此时的直径是环上 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span>的路径加上二者子树的直径，或者某个子树的直径。</p><p>而删边的影响仅仅是干掉某些环上的路径。</p><p>长度为 <span class="math inline">\(n\)</span>的那个滑动窗口能够做到“删掉某条边”。</p><p>由于这个单调队列一次能干掉的决策只有一个，所以用<code>std::set</code>即可，但是要注意判断最优决策相等的情况，维护次大值。</p><h3 id="cf711d-directed-roads">CF711D Directed Roads</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(n\)</span>边的无向图，多少种给边定向的方式，是的新图中无环。</p><p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p></blockquote><p>考虑一个联通块。如果无环，那么每条边任意。否则一定只有 <spanclass="math inline">\(1\)</span> 个环，减掉保留这个环的方案数即可。</p><p>注意环可能有两种方向。</p><h3 id="cf1454e-number-of-simple-paths">CF1454E Number of SimplePaths</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(n\)</span>边的无向图，问一共有多少条简单路径。</p><p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p></blockquote><p>如果两个点之间的路径跨越环上某一部分，那么就有两条简单路径，否则只有一条。对环上每棵子树分别考虑即可。</p><h3 id="cf1607f-robot-on-the-board-2">CF1607F Robot on the Board 2</h3><blockquote><p><span class="math inline">\(n \times m\)</span>的矩阵，每个点都往上下左右某一个位置连一条边，从任意节点出发按照边走，直到走到之前经过的点为止。求能经过的最大节点数量以及相应起点。</p><p><span class="math inline">\(n,m \le 2000\)</span></p></blockquote><p>连边后是一个内向树森林，直接 DP 即可。</p><h3 id="cf1770d-koxia-and-game">CF1770D Koxia and Game</h3><blockquote><p>给定 <span class="math inline">\(n\)</span> 和长度为 <spanclass="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a,b\)</span>，考虑另一个序列 <spanclass="math inline">\(c\)</span>。</p><p>先手在第 <span class="math inline">\(i\)</span>次操作，可以拿走可重集 <spanclass="math inline">\(\{a_i,b_i,c_i\}\)</span>中的一个元素，后手再二选一拿走一个。</p><p>做完 <span class="math inline">\(n\)</span>次操作后，如果后手拿走的所有元素是 <span class="math inline">\(1 \simn\)</span> 的一个排列，那么先手胜，否则先手败。</p><p>求有多少个 <span class="math inline">\(c\)</span>，满足先手能胜利。对<span class="math inline">\(998244353\)</span> 取模。</p><p><span class="math inline">\(n \le 10^5\)</span>，<spanclass="math inline">\(a_i,b_i \in [1,n]\)</span></p></blockquote><p>博弈，但并不是传统的博弈论题目。</p><p>正着想很困难，考虑先手能赢的条件。</p><p>对于 <spanclass="math inline">\(\{a_n,b_n,c_n\}\)</span>，如果不存在两者相同，那么无论先手拿走哪一个，后手都有办法使得先手输掉。所以<span class="math inline">\(\{a_n,b_n,c_n\}\)</span>存在两者相同是一个必要条件。</p><p>考虑 <spanclass="math inline">\(\{a_{n-1},b_{n-1},c_{n-1}\}\)</span>，假设 <spanclass="math inline">\(\{a_n,b_n,c_n\}\)</span> 满足上述条件，发现 <spanclass="math inline">\(\{a_{n-1},b_{n-1},c_{n-1}\}\)</span>满足上述条件依然是必要的。</p><p>由此递归下去，得到对于任意 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(\{a_i,b_i,c_i\}\)</span>满足上述条件是充要的。</p><p>问题转化为对于任意 <span class="math inline">\(i\)</span>，要在 <spanclass="math inline">\((a_i,b_i)\)</span> 中选择一个数，求选出的数构成<span class="math inline">\([1,n]\)</span> 的一个排列的方案数。对于<span class="math inline">\(a_i = b_i\)</span> 的情况，对方案的贡献是<span class="math inline">\(n\)</span>。</p><p>转化为图论问题。将 <span class="math inline">\(a_i\)</span> 与 <spanclass="math inline">\(b_i\)</span> 视为点，在 <spanclass="math inline">\((a_i,b_i)\)</span>间连一条无向边，这样就会得到一些连通块。由数据范围可知最多有 <spanclass="math inline">\(n\)</span> 个点与 <spanclass="math inline">\(n\)</span> 条边。</p><p>由于一条边连接的两个点中必然有一个被选择且不允许重复（要构成排列），所以如果一个联通块点数不等于边数，无解。那么有解的连通块一定是一棵基环树。</p><p>容易发现方案只有 <span class="math inline">\(2\)</span>种，区别在环上选择的方向。环也有可能是自环，就是 <spanclass="math inline">\(a_i=b_i\)</span> 的情况，方案是 <spanclass="math inline">\(1\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> T, n, ans, fg, v[N], a[N], b[N];<span class="hljs-type">int</span> cnt;vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N], sz[N], cnte[N];<span class="hljs-type">bool</span> slp[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;;<span class="hljs-type">int</span> tx=<span class="hljs-built_in">get</span>(x), ty=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(fa[tx]!=ty) fa[tx]=ty, sz[ty]+=sz[tx], cnte[ty]+=cnte[tx];++cnte[ty];slp[ty]|=slp[tx];<span class="hljs-keyword">if</span>(x==y) slp[ty]=<span class="hljs-number">1</span>;&#125;    <span class="hljs-comment">// 经过某道题的教训，终于老老实实写些并查集维护起来相对容易的信息了</span>&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-number">0</span>, dsu.fa[i]=i, dsu.cnte[i]=dsu.slp[i]=<span class="hljs-number">0</span>, dsu.sz[i]=<span class="hljs-number">1</span>, a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> x=a[i], y=b[i];dsu.<span class="hljs-built_in">merge</span>(x,y);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i==dsu.<span class="hljs-built_in">get</span>(i)) &#123;<span class="hljs-keyword">if</span>(dsu.sz[i]!=dsu.cnte[i]) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(dsu.slp[i]) (ans*=n)%=mod;<span class="hljs-keyword">else</span> (ans*=<span class="hljs-number">2</span>)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><p>贴上<code>DFS</code>版本的 std。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, a[N], b[N];vector &lt;<span class="hljs-type">int</span>&gt; G[N];<span class="hljs-type">bool</span> vis[N];<span class="hljs-type">int</span> vertex, edge, self_loop;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">return</span> ;vis[x] = <span class="hljs-literal">true</span>;vertex++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : G[x]) &#123;edge++;<span class="hljs-built_in">dfs</span>(y);<span class="hljs-keyword">if</span> (y == x) self_loop++; &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) G[i].<span class="hljs-built_in">clear</span>(); <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;G[a[i]].<span class="hljs-built_in">push_back</span>(b[i]);G[b[i]].<span class="hljs-built_in">push_back</span>(a[i]);&#125; <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span> ;vertex = <span class="hljs-number">0</span>;edge = <span class="hljs-number">0</span>;self_loop = <span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(i);<span class="hljs-keyword">if</span> (edge != <span class="hljs-number">2</span> * vertex) ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self_loop) ans = <span class="hljs-number">1ll</span> * ans * n % P; <span class="hljs-keyword">else</span> ans = ans * <span class="hljs-number">2</span> % P;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<span class="hljs-keyword">while</span> (t--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cf512d-fox-and-travelling">CF512D Fox And Travelling</h3><p><del>不知道和基环树有什么关系</del>。</p><p>首先可以发现，环中的节点和链接两个环的链上的节点是不能选的。</p><p>用上文的无向图拓扑排序可以找到所有上述节点，这样的话就会得到一个森林。</p><p>注意选点是有顺序的，考虑一棵树中，一定是从叶子开始自底向上选，且如果一个点没有被选，其一定不会产生任何贡献。</p><p>设 <span class="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，选择 <spanclass="math inline">\(i\)</span> 个点，其中 <spanclass="math inline">\(x\)</span> 必须选择的方案数。 <spanclass="math display">\[g_j = \binom{j}{k} \times f_{x,k} \times f_{y,j-k}\]</span> <span class="math inline">\(\binom{j}{k}\)</span> 的含义是从<span class="math inline">\(j\)</span> 个位置中选择 <spanclass="math inline">\(k\)</span> 个给当前以 <spanclass="math inline">\(x\)</span> 为根的子树。</p><p>能发现 <span class="math inline">\(x\)</span> 是最后被选择的。</p><p>对于挂在环上的树，这种选择方式显然是唯一的。</p><p>考虑孤立的树。由于 <span class="math inline">\(n \le100\)</span>，所以直接以每个点为根做一次树形 DP。设选择 <spanclass="math inline">\(i\)</span> 个节点，这样只能保证选 <spanclass="math inline">\(sz_{root}\)</span> 个点时没有重复。</p><p>考虑选出的 <span class="math inline">\(i\)</span>个节点，这个方案一定在以剩下 <spanclass="math inline">\(sz_{root}-i\)</span>个节点为根时都被算过一次，除掉即可。</p><h3 id="luogu5049-noip2018-提高组-旅行-加强版">luogu5049 [NOIP2018提高组] 旅行 加强版</h3><blockquote><p>给定一棵 <span class="math inline">\(n\)</span>个点的树或基环树，起点为 <span class="math inline">\(1\)</span>。</p><p>有两种操作</p><ol type="1"><li>到达一个当前点能直接到达的，没有到达过的点。</li><li>沿着到达当前点的边退回这条边的另一个端点。</li></ol><p>要求遍历所有点，最小化节点遍历的字典序。</p><p><span class="math inline">\(n \le 5 \cdot 10^5\)</span></p></blockquote><p>对于一棵树，必须按照子节点编号递增的顺序<code>DFS</code>，所以下文访问顺序指的就是兄弟节点之间的编号顺序。</p><p>对于基环树，多了的操作是「从环上往后退」。</p><p>什么时候可以往后退呢？当且仅当对于环上的父子节点 <spanclass="math inline">\((x,y)\)</span>，<spanclass="math inline">\(y\)</span> 是 <spanclass="math inline">\(x\)</span>最后遍历的子节点（这样才能从另一边绕回来），同时回溯到 <spanclass="math inline">\(y\)</span> 的祖先时，能够到达编号小于 <spanclass="math inline">\(y\)</span> 的点。</p><p>更进一步地，如果选择了退回，那么不可能再次后退。所以这个编号小于<span class="math inline">\(y\)</span>的点，一定是回溯过程中遇到的第一个祖先的儿子，满足它是这个祖先下一个应访问的节点，否则就无法遍历到了。</p><p>因此就变成了树的做法。</p><p>如何实现？对于节点 <spanclass="math inline">\(x\)</span>，维护最小子节点编号，<code>DFS</code>时记录之，这样一定能找到最优退回的地方。</p><p>顺带一提，优先队列的内存优化优于队列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, num, fg, root, dfn[N], fa[N];<span class="hljs-type">bool</span> v[N], cir[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N], ans;<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;ans.<span class="hljs-built_in">pb</span>(x);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_cir</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    dfn[x]=++num;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;        <span class="hljs-keyword">if</span>(dfn[y]) &#123;            <span class="hljs-keyword">if</span>(dfn[y]&lt;dfn[x]) <span class="hljs-keyword">continue</span>;            cir[y]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(y!=x) &#123;            cir[fa[y]]=<span class="hljs-number">1</span>;            y=fa[y];            &#125;        &#125; <span class="hljs-keyword">else</span> fa[y]=x, <span class="hljs-built_in">get_cir</span>(y);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> pre)</span> </span>&#123;v[x]=<span class="hljs-number">1</span>;ans.<span class="hljs-built_in">pb</span>(x);priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> y=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(!fg&amp;&amp;q.<span class="hljs-built_in">empty</span>()&amp;&amp;cir[x]&amp;&amp;cir[y]&amp;&amp;pre&lt;y) &#123;fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(v[y]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(cir[x]&amp;&amp;q.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">DFS</span>(y,q.<span class="hljs-built_in">top</span>());<span class="hljs-keyword">else</span> <span class="hljs-built_in">DFS</span>(y,pre);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">sort</span>(p[i].<span class="hljs-built_in">begin</span>(),p[i].<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span>(m==n<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">get_cir</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1e9</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><ul><li>欲穷千里目，更上一层楼。</li></ul><h3 id="luogu8288-daoi-r1fireworks">luogu8288 「DAOI R1」Fireworks</h3><p>题面较复杂，就不放了。</p><p>本题相当缝合。</p><p>坚持自己的想法，让我得到了无数次 WA。最终也是放弃了自己的框架，参考了std。</p><p>这么多次写挂，背后的原因，不全是因为此题代码实现相对复杂。经过教练的指导，我也明白了我深层的不足。</p><p>为了不留下遗憾，勇敢面对吧！</p><p>连边 <span class="math inline">\((a_x \rightarrow x)\)</span>，权值<span class="math inline">\(b_x\)</span>。</p><p>如果没有系列的限制，相当于在外向树森林上做一个简单 DP。</p><p>有了限制，就把同一个系列的点缩成一个，其权值为所有点权之和。</p><p>设 <span class="math inline">\(f_{x,0/1}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span>选还是不选的最大价值。每个节点的入边最多为 <spanclass="math inline">\(1\)</span>，因此无入度点一定不会进入环，直接搜。</p><p>如果有环，强制环上一点选或者不选，两次 DP 即可。</p><p>设主节点为 <span class="math inline">\(p\)</span>，对于非主要点 <spanclass="math inline">\(x\)</span>，如果 <spanclass="math inline">\(a_x\)</span> 所在系列是 <spanclass="math inline">\(x\)</span> 所在的系列，让点权减少 <spanclass="math inline">\(b_x\)</span>；否则如果 <spanclass="math inline">\(a_x\)</span> 所在的系列和 <spanclass="math inline">\(a_p\)</span> 所在系列相同，就让边权加上 <spanclass="math inline">\(b_x\)</span>。</p><p>注意如果 <span class="math inline">\(a_p\)</span> 就是 <spanclass="math inline">\(p\)</span>所在系列，优先执行前者。而这对应的就是无入度点。</p><p>如果有点不属于任何一个系列，新建立一个系列，只有这个点。</p><p>主要问题在于实现。</p><p>代码详细解释。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;ll a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, num, cnt, a[N], p[N], bel[N];ll b[N], v[N], v2[N], ww[N], f[N][<span class="hljs-number">2</span>];vector&lt;<span class="hljs-type">int</span>&gt; s[N];vector&lt;pair&lt;<span class="hljs-type">int</span>,ll&gt; &gt; g[N];pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cir[N];<span class="hljs-type">bool</span> vis[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;&#125; dsu;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> i)</span> </span>&#123;f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=v2[x];    <span class="hljs-comment">// 赋初值避开清空数组</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<span class="hljs-type">int</span> y=t.first;ll z=t.second;<span class="hljs-built_in">dfs</span>(y,i);        <span class="hljs-comment">// 出边可能不止有一条。虽然断开了环上那条边，但cir[i].second也可能到达其他点</span>        <span class="hljs-comment">// 因此还要往下DFS，这时候就能看出避免连环上这条边的重要性</span>        <span class="hljs-comment">// 只需要在更新cir[i].second的父节点时候特判</span><span class="hljs-keyword">if</span>(i&amp;&amp;y==cir[i].second) &#123;f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-ww[i]);f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-ww[i]-z);            <span class="hljs-comment">// 无论如何必须减掉i这条边的权值</span>&#125; <span class="hljs-keyword">else</span> &#123;f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-built_in">read</span>(), a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;p[++num]=<span class="hljs-built_in">read</span>(); <span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();dsu.fa[num]=num;<span class="hljs-keyword">while</span>(k--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();v2[num]+=v[x], bel[x]=num;s[num].<span class="hljs-built_in">pb</span>(x);&#125;        <span class="hljs-comment">// num表示有多少个系列</span>        <span class="hljs-comment">// 只有系列才是有用的，因此直接重新编号，避免不必要的麻烦</span>        <span class="hljs-comment">// 笔者在写的时候，没有进行重新编号，而是用DSU进行缩点</span>        <span class="hljs-comment">// 不重新编号，会带来各种各样的麻烦</span>        <span class="hljs-comment">// 重新编号则没有什么坏处</span>        <span class="hljs-comment">// 因为原来的点的编号在预处理完之后就没有任何用处了</span>&#125;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!bel[i]) &#123;p[++num]=i, bel[i]=num, v2[num]=v[i];s[num].<span class="hljs-built_in">pb</span>(i);dsu.fa[num]=num;        <span class="hljs-comment">// 处理不在任何系列中的点</span>&#125;        <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,num) &#123;<span class="hljs-type">int</span> tp=bel[a[p[i]]];ll res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s[i]) &#123;<span class="hljs-type">int</span> tx=bel[a[x]];<span class="hljs-keyword">if</span>(tx==i) v2[i]-=b[x];            <span class="hljs-comment">// 优先执行这个</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tx==tp) res+=b[x];&#125;<span class="hljs-keyword">if</span>(tp==i) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 无入度点</span>vis[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==dsu.<span class="hljs-built_in">get</span>(tp)) &#123;            <span class="hljs-comment">// DSU判环</span>            <span class="hljs-comment">// 但注意不要烦笔者这样的错误</span>            <span class="hljs-comment">// 突然降智，过于依赖DSU的结构，用DSU存每个连通块那一条环上边</span>            <span class="hljs-comment">// 自找麻烦罢了</span>cir[++cnt].first=i, cir[cnt].second=tp, ww[cnt]=res;            <span class="hljs-comment">// ww[cnt]为这条边的权值</span>&#125; <span class="hljs-keyword">else</span> &#123;dsu.fa[dsu.<span class="hljs-built_in">get</span>(i)]=dsu.<span class="hljs-built_in">get</span>(tp);g[tp].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">make_pair</span>(i,res));            <span class="hljs-comment">// 成环的时候不连边，保证DFS无环</span>            <span class="hljs-comment">// 否则就连反边</span>&#125;&#125;ll ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,num) <span class="hljs-keyword">if</span>(!vis[i]) &#123;<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);ans+=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],f[i][<span class="hljs-number">1</span>]);        <span class="hljs-comment">// 这样的点可以直接搜</span>&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;<span class="hljs-type">int</span> x=cir[i].first;ll aa=<span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(x,i);        <span class="hljs-comment">// 强制cir[i].first必须选，cir[i].second-&gt;cir[i].first必须考虑</span>aa=f[x][<span class="hljs-number">1</span>];<span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">0</span>);aa=<span class="hljs-built_in">max</span>(aa,f[x][<span class="hljs-number">0</span>]);        <span class="hljs-comment">// 不选，不考虑cir[i].second-&gt;cir[i].first</span>ans+=aa;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><ul><li>不要过于依赖提交，认真分析程序。</li><li>思路应该更广阔些，本题应该在发现建图后就是外向树森林，进而分析图的特殊形态而简化实现</li></ul><p>必须要把我的某一版 sb 程序贴出来，以作警示。</p><p>想不到还有 30pts。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans, v[N], vv[N], a[N], b[N], p[N], f[N][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> to[N][<span class="hljs-number">2</span>];<span class="hljs-type">bool</span> vis[N];vector&lt;<span class="hljs-type">int</span>&gt; s[N];vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; g[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<span class="hljs-type">int</span> fa[N];pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cir[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, cir[i].fi=cir[i].se=<span class="hljs-number">0</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> dx=<span class="hljs-built_in">get</span>(x), dy=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(dx!=dy) fa[dx]=dy;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=y) cir[dy]=&#123;x,y&#125;;&#125;&#125; dsu, dsu2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span> </span>&#123;vis[x]=<span class="hljs-number">1</span>;f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=v[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<span class="hljs-type">int</span> y=t.fi, z=t.se;<span class="hljs-keyword">if</span>(y==root) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,root);f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span> </span>&#123;f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;f[x][<span class="hljs-number">1</span>]=v[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<span class="hljs-type">int</span> y=t.fi, z=t.se;<span class="hljs-keyword">if</span>(y==root) &#123;f[x][<span class="hljs-number">1</span>]-=z;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs1</span>(y,root);f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);&#125;<span class="hljs-comment">// printf(&quot;x=%lld f=%lld %lld\n&quot;,x,f[x][0],f[x][1]);</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">redirect</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<span class="hljs-type">int</span> y=to[i][<span class="hljs-number">0</span>], z=to[i][<span class="hljs-number">1</span>];g[y].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">make_pair</span>(i,z));&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;dsu2.<span class="hljs-built_in">merge</span>(i,to[i][<span class="hljs-number">0</span>]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-built_in">read</span>(), a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();dsu.<span class="hljs-built_in">init</span>(), dsu2.<span class="hljs-built_in">init</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;p[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(k--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x==p[i]) <span class="hljs-keyword">continue</span>;v[p[i]]+=v[x];s[p[i]].<span class="hljs-built_in">pb</span>(x);dsu.<span class="hljs-built_in">merge</span>(x,p[i]);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;to[i][<span class="hljs-number">0</span>]=dsu.<span class="hljs-built_in">get</span>(a[i]), to[i][<span class="hljs-number">1</span>]=b[i];<span class="hljs-keyword">if</span>(!s[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s[i]) &#123;<span class="hljs-type">int</span> px=dsu.<span class="hljs-built_in">get</span>(a[x]);<span class="hljs-keyword">if</span>(px==i) v[i]-=b[x];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px==to[i][<span class="hljs-number">0</span>]) to[i][<span class="hljs-number">1</span>]+=b[x];&#125;&#125;<span class="hljs-built_in">redirect</span>();<span class="hljs-built_in">rebuild</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<span class="hljs-type">int</span> aa=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> root=<span class="hljs-number">0</span>, pi=dsu2.<span class="hljs-built_in">get</span>(i);<span class="hljs-keyword">if</span>(dsu2.cir[pi].fi!=<span class="hljs-number">0</span>) root=dsu2.cir[pi].fi;<span class="hljs-keyword">else</span> &#123;root=pi;<span class="hljs-built_in">dfs</span>(root,root);ans+=<span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>],f[root][<span class="hljs-number">1</span>]);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">dfs</span>(root,root);aa=f[root][<span class="hljs-number">0</span>];<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs1</span>(root,root);aa=<span class="hljs-built_in">max</span>(aa,f[root][<span class="hljs-number">1</span>]);ans+=aa;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h3 id="luogu6890-ceoi2006-link">luogu6890 [CEOI2006] Link</h3><p>首先执行拓扑排序，将 <span class="math inline">\(1\)</span>和无入度点加入队列，<span class="math inline">\(1\)</span>一定会对它们连边。每求出一个 <span class="math inline">\(f_x &gt;k\)</span> 就将其置为 <spanclass="math inline">\(1\)</span>，再更新别的点。</p><p>把环拎出来，考虑别的点进入环后只能到达环上一个区间，可以用差分维护。这些点肯定不需要连边。对于剩下的点，如果第一个连边的点确定了，那么就直接贪心。</p><p>考虑枚举第一个连边的点，设环长为 <spanclass="math inline">\(m\)</span>，发现只会跳 <spanclass="math inline">\(O(\frac{m}{k})\)</span> 次。由于开头 <spanclass="math inline">\(k\)</span> 个点必然至少有一个连边，所以复杂度就是<span class="math inline">\(O(m)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, k, ans, cnt, to[N], in[N], f[N], c[N];<span class="hljs-type">bool</span> v[N];vector&lt;<span class="hljs-type">int</span>&gt; cir[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(!in[i]||i==<span class="hljs-number">1</span>) &#123;f[i]=i==<span class="hljs-number">1</span>? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>) ++ans;q.<span class="hljs-built_in">push</span>(i);&#125; <span class="hljs-keyword">else</span> f[i]=k+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(f[x]&gt;k) ++ans, f[x]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> y=to[x];<span class="hljs-keyword">if</span>(y&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;f[y]=<span class="hljs-built_in">min</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcir</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;v[i]=<span class="hljs-number">1</span>;cir[++cnt].<span class="hljs-built_in">pb</span>(<span class="hljs-number">114514</span>), cir[cnt].<span class="hljs-built_in">pb</span>(i);<span class="hljs-type">int</span> x=i;<span class="hljs-keyword">while</span>(to[x]!=i) v[to[x]]=<span class="hljs-number">1</span>, cir[cnt].<span class="hljs-built_in">pb</span>(to[x]), x=to[x];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;m=cir[x].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,(m+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(f[cir[x][i]]&gt;k) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> R=i+k-f[cir[x][i]];<span class="hljs-keyword">if</span>(R&lt;=m) ++c[i], --c[R+<span class="hljs-number">1</span>];<span class="hljs-keyword">else</span> ++c[i], --c[m+<span class="hljs-number">1</span>], ++c[<span class="hljs-number">1</span>], --c[R+<span class="hljs-number">1</span>-m];&#125;vector&lt;<span class="hljs-type">int</span>&gt; v; v.<span class="hljs-built_in">pb</span>(<span class="hljs-number">1919810</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;c[i]+=c[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) v.<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-type">int</span> res=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, mm=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mm,k);++i) &#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v[i];j&lt;v[i]+m;++j) &#123;<span class="hljs-type">int</span> jj=j&gt;m? j-m:j;<span class="hljs-keyword">if</span>(c[jj]==<span class="hljs-number">0</span>) ++a, j+=k<span class="hljs-number">-1</span>;&#125;res=<span class="hljs-built_in">min</span>(res,a);&#125;ans+=res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();to[x]=y, ++in[y];&#125;<span class="hljs-built_in">toposort</span>();<span class="hljs-built_in">getcir</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-built_in">solve</span>(i);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>计数</tag>
      
      <tag>博弈论</tag>
      
      <tag>基环树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP Record」#1 树形DP（1）</title>
    <link href="/2023/noip-record-1/"/>
    <url>/2023/noip-record-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>树形 DP 计数。</p><h2 id="luogu8867-建造军营">luogu8867 建造军营</h2><p>对于图中一条非割边，看守与否都相同，因此可以用 Tarjan算法求出边双再缩点，把非树边单独拿出来，讨论每一条树边。</p><p>然而貌似不是很好做，子树外是否建造会影响子树内。考虑设 <spanclass="math inline">\(f_x\)</span> 为军营只在以 <spanclass="math inline">\(x\)</span> 为根的子树中出现，且至少存在 <spanclass="math inline">\(1\)</span> 个军营的方案数。</p><p>转移时对于边 <span class="math inline">\((x,y)\)</span>，如果 <spanclass="math inline">\(y\)</span> 中没有军营，那么子树 <spanclass="math inline">\(y\)</span> 中每条边以及 <spanclass="math inline">\((x,y)\)</span> 看守与否均可，方案数 <spanclass="math inline">\(2^{sz_y}\)</span>；否则 <spanclass="math inline">\((x,y)\)</span> 一定要看守，方案数 <spanclass="math inline">\(f_y\)</span>。</p><p>还要乘上 <span class="math inline">\(x\)</span>所在边双中任意选择的方案数，并且减掉子树中一个都不选的方案。 <spanclass="math display">\[f_x = 2^{c_x} \prod_{y \in son(x)} (f_y+2^{sz_y}) - 2^{sz_x-1}\]</span> 但这样求出的并不是答案。</p><p>直接对一个 <span class="math inline">\(f_x\)</span>求对答案的贡献会产生重复，举个例子，如果 <spanclass="math inline">\(x\)</span> 只有 <spanclass="math inline">\(y\)</span> 这一个儿子，那么 <spanclass="math inline">\(y\)</span> 节点上建造了军营，<spanclass="math inline">\(x\)</span> 没有建造，那么这样的情况就会在 <spanclass="math inline">\(f_x\)</span> 与 <spanclass="math inline">\(f_y\)</span> 中被重复统计到。</p><p>考虑将节点贡献在 <spanclass="math inline">\(\operatorname{LCA}\)</span> 处统计。在节点 <spanclass="math inline">\(x\)</span> 处的贡献，要么是 <spanclass="math inline">\(x\)</span> 节点中建造了，要么是 <spanclass="math inline">\(x\)</span>有至少两个儿子所在子树中建造了。这两种情况都在 <spanclass="math inline">\(f_x\)</span> 中被统计过。</p><p>非法方案是 <span class="math inline">\(x\)</span>没有建造军营，并且只有一个儿子 <span class="math inline">\(y\)</span>所在子树中建造了，容易得到这部分就是 <span class="math display">\[2^{dcc-1-(sz_x-1)}\sum_{y \in son(x)} f_y \times 2^{sz_x-sz_y-1}\]</span> 最后乘上每条非树边可选可不选的方案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, num, cnt, pw[M];<span class="hljs-type">int</span> ans, bel[N], c[N], sz[N], f[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gr</span> &#123;<span class="hljs-type">int</span> tot, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;&#125; G, T;<span class="hljs-type">int</span> dcc, tp, dfn[N], low[N], st[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> lst)</span> </span>&#123;dfn[x]=low[x]=++num;st[++tp]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i];<span class="hljs-keyword">if</span>(i!=(lst^<span class="hljs-number">1</span>)) &#123;<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y,i);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>; ++dcc;<span class="hljs-keyword">do</span> y=st[tp--], ++c[dcc], bel[y]=dcc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>, f[x]=pw[c[x]];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=T.h[x];i;i=T.nxt[i]) &#123;<span class="hljs-type">int</span> y=T.to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);(f[x]*=(f[y]+pw[sz[y]])%mod)%=mod;sz[x]+=sz[y];&#125;(f[x]-=pw[sz[x]<span class="hljs-number">-1</span>]-mod)%=mod;<span class="hljs-type">int</span> F=f[x];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=T.h[x];i;i=T.nxt[i]) &#123;<span class="hljs-type">int</span> y=T.to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;(F-=f[y]*pw[sz[x]-sz[y]<span class="hljs-number">-1</span>]-mod)%=mod;&#125;(ans+=F*pw[dcc-sz[x]]%mod)%=mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">suodian</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=G.h[x];i;i=G.nxt[i]) &#123;<span class="hljs-type">int</span> y=G.to[i];<span class="hljs-keyword">if</span>(bel[x]!=bel[y]) &#123;T.<span class="hljs-built_in">add</span>(bel[x],bel[y]);&#125; <span class="hljs-keyword">else</span> ++cnt;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;G.tot=<span class="hljs-number">1</span>;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();G.<span class="hljs-built_in">add</span>(x,y), G.<span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">suodian</span>();pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">max</span>(n,m);++i) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans*pw[cnt&gt;&gt;<span class="hljs-number">1</span>]%mod);&#125;</code></pre></div><p>自己顺着错误的想法推导的过程中，也得到了很多教训。</p><ul><li>计数的式子，一定再三考虑后再写下</li><li>不要老是想着容斥掉某些东西</li><li>对于边双内部的点、边这类“可以提到外面”的东西，尽量不要放到 DP的过程里面，太容易写错了，而且会让过程复杂化。</li><li>把板子打熟练</li></ul><h2 id="luogu7727-风暴之眼eye-of-the-storm">luogu7727 风暴之眼（Eye ofthe Storm）</h2><p>对于此类有着复杂定义的题目，不妨先静下心来进行一些观察。</p><ul><li><p>首先如果一个节点是初始为 <span class="math inline">\(0\)</span>的 <span class="math inline">\(\text{AND}\)</span> 型节点或者初始值为<span class="math inline">\(1\)</span> 的 <spanclass="math inline">\(\text{OR}\)</span>型节点，那么一定不会改变自身的颜色。称其为黑点，其他成为白点。</p></li><li><p>白点最多变化一次。</p></li><li><p>同一个初始权值白色连通块内，要么权值都变化一次，要么都不变。证明略。</p></li><li><p>那么一个白色连通块何时才不会改变权值呢？只需要考虑它周围的一圈黑点。如果是<span class="math inline">\((0,\text{AND})\)</span> 与 <spanclass="math inline">\((0,\text{OR})\)</span>，<spanclass="math inline">\((1,\text{OR})\)</span> 与 <spanclass="math inline">\((1,\text{AND})\)</span>，那么右边就不会因为左边改变权值，而两个不同类型的白点<span class="math inline">\((1,\text{AND})\)</span> 与 <spanclass="math inline">\((0,\text{OR})\)</span>或者一黑一白是会影响对方的。因此推出一个白色连通块的权值不改变，当且仅当整个连通块以及周围的一圈黑点，权值都相同。</p></li><li><p>如何让一个白色连通块达到权值相同？需要满足以下两个条件之一。1.连通块内存在一个白点，满足初始权值等于最终权值。2.周围存在一个黑点，满足其与这个连通块的最终权值相同。</p></li></ul><p>考虑用树形 DP 来做。</p><p>为了方便采用如下标记</p><ul><li><span class="math inline">\(p(0/1)\)</span>，黑点还是白点。</li><li><spanclass="math inline">\(q(0/1)\)</span>，初始权值是否等于最终权值。</li><li><spanclass="math inline">\(r(0/1)\)</span>，此时这个连通块内能否满足最终权值的条件。</li></ul><p>每一种状态都存在吗？不然。</p><p>首先 <span class="math inline">\(q\)</span> 和 <spanclass="math inline">\(r\)</span> 就存在非法组合。</p><p>对于黑点，能接上它的白色连通块一定都满足最终权值的条件，且其初始权值必然等于最终权值。</p><p>对于白点，如果其初始权值等于最终权值，那么接上一个合法的白色连通块之后，必然满足最终权值条件。</p><p>因此随便钦定一个点为根，然后设 <spanclass="math inline">\(f_{x,0/1/2/3}\)</span> 为在以 <spanclass="math inline">\(x\)</span> 为根的子树中</p><ul><li><span class="math inline">\(p(0),q(0),r(0)\)</span></li><li><span class="math inline">\(p(1),q(0),r(0)\)</span></li><li><span class="math inline">\(p(1),q(1),r(0)\)</span></li><li><span class="math inline">\(p(1),q(1),r(1)\)</span></li></ul><p>然后考虑转移，用上上面的结论。方式是将 <spanclass="math inline">\(x\)</span> 的子节点 <spanclass="math inline">\(y\)</span> 看作是一个连通块，按照把 <spanclass="math inline">\(y\)</span> 接到 <spanclass="math inline">\(x\)</span> 上形成新的连通块来计数，同时根据 <spanclass="math inline">\(a_x\)</span> 与 <spanclass="math inline">\(a_y\)</span> 得到对应的转移方案。</p><p>开个临时数组 <span class="math inline">\(g\)</span>。</p><p>对于 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y \in son(x)\)</span>，如果 <spanclass="math inline">\(a_x = a_y\)</span> <span class="math display">\[g_0 = f_{x,0} \cdot (f_{y,0} + f_{y,1})\]</span> <span class="math display">\[g_1 = f_{x,1} \cdot (f_{y,0} + f_{y,1} + f_{y,2} + f_{y,3})\]</span></p><p><span class="math display">\[g_2 = f_{x,2} \cdot (f_{y,1}+f_{y,2}+f_{y,3}) + f_{x,3} \cdot(f_{y,1}+f_{y,2})\]</span></p><p><span class="math display">\[g_3 = f_{x,3} \cdot f_{y,3}\]</span></p><p>若 <span class="math inline">\(a_x \neq a_y\)</span> <spanclass="math display">\[g_0 = 0\]</span> <span class="math display">\[g_1 = f_{x,1} \cdot (f_{y,1} + f_{y,2})\]</span></p><p><span class="math display">\[g_2 = f_{x,2} \cdot (f_{y,1}+f_{y,2} + f_{y,3}) + f_{x,3} \cdot (f_{y,2}+ f_{y,3})\]</span></p><p><span class="math display">\[g_3 = f_{x,3} \cdot f_{y,1}\]</span></p><p>然后 <span class="math display">\[f_x \leftarrow g\]</span> 答案是 <spanclass="math inline">\(f_{1,0}+f_{1,1}+f_{1,2}\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, a[N], f[N][<span class="hljs-number">4</span>], g[<span class="hljs-number">4</span>];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(a[x]==a[y]) &#123;g[<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">0</span>]*(f[y][<span class="hljs-number">0</span>]+f[y][<span class="hljs-number">1</span>])%mod;g[<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]*((f[y][<span class="hljs-number">0</span>]+f[y][<span class="hljs-number">1</span>])%mod+(f[y][<span class="hljs-number">2</span>]+f[y][<span class="hljs-number">3</span>])%mod)%mod;g[<span class="hljs-number">2</span>]=(f[x][<span class="hljs-number">2</span>]*(f[y][<span class="hljs-number">1</span>]+f[y][<span class="hljs-number">2</span>]+f[y][<span class="hljs-number">3</span>])%mod+f[x][<span class="hljs-number">3</span>]*(f[y][<span class="hljs-number">1</span>]+f[y][<span class="hljs-number">2</span>])%mod)%mod;g[<span class="hljs-number">3</span>]=f[x][<span class="hljs-number">3</span>]*f[y][<span class="hljs-number">3</span>]%mod;&#125; <span class="hljs-keyword">else</span> &#123;g[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;g[<span class="hljs-number">1</span>]=f[x][<span class="hljs-number">1</span>]*(f[y][<span class="hljs-number">1</span>]+f[y][<span class="hljs-number">2</span>])%mod;g[<span class="hljs-number">2</span>]=(f[x][<span class="hljs-number">2</span>]*(f[y][<span class="hljs-number">1</span>]+f[y][<span class="hljs-number">2</span>]+f[y][<span class="hljs-number">3</span>])%mod+f[x][<span class="hljs-number">3</span>]*(f[y][<span class="hljs-number">2</span>]+f[y][<span class="hljs-number">3</span>])%mod)%mod;g[<span class="hljs-number">3</span>]=f[x][<span class="hljs-number">3</span>]*f[y][<span class="hljs-number">1</span>]%mod;&#125;<span class="hljs-built_in">memcpy</span>(f[x],g,<span class="hljs-built_in">sizeof</span>(g));&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+f[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])%mod);&#125;</code></pre></div><ul><li>状态间的转移应仔细推敲。</li><li>见到这种看起来很吓人的题目，千万不要手足无措白白浪费时间，尝试观察性质，哪怕打个暴力呢。</li></ul><h2 id="luogu8973-groi-r1-继续深潜为了同一个梦想">luogu8973 『GROI-R1』继续深潜，为了同一个梦想</h2><p>一个点被这样的点集所包含，只有两种情况。</p><p>要么是从子树内到某个祖先的一条链，要么是端点在两个子节点的子树内，跨越这个点的一条链。</p><p>考虑一个转化，求 <span class="math inline">\(ans_i\)</span> 时，将<span class="math inline">\(i\)</span>钦定为根。那么前者转化为子树内到达 <spanclass="math inline">\(i\)</span> 的链。</p><p>设 <span class="math inline">\(f_r(x)\)</span> 为整棵树以 <spanclass="math inline">\(r\)</span> 为根，在以 <spanclass="math inline">\(x\)</span> 为根的子树内，有多少以 <spanclass="math inline">\(x\)</span>为端点且满足条件的的链，其实就是在子树内除了 <spanclass="math inline">\(x\)</span> 选择至少一个节点的方案数。 <spanclass="math display">\[f_{r}(x) = \sum_{y \in son(x)} (2f_r(y) +1)\]</span> 然后考虑第二种情况，其实就是两条上述的链拼凑而成，</p><p>设 <span class="math inline">\(S = f_r(x)\)</span>，<spanclass="math inline">\(F(x) = 2f_r(x)+1\)</span>。</p><p>对于一个子节点 <span class="math inline">\(y\)</span>，其贡献为 <spanclass="math inline">\(F(y) \cdot (S-F(y)+1)\)</span>，<spanclass="math inline">\(+1\)</span>是顺便把第一种情况算上。同时为了避免重复计数，计算完 <spanclass="math inline">\(y\)</span> 之后令 <span class="math inline">\(S\leftarrow S-F(y)\)</span>。</p><p>综上，得到以 <span class="math inline">\(r\)</span>为整棵树的根时，以 <span class="math inline">\(x\)</span>为根的子树内的答案 <span class="math inline">\(g_r(x)\)</span>。</p><p>那么如何得到所有结点的答案呢？考虑换根。</p><p>发现对于 <span class="math inline">\((x,y)\)</span>，有 <spanclass="math display">\[f_y(x) = f_x(x) - F(y)\]</span> <span class="math display">\[f_y(y) = f_x(y) + F(x)\]</span></p><p>直接求即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, f[N], g[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>*f[x]%mod+<span class="hljs-number">1</span>)%mod; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);(f[x]+=<span class="hljs-number">2</span>*f[y]+<span class="hljs-number">1</span>)%=mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];(S+=<span class="hljs-built_in">F</span>(y))%=mod;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];(g[x]+=<span class="hljs-built_in">F</span>(y)*(S-<span class="hljs-built_in">F</span>(y)+<span class="hljs-number">1</span>+mod)%mod)%=mod;(S-=<span class="hljs-built_in">F</span>(y)-mod)%=mod;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> tx=f[x], ty=f[y];(f[x]-=<span class="hljs-number">2</span>*f[y]%mod+<span class="hljs-number">1</span>-mod)%=mod;(f[y]+=<span class="hljs-number">2</span>*f[x]%mod+<span class="hljs-number">1</span>)%=mod;<span class="hljs-built_in">dfs2</span>(y,x);f[x]=tx, f[y]=ty;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans^=g[i]*i;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="luogu8280-mcoi-08photoelectric-effect">luogu8280「MCOI-08」Photoelectric Effect</h2><p>思路并不难想。考虑以 <span class="math inline">\(x\)</span>为根的子树和其若干子节点 <spanclass="math inline">\(\{y_i\}\)</span>。</p><p>设 <span class="math inline">\(x\)</span> 颜色为 <spanclass="math inline">\(c_x\)</span>，对于 <spanclass="math inline">\(y_1\)</span> 和 <spanclass="math inline">\(y_2\)</span>，以 <spanclass="math inline">\(y_1\)</span> 为根的子树中任何一个节点与 <spanclass="math inline">\(y_2\)</span> 子树中的任意一个节点颜色之并等于<spanclass="math inline">\(c_x\)</span>。那么两棵子树的颜色集合两两之并都是<spanclass="math inline">\(c_x\)</span>，这个可以预处理，同时也能看出子树颜色集合必须加入状态中。</p><p>从样例中能看到这个并运算不满足交换律，因此预处理时要注意如果集合<span class="math inline">\(S_1\)</span> 与 <spanclass="math inline">\(S_2\)</span> 正反两种并不同，那么不合法。</p><p>考虑到颜色关系的特殊性，需要一棵一棵地加入子树来统计答案。特别的，第一棵子树不存在颜色限制。</p><p>为了避免包含等不必要的麻烦，设 <spanclass="math inline">\(S_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，不含 <spanclass="math inline">\(x\)</span> 的颜色集合。同时设 <spanclass="math inline">\(S_1 \otimes S_2\)</span> 表示 <spanclass="math inline">\(S_1\)</span> 中任意元素并上 <spanclass="math inline">\(S_2\)</span> 中任意元素结果为同一种颜色，且满足<span class="math inline">\(S_1 \otimes S_2 = S_1 \otimesS_1\)</span>。</p><p>设 <span class="math inline">\(f_{x,i,S}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，<spanclass="math inline">\(x\)</span> 的颜色是 <spanclass="math inline">\(i\)</span>，其他子树内的颜色集合是 <spanclass="math inline">\(S\)</span> 的方案数。</p><p>考虑 <span class="math inline">\(f_{y,j,S_0}\)</span> 如何转移。</p><p>条件是 <span class="math inline">\(T=S_0 \cup \{j\}\)</span>，存在<span class="math inline">\(S\)</span> 满足 <spanclass="math inline">\(S \otimes T = i\)</span>，贡献为 <spanclass="math display">\[f_{y,j,S_0} \cdot f_{x,i,S} \rightarrow f&#39;_{x,i,S|T}\]</span></p><p>特别地，对于 <span class="math inline">\(x\)</span> 的第一棵子树<span class="math display">\[f_{y,j,S_0} \rightarrow f_{x,i,S_0 \cup \{j\}}\]</span> 复杂度 <span class="math inline">\(O(nk2^{2k})\)</span></p><p>相当恐怖，不过剪掉无用状态后就跑不满，可过。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> T, n, k, U, son[N], t[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>], p[<span class="hljs-number">32</span>][<span class="hljs-number">32</span>], f[N][<span class="hljs-number">5</span>][<span class="hljs-number">32</span>], g[<span class="hljs-number">5</span>][<span class="hljs-number">32</span>];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">-2</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(x&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(y&amp;(<span class="hljs-number">1</span>&lt;&lt;j)) &#123;<span class="hljs-keyword">if</span>(res==<span class="hljs-number">-2</span>) res=t[i][j];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res!=t[i][j]) res=<span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(x&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-keyword">if</span>(y&amp;(<span class="hljs-number">1</span>&lt;&lt;j)) &#123;<span class="hljs-keyword">if</span>(res==<span class="hljs-number">-2</span>) res=t[i][j];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res!=t[i][j]) res=<span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">if</span>(!son[x]) &#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) f[x][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-keyword">if</span>(!fg) &#123;<span class="hljs-built_in">rep</span>(nw,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(S,<span class="hljs-number">0</span>,U) <span class="hljs-built_in">rep</span>(w,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) &#123;(f[x][nw][S|(<span class="hljs-number">1</span>&lt;&lt;w)]+=f[y][w][S])%=mod;&#125;fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">rep</span>(nw,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(S,<span class="hljs-number">1</span>,U) g[nw][S]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(nw,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(S0,<span class="hljs-number">0</span>,U) <span class="hljs-keyword">if</span>(f[y][nw][S0]) <span class="hljs-built_in">rep</span>(S,<span class="hljs-number">1</span>,U) &#123;<span class="hljs-type">int</span> T=S0|(<span class="hljs-number">1</span>&lt;&lt;nw);<span class="hljs-keyword">if</span>(p[S][T]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;(g[p[S][T]][S|T]+=f[x][p[S][T]][S]*f[y][nw][S0]%mod)%=mod;&#125;<span class="hljs-built_in">memcpy</span>(f[x],g,<span class="hljs-built_in">sizeof</span>(g));&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>;tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;h[i]=son[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">SET</span>(f[i],<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">SET</span>(p,<span class="hljs-number">-1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;t[i][j]=x;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();++son[x];<span class="hljs-built_in">add</span>(x,i), <span class="hljs-built_in">add</span>(i,x);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,U) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,U) p[i][j]=<span class="hljs-built_in">get</span>(i,j);<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,U) (ans+=f[<span class="hljs-number">1</span>][i][j])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><ul><li>状态压缩，优先使用刷表法</li><li><strong>考虑再三后再预处理</strong></li><li><strong>预处理时一定不要把初始状态设成无解状态</strong></li><li>加入子树的计数思路</li><li>一开始竟然设 <span class="math inline">\(S_x\)</span> 为以 <spanclass="math inline">\(x\)</span>为根的子树的所有颜色，导致很多麻烦且干扰思路与转移。</li></ul><p>最后附上我一开始写的 SB 预处理。</p><p>之前也在预处理上吃过亏啊，以后要多加小心。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,U) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,U) <span class="hljs-keyword">if</span>(p[i][j]&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> kk=<span class="hljs-number">-1</span>;        <span class="hljs-comment">// 从头开始就错了</span><span class="hljs-built_in">rep</span>(k1,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;k1)) &#123;<span class="hljs-type">int</span> q=<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(k2,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-keyword">if</span>(j&amp;(<span class="hljs-number">1</span>&lt;&lt;k2)) &#123;<span class="hljs-keyword">if</span>(q==<span class="hljs-number">-1</span>) q=p[k1][k2];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q!=p[k1][k2]) &#123; kk=<span class="hljs-number">-1</span>; <span class="hljs-keyword">goto</span> pq; &#125;&#125;<span class="hljs-keyword">if</span>(kk==<span class="hljs-number">-1</span>) kk=q;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(kk!=q) &#123; kk=<span class="hljs-number">-1</span>; <span class="hljs-keyword">break</span>; &#125;&#125;pq: p[i][j]=kk;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,U) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,U) <span class="hljs-keyword">if</span>(p[i][j]!=p[j][i]) p[i][j]=p[j][i]=<span class="hljs-number">-1</span>;&#125;</code></pre></div><h2 id="luogu3349-zjoi2016小星星">luogu3349 [ZJOI2016]小星星</h2><p>题意比较裸。</p><p>设 <span class="math inline">\(f_{x,i,G_0}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，节点 <spanclass="math inline">\(x\)</span> 映射到原图中的 <spanclass="math inline">\(i\)</span>，此时子树内映射到图中的节点集合为 <spanclass="math inline">\(G_0\)</span> 的方案数。</p><p>转移则遇到了困难，首先复杂度就很高了，其次 <spanclass="math inline">\(G_0\)</span> 这一维的转移要把 <spanclass="math inline">\(G_0\)</span> 不重不漏地划分成 <spanclass="math inline">\(x\)</span>的子节点个数个非空子集，也就是一个子集卷积。</p><p>考虑困难的来源是「每个节点只能映射一次」这个限制导致了必须记录 <spanclass="math inline">\(G_0\)</span>。不难发现只要有节点映射了超过一次，那么一定有节点没有被映射，这个是可以容斥的。</p><p>考虑枚举集合 <span class="math inline">\(S&#39; \subseteqS\)</span>，其中 <span class="math inline">\(S\)</span>是节点集合，表示不能映射 <span class="math inline">\(S&#39;\)</span>中的节点，进行最原始的集合间的容斥即可。</p><p>考虑此时如何求方案数。设 <span class="math inline">\(f_{x,i}\)</span>表示以 <span class="math inline">\(x\)</span> 为根的子树，节点 <spanclass="math inline">\(x\)</span> 映射到了图中节点 <spanclass="math inline">\(i\)</span> 的方案数，容易写出 <spanclass="math display">\[f_{x,i} = \prod_{y \in son(x)} \sum_{(i,j) \in G} f_{y,j}\]</span> <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>;<span class="hljs-type">int</span> n, m, U, S, popcnt[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>];<span class="hljs-type">int</span> lg[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>];<span class="hljs-type">int</span> tot, h[N], to[N*N], nxt[N*N];<span class="hljs-type">int</span> t2, h2[N], to2[N*N], nxt2[N*N];uint ans, f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;-x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to2[++t2]=y, nxt2[t2]=h2[x], h2[x]=t2;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h2[x];i;i=nxt2[i]) &#123;<span class="hljs-type">int</span> y=to2[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> T=S^U;T;T-=<span class="hljs-built_in">lowbit</span>(T)) &#123;<span class="hljs-type">int</span> a=lg[<span class="hljs-built_in">lowbit</span>(T)];f[x][a]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h2[x];i;i=nxt2[i]) &#123;<span class="hljs-type">int</span> y=to2[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=h[a];j;j=nxt[j]) dlt+=f[y][to[j]];f[x][a]*=dlt;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;lg[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add2</span>(x,y), <span class="hljs-built_in">add2</span>(y,x);lg[<span class="hljs-number">1</span>&lt;&lt;i]=i+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(S=<span class="hljs-number">0</span>;S&lt;=U;++S) &#123;popcnt[S]=popcnt[S&gt;&gt;<span class="hljs-number">1</span>]+(S&amp;<span class="hljs-number">1</span>);<span class="hljs-type">int</span> ss=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) f[i][j]=<span class="hljs-number">0</span>; <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=S^U;i;i-=<span class="hljs-built_in">lowbit</span>(i)) ss+=f[<span class="hljs-number">1</span>][lg[<span class="hljs-built_in">lowbit</span>(i)]];<span class="hljs-keyword">if</span>(popcnt[S]&amp;<span class="hljs-number">1</span>) ans-=ss; <span class="hljs-keyword">else</span> ans+=ss;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,ans);&#125;</code></pre></div></p><p> </p><p>树形背包。</p><p>用来解决树形 DP中，子树之间会互相影响的转移。具体方法是先依次合并各子树信息，再处理根的影响。</p><p>为什么是「类」树形背包？因为此类题目一般没有给出作为背包容积的上界，因此必须用当前子树大小卡好复杂度，否则会退化。</p><p>因此，在实现上是需要注意的。</p><h2 id="abc287f-components">ABC287F Components</h2><blockquote><p>给定一棵树 <span class="math inline">\(T=(V,E)\)</span>，求对于 <spanclass="math inline">\(x=1,2,\ldots,n\)</span>，所有 <spanclass="math inline">\(V\)</span> 的子集与 <spanclass="math inline">\(E\)</span> 构成的图中，恰好有 <spanclass="math inline">\(x\)</span> 个连通块的方案数。对 <spanclass="math inline">\(998244353\)</span> 取模。</p><p><span class="math inline">\(n \le 5000\)</span></p></blockquote><p>考虑在各子树的父节点处统计贡献。</p><p>设 <span class="math inline">\(f_{x,i,0/1}\)</span> 表示以 <spanclass="math inline">\(x\)</span>为根的子树，每个节点可选可不选，恰好存在 <spanclass="math inline">\(i\)</span> 个连通块，其中 <spanclass="math inline">\(x\)</span> 有没有被选择的方案数。</p><p>用类似树形背包的方式转移，好处是可以容易考虑一棵子树对其它子树的影响。</p><p>如果 <span class="math inline">\(x\)</span> 不选择，那么对于子节点<span class="math inline">\(y\)</span>，其选不选都不收影响，因此 <spanclass="math display">\[f_{x,j,0} \cdot (f_{y,k,0}+f_{y,k,1}) \rightarrow g_{j+k,0}\]</span> 如果 <span class="math inline">\(x\)</span> 选择，那么如果<span class="math inline">\(y\)</span> 选择了，就会减少一个连通块 <spanclass="math display">\[f_{x,j,1} \cdot (f_{y,k,0}+f_{y,k+1,1}) \rightarrow g_{j+k,1}\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, sz[N], f[N][N][<span class="hljs-number">2</span>], g[N][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;sz[x]=f[x][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j)  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=sz[y];++k) &#123;(g[j+k][<span class="hljs-number">0</span>]+=f[x][j][<span class="hljs-number">0</span>]*((f[y][k][<span class="hljs-number">0</span>]+f[y][k][<span class="hljs-number">1</span>])%mod)%mod)%=mod;(g[j+k][<span class="hljs-number">1</span>]+=f[x][j][<span class="hljs-number">1</span>]*((f[y][k][<span class="hljs-number">0</span>]+f[y][k+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])%mod)%mod)%=mod;&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,sz[x]+sz[y]) f[x][j][<span class="hljs-number">0</span>]=g[j][<span class="hljs-number">0</span>], f[x][j][<span class="hljs-number">1</span>]=g[j][<span class="hljs-number">1</span>];sz[x]+=sz[y]; &#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]+f[<span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>])%mod);&#125;</code></pre></div><h2 id="luogu8564-ρarsey">luogu8564 ρars/ey</h2><p>容易设出状态，<span class="math inline">\(f_{x,i}\)</span> 表示以<span class="math inline">\(x\)</span> 为根的子树，还剩下 <spanclass="math inline">\(i\)</span> 个节点，所需要的最小代价。</p><p>把转移过程分为两部分，一部分从子树处继承没有被删去的节点数量，另一部分从<span class="math inline">\(x\)</span> 处删点。</p><p>设当前加入了 <span class="math inline">\(cnt\)</span>棵子树，那么在合并子树的过程中，最少剩下 <spanclass="math inline">\(cnt+1\)</span>个节点，这个下界会不断改变，因此要不断更新相应的信息。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-type">int</span> n, a[N], sz[N], f[N][N], g[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>, f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=cnt+<span class="hljs-number">1</span>;j&lt;=sz[x];++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k)g[j+k]=<span class="hljs-built_in">min</span>(g[j+k],f[x][j]+f[y][k]);++cnt, sz[x]+=sz[y];        f[x][cnt]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=cnt+<span class="hljs-number">1</span>;j&lt;=sz[x];++j) f[x][j]=g[j], g[j]=inf;&#125;f[x][<span class="hljs-number">1</span>]=a[sz[x]];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=cnt+<span class="hljs-number">1</span>;k&lt;=sz[x];++k) f[x][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[x][<span class="hljs-number">1</span>],f[x][k]+a[k]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">SET</span>(g,<span class="hljs-number">0x3f</span>);    <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);&#125;</code></pre></div><h2 id="luogu6478-noi-online-2-提高组-游戏">luogu6478 [NOI Online #2提高组] 游戏</h2><p>如果出现了平局，那么一定是两个点在以它们的 <spanclass="math inline">\(lca\)</span> 为根的，不同的子树中。</p><p>在树形 DP 中合并信息是容易的。</p><p>设 <span class="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，有 <spanclass="math inline">\(i\)</span> 个回合没有平的方案数。</p><p>合并完子树的过程中，统计出子树内每种颜色的点的数量，然后只要选择和<span class="math inline">\(x\)</span> 颜色相反的就能让非平局回合数量加<span class="math inline">\(1\)</span>。</p><p>但是这样得到的是整棵树中，至少有 <spanclass="math inline">\(i\)</span>个非平局回合的方案数。所以套一个二项式反演即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, a[N], sz[N], c[N][<span class="hljs-number">2</span>], F[N], G[N], f[N][N], g[N], fac[N], inv[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;++c[x][a[x]], f[x][<span class="hljs-number">0</span>]=sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x]+sz[y];++j) g[j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=sz[y];++k) (g[j+k]+=f[x][j]*f[y][k]%mod)%=mod;sz[x]+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sz[x];++j) f[x][j]=g[j];c[x][<span class="hljs-number">0</span>]+=c[y][<span class="hljs-number">0</span>], c[x][<span class="hljs-number">1</span>]+=c[y][<span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c[x][a[x]^<span class="hljs-number">1</span>];~i;--i) (f[x][i]+=f[x][i<span class="hljs-number">-1</span>]*(c[x][a[x]^<span class="hljs-number">1</span>]-(i<span class="hljs-number">-1</span>))%mod)%=mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[m]=<span class="hljs-built_in">fp</span>(fac[m],mod<span class="hljs-number">-2</span>);<span class="hljs-built_in">per</span>(i,m<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();m=n&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">init</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) G[i]=f[<span class="hljs-number">1</span>][i]*fac[m-i]%mod;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) <span class="hljs-built_in">rep</span>(j,i,m) &#123;<span class="hljs-type">int</span> c=((j-i)&amp;<span class="hljs-number">1</span>)? <span class="hljs-number">-1</span>:<span class="hljs-number">1</span>;(F[i]+=c*<span class="hljs-built_in">C</span>(j,i)%mod*G[j]%mod)%=mod;<span class="hljs-keyword">if</span>(F[i]&lt;<span class="hljs-number">0</span>) F[i]+=mod;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,F[i]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>计数</tag>
      
      <tag>容斥原理</tag>
      
      <tag>状态压缩</tag>
      
      <tag>二项式反演</tag>
      
      <tag>边双连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「博弈论学习笔记」#1 组合游戏基础</title>
    <link href="/2023/notes-gt-1/"/>
    <url>/2023/notes-gt-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>OI 中的博弈论主要研究公平组合游戏（ICG）。</p><p>此外还有非公平组合游戏，比如大部分的棋类；反常游戏，ICG中的胜者改为败者。</p><h2 id="公平组合游戏">公平组合游戏</h2><h3 id="定义">定义</h3><p>如果一个游戏满足以下条件，就称其为一个公平组合游戏</p><ol type="1"><li>由两名玩家交替行动。</li><li>在游戏的任意时刻，能执行的合法操作与当前是那一名玩家无关。</li><li>先无法行动者告负。</li></ol><p>同时公平组合游戏一定只有先手必胜和先手必败两种情况。</p><h2 id="bash-game">Bash Game</h2><p>Bash 游戏形式如下</p><blockquote><p>有 <span class="math inline">\(n\)</span>个石子，两人博弈，每人每次可以拿 <span class="math inline">\(1 \simm\)</span> 个石子，无法拿石子的人告负。给定 <spanclass="math inline">\(n\)</span>，<spanclass="math inline">\(m\)</span>，求先手是否必胜。</p></blockquote><ul><li>若 <span class="math inline">\(n \lem\)</span>，那么先手直接全部拿走即可，必胜。</li><li>若 <span class="math inline">\(n =m+1\)</span>，那么先手不能一次都拿走且后手一定能全部拿走，先手必败。</li></ul><p>将上述情况进行扩展，如果 <span class="math inline">\(m+1 \midn\)</span>，那么若先手拿走 <span class="math inline">\(k\)</span>个，后手只要拿走 <span class="math inline">\(m+1-k\)</span>个，那么仍然满足 <span class="math inline">\(m+1 \mid n\)</span>。由于当<span class="math inline">\(n=0\)</span> 时 <spanclass="math inline">\(m+1 \midn\)</span>，所以如此循环往复下去先手一定会面临 <spanclass="math inline">\(n=0\)</span> 的局面，所以先手必败。</p><p>否则先手只要取 <span class="math inline">\(k\)</span> 个使得 <spanclass="math inline">\(m+1 \midn-k\)</span>，就能回到上述状态，只不过上面的「先手」是现在的后手，其必败，所以这种情况先手必胜。</p><h3 id="luogu4018">luogu4018</h3><p>题面</p><blockquote><p>将上题取 <span class="math inline">\(1 \sim m\)</span>个改为取任意能表示为 <span class="math inline">\(p^k\)</span>的数个，其中 <span class="math inline">\(p\)</span> 是质数且 <spanclass="math inline">\(k \in \mathbb{N^+}\)</span>，同时 <spanclass="math inline">\(p^k\)</span> 小于等于当前剩余石子数。</p></blockquote><p>考虑 <span class="math inline">\(n \in [1,5]\)</span>时，先手都可以一次取完。</p><p>而当 <span class="math inline">\(n=6\)</span> 时则不能。</p><p>由唯一分解定理容易发现任何 <span class="math inline">\(6\)</span>的倍数都不能写成 <span class="math inline">\(p^k\)</span> 的形式。</p><p>所以仿照上述操作，如果 <span class="math inline">\(6 \midn\)</span>，那么先手一定无法取 <span class="math inline">\(6\)</span>的倍数个，而后手一定能使得两次取走 <spanclass="math inline">\(6\)</span> 的倍数个，所以此时先手必败。</p><p>否则先手将 <span class="math inline">\(n\)</span> 取成 <spanclass="math inline">\(6\)</span> 的倍数个即可，必胜。</p><h2 id="nim-game">Nim Game</h2><blockquote><p><span class="math inline">\(n\)</span> 堆石头，第 <spanclass="math inline">\(i\)</span> 堆有 <spanclass="math inline">\(a_i\)</span>个石子。两名玩家博弈，每次可以选择一堆并取走其中任意非 <spanclass="math inline">\(0\)</span>个石子，无法取石子者告负。判断先手必胜还是必败。</p></blockquote><p>定理：</p><blockquote><p>Nim游戏先手必胜，当且仅当 <spanclass="math inline">\(\bigoplus_{i=1}^n a_i \neq 0\)</span>，也就是 nim和为 <span class="math inline">\(0\)</span>。</p></blockquote><p>证明：</p><blockquote><p>所有石子被取走的局面是失败局面，此时 nim 和为 <spanclass="math inline">\(0\)</span>。考虑一个 nim 和 <spanclass="math inline">\(x\)</span> 不为 <spanclass="math inline">\(0\)</span> 的情况，那么设 <spanclass="math inline">\(x\)</span> 最高为的 <spanclass="math inline">\(1\)</span> 在第 <spanclass="math inline">\(k\)</span> 位，一定存在至少一个 <spanclass="math inline">\(a_i\)</span> 满足第 <spanclass="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>。设它为 <spanclass="math inline">\(a_j\)</span>，那么有 <spanclass="math inline">\(a_j \oplus x &lt; a_j\)</span>，而 <spanclass="math inline">\(a_j \oplus x\)</span> 与 <spanclass="math inline">\(x \oplus a_j\)</span> 做异或运算为 <spanclass="math inline">\(0\)</span>，其中后者表示 nim 和除掉 <spanclass="math inline">\(a_j\)</span>。因此只要让 <spanclass="math inline">\(a_j\)</span> 变成 <span class="math inline">\(a_j\oplus x\)</span> 就能使得 nim 和为 <spanclass="math inline">\(0\)</span>，而后者小于前者，因此可以通过一次操作使得nim 和为 <span class="math inline">\(0\)</span>。</p><p>如此重复，一定能使得后手只会面临 nim 和为 <spanclass="math inline">\(0\)</span> 的局面，最终到无法取走石子。</p></blockquote><h3 id="hdu1850">hdu1850</h3><blockquote><p>Nim 游戏，先手第一次操作有多少种必胜方法。</p></blockquote><p>仿照证明过程，如果 nim 和不为 <spanclass="math inline">\(0\)</span>，那么任意选择一个 <spanclass="math inline">\(a_i \oplus x &lt; a_i\)</span> 的就行</p><h2 id="有向图游戏与-sg-函数">有向图游戏与 SG 函数</h2><h3 id="有向图游戏">有向图游戏</h3><p>给定一个 DAG，形式化地写作 <spanclass="math inline">\(G(X,F)\)</span>，其中点集 <spanclass="math inline">\(X\)</span> 为局面集合，<spanclass="math inline">\(F\)</span> 是 <spanclass="math inline">\(X\)</span> 上的函数，对于节点 <spanclass="math inline">\(x \in X\)</span>，<spanclass="math inline">\(F(x)\)</span>表示从其出发能够一步移动到的位置集合，表示了一个形式上的边集。如果 <spanclass="math inline">\(F(x) = \varnothing\)</span>，那么称 <spanclass="math inline">\(x\)</span> 为终点，如果 <spanclass="math inline">\(y\)</span> 不属于任何一个 <spanclass="math inline">\(F(x)\)</span>，那么称其为起点。</p><p>两人轮流移动初始在起点的一枚棋子，若其在 <spanclass="math inline">\(x_0\)</span>，那么可以移动到 <spanclass="math inline">\(F(x_0)\)</span> 内的任意节点。无法移动者告负。</p><p>任何一个 ICG 都能转化成有向图游戏，具体方法是将每个局面都带入点集<span class="math inline">\(X\)</span>，从局面 <spanclass="math inline">\(x\)</span> 能到达的局面集合构成 <spanclass="math inline">\(F(x)\)</span>。由 ICG的定义可知其不可能存在环，若存在环则游戏一定存在平局。</p><p>上文有一些很奇妙的内容。</p><p>我们能通过考虑小范围的胜负情况来让大范围的状态归约到它们上；失败局面可以倒推出先手必败局面；本来是先手必败的状态，经过一次操作之后就变成先手必胜了。</p><p>把这一切放到图上就容易理解了。由于 ICG只有先手必胜局面和先手必败局面，所以每个节点（状态）都是必胜或必败状态之一。而且状态可以转化，对于<span class="math inline">\(x\)</span>，<spanclass="math inline">\(F(x)\)</span>都是他的「子游戏」，二者之间相差一次操作。所以对于一条从终点倒推向起点的链，其节点状态必然是必败，必胜，必败，必胜。在一张图上，一个节点连到的点，他们到终点的长度不一样，自然有必胜也有必败。</p><p>比较简单的情况就是如果 <span class="math inline">\(F(x)\)</span>都是必败局面，那么无论怎么操作 <spanclass="math inline">\(x\)</span>，对方都一定面临必败局面，所以是必胜；反过来也一样。</p><p>但考虑到二者绝顶聪明，只要 <span class="math inline">\(F(x)\)</span>中又一个必败局面，当前玩家一定会这样操作。而如果 <spanclass="math inline">\(F(x)\)</span>中存在一个必胜局面，玩家绝对不会这样做。所以只有 <spanclass="math inline">\(F(x)\)</span> 全都是必胜局面，<spanclass="math inline">\(x\)</span> 才是必败局面。</p><p>此时引入概念<strong>后继状态</strong>。对于 <spanclass="math inline">\(x\)</span>，其后继状态为 <spanclass="math inline">\(F(x)\)</span>，在图上也可称后继节点。</p><h3 id="sg-函数">SG 函数</h3><p>定义 <span class="math display">\[SG(x)= \operatorname{mex} \big\{ SG(y) | y \in F(x) \big\}\]</span> 也就是 <span class="math inline">\(x\)</span> 所有后继状态的<span class="math inline">\(SG\)</span>函数值中没有出现过的最小非负整数。</p><p>整个游戏的 <span class="math inline">\(SG\)</span> 函数值为起点的<span class="math inline">\(SG\)</span> 函数值。</p><p>特殊规定终点的 <span class="math inline">\(SG\)</span> 函数值为 <spanclass="math inline">\(0\)</span>，同时要保证必败局面的 <spanclass="math inline">\(SG\)</span> 函数值都为 <spanclass="math inline">\(0\)</span>。</p><p>如果存在一个 <span class="math inline">\(SG(x) &gt; 0\)</span>，那么<span class="math inline">\(x\)</span> 的后继状态中一定存在 <spanclass="math inline">\(SG\)</span> 函数值为 <spanclass="math inline">\(0\)</span> 的状态，也就是存在必败局面，此时 <spanclass="math inline">\(x\)</span> 为必胜局面。否则 <spanclass="math inline">\(SG(x)=0\)</span>，那么 <spanclass="math inline">\(x\)</span> 的后继状态中一定不存在 <spanclass="math inline">\(SG\)</span> 函数值为 <spanclass="math inline">\(0\)</span> 的状态，也就是全部为必胜局面，此时<span class="math inline">\(x\)</span> 必败。</p><p>得到</p><ul><li>有向图游戏的某个局面 <span class="math inline">\(x\)</span>必胜，当且仅当 <span class="math inline">\(SG(x)&gt; 0\)</span>。</li><li>有向图游戏的某个局面 <span class="math inline">\(x\)</span>必败，当且仅当 <span class="math inline">\(SG(x) = 0\)</span>。</li></ul><h3 id="sg-定理">SG 定理</h3><p>设 <span class="math inline">\(G_1,G_2,\cdots G_m\)</span> 为 <spanclass="math inline">\(m\)</span> 个有向图游戏，存在一个有向图游戏 <spanclass="math inline">\(G\)</span>，其规则是选择其中一个有向图游戏 <spanclass="math inline">\(G_i\)</span>，在其之上操作一次，无法操作者告负。<spanclass="math inline">\(G\)</span> 也成为 <spanclass="math inline">\(\{G_i\}\)</span> 的和。</p><p>那么 <span class="math display">\[SG(G) = \bigoplus_{i=1}^m SG(G_i)\]</span> <span class="math inline">\(G\)</span> 先手必胜，当且仅当<span class="math inline">\(SG(G) &gt; 0\)</span>。</p><p>证明。</p><blockquote><p>类似与 Nim 游戏的做法，考虑 <span class="math inline">\(x =SG(G)\)</span>，那么仍然找到 <spanclass="math inline">\(SG(G_j)\)</span> 第 <spanclass="math inline">\(k\)</span> 为和 <spanclass="math inline">\(x\)</span> 第 <spanclass="math inline">\(k\)</span> 位都为 <spanclass="math inline">\(1\)</span>。此时 <spanclass="math inline">\(SG(G_j) \oplus x &lt; SG(G_j)\)</span>。考虑 <spanclass="math inline">\(\operatorname{mex}\)</span> 运算的本质，就能发现<span class="math inline">\(\big[0,SG(G_j)\big)\)</span> 都能在操作一次<span class="math inline">\(G_j\)</span>后得到，因此一定能通过一次操作使得 <span class="math inline">\(SG(G_j)\leftarrow SG(G_j) \oplus x\)</span>，从而使得 <spanclass="math inline">\(SG(G)=0\)</span>。</p></blockquote><h3 id="code">code</h3><p>随便写一下 Nim 游戏的 <span class="math inline">\(SG\)</span>函数做法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// sg[i]表示大小为i的石子堆的SG函数值</span>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,N) &#123;        <span class="hljs-built_in">SET</span>(s,<span class="hljs-number">0</span>);        <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i) s[sg[i-j]]=<span class="hljs-number">1</span>;        <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,i) <span class="hljs-keyword">if</span>(!s[j]) &#123; sg[i]=j; <span class="hljs-keyword">break</span>; &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">pre</span>();    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), ans^=sg[a[i]];    <span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;win&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;lose&quot;</span>);&#125;</code></pre></div><h2 id="例题">例题</h2><h3 id="hdu2999">hdu2999</h3><p>考虑操作一次之后，这段序列就分成了互相独立的两段，可知这一段的一个后继状态的<span class="math inline">\(SG\)</span> 函数值等于两小段的异或起来。</p><p>所以预处理 <span class="math inline">\(SG(x)\)</span> 表示长度为<span class="math inline">\(x\)</span>的序列的函数值。处理的过程中枚举所有选那一个长度断开，然后枚举一遍断点即可。</p><p>排个序在枚举的时候理论上会快不少。</p><h3 id="poj2311">POJ2311</h3><p>剪出 <span class="math inline">\(1 \times 1\)</span>是必胜局面，不符合「终点为必败局面」的条件。</p><p>考虑到剪出 <span class="math inline">\(1 \times 1\)</span> 必须要<span class="math inline">\(1 \times x\)</span> 或者 <spanclass="math inline">\(x \times1\)</span>，那么可以把这二者作为终点。</p><p>设 <span class="math inline">\(SG(x,y)\)</span> 表示长 <spanclass="math inline">\(x\)</span> 宽 <spanclass="math inline">\(y\)</span> 的纸片的函数值。</p><p>一刀可以横着或者竖着切，那么对于 <spanclass="math inline">\((x,y)\)</span>，其后继局面可以是 <spanclass="math inline">\((x,i),(x,y-i)\)</span> 与 <spanclass="math inline">\((x-i,y),(i,y)\)</span>，每一组的 <spanclass="math inline">\(SG\)</span> 函数异或值就是 <spanclass="math inline">\((x,y)\)</span> 一个后继局面的 <spanclass="math inline">\(SG\)</span> 函数值。</p><p>枚举 <span class="math inline">\(i\)</span>，可以在 <spanclass="math inline">\(O(n^3)\)</span> 的时间里处理出所有 <spanclass="math inline">\(SG\)</span> 函数值。</p><h2 id="参考">参考</h2><p><ahref="https://do-while-true.github.io/2022/02/15/%E3%80%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%E5%8D%9A%E5%BC%88%E8%AE%BA/">「学习笔记」博弈论By do_while_true</a></p><p>《算法竞赛进阶指南》 By 李煜东</p><p>《算法竞赛》 By 罗勇军，郭卫斌</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构学习笔记」#3 树链剖分</title>
    <link href="/2023/notes-ds-3/"/>
    <url>/2023/notes-ds-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>树链剖分能够将一棵树按照某种法则剖分为若干条链，从而便于维护树上路径的信息。</p><p>按照剖出链的法则不同，其性质也不同，大体可将树剖分成重链剖分，长链剖分和用于Link-Cut Tree 的剖分（实链剖分）。</p><p>其中重链剖分用途最广泛，本文也只介绍重链剖分。</p><h2 id="重链剖分">重链剖分</h2><h3 id="定义与部分性质">定义与部分性质</h3><p>给出如下定义</p><ul><li><strong>重儿子</strong>。对于一个非叶子节点，其重儿子为其以它的所有儿子为根的子树中，最大子树所对应的那个子节点。如果最大不唯一则任取其一。</li><li><strong>轻儿子</strong>。对于一个非叶子节点，其重儿子之外的子节点都为轻儿子。</li><li><strong>重边</strong>。一个节点到其重儿子的边。</li><li><strong>重链</strong>。多条相连的重边构成的链，或者链接连续的重儿子的链。</li><li><strong>轻边</strong>。连接两条重链的边。</li><li><strong>链头</strong>。一条重链中深度最小的节点，其必定是轻儿子或根。</li></ul><figure><img src="https://oi-wiki.org/graph/images/hld.png" srcset="/img/loading.gif" lazyloadalt="图源 OI-wiki" /><figcaption aria-hidden="true">图源 OI-wiki</figcaption></figure><p>性质：同一条重链上的点，其 LCA 为链头。</p><p>重要性质：从叶子节点到根，最多经过 <spanclass="math inline">\(O(\log_2 n)\)</span> 条轻边（重链）。</p><p>证明：</p><blockquote><p>考虑从叶子节点 <span class="math inline">\(x\)</span>向上跳到根。如果 <span class="math inline">\(x\)</span>在重链上，那么直接跳到链头。如果 <span class="math inline">\(x\)</span>在轻边上，那么跳到的 <span class="math inline">\(fa(x)\)</span>必然是一条重链的链头，由于重儿子不是 <spanclass="math inline">\(x\)</span>，所以以其重儿子为根的子树大小加上 <spanclass="math inline">\(sz(x)\)</span>，大小必然超过 <spanclass="math inline">\(2sz(x)\)</span>。因此最多经过 <spanclass="math inline">\(O(\log_2 n)\)</span>条轻边，而轻边链接重链，所以经过 <span class="math inline">\(O(\log_2n)\)</span> 条重链。</p></blockquote><p>也不难看出对于任意两点，其间路径长度也是 <spanclass="math inline">\(O(\log_2 n)\)</span>。</p><h3 id="求-lca">求 LCA</h3><ul><li>如果 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 在同一条重链上，那么 <spanclass="math inline">\(lca(x,y)\)</span> 就是深度更小的那个点。</li><li>否则让所在链的链头深度大的那个点往上跳一条重链。</li><li>最后深度小的为 <span class="math inline">\(lca(x,y)\)</span>。</li></ul><p>由上述性质可知复杂度为 <span class="math inline">\(O(\log_2n)\)</span>。</p><p>代码如下</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;   <span class="hljs-comment">// top[x] x所在链的链头</span>    <span class="hljs-comment">// 如果x为轻儿子，则top[x]=x</span>    <span class="hljs-comment">// fa[x] x的父亲</span>    <span class="hljs-comment">// dep[x] x的深度</span>    <span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);        x=fa[top[x]];        <span class="hljs-comment">// top[x]跳到链头，fa[top[x]]跳到下一条链</span>    &#125;    <span class="hljs-keyword">return</span> dep[x]&lt;dep[y]? x:y;&#125;</code></pre></div><h3 id="树上问题转化序列问题">树上问题转化序列问题</h3><p>如果在<code>dfs</code>的过程中优先访问重儿子，那么可以发现每一条重链<span class="math inline">\(dfn\)</span>是连续的，对应着序列上的一个区间。而轻儿子则相对封闭，对应着序列上的一个单点。</p><figure><img src="https://oi-wiki.org/graph/images/hld.png" srcset="/img/loading.gif" lazyload alt="再次放图" /><figcaption aria-hidden="true">再次放图</figcaption></figure><p>对于树上两点 <span class="math inline">\((x,y)\)</span>，其路径必然是<span class="math inline">\(x \rightarrow lca(x,y)\)</span>，<spanclass="math inline">\(lca(x,y) \rightarrow y\)</span>。结合上面讲到的求<span class="math inline">\(lca\)</span>的方法，可以发现在这个过程中，每将那个点向上跳一步，就对应了一个区间，这些区间一定能不重不漏地覆盖此点到<span class="math inline">\(lca(x,y)\)</span>的所有点，跳完之后在一条重链上，而重链上两点之间路径的 <spanclass="math inline">\(dfn\)</span> 必然是一个区间。</p><p>因此，如果将 <span class="math inline">\(dfn\)</span>看作序列，用序列上的数据结构来处理链信息，那么最多处理 <spanclass="math inline">\(O(\log_2 n)\)</span> 次。</p><p>这个数据结构一般是线段树。</p><p>还有一个 dfs 本身的性质，以 <span class="math inline">\(x\)</span>为根的子树内，其所有 dfs 序构成一个区间 <spanclass="math inline">\([dfn(x),dfn(x)+sz_x-1]\)</span>。</p><p>因此能更快地维护子树信息。</p><h3 id="code">code</h3><p><code>dep[x]</code>，<code>fa[x]</code>，<code>top[x]</code>意义同求<span class="math inline">\(lca\)</span> 的那部分代码中。</p><p><code>son[x]</code>表示节点 <span class="math inline">\(x\)</span>的重儿子，<code>sz[x]</code>表示以 <spanclass="math inline">\(x\)</span>为根的子树大小，<code>id[x]</code>表示节点 <spanclass="math inline">\(dfn(x)\)</span>。</p><p>先用一遍<code>dfs</code>求出<code>dep[x]</code>，<code>fa[x]</code>，<code>son[x]</code>，<code>sz[x]</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;    dep[x]=dep[fr]+<span class="hljs-number">1</span>, fa[x]=fr;    sz[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(y,x);        sz[x]+=sz[y];        <span class="hljs-keyword">if</span>(!son[x]||sz[son[x]]&lt;sz[y]) son[x]=y;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div><p>然后进行一次优先访问重儿子的<code>dfs</code>，求出<code>id[x]</code>，<code>top[x]</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;id[x]=++num, top[x]=tp;    <span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">dfs2</span>(son[x],tp);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa[x]||y==son[x]) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs2</span>(y,y);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;</code></pre></div><p>然后</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    <span class="hljs-comment">// 处理(x -&gt; y)的点信息</span>    <span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);        <span class="hljs-comment">/*</span><span class="hljs-comment">        此时[id[top[x]],id[x]]就是路径上的一个区间</span><span class="hljs-comment">        这里用数据结构处理这个区间的信息</span><span class="hljs-comment">        */</span>        x=fa[top[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-comment">/*</span><span class="hljs-comment">    此时x为lca</span><span class="hljs-comment">    处理[id[x],id[y]]的信息</span><span class="hljs-comment">    */</span>&#125;</code></pre></div><p>查询同上。</p><h3 id="边权转化点权">边权转化点权</h3><p>上述操作都是建立在权值为点权的基础上的，不能直接解决边权问题。</p><p>考虑将边权转化为点权，一种方法是将边 <span class="math inline">\((x\rightarrow y)\)</span>，其中 <spanclass="math inline">\(dep(x)&lt;dep(y)\)</span>，其权值 <spanclass="math inline">\(z\)</span> 放到 <spanclass="math inline">\(y\)</span> 上。</p><p>如图。</p><p><imgsrc="https://cdn-us.imgs.moe/2023/01/27/63d331674ae07.png" srcset="/img/loading.gif" lazyload /></p><p><imgsrc="https://cdn-us.imgs.moe/2023/01/27/63d3316703f87.png" srcset="/img/loading.gif" lazyload /></p><p>可以发现如果要求得 <span class="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 的链信息，就要忽略 <spanclass="math inline">\(lca(x,y)\)</span> 的点权。</p><p>那么在修改和查询的时候忽略 <span class="math inline">\(lca\)</span>就可以了。</p><p>也就是说</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">// 以上省略</span>    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-comment">/*</span><span class="hljs-comment">    此时x为lca</span><span class="hljs-comment">    处理[id[x],id[y]]的信息</span><span class="hljs-comment">    改为</span><span class="hljs-comment">    处理[id[x]+1,id[y]]的信息</span><span class="hljs-comment">    */</span>&#125;</code></pre></div><h3 id="luogu7735-轻重边">luogu7735 轻重边</h3><p>题目里的「轻重边」只是一个新定义，不如用 <spanclass="math inline">\(0\)</span> 边和 <spanclass="math inline">\(1\)</span> 边代替。</p><p>发现如果局限于 0/1 两种状态的话并不好做。</p><p>不难发现如果 <span class="math inline">\((x \rightarrow y)\)</span>是 <span class="math inline">\(1\)</span> 边，那么 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>一定同时在某一次操作的链上，可以看作是同一次被覆盖。</p><p>然后这个显然是充要的。</p><p>如果把每个节点被覆盖的颜色看作点权，那么问题等价于路径上有多少相邻点的点权相同。考虑树剖然后用线段树维护。</p><p>如何维护？记录区间左右端点的被覆盖的颜色，然后就合并就行了。叶子节点的初始颜色为其<span class="math inline">\(dfn\)</span>，这样就能保证初始不存在 <spanclass="math inline">\(1\)</span> 边。</p><p>还有一个问题，要得到路径上轻边左右端点的信息，也就是要单点查询<code>id[top[x]]</code>和<code>id[fa[top[x]]]</code>的颜色。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, num, tim;<span class="hljs-type">int</span> sz[N], son[N], fa[N], top[N], dep[N], id[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], lt[N&lt;&lt;<span class="hljs-number">2</span>], rt[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;lt[x]=lt[x&lt;&lt;<span class="hljs-number">1</span>], rt[x]=rt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(rt[x&lt;&lt;<span class="hljs-number">1</span>]==lt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) ++t[x];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span> </span>&#123;t[x]=r-l, lt[x]=rt[x]=k;tag[x]=k;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]) &#123;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid,tag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,tag[x]);tag[x]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;tag[x]=lt[x]=rt[x]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r) &#123; t[x]=<span class="hljs-number">0</span>, lt[x]=rt[x]=l; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,l,r,k); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">modify</span>(L,R,k,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">modify</span>(L,R,k,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-keyword">if</span>(L&lt;=mid&amp;&amp;R&gt;mid&amp;&amp;rt[x&lt;&lt;<span class="hljs-number">1</span>]==lt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) ++ans;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query2</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> lt[x];<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query2</span>(k,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query2</span>(k,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;dep[x]=dep[fr]+<span class="hljs-number">1</span>, fa[x]=fr;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs1</span>(y,x);sz[x]+=sz[y];<span class="hljs-keyword">if</span>(!son[x]||sz[y]&gt;sz[son[x]]) son[x]=y;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;id[x]=++num, top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> tim,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">modify</span>(id[top[x]],id[x],tim);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">modify</span>(id[x],id[y],tim);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);ans+=<span class="hljs-built_in">query</span>(id[top[x]],id[x]);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">query2</span>(id[fa[top[x]]])==<span class="hljs-built_in">query2</span>(id[top[x]])) ++ans;x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);ans+=<span class="hljs-built_in">query</span>(id[x],id[y]);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();tot=num=<span class="hljs-number">0</span>, tim=n;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=son[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">build</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) ++tim, <span class="hljs-built_in">upd</span>(tim,x,y);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">ask</span>(x,y));&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="参考">参考</h2><p><a href="https://oi-wiki.org/graph/hld/">OI wiki 树链剖分</a></p><p>《算法竞赛》 By 罗勇军，郭卫斌</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构学习笔记」#2 可持久化线段树</title>
    <link href="/2023/notes-ds-2/"/>
    <url>/2023/notes-ds-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="可持久化线段树">可持久化线段树</h2><h3 id="思想">思想</h3><p>可持久化线段树的思想如下</p><ul><li>建立多棵线段树，代表不同版本。</li><li>为了降低空间复杂度，每棵线段树只储存与上一棵不同的部分，结构并不完整。换句话说，每个节点都是先继承上个版本，如果自己的儿子信息被修改了，那么新建立一个节点代替自己。而对于根节点，无论修改是否改变了根节点的信息，根节点的版本都改变了，因此必须新建节点，同时也能代表版本。</li><li>任意两棵线段树都能相减得到一棵新线段树，利用这颗线段树的信息解决问题。</li></ul><p>多棵线段树，可以是 <span class="math inline">\(i \in[1,n]\)</span>，在每个 <span class="math inline">\([1,i]\)</span>上建树，这样相减能得到 <span class="math inline">\([l,r]\)</span>的线段树。也可以是每个「时间」的线段树，得到每段时间 <spanclass="math inline">\([s,t]\)</span> 的信息。</p><p>无论是上述哪一种方式，都可以发现相邻两个版本间的差距只有一次修改。</p><p>如果是单点修改的话，那么两棵树的差别就是一条长度为 <spanclass="math inline">\(O(\log_2 n)\)</span>的链。被修改了的节点会单独创建，否则就直接继承先前版本。</p><p>如图，蓝色的是前连续多少个版本的并集，而橙色是将节点 <spanclass="math inline">\(4\)</span> 加上 <spanclass="math inline">\(2\)</span> 的下一个版本。</p><p><imgsrc="https://pic2.zhimg.com/v2-e41c74ec213257cec4f3c3429e9d037d_r.jpg" srcset="/img/loading.gif" lazyload /></p><p>区间修改呢？可以证明普通线段树区间操作每层节点最多访问 <spanclass="math inline">\(4\)</span> 个，所以会访问的节点数量是 <spanclass="math inline">\(O(\log_2 n)\)</span>的。但是如果要下传标记呢？在一棵不完整的线段树上下传标记，如果暴力创建左右儿子那么空间就会爆炸，所以只能用标记永久化。</p><p> </p><p>可以发现，如果没有初始树，那么每次操作要开大小为 <spanclass="math inline">\(O(\log_2 n)\)</span> 的一棵树，总空间复杂度为<span class="math inline">\(O(m \log_2 n)\)</span>，有初始树的话要加上<span class="math inline">\(O(n \log_2 n)\)</span>。</p><p>而修改操作则与普通线段树相同。</p><h3 id="code">Code</h3><p>建初始树</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l==r) &#123;        <span class="hljs-comment">// init a node.</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(ls[x],l,mid);    <span class="hljs-built_in">build</span>(rs[x],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    root[<span class="hljs-number">0</span>]=++cnt;    <span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>]);&#125;</code></pre></div><p>单点修改</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-comment">// p是当前线段树，q是上一棵</span>    <span class="hljs-keyword">if</span>(l==r) &#123;        <span class="hljs-comment">// modify node p;</span>        <span class="hljs-keyword">return</span>;    &#125;    ls[p]=ls[q], rs[p]=rs[q];    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x&lt;=mid) ls[p]=++cnt, <span class="hljs-built_in">modify</span>(ls[p],ls[q],x,d,l,mid);    <span class="hljs-comment">// 要修改的点在左边，那么ls[p]必然和ls[q]不同，所以新建。右边同理。</span>    <span class="hljs-keyword">else</span> rs[p]=++cnt, <span class="hljs-built_in">modify</span>(rs[p],rs[q],x,d,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>(root[i]==<span class="hljs-number">0</span>) root[i]=++cnt;    <span class="hljs-built_in">modify</span>(root[i],root[i<span class="hljs-number">-1</span>],x,d);&#125;</code></pre></div><p>区间查</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query</span>(L,R,ls[x],l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid) ans+=<span class="hljs-built_in">query</span>(L,R,rs[x],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>（权值线段树）二分第 <span class="math inline">\(k\)</span> 大。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;    <span class="hljs-type">int</span> d=t[ls[p]]-t[ls[q]];    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(d&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[p],ls[q],k,l,mid);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[p],rs[q],k-d,mid+<span class="hljs-number">1</span>,r);&#125;</code></pre></div><p>考虑区间加法操作，我们只修改完全覆盖的区间的标记，不能完全覆盖则创建新节点，感性理解一下，时间和空间复杂度都是<span class="math inline">\(O(\log_2n)\)</span>，前文说到线段树区间操作最多访问一层中的 <spanclass="math inline">\(4\)</span>个节点，而不能被完全覆盖的最多只有两个。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify1</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    ls[p]=ls[q], rs[p]=rs[q], sum[p]=sum[q], tag[p]=tag[q];    <span class="hljs-comment">// 先继承</span>    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; tag[p]+=d, sum[p]+=(r-l+<span class="hljs-number">1</span>)*d; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// 被完全覆盖，直接在继承的基础上修改</span>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-comment">// 否则就要创建新节点</span>    <span class="hljs-keyword">if</span>(L&lt;=mid) ls[p]=++cnt, <span class="hljs-built_in">modify1</span>(L,R,d,ls[p],ls[q],l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid) rs[p]=++cnt, <span class="hljs-built_in">modify1</span>(L,R,d,rs[p],rs[q],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>(!root[i]) root[i]=++cnt;    <span class="hljs-built_in">modify1</span>(l,r,root[i],root[i<span class="hljs-number">-1</span>]);&#125;</code></pre></div><p>区间查就要记录当前区间的标记来保证正确性，同时要注意标记可能会溢出。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> sum[x]+(r-l+<span class="hljs-number">1</span>)*tag[x];    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, ans=(<span class="hljs-built_in">min</span>(R,r)-<span class="hljs-built_in">max</span>(L,l)+<span class="hljs-number">1</span>)*tag[x];    <span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query1</span>(L,R,ls[x],l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid) ans+=<span class="hljs-built_in">query1</span>(L,R,rs[x],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>关于这玩意的空间，为了保险起见可以开 <span class="math inline">\(2^5n\)</span></p><h3 id="静态区间-kth">静态区间 kth</h3><p>在每个 <span class="math inline">\(i\in[1,n]\)</span>，<spanclass="math inline">\([1,i]\)</span> 上建立可持久化的权值线段树。第<span class="math inline">\(r\)</span> 棵线段树减去第 <spanclass="math inline">\(l\)</span> 棵线段树就是 <spanclass="math inline">\([l,r]\)</span> 的线段树。</p><p>然后在全局二分第 <span class="math inline">\(k\)</span>大即可，很好写。</p><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/250565583">算法学习笔记(50):可持久化线段树 By Pecco</a></p><p><a href="https://oi-wiki.org/ds/persistent-seg/">OI wiki可持久化线段树</a></p><p>《算法竞赛》 By 罗勇军，郭卫斌</p><p>《算法竞赛进阶指南》 By 李煜东</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可持久化线段树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构学习笔记」#1 线段树相关</title>
    <link href="/2023/notes-ds-1/"/>
    <url>/2023/notes-ds-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="线段树上二分">线段树上二分</h2><p>用形式化的语言讲，线段树上二分求解的是这一类问题。</p><p>给定 <span class="math inline">\(L\)</span>，找到一个 <spanclass="math inline">\(R \in [L,n]\)</span> 满足 <spanclass="math display">\[f \Big( op\big([L,R-1]\big) \Big) = 1\]</span> <span class="math display">\[f\Big( op\big(R\big) \Big)=0\]</span></p><p>其中 <span class="math inline">\(f\)</span> 为某种合法性函数，<spanclass="math inline">\(op\)</span> 是将区间信息合并为 <spanclass="math inline">\(f\)</span> 能处理的信息的过程。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span>&amp; S,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>;</code></pre></div><p>其中 <span class="math inline">\(S\)</span>为当前已经合并的区间信息，<span class="math inline">\(x: [l,r]\)</span>为当前节点。</p><p> </p><p>如何进行求解？既然要以 <span class="math inline">\(L\)</span>为左端点进行区间合并，那么无论何时我们都优先递归左儿子，对于一个 <spanclass="math inline">\([l,r]\)</span>，若 <spanclass="math inline">\(r&lt;L\)</span>，就不再往下递归了。</p><p>此后便一定能找到 <span class="math inline">\(L \lel\)</span>，且第一次找到时一定满足 <spanclass="math inline">\(L=l\)</span>，于是就合并信息。如果此时 <spanclass="math inline">\(f(S)=1\)</span>，那么往继续往右边找，结束递归。如果<span class="math inline">\(f(S)=0\)</span> 且 <spanclass="math inline">\(l=r\)</span>，答案 <spanclass="math inline">\(R=l\)</span>。</p><p>如果 <span class="math inline">\(l &lt; L \operatorname{ and } L \ler\)</span>，往下递归即可。</p><p>借用<ahref="https://www.zhihu.com/people/yan-ge-ge-32-1">严格鸽</a>的图，不难看出合并区间的过程是连续的。按顺序合并了<span class="math inline">\(7,8,9,10,11\)</span>，在 <spanclass="math inline">\(12\)</span> 处找到了答案。</p><p><imgsrc="https://pic4.zhimg.com/v2-f3c0d4b007aa1e68655f0e9f078cde37_r.jpg" srcset="/img/loading.gif" lazyload /></p><p><imgsrc="https://pic1.zhimg.com/v2-8f097f2ef9d9cf2fca3816843a9000b4_r.jpg" srcset="/img/loading.gif" lazyload /></p><p><imgsrc="https://pic2.zhimg.com/v2-b1fb9d1bcb102eb61797eb2727a4ae21_r.jpg" srcset="/img/loading.gif" lazyload /></p><p> </p><p>那这玩意复杂度是多少？</p><ol type="1"><li>找 <span class="math inline">\(L\)</span>的过程相当于优先递归左端点的单点查找，但是如果和 <spanclass="math inline">\([L,n]\)</span> 无交便不会递归下去，复杂度 <spanclass="math inline">\(O(\log_2 n)\)</span>。</li><li>之后只有合并后 <span class="math inline">\(f\)</span> 值为 <spanclass="math inline">\(0\)</span>才往下递归，否则就合并信息。临界点又是固定的，所以每递归一次区间长度就减半，所以复杂度还是<span class="math inline">\(O(\log_2 n)\)</span>。</li></ol><p>因此总复杂度 <span class="math inline">\(O(\log_2n)\)</span>。</p><p>下面给出模板。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,node&amp; S,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(r&lt;L) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(L&lt;=l) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(<span class="hljs-built_in">op</span>(S,x))) &#123;S=<span class="hljs-built_in">op</span>(S,x);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;&#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-type">int</span> res=<span class="hljs-built_in">query</span>(L,S,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(res==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(L,S,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><p>这种带着引用的写法存在一定局限性，但是某种程度上更加便于理解。</p><p> </p><p>考虑这样一个模板题</p><blockquote><p>维护一个 01 序列，求 <span class="math inline">\([L,n]\)</span>从左往右第 <span class="math inline">\(k\)</span> 个 1 的位置。</p></blockquote><p>转化为</p><blockquote><p>给定 <span class="math inline">\(L\)</span>，找到 <spanclass="math inline">\(R\)</span> 满足 <spanclass="math inline">\([L,R-1]\)</span> 中有不超过 <spanclass="math inline">\(k\)</span> 个 <spanclass="math inline">\(1\)</span>。</p></blockquote><p>因此<code>node&amp; S</code>就是当前还需要找到 <spanclass="math inline">\(S\)</span> 个 <spanclass="math inline">\(k\)</span>，<code>op(S,x)</code>就是 <spanclass="math inline">\(S\)</span> 减去区间内 <spanclass="math inline">\(1\)</span> 的个数，<spanclass="math inline">\(f\)</span> 就是看是不是大于 <spanclass="math inline">\(0\)</span>（还要给 <spanclass="math inline">\(R\)</span> 留一个 1 的位置）。</p><p> </p><p>这玩意的用法很灵活。</p><h3 id="luogu4198-楼房重建">luogu4198 楼房重建</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span>次操作，每次操作单点修改，操作完之后查询全局有多少 <spanclass="math inline">\(a_i\)</span>，满足对于 <spanclass="math inline">\(j \in [1,i-1]\)</span>，<spanclass="math inline">\(a_j &lt; a_i\)</span>。规模 <spanclass="math inline">\(10^5\)</span>。</p></blockquote><p>由于只查全局，所以考虑线段树直接维护。设 <spanclass="math inline">\(s\big(x:[l,r]\big)\)</span> 为 <spanclass="math inline">\([l,r]\)</span> 内满足条件的 <spanclass="math inline">\(a_i\)</span> 的个数，<spanclass="math inline">\(t\big(x:[l,r]\big)\)</span> 为 <spanclass="math inline">\([l,r]\)</span> 内的最大值。</p><p>对于一个区间 <spanclass="math inline">\(x:[l,r]\)</span>，首先它会直接继承 <spanclass="math inline">\(s(x)\)</span>，然后加上 <spanclass="math inline">\([mid+1,r]\)</span>中的一个子序列，满足严格递增且第一个元素大于 <spanclass="math inline">\(t(x)\)</span>。</p><p>看起来不好做，但是考虑那第一个大于 <spanclass="math inline">\(t(x)\)</span> 的值，如果它在某个节点 <spanclass="math inline">\(y\)</span>的左儿子内，那么其右儿子内大于它的数量一定是 <spanclass="math inline">\(s(y)-s\big(lson(y)\big)\)</span>。</p><p>这样线段树上二分，在 <span class="math inline">\([mid+1,r]\)</span>内查找第一个大于 <span class="math inline">\(t\big(lson(x)\big)\)</span>的数，顺便加上上面那个即可。</p><h3 id="cf1440e-greedy-shopping">CF1440E Greedy Shopping</h3><blockquote><p><span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 次操作，一种操作是前缀取 <spanclass="math inline">\(\max\)</span>，另一种操作是给定 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(k\)</span>，从 <spanclass="math inline">\(L\)</span> 到 <spanclass="math inline">\(n\)</span>，如果到 <spanclass="math inline">\(i\)</span> 时有 <span class="math inline">\(a_i\le k\)</span>，那么就让让答案加 1，<spanclass="math inline">\(k-a_i\)</span>，表示购买。<spanclass="math inline">\(\{a\}\)</span> 单调不增，规模 <spanclass="math inline">\(2 \cdot 10^5\)</span>。</p></blockquote><p>容易看出来购买的一定是若干个连续段。</p><p>单独求一个连续段是容易的，在 <spanclass="math inline">\([L,n]\)</span> 上查找第一个满足 <spanclass="math inline">\(Sum[L,i+1] &gt; k\)</span> 的 <spanclass="math inline">\(i\)</span>即可。多个的话，可以再二分第一个小于等于剩下的 <spanclass="math inline">\(k\)</span> 的位置。</p><p>考虑一个性质，如果已经无法购买，说明剩下的 <spanclass="math inline">\(k\)</span>不会多于之前的一半了，否则由于序列单调，必然可以购买，所以最多二分 <spanclass="math inline">\(O(\log_2 \max\{Y\})\)</span> 次。</p><p>然后记录区间最小值可以做到可行性剪枝。</p><p>考虑前缀取 <span class="math inline">\(\max\)</span>的操作，区间内是有不同的数的，比较好的解决方法是记录区间最大值，只在取<span class="math inline">\(\max\)</span>的值不小于区间最大值时再打标记，<code>pushup</code>维护即可。</p><p> </p><p>这玩意也能在权值线段树（主席树）上用。</p><h2 id="动态开点">动态开点</h2><p>很多时候值域很大又不能离散化，为了降低空间复杂度，可以抛弃二叉树的结构，直接记录左右儿子，且一个节点被创建当且仅当被使用到。</p><p>如果是动态操作且值域较大，那么可以考虑动态开点。</p><p>那么如果一次操作复杂度是 <span class="math inline">\(O(\log_2n)\)</span> 的话，用到的节点数也是 <spanclass="math inline">\(O(\log_2n)\)</span> 的，<spanclass="math inline">\(m\)</span> 次操作时候节点数量为 <spanclass="math inline">\(O(m \log_2 n)\)</span>。</p><p>写法倒是很简单，而且能直接套上普通线段树的<code>pushup</code>和<code>pushdown</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) x=++cnt;<span class="hljs-keyword">if</span>(l==r) &#123;ls[x]=rs[x]=<span class="hljs-number">0</span>;        <span class="hljs-comment">// init a node.</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">modify</span>(ls[x],p,l,mid);<span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(rs[x],p,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;</code></pre></div><p>下面是摘自<ahref="https://oi-wiki.org/ds/seg/">OI-wiki</a>的两段代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// root 表示整棵线段树的根结点；cnt 表示当前结点个数</span><span class="hljs-type">int</span> n, cnt, root;<span class="hljs-type">int</span> sum[n * <span class="hljs-number">2</span>], ls[n * <span class="hljs-number">2</span>], rs[n * <span class="hljs-number">2</span>];<span class="hljs-comment">// 用法：update(root, 1, n, x, f); 其中 x 为待修改节点的编号</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span> </span>&#123;  <span class="hljs-comment">// 引用传参</span>  <span class="hljs-keyword">if</span> (!p) p = ++cnt;  <span class="hljs-comment">// 当结点为空时，创建一个新的结点</span>  <span class="hljs-keyword">if</span> (s == t) &#123;    sum[p] += f;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);  <span class="hljs-keyword">if</span> (x &lt;= m)    <span class="hljs-built_in">update</span>(ls[p], s, m, x, f);  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">update</span>(rs[p], m + <span class="hljs-number">1</span>, t, x, f);  sum[p] = sum[ls[p]] + sum[rs[p]];  <span class="hljs-comment">// pushup</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 用法：query(root, 1, n, l, r);</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果结点为空，返回 0</span>  <span class="hljs-keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> sum[p];  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>), ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (l &lt;= m) ans += <span class="hljs-built_in">query</span>(ls[p], s, m, l, r);  <span class="hljs-keyword">if</span> (r &gt; m) ans += <span class="hljs-built_in">query</span>(rs[p], m + <span class="hljs-number">1</span>, t, l, r);  <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>没啥可说了。</p><h2 id="线段树合并">线段树合并</h2><p>两棵结构相同的线段树可以直接进行合并。</p><p>用两个指针 <span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span>，同步遍历两棵树。</p><ol type="1"><li>若 <span class="math inline">\(p\)</span> 或 <spanclass="math inline">\(q\)</span>为空，那么非空的那个作为合并后的节点。</li><li>否则将 <span class="math inline">\(q\)</span> 的信息合并到 <spanclass="math inline">\(p\)</span>，遍历左右儿子然后<code>pushup</code>。</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p,<span class="hljs-type">int</span> q,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(!p||!q) &#123; p|=q; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(l==r) &#123;<span class="hljs-comment">// 合并叶子节点</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">merge</span>(ls[p],ls[q],l,mid);<span class="hljs-built_in">merge</span>(rs[p],rs[q],mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(p);&#125;</code></pre></div><p>复杂度？</p><p><del>我不会证</del>。</p><figure><img src="https://cdn-us.imgs.moe/2023/01/23/63ceab4b00b39.png" srcset="/img/loading.gif" lazyloadalt="orz" /><figcaption aria-hidden="true">orz</figcaption></figure><figure><img src="https://cdn-us.imgs.moe/2023/01/23/63ce9354ef0d8.png" srcset="/img/loading.gif" lazyloadalt="势能分析恐怖如斯" /><figcaption aria-hidden="true">势能分析恐怖如斯</figcaption></figure><h3 id="luogu3224-永无乡">luogu3224 永无乡</h3><p>板子题，并查集维护连通块，顺便进行合并，查询的时候全局线段树上二分即可。</p><h3 id="luogu3201-梦幻布丁">luogu3201 梦幻布丁</h3><p>每种颜色开一棵线段树，叶子为 <span class="math inline">\(1\)</span>表示这个位置的颜色是它。那么这棵线段树对答案的贡献就是连续 <spanclass="math inline">\(1\)</span>段的段数。记录区间左右端点的颜色，容易维护。</p><p>合并两种颜色就相当于合并这两棵线段树，对答案的影响显然与其它颜色段无关，随便搞一下就完了。</p><h2 id="标记永久化">标记永久化</h2><p>通过摒弃下传标记来降低常数。</p><ul><li>遇到一个被完全覆盖的区间直接打标记</li><li>否则直接通过这个区间与操作区间的交修改区间信息</li><li>查询的时候加上标记</li></ul><p>下面给出区间加法的代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; tag[x]+=d; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">modify</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid)  <span class="hljs-built_in">modify</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x]+tag[x]*(r-l+<span class="hljs-number">1</span>);    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, ans=tag[x]*(<span class="hljs-built_in">min</span>(R,r)-<span class="hljs-built_in">max</span>(L,l)+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid)  ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>这不就是分块时维护的标记吗？</p><h2 id="参考">参考</h2><p><ahref="https://zhuanlan.zhihu.com/p/573489802">ACM——线段树上二分教程 By严格鸽</a></p><p><a href="https://zhuanlan.zhihu.com/p/575513452">算法学习笔记(88):线段树合并 By Pecco</a></p><p><ahref="https://www.cnblogs.com/Y-B-X/p/15091099.html">关于线段树合并的时间复杂度By Y_B_X</a></p><p><a href="https://oi-wiki.org/ds/seg">OI wiki 线段树</a></p><p>《算法竞赛》 By 罗勇军，郭卫斌</p><p>《算法竞赛进阶指南》 By 李煜东</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回归</title>
    <link href="/2023/return/"/>
    <url>/2023/return/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>关于为啥失踪这么久……</p><p>NOIP 挂了太多的分。</p><p>由于疫情就回家上网课去了。</p><p>文化课实在是令人厌倦，但是又对 OI没啥信心了，所以就开始了大摸鱼时代。</p><p>期间几经辗转终于买到了新书《算法竞赛》，想着最后学点东西，结束 OI生涯了。</p><p>可是文化课实在是过于恶心人，一句话不如 OI。</p><p>由于一些原因，我弃置了所有原有的 OJ 账号。</p><p>然后再次。</p><p>只不过我上学期是把自己的电脑放到机房里了，下学期很可能找不到时机带进去，所以我应该只能在洛谷博客上同步更新了。而且这个博客换了更加高效的主题，还有很多地方没时间进行调整，观感可能也不是很好。</p><p><a href="https://www.luogu.com.cn/blog/yozora0908/">LuoguBlog</a></p>]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8817 假期计划 题解</title>
    <link href="/2022/lg8817-solution/"/>
    <url>/2022/lg8817-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>用 <span class="math inline">\(n\)</span> 次 BFS求出任意两点之间的距离。</p><p>枚举 <span class="math inline">\(b,c\)</span>，预处理 <spanclass="math inline">\(p(b,0/1/2)\)</span>，表示能到达 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大/次大/第三大值，<spanclass="math inline">\(q(c,0/1/2)\)</span> 同理。</p><p>那么接下来就是要求选出的两个点不等于 <spanclass="math inline">\(b,c\)</span> 且不相等，是一个大分类讨论。</p><p>但是注意到最多 <span class="math inline">\(9\)</span>种搭配，所以只要求合法的最大值即可。</p><p>教训：不要上来就刚分类讨论，一定要把思路完善到底。对于这类有着很有限的情况和很复杂的分类，可以枚举所有合法方案取最优。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2505</span>;<span class="hljs-type">int</span> n, m, k, ans, a[N], p[N][<span class="hljs-number">3</span>], q[N][<span class="hljs-number">3</span>], d[N][N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">8</span>*N], nxt[<span class="hljs-number">8</span>*N];<span class="hljs-comment">// 边数用了2*N，调了好久才破案，教训+1</span><span class="hljs-type">int</span> v[N], vis[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span>* d)</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) vis[i]=<span class="hljs-number">0</span>;d[s]=<span class="hljs-number">0</span>;vis[s]=<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;vis[y]=<span class="hljs-number">1</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doit</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(d[<span class="hljs-number">1</span>][j]&gt;k+<span class="hljs-number">1</span>||d[j][i]&gt;k+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(a[j]&gt;a[p[i][<span class="hljs-number">0</span>]]) &#123;p[i][<span class="hljs-number">2</span>]=p[i][<span class="hljs-number">1</span>], p[i][<span class="hljs-number">1</span>]=p[i][<span class="hljs-number">0</span>], p[i][<span class="hljs-number">0</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[p[i][<span class="hljs-number">1</span>]]) &#123;p[i][<span class="hljs-number">2</span>]=p[i][<span class="hljs-number">1</span>], p[i][<span class="hljs-number">1</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[p[i][<span class="hljs-number">2</span>]]) p[i][<span class="hljs-number">2</span>]=j;<span class="hljs-keyword">if</span>(a[j]&gt;a[q[i][<span class="hljs-number">0</span>]]) &#123;q[i][<span class="hljs-number">2</span>]=q[i][<span class="hljs-number">1</span>], q[i][<span class="hljs-number">1</span>]=q[i][<span class="hljs-number">0</span>], q[i][<span class="hljs-number">0</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[q[i][<span class="hljs-number">1</span>]]) &#123;q[i][<span class="hljs-number">2</span>]=q[i][<span class="hljs-number">1</span>], q[i][<span class="hljs-number">1</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[q[i][<span class="hljs-number">2</span>]]) q[i][<span class="hljs-number">2</span>]=j;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!d[i][j]) d[i][j]=<span class="hljs-number">114514</span>;    <span class="hljs-comment">// 图可能不连通，这个函数很重要</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">bfs</span>(i,d[i]);<span class="hljs-built_in">check</span>();<span class="hljs-built_in">doit</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;b&lt;=n;++b) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">2</span>;c&lt;=n;++c) &#123;<span class="hljs-keyword">if</span>(!p[b][<span class="hljs-number">0</span>]) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(b==c||d[b][c]&gt;k+<span class="hljs-number">1</span>||p[c][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j) &#123;<span class="hljs-keyword">if</span>(p[b][i]&amp;&amp;q[c][j]&amp;&amp;p[b][i]!=q[c][j]&amp;&amp;p[b][i]!=c&amp;&amp;q[c][j]!=b)ans=<span class="hljs-built_in">max</span>(ans,a[p[b][i]]+a[q[c][j]]+a[b]+a[c]);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7715 Shape 题解</title>
    <link href="/2022/lg7715-solution/"/>
    <url>/2022/lg7715-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>枚举极长横杠。</p><p>设 <span class="math inline">\(f(x,y)\)</span> 为从 <spanclass="math inline">\((x,y)\)</span>最多同时向上向下延伸多少个白色格子。</p><p>对于每一行 <spanclass="math inline">\(x\)</span>，直接处理两个黑色格子中间的部分，设为<span class="math inline">\([l,r]\)</span>，那么贡献为 <spanclass="math display">\[\sum_{y_1=l}^r \sum_{y_2=y_1+1}^r \min\{f(x,y_1),f(x,y_2)\}\]</span> 考虑如果将 <span class="math inline">\(f(x,y)\)</span>递增排序，那么对于排名为 <span class="math inline">\(k\)</span> 的 <spanclass="math inline">\(f(x,y_0)\)</span> 会贡献出 <spanclass="math inline">\(r-k\)</span> 次。</p><p>于是乎这部分的复杂度为 <span class="math inline">\(O(nm \log_2m)\)</span>，可以通过。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-type">int</span> n, m, ans, a[N][N], f[N][N], t[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(j,l,r) t[++cnt]=f[i][j];<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) res+=t[j]*(cnt-j);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) a[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> p=<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(!a[i][j]) ++p; <span class="hljs-keyword">else</span> p=<span class="hljs-number">-1</span>;f[i][j]=p;&#125;p=<span class="hljs-number">-1</span>;<span class="hljs-built_in">per</span>(i,n,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(!a[i][j]) ++p; <span class="hljs-keyword">else</span> p=<span class="hljs-number">-1</span>;f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],p);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-type">int</span> lst=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(a[i][j]) ans+=<span class="hljs-built_in">calc</span>(i,lst,j<span class="hljs-number">-1</span>), lst=j+<span class="hljs-number">1</span>;ans+=<span class="hljs-built_in">calc</span>(i,lst,m);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6748 Fallen Lord 题解</title>
    <link href="/2022/lg6748-solution/"/>
    <url>/2022/lg6748-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><span class="math inline">\(\texttt{analysis}\)</span></p><p>发现每条边 <span class="math inline">\((x,y)\)</span> 的权值只可能是<span class="math inline">\(a_x\)</span>，<spanclass="math inline">\(a_y\)</span>，<spanclass="math inline">\(m\)</span>。</p><p>对于一个节点 <spanclass="math inline">\(x\)</span>，与它相连的所有边权的中位数不超过 <spanclass="math inline">\(a_x\)</span>，那么 <spanclass="math inline">\(deg_x\)</span> 条边中，最多有 <spanclass="math inline">\(\lfloor \frac{deg_x}{2} \rfloor + 1\)</span>条边小于等于 <span class="math inline">\(a_x\)</span>，也就是至多有<span class="math inline">\(\lceil \frac{deg_x}{2} \rceil - 1\)</span>条边权大于 <span class="math inline">\(a_x\)</span>。设其为 <spanclass="math inline">\(t\)</span>。</p><p>设 <span class="math inline">\(f(x,0/1)\)</span> 表示以 <spanclass="math inline">\(x\)</span> 为根的子树的最大价值，其中 <spanclass="math inline">\((x,fa_x)\)</span> 的权值是小于等于还是大于 <spanclass="math inline">\(a_x\)</span>。</p><p>对于 <span class="math inline">\(f(x,0)\)</span>，在 <spanclass="math inline">\(x\)</span> 连向子节点的边中，最多可以有 <spanclass="math inline">\(t\)</span> 条边大于 <spanclass="math inline">\(a_x\)</span>。对于 <spanclass="math inline">\(f(x,1)\)</span>，这样的边数为 <spanclass="math inline">\(t-1\)</span>。</p><p>考虑 <span class="math inline">\(x\)</span> 的子节点 <spanclass="math inline">\(y\)</span>，分类讨论一下其对 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 状态的贡献 <spanclass="math inline">\(g_{0/1}\)</span>，那么 <spanclass="math inline">\(f(x,0)\)</span> 能取 <spanclass="math inline">\(t\)</span> 个 <spanclass="math inline">\(g_1\)</span>，<spanclass="math inline">\(f(x,1)\)</span> 少 <spanclass="math inline">\(1\)</span> 个。 <span class="math display">\[g_0 = \begin{cases}\max\Big(f(y,0)+a_y, f(y,1)+a_x\Big) &amp; a_y \le a_x\\\max\Big(f(y,0)+a_x, f(y,1)+a_x \Big) &amp; a_y &gt; a_x\end{cases}\]</span></p><p><span class="math display">\[g_1 = \begin{cases}\max\Big(f(y,0)+a_y, f(y,1)+m \Big) &amp; a_y \le a_x\\\max\Big( f(y,0)+a_y, f(y,1)+m \Big) &amp; a_y &gt; a_x\end{cases}\]</span></p><p>能发现 <span class="math inline">\(g1 \ge g_0\)</span>，因此先求<span class="math inline">\(g_0\)</span> 的和，把 <spanclass="math inline">\(g_1-g_0\)</span>扔进一个优先队列里面，换出最大的几个 <spanclass="math inline">\(g_1\)</span> 即可。</p><p>特别的，当 <span class="math inline">\(t=0\)</span> 时，<spanclass="math inline">\(f(x,1) = -\infty\)</span>。</p><p>答案是 <span class="math inline">\(\max \Big(f(1,0),f(1,1)\Big)\)</span>。</p><p><span class="math inline">\(\texttt{code}\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, a[N], deg[N], f[N][<span class="hljs-number">2</span>], s[N], g[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>, t=(deg[x]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">dfs</span>(y,x);<span class="hljs-type">int</span> g0=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>]+<span class="hljs-built_in">min</span>(a[x],a[y]),f[y][<span class="hljs-number">1</span>]+a[x]);<span class="hljs-type">int</span> g1=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>]+a[y],f[y][<span class="hljs-number">1</span>]+m);dlt+=g0;q.<span class="hljs-built_in">push</span>(g1-g0);&#125;f[x][<span class="hljs-number">0</span>]=f[x][<span class="hljs-number">1</span>]=dlt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i) &#123;<span class="hljs-type">int</span> z=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();f[x][<span class="hljs-number">0</span>]+=z;<span class="hljs-keyword">if</span>(i!=t) f[x][<span class="hljs-number">1</span>]+=z;        <span class="hljs-comment">// 这个最好循环到t，特判i!=t时不给f[x][1]</span>        <span class="hljs-comment">// 为了避免t=0和1时f[x][0]没有被修改</span>&#125;<span class="hljs-keyword">if</span>(!t) f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">-1e15</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF981D Bookshelves 题解</title>
    <link href="/2022/cf981d-solution/"/>
    <url>/2022/cf981d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>按位贪心。</p><p>由于高位的 <span class="math inline">\(1\)</span> 优于低位的所有<spanclass="math inline">\(1\)</span>，所以考虑一个过程<code>check(x)</code>，表示是否能够在保证更高位的<span class="math inline">\(1\)</span>不会减少的情况下，使得当前这一位为 <spanclass="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 本书，划分成 <spanclass="math inline">\(j\)</span> 段是否可行。 <spanclass="math display">\[f(i,j) = \operatorname{OR}_{k=0}^{i-1} f(k,j-1) \operatorname{AND}[sum(k+1,i) \&amp; x = x]\]</span> 如果 <span class="math inline">\(sum(k+1,i) \&amp; x =x\)</span>，那么说明这一段在满足之前所有 <spanclass="math inline">\(1\)</span> 的情况下还能满足这一位是 <spanclass="math inline">\(1\)</span>。至于其他位则不必关心。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-type">int</span> n, k, s[N], f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;i;++k) &#123;f[i][j]|=f[k][j<span class="hljs-number">-1</span>]&amp;(((s[i]-s[k])&amp;x)==x);&#125;&#125;<span class="hljs-keyword">return</span> f[n][k];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">62</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(ans|(<span class="hljs-number">1ll</span>&lt;&lt;i))) ans|=(<span class="hljs-number">1ll</span>&lt;&lt;i);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8162 让我们赢得选举 题解</title>
    <link href="/2022/lg8162-solution/"/>
    <url>/2022/lg8162-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先让自己和协作者在多个不同的州演讲一定不优。</p><p>证明：反证法。假设更优，那么由于自己和协作者的演讲速度相同，所以在同样的时间里，让协作者为自己「加速」和分头演讲的总量是不变的。而让自己加速能够在更短的时间里得到正在演讲的那个州的票，矛盾。</p><p>其次，对于任意一个州，它的演讲时间只能为 <spanclass="math inline">\(A_i\)</span>，<span class="math inline">\(B_i[B_i\neq -1]\)</span>，<spanclass="math inline">\(0\)</span>。这个是显然的。为了方便起见，分别称之为2 类州，1 类州和 3 类州。</p><p>对于所有 1 类州，一定最先被演讲完。</p><p>证明：微扰。如果存在一个 1 类州在一个 2 类州之后，将二者交换后，在<span class="math inline">\(j\)</span> 演讲的时候就多了一个演讲者，在<span class="math inline">\(B_i\)</span>演讲时演讲者数量不变，显然更优。</p><p>对于所有 1 类州，一定按照 <span class="math inline">\(B_i\)</span>为第一关键字，<span class="math inline">\(A_i\)</span>为第二关键字递增排序。</p><p>证明：微扰。如果存在一种不符合这个法则的方案，设他们为 <spanclass="math inline">\((i,j)\)</span>，那么得到两张票的用时为 <spanclass="math display">\[\frac{B_i}{k} + \frac{B_j}{k+1}\]</span> 交换后为 <span class="math display">\[\frac{B_i}{k+1} + \frac{B_j}{k}\]</span></p><p>同乘 <span class="math inline">\(k(k+1)\)</span></p><p><span class="math display">\[B_i(k+1) + B_jk\]</span></p><p><span class="math display">\[B_ik + B_j (k+1)\]</span></p><p>由于 <span class="math inline">\(B_i &gt;B_j\)</span>，根据排序不等式，后者不劣于前者。</p><p>具体实现时只要将所有州按照这个法则排序即可。</p><p> </p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个州，得到了 <spanclass="math inline">\(j\)</span> 张票，其中总管有 <spanclass="math inline">\(d\)</span> 1 类州，已经完成了 <spanclass="math inline">\(k\)</span> 个的最小代价。 <spanclass="math display">\[f(i,j,k) \rightarrow f(i+1,j,k)\]</span></p><p><span class="math display">\[f(i,j,k) + \lfloor \frac{A_{i+1}}{d+1} \rfloor \rightarrow f(i,j+1,k)\]</span></p><p><span class="math display">\[f(i,j,k) + \lfloor \frac{B_{i+1}}{k+1} \rfloor  \rightarrowf(i+1,j+1,k+1)\]</span></p><p>采用刷表法的原因：转移方式较多，状态较为复杂。</p><p>由于 1 类州的数量无法确定且没有什么性质，所以要枚举。</p><p>复杂度 <span class="math inline">\(O(n^3K)\)</span>，可以得到 56pts的高分。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=n;++k) f[i][j][k]=<span class="hljs-number">1.0</span>*inf;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=K;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=d;++k) &#123;f[i+<span class="hljs-number">1</span>][j][k]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j][k],f[i][j][k]);f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k],f[i][j][k]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].a/(d+<span class="hljs-number">1</span>));f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>],f[i][j][k]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].b/(k+<span class="hljs-number">1</span>));&#125;&#125;&#125;<span class="hljs-keyword">return</span> f[n][K][d];&#125;</code></pre></div><p>考虑下面那一档性质分。发现 <span class="math inline">\(K=n\)</span>时可以略去 <span class="math inline">\(j\)</span> 那一维，复杂度 <spanclass="math inline">\(O(n^2K)\)</span>，可以多拿 11pts。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve2</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) g[i][j]=<span class="hljs-number">1.0</span>*inf;g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=d;++j) &#123;g[i+<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">min</span>(g[i+<span class="hljs-number">1</span>][j],g[i][j]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].a/(d+<span class="hljs-number">1</span>));g[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(g[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>],g[i][j]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].b/(j+<span class="hljs-number">1</span>));&#125;&#125;<span class="hljs-keyword">return</span> g[n][d];&#125;</code></pre></div><p>考虑优化。</p><p>当完成了所有 1类州的演讲时，剩下的肯定是挑选时间最小的那些州进行演讲。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为前 <spanclass="math inline">\(i\)</span> 个州，选出了 <spanclass="math inline">\(j\)</span> 个 1 类州的最小时间。</p><p>由于边界条件的原因，不能使用刷表法了。</p><p>不选 <span class="math inline">\(i\)</span> <spanclass="math display">\[f(i-1,j) + \lfloor \frac{A_i}{d+1} \rfloor \rightarrow f(i,j)\]</span> 选 <span class="math display">\[f(i-1,j-1) + \lfloor \frac{B_i}{j} \rfloor \rightarrow f(i,j)\]</span> 然后取一个 <span class="math inline">\(\delta = \min_{i=K}^n\{ f(i,d) \}\)</span>，这代表在寻找最优的 1 类州时已经完成 <spanclass="math inline">\(K\)</span> 张票的最小时间。</p><p>枚举 <span class="math inline">\(i \in [d,K-1]\)</span>，找到 <spanclass="math inline">\([i,n]\)</span> 中前 <spanclass="math inline">\(K-i\)</span> 小的 <spanclass="math inline">\(A_i\)</span> 的和 <spanclass="math inline">\(val\)</span>，<span class="math inline">\(f(i,d) +\lfloor \frac{val}{d+1} \rfloor\)</span> 即为这部分的最小时间。</p><p>取最小值即可。</p><p>这样复杂度就变成了 <span class="math inline">\(O(nK^2)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, inf=<span class="hljs-number">1e9</span>;<span class="hljs-type">int</span> n, K;<span class="hljs-type">double</span> ans=<span class="hljs-number">1.0</span>*inf, t[N], f[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> a, b;&#125; s[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node x,node y) &#123;<span class="hljs-keyword">if</span>(x.b!=y.b) <span class="hljs-keyword">return</span> x.b&lt;y.b;<span class="hljs-keyword">return</span> x.a&lt;y.a;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) t[i]=<span class="hljs-number">1.0</span>*s[i].a;<span class="hljs-type">double</span> ans=<span class="hljs-number">1.0</span>*inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) f[i][j]=<span class="hljs-number">1.0</span>*inf;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-built_in">min</span>(d,i);++j) &#123;f[i][j]=f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1.0</span>*s[i].a/(d+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(j&amp;&amp;s[i].b!=<span class="hljs-number">1e15</span>) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1.0</span>*s[i].b/j);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=K;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,f[i][d]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=K<span class="hljs-number">-1</span>;i&gt;=d;--i) &#123;<span class="hljs-built_in">sort</span>(t+i+<span class="hljs-number">1</span>,t+n+<span class="hljs-number">1</span>);        <span class="hljs-comment">// 对这个后缀排序</span><span class="hljs-type">double</span> val=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=K-i;++j) val+=t[i+j];ans=<span class="hljs-built_in">min</span>(ans,f[i][d]+val/(d+<span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;s[i].a=<span class="hljs-built_in">read</span>(), s[i].b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(s[i].b==<span class="hljs-number">-1</span>) s[i].b=<span class="hljs-number">1e15</span>;&#125;<span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;++i) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">solve</span>(i));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.15lf\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题选讲4</title>
    <link href="/2022/tititi-solution-4/"/>
    <url>/2022/tititi-solution-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>杂题选讲</strong> 4.</p><h2 id="luogu8110-矩阵">luogu8110 矩阵</h2><h3 id="分析">分析</h3><p>萌萌题。 <span class="math display">\[A^2_{i,j} = \sum_{i=k}^n A_{i,k} \cdot A_{k,j} = \sum_{k=1}^na_ib_ka_kb_j = a_ib_j\Big( (\sum_{k=1}^n a_ib_i)  = d\Big)\]</span></p><p><span class="math display">\[\sum_{i=1}^n \sum_{j=1}^n A^2_{i,j} = \sum_{i=1}^n \sum_{j=1}^n a_ib_jd= \Big( \sum_{i=1}^n a_i \cdot \sum_{i=1}^n b_i \Big) d\]</span></p><p>归纳一下得到答案。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, k, sa, sb, a[N], b[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=(<span class="hljs-built_in">read</span>()%mod+mod)%mod;(sa+=a[i])%=mod;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=(<span class="hljs-built_in">read</span>()%mod+mod)%mod;(sb+=b[i])%=mod;&#125;<span class="hljs-keyword">if</span>(!k) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) (d+=a[i]*b[i]%mod)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sa*sb%mod*<span class="hljs-built_in">fp</span>(d,k<span class="hljs-number">-1</span>)%mod);&#125;</code></pre></div><h2 id="luogu6599-异或">luogu6599 异或</h2><h3 id="分析-1">分析</h3><p>按位贪心。</p><p>若答案的第 <span class="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>，设 <spanclass="math inline">\(x\)</span> 为序列中第 <spanclass="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span> 的个数。不难发现它会与所有第 <spanclass="math inline">\(k\)</span> 位不是 <spanclass="math inline">\(1\)</span> 的数产生 <spanclass="math inline">\(2^k\)</span> 的贡献。</p><p>那么总贡献为 <span class="math inline">\(2^k \cdot x \times(l-x)\)</span>，当 <span class="math inline">\(x = \lfloor \frac{l}{2}\rfloor\)</span> 时有最大值。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> t, n, l;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> base=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">40</span>, x=l&gt;&gt;<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(base) &#123;base&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(n&lt;base) <span class="hljs-keyword">continue</span>;(ans+=base*x%mod*(l-x))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="luogu7714-排列排序">luogu7714 排列排序</h2><h3 id="分析-2">分析</h3><p>容易想到，一定存在一种排序方法，使得每个数之多被操作 <spanclass="math inline">\(1\)</span> 次（因为代价的上界为 <spanclass="math inline">\(n\)</span>）。</p><p>考虑这样的区间是什么样的。</p><p>设其为 <span class="math inline">\([l,r]\)</span>。其中 <spanclass="math inline">\([1,l-1]\)</span> 中的数要严格小于 <spanclass="math inline">\([l,r]\)</span> 中的最小值，<spanclass="math inline">\([r+1,n]\)</span> 中的数要严格大于 <spanclass="math inline">\([l,r]\)</span> 中的最大值。</p><p>双指针找即可。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=n) &#123;<span class="hljs-keyword">if</span>(p[l]==l) ++l;        <span class="hljs-comment">// 跳过已经有序的部分</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> r=l+<span class="hljs-number">1</span>, mx=<span class="hljs-built_in">max</span>(p[l],p[r]);<span class="hljs-keyword">while</span>(mx&gt;r) &#123;                <span class="hljs-comment">// 直到最大值和右端点相等</span>++r;mx=<span class="hljs-built_in">max</span>(mx,p[r]);&#125;ans+=r-l+<span class="hljs-number">1</span>;l=r+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="luogu8161-自学-self-study">luogu8161 自学 (Self Study)</h2><h3 id="分析-3">分析</h3><p>二分答案 <spanclass="math inline">\(mid\)</span>，以课程数量作为限制。</p><p>对于一个 <span class="math inline">\(i\)</span>，如果 <spanclass="math inline">\(b_i &gt;a_i\)</span>，那么就没必要上课，全部自学即可。</p><p>否则贪心的多上课。如果上课就足够满足了，那么就上那么多课，否则就占用自学的课程。</p><p>如果某个时刻需要的课程数量超过了 <spanclass="math inline">\(nm\)</span>，那么不行。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, a[N], b[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cil</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x+y<span class="hljs-number">-1</span>)/y; &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> nd=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&lt;b[i]) nd+=<span class="hljs-built_in">cil</span>(x,b[i]);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(a[i]*m&gt;=x) nd+=<span class="hljs-built_in">cil</span>(x,a[i]);<span class="hljs-keyword">else</span> nd+=m+<span class="hljs-built_in">cil</span>(x-a[i]*m,b[i]);&#125;<span class="hljs-keyword">if</span>(nd&gt;n*m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1000000000000000010</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div><h2 id="luogu8432-ぽかぽかの星">luogu8432 ぽかぽかの星</h2><h3 id="分析-4">分析</h3><p>发现直接做比较困难。</p><p>考虑从值域下手。把相加为 <span class="math inline">\(k+1\)</span>的数两两分组，<span class="math inline">\((1,k)\)</span>，<spanclass="math inline">\((2,k-1)\)</span>，<spanclass="math inline">\(\cdots\)</span>。</p><p>对于任意一组，至少有一个数出现的次数为 <spanclass="math inline">\(0\)</span>。</p><p>设 <span class="math inline">\(m\)</span> 为组数。</p><p>当 <span class="math inline">\(2 \mid k\)</span>时，有正好偶数组。</p><p>枚举非全 <span class="math inline">\(0\)</span> 的组数 <spanclass="math inline">\(i\)</span>，方案数 <spanclass="math inline">\(\binom{m}{i}\)</span>，将 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(1\)</span> 分配到 <spanclass="math inline">\(i\)</span> 组中，每一组不能为 <spanclass="math inline">\(0\)</span>，方案数 <spanclass="math inline">\(\binom{n-1}{i-1}\)</span>，每一组有 <spanclass="math inline">\(2\)</span> 种方法，方案数为 <spanclass="math inline">\(2^i\)</span>。</p><p>答案为 <span class="math display">\[\sum_{i=1}^{\min(n,m)} \binom{m}{i} \binom{n-1}{i-1} 2^i\]</span> 当 <span class="math inline">\(2 \nmid k\)</span>时，存在一个孤立的数字。</p><p>那么一次统计去掉它的方案数，一次强制选择它，累加即可。</p><p>答案 <span class="math display">\[\sum_{i=1}^{\min(n,m)} \binom{m}{i} \binom{n-1}{i-1} 2^i +\sum_{i=1}^{\min(n-1,m)} \binom{m}{i} \binom{n-2}{i-1} 2^i\]</span></p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> t, n, k, fac[N], inv[N], p2[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">1</span>]=inv[<span class="hljs-number">0</span>]=p2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;p2[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">5e6</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod, p2[i]=p2[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;inv[N<span class="hljs-number">-5</span>]=<span class="hljs-built_in">fp</span>(fac[N<span class="hljs-number">-5</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N<span class="hljs-number">-6</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> n&lt;=m? <span class="hljs-number">1</span>:fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,k);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> m=k/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(n,m);++i) (ans+=<span class="hljs-built_in">C</span>(m,i)*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,i<span class="hljs-number">-1</span>)%mod*p2[i]%mod)%=mod;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> m=(k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(n,m);++i) (ans+=<span class="hljs-built_in">C</span>(m,i)*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,i<span class="hljs-number">-1</span>)%mod*p2[i]%mod)%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(n<span class="hljs-number">-1</span>,m);++i) (ans+=<span class="hljs-built_in">C</span>(m,i)*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-2</span>,i<span class="hljs-number">-1</span>)%mod*p2[i]%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="luogu5689-多叉堆">luogu5689 多叉堆</h2><h3 id="分析-5">分析</h3><p>套路题。</p><p>设 <span class="math inline">\(f_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的树的方案数。</p><p>对于 <span class="math inline">\(x\)</span> 合并到 <spanclass="math inline">\(y\)</span>，只需要钦定 <spanclass="math inline">\(y\)</span> 的根为 <spanclass="math inline">\(0\)</span>，随便选出 <spanclass="math inline">\(sz_x\)</span> 个数放到 <spanclass="math inline">\(x\)</span> 里面，都有 <spanclass="math inline">\(f_x\)</span> 种方法，其他的节点的方案数为 <spanclass="math inline">\(f_y\)</span>，所以得到 <spanclass="math display">\[f_y = \binom{sz_y + sz_x -1}{sz_x} f_x f_y\]</span> 用并查集维护合并操作即可。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, q, fa[N], sz[N], fac[N], inv[N], f[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);sz[y]+=sz[x];fa[x]=y;f[y]=(f[y]*f[x]%mod*<span class="hljs-built_in">C</span>(sz[y]<span class="hljs-number">-1</span>,sz[x])%mod)%mod;<span class="hljs-comment">// do DP</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) fa[i]=i, f[i]=<span class="hljs-number">1</span>, sz[i]=<span class="hljs-number">1</span>;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[n]=<span class="hljs-built_in">fp</span>(fac[n],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-type">int</span> lst=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> x=(<span class="hljs-built_in">read</span>()+lst)%n, y=(<span class="hljs-built_in">read</span>()+lst)%n;<span class="hljs-built_in">merge</span>(x,y);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x=(<span class="hljs-built_in">read</span>()+lst)%n;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,lst=f[<span class="hljs-built_in">get</span>(x)]);&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>二分答案</tag>
      
      <tag>组合数学</tag>
      
      <tag>并查集</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8112 符文破译 题解</title>
    <link href="/2022/lg8112-solution/"/>
    <url>/2022/lg8112-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>显然 <span class="math inline">\(Z\)</span> 函数。</p><p>由于在 <span class="math inline">\(Z\)</span>函数中考虑的是匹配串的后缀，所以从后往前考虑。</p><p>设 <span class="math inline">\(f_i\)</span> 为考虑 <spanclass="math inline">\([i,n]\)</span>，能够划分的最小段数，设 <spanclass="math inline">\(g_i\)</span> 为匹配串的 <spanclass="math inline">\([i,n]\)</span> 与模式串的 LCP 长度。</p><p>转是显然的。</p><p><span class="math display">\[f_i = \min_{j \in [i+1,i+g_i]} \{ f_j  \} + 1\]</span></p><p>虽然 <span class="math inline">\(i+g_i\)</span>不存在单调性，但是考虑如果存在 <spanclass="math inline">\(i&lt;j\)</span>，满足 <spanclass="math inline">\(g_i &gt; g_j\)</span>，那么从 <spanclass="math inline">\(j\)</span> 划分一定不优，于是直接把 <spanclass="math inline">\(j\)</span>删掉就行，这样就满足单调性，可以用单调队列优化。</p><p>不难证明，如果这样做后无解，那么不这样做一定无解。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, z[N], g[N], f[N], q[N];<span class="hljs-type">char</span> s[N], t[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;z[<span class="hljs-number">0</span>]=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) z[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;z[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(i+z[i]&lt;n&amp;&amp;t[z[i]]==t[i+z[i]]) ++z[i];<span class="hljs-keyword">if</span>(r&lt;i+z[i]<span class="hljs-number">-1</span>) l=i, r=i+z[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exkmp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">Z</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>, r=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) g[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;g[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(i+g[i]&lt;m&amp;&amp;t[g[i]]==s[i+g[i]]) ++g[i];<span class="hljs-keyword">if</span>(r&lt;i+g[i]<span class="hljs-number">-1</span>) l=i, r=i+g[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,t,s);<span class="hljs-built_in">exkmp</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-type">int</span> k=i+g[i];<span class="hljs-keyword">if</span>(j&gt;k) g[i]=inf; <span class="hljs-keyword">else</span> j=k;&#125;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));f[m]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;q[l]=m;<span class="hljs-comment">// 初始决策，使得f[q[l]]=0</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;~i;--i) <span class="hljs-keyword">if</span>(g[i]!=inf) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;i+g[i]) ++l;f[i]=f[q[l]]+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[q[r]]&gt;=f[i]) --r;q[++r]=i;&#125;<span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>]&lt;inf) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">0</span>]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Fake&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
      <tag>字符串</tag>
      
      <tag>扩展kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6381 Odyssey 题解</title>
    <link href="/2022/lg6381-solution/"/>
    <url>/2022/lg6381-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>对于 <span class="math inline">\(ab = c^k\)</span>，不难想到把 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 都分解。</p><p><span class="math display">\[a= \prod_{i=1}^{c_a} p^{x_i}_i\]</span></p><p><span class="math display">\[b=\prod_{i=1}^{c_b} p^{y_i}_i\]</span></p><p>对于一个 <span class="math inline">\(p_i\)</span>，一定有 <spanclass="math inline">\(x_i + y_i \equiv 0 \pmod{k}\)</span>。</p><p>不难想到，一旦 <span class="math inline">\(a\)</span>确定了，就可以限定 <spanclass="math inline">\(b\)</span>，这样就是一个分层图的结构。</p><p>对于一个 <span class="math inline">\(w\)</span>，可以预处理出其分解中所有指数在对 <span class="math inline">\(k\)</span>取模的意义下的值。 <span class="math display">\[w_1 = \prod_{i=1}^{c_w} p^{x_i \bmod k}_i\]</span> 和 <span class="math display">\[w_2 = \prod_{i=1}^{c_w} p^{k - x_i \bmod k}_i\]</span> 将所有 <span class="math inline">\(w_i\)</span>都这样处理，合法路径就都被确定了。两条边 <spanclass="math inline">\((i,j)\)</span> 形成的路径合法，当且仅当 <spanclass="math inline">\(w_2(i) =w_1(j)\)</span>。这相当于是一张分层图。</p><p>为了处理点与边，所以状态设计得比较不可读。</p><p>设 <span class="math inline">\(f_{x,d}\)</span> 为以节点 <spanclass="math inline">\(x\)</span> 结尾，出边 <spanclass="math inline">\(i\)</span> 满足 <spanclass="math inline">\(w_2(i)=d\)</span> 的最长路径。拓扑排序即可。</p><p><span class="math display">\[f_{x,w2(i)} + z \rightarrow f_{y,w1(i)}\]</span></p><p>其中 <span class="math inline">\(z=l(i)\)</span>。</p><p><span class="math inline">\(w_1\)</span> 和 <spanclass="math inline">\(w_2\)</span>的范围可能很大，但数量不多，使用<code>std::unordered_map</code>实现。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, k, ans, in[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N], w[<span class="hljs-number">2</span>*N], e[<span class="hljs-number">2</span>*N], l[<span class="hljs-number">2</span>*N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; f[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">devide1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i, ++c;c%=k;<span class="hljs-keyword">while</span>(c--) ans*=i;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>&amp;&amp;k!=<span class="hljs-number">1</span>) ans*=x;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">devide2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i, ++c;c%=k;<span class="hljs-keyword">if</span>(c) &#123;<span class="hljs-type">int</span> tc=k-c;<span class="hljs-keyword">while</span>(tc--) ans*=i;&#125;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> tc=k<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(tc--) ans*=x;&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> li)</span> </span>&#123;to[++tot]=y, w[tot]=<span class="hljs-built_in">devide1</span>(z), e[tot]=<span class="hljs-built_in">devide2</span>(z), l[tot]=li;nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">// do DP</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], w1=w[i], w2=e[i], z=l[i];f[y][w1]=<span class="hljs-built_in">max</span>(f[y][w1],f[x][w2]+z);ans=<span class="hljs-built_in">max</span>(ans,f[y][w1]);<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>(), li=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z,li), ++in[y];&#125;    <span class="hljs-built_in">toposort</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>数论</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8564 ρars/ey 题解</title>
    <link href="/2022/lg8564-solution/"/>
    <url>/2022/lg8564-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>设 <span class="math inline">\(c(i)\)</span>为一次删去同一棵子树内不包括根的 <spanclass="math inline">\(i-1\)</span> 个节点的代价。</p><h3 id="链">链</h3><p>将 <span class="math inline">\(1\)</span> 号节点作为链首，不难想到设<span class="math inline">\(f_i\)</span> 为删掉以 <spanclass="math inline">\(i\)</span>为根的子树的最小代价，每次删掉的都是连续的一段，所以 <spanclass="math display">\[f_i = \min_{j \in [i+1,n]}\{ f_j + c(j-i+1)\}\]</span> 答案 <span class="math inline">\(f_1\)</span>。</p><h3 id="菊花">菊花</h3><p>显然，答案为 <span class="math inline">\(c(n)\)</span>。</p><h3 id="正解">正解</h3><p>设 <span class="math inline">\(f_{x,j}\)</span> 为以 <spanclass="math inline">\(x\)</span>为根的子树，完成所有子节点的删除操作后，还剩下 <spanclass="math inline">\(j\)</span> 个节点的最小代价。</p><p>注意到 <span class="math inline">\(j\)</span> 就是 <spanclass="math inline">\(x\)</span>的所有儿子节点剩下的节点数量之和，这个可以转化为用一个类似于树形背包的转移。</p><p>树形背包的实现方式是「对于一个节点 <spanclass="math inline">\(x\)</span>，将其子树 <spanclass="math inline">\(y\)</span> 依次加入以 <spanclass="math inline">\(x\)</span>为根的子树，同时合并信息」。这个状态也可以这样去合并。但为什么这个不是树形背包呢？因为并没有所谓「一个固定的容积」，这就导致了处理<span class="math inline">\(f\)</span>时必须严格维护当前树的大小，同时只处理 <spanclass="math inline">\(sz(x)\)</span> 位，</p><p>先对于 <span class="math inline">\(x\)</span> 的儿子节点 <spanclass="math inline">\(y\)</span>，进行一个合并 <spanclass="math display">\[f_{x,j+k} = \min_{k \in [1,sz(y)]}\{ f_{x,j} + f_{y,k} \}\]</span> <span class="math inline">\(j \in [cnt+1,s+1]\)</span>，其中<span class="math inline">\(cnt\)</span> 是在加入 <spanclass="math inline">\(y\)</span> 之前，已经加入的子树个数，<spanclass="math inline">\(s\)</span> 就是这些子树的大小之和。</p><p>然后进行 <span class="math inline">\(x\)</span> 的一次删除。 <spanclass="math display">\[f_{x,1} = \min\{ f_{x,k} + c(k) \}\]</span> 复杂度是 <span class="math inline">\(O(n^2)\)</span>的，实现不当则会退化成 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, a[N], sz[N], f[N][N], F[N], deg[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-keyword">namespace</span> sub1 &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,a[n]);&#125;&#125;;<span class="hljs-keyword">namespace</span> sub2 &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(F,<span class="hljs-number">0x3f</span>);F[n]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;F[i]=<span class="hljs-built_in">min</span>(F[i],F[j]+a[j-i+<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,F[<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-keyword">namespace</span> bf &#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;sz[x];++i) f[x][i]=<span class="hljs-number">1e15</span>;f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=s+<span class="hljs-number">1</span>;j&gt;=cnt+<span class="hljs-number">1</span>;--j) &#123;                <span class="hljs-comment">// 倒序循环</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) f[x][j+k]=<span class="hljs-built_in">min</span>(f[x][j+k],f[x][j]+f[y][k]);f[x][j]=<span class="hljs-number">1e15</span>;                <span class="hljs-comment">// 顺便置为正无穷</span>&#125;++cnt, s+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=cnt;j;--j) f[x][j]=<span class="hljs-number">1e15</span>;&#125;f[x][<span class="hljs-number">1</span>]=a[sz[x]];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=cnt+<span class="hljs-number">1</span>;k&lt;=sz[x];++k) f[x][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[x][<span class="hljs-number">1</span>],f[x][k]+a[k]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-type">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(deg[i]&gt;=<span class="hljs-number">2</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(deg[<span class="hljs-number">1</span>]!=<span class="hljs-number">1</span>&amp;&amp;fg) sub1::<span class="hljs-built_in">solve</span>(); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(deg[<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>&amp;&amp;fg) sub2::<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">else</span> bf::<span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8231 沈阳大街 2 题解</title>
    <link href="/2022/lg8231-solution/"/>
    <url>/2022/lg8231-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>以下部分内容来自洛谷题解</p><p>把两个序列看成二分图，对于一个排列 <spanclass="math inline">\(p\)</span>，左面点 <spanclass="math inline">\(i\)</span> 和右面点 <spanclass="math inline">\(p_i\)</span>连一条边，这样就恰好形成一组完美匹配。</p><p>现在我们变成这样一个问题：<span class="math inline">\((i,j)\)</span>的边权是 <spanclass="math inline">\(\min(A_i,B_j)\)</span>，定义一个完美匹配权值是所有边权的积，你要求所有完美匹配权值之和。</p><p>这样还是不太好做，考虑两个序列都从大到小排序，然后把边定向，定义成点权较小的点向点权较大的点的有向边。</p><p>这样定向后就有一个性质：<strong>每个点的出边边权相同并且为这个点的点权，而且这些边指向的点为对面点一个前缀。</strong></p><p>设 <span class="math inline">\(f(i,j)\)</span> 为考虑 <spanclass="math inline">\([1,i]\)</span> 的匹配，匹配了 <spanclass="math inline">\(j\)</span> 个的值。</p><p>设 <span class="math inline">\(k\)</span> 为 <spanclass="math inline">\([1,i-1]\)</span> 中与 <spanclass="math inline">\(i\)</span> 在二分图中不在同一边的节点个数，<spanclass="math inline">\(c_i\)</span> 为 <spanclass="math inline">\(i\)</span> 的值。 <span class="math display">\[f(i,j) = f(i-1,j-1) \cdot c_i \cdot \big(k-(j-1)\big) + f(i-1,j)\]</span> 答案是 <span class="math inline">\(f(2n,n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, f[<span class="hljs-number">2</span>*N][N], sa[<span class="hljs-number">2</span>*N], sb[<span class="hljs-number">2</span>*N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IEE</span> &#123;<span class="hljs-type">int</span> q, val;&#125; a[<span class="hljs-number">2</span>*N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(IEE a,IEE b) &#123;<span class="hljs-keyword">if</span>(a.val!=b.val) <span class="hljs-keyword">return</span> a.val&gt;b.val;<span class="hljs-keyword">return</span> a.q&lt;b.q;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=(IEE)&#123;<span class="hljs-number">1</span>,<span class="hljs-built_in">read</span>()&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i+n]=(IEE)&#123;<span class="hljs-number">2</span>,<span class="hljs-built_in">read</span>()&#125;;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) sa[i]=sa[i<span class="hljs-number">-1</span>]+(a[i].q==<span class="hljs-number">1</span>), sb[i]=sb[i<span class="hljs-number">-1</span>]+(a[i].q==<span class="hljs-number">2</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) &#123;<span class="hljs-type">int</span> lim=a[i].q==<span class="hljs-number">1</span>? sb[i]:sa[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-built_in">min</span>(n,i);++j) &#123;<span class="hljs-keyword">if</span>(j&amp;&amp;lim-j+<span class="hljs-number">1</span>&gt;<span class="hljs-number">0</span>) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]*a[i].val%mod*(lim-j+<span class="hljs-number">1</span>)%mod;(f[i][j]+=f[i<span class="hljs-number">-1</span>][j])%=mod;&#125;&#125;<span class="hljs-type">int</span> d=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) d=d*i%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">2</span>*n][n]*<span class="hljs-built_in">fp</span>(d,mod<span class="hljs-number">-2</span>)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题选讲3</title>
    <link href="/2022/tititi-solution-3/"/>
    <url>/2022/tititi-solution-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="luogu2135-方块消除">luogu2135 方块消除</h2><h3 id="分析">分析</h3><p>把同颜色方块区域转化成同色方块相邻，排成一列。</p><p>发现是套路区间 DP。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span>，其中右侧有 <spanclass="math inline">\(k\)</span> 个和 <spanclass="math inline">\(j\)</span> 同色的东西。</p><p>设 <span class="math inline">\(c_i\)</span> 为 <spanclass="math inline">\(i\)</span> 的颜色，<spanclass="math inline">\(d_i\)</span> 为和 <spanclass="math inline">\(i\)</span> 颜色相同的方块数量。</p><p>一个显然的结论：同色方块会被同时删掉。</p><p>证明略。</p><p>这个结论可以把我们的状态中的 <spanclass="math inline">\([i,j]\)</span> 变成从第 <spanclass="math inline">\(i\)</span> 中颜色到第 <spanclass="math inline">\(j\)</span> 种颜色。</p><p>直接删去右边这一段 <span class="math display">\[f(i,j,k) = f(i,j-1,0) + (d_j + k) ^ 2\]</span> 套路性地枚举断点 <span class="math display">\[f(i,j,k) = \max_{l \in [1,r-1]} \{ f(i,l,d_j + k) + f(l+1,j-1,0) \}\]</span> 其中 <span class="math inline">\(c_l = c_j\)</span>。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-type">int</span> n, c[N], d[N], f[N][N][<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> rr=d[r]+p;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> rr*rr;<span class="hljs-keyword">if</span>(~f[l][r][rr]) <span class="hljs-keyword">return</span> f[l][r][rr];<span class="hljs-type">int</span>&amp; x=f[l][r][rr];x=<span class="hljs-built_in">dp</span>(l,r<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+rr*rr;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l;k&lt;r;++k) <span class="hljs-keyword">if</span>(c[k]==c[r]) &#123;x=<span class="hljs-built_in">max</span>(x,<span class="hljs-built_in">dp</span>(l,k,rr)+<span class="hljs-built_in">dp</span>(k+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>));&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) d[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>));&#125;</code></pre></div><h2 id="luogu6146-help-yourself">luogu6146 Help Yourself</h2><h3 id="分析-1">分析</h3><p>看到子集，显然统计贡献。</p><p>根据必修一的知识，我们知道对于一个元素 <spanclass="math inline">\(i\)</span>，它在全集的任意一个子集中，只有选和不选两种方案。</p><p>设 <span class="math inline">\(f_i\)</span> 为前 <spanclass="math inline">\(i\)</span> 条线段所产生的贡献。</p><p>不选 <spanclass="math inline">\(i\)</span>，那么不会产生任何贡献。</p><p>选 <span class="math inline">\(i\)</span>，那么如果存在 <spanclass="math inline">\(j\)</span>，满足 <span class="math inline">\(r_j&lt; l_i\)</span>，那么 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span> 必然不连通。设这样的 <spanclass="math inline">\(j\)</span> 的数量为 <spanclass="math inline">\(x\)</span>，那么贡献为 <spanclass="math inline">\(2^x\)</span>。</p><p>那么 <span class="math display">\[f_i = f_{i-1} + f_{i-1} + 2^x\]</span> 简单维护线段右端点的信息即可。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, f[N], c[<span class="hljs-number">2</span>*N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> l first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> r second</span>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i].l=<span class="hljs-built_in">read</span>(), a[i].r=<span class="hljs-built_in">read</span>(), ++c[a[i].r];<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) c[i]+=c[i<span class="hljs-number">-1</span>];f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]%mod+<span class="hljs-built_in">fp</span>(<span class="hljs-number">2</span>,c[a[i].l<span class="hljs-number">-1</span>]))%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div><h2 id="luogu6733-间歇泉">luogu6733 间歇泉</h2><h3 id="分析-2">分析</h3><p>考虑二分第 <span class="math inline">\(k\)</span> 大的温度 <spanclass="math inline">\(T\)</span>。</p><p>问题转化为求满足下面式子的 <span class="math inline">\((i,j)\)</span>的个数是否大于等于 <span class="math inline">\(k\)</span>。 <spanclass="math display">\[T \le \frac{a_i c_i + a_j c_j}{a_i + a_j}\]</span> 把式子拆开 <span class="math display">\[a_iT + a_j T \le a_i c_i + a_j c_j\]</span></p><p><span class="math display">\[a_i c_i - a_i T \ge a_j T - a_j c_j\]</span></p><p>发现这些变量的数量是 <span class="math inline">\(O(n)\)</span>级别的。</p><p>求出对于每个 <span class="math inline">\(i\)</span>，满足条件的 <spanclass="math inline">\(j\)</span> 的数量即可。</p><p>排序后双指针。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-5</span>;<span class="hljs-type">int</span> n, k, a[N], c[N];<span class="hljs-type">double</span> p[N], q[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">double</span> u=<span class="hljs-number">1.0</span>*a[i]*c[i], v=x*a[i];p[i]=u-v, q[i]=v-u;<span class="hljs-keyword">if</span>(q[i]-p[i]&lt;eps) --cnt;        <span class="hljs-comment">// 如果相等了，那么只能算1个</span>&#125;<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>((q[j+<span class="hljs-number">1</span>]-p[i])&lt;eps&amp;&amp;j+<span class="hljs-number">1</span>&lt;=n) ++j;cnt+=j;&#125;<span class="hljs-keyword">return</span> (cnt/<span class="hljs-number">2</span>&lt;k);    <span class="hljs-comment">// 数对是无序的，所以要/2</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">double</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">1e9</span>;<span class="hljs-keyword">while</span>(r-l&gt;eps) &#123;<span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf\n&quot;</span>,l);&#125;</code></pre></div><h2 id="luogu8161-自学-self-study">luogu8161 自学 (Self Study)</h2><h3 id="分析-3">分析</h3><p>二分答案 <span class="math inline">\(x\)</span>。</p><p>如果某个科目，自学的收益完全大于上课，那么直接全部自学。</p><p>否则如果上满 <span class="math inline">\(m\)</span> 节课能够到达<span class="math inline">\(x\)</span>，那么就上课。</p><p>否则就自学。</p><p>维护一个总共需要的课程数量，如果大于 <spanclass="math inline">\(nm\)</span>，那么无解。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, a[N], b[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cil</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x+y<span class="hljs-number">-1</span>)/y; &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> nd=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&lt;b[i]) nd+=<span class="hljs-built_in">cil</span>(x,b[i]);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(a[i]*m&gt;=x) nd+=<span class="hljs-built_in">cil</span>(x,a[i]);<span class="hljs-keyword">else</span> nd+=m+<span class="hljs-built_in">cil</span>(x-a[i]*m,b[i]);&#125;<span class="hljs-keyword">if</span>(nd&gt;n*m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1000000000000000010</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div><h2 id="luogu8359-垃圾回收">luogu8359 垃圾回收</h2><p>删边转化倒序加边，并查集维护连通块。</p><p>没啥可说的，实现注意细节。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, q, cnt, fa[N], w[N], r[N], alive[N];<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;string str;<span class="hljs-type">bool</span> v[N], vis[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> x, y; &#125; e[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">pp</span> &#123; <span class="hljs-type">int</span> op, x; &#125; p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);x=<span class="hljs-built_in">get</span>(x),  y=<span class="hljs-built_in">get</span>(y);fa[x]=y;    <span class="hljs-comment">// 加边也是合并</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(vis[x]) <span class="hljs-keyword">return</span>;vis[x]=<span class="hljs-number">1</span>;r[++cnt]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-built_in">dfs</span>(y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<span class="hljs-built_in">dfs</span>(x);    <span class="hljs-comment">// 找出x所在连通块的所有点</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) e[i].x=<span class="hljs-built_in">read</span>(), e[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;cin&gt;&gt;str;<span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;GC&quot;</span>) p[i].op=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> p[i].op=<span class="hljs-number">1</span>, p[i].x=<span class="hljs-built_in">read</span>(), v[p[i].x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) w[i]=<span class="hljs-built_in">read</span>(), fa[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!v[i]) <span class="hljs-built_in">addedge</span>(e[i].x,e[i].y);    <span class="hljs-comment">// 没有被删去的边</span><span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i) alive[r[i]]=q+<span class="hljs-number">1</span>;    <span class="hljs-comment">// q+1时刻被删去的点</span><span class="hljs-type">int</span> lst=q+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=q;i;--i) &#123;<span class="hljs-keyword">if</span>(p[i].op==<span class="hljs-number">2</span>) lst=i;        <span class="hljs-comment">// 维护上一次删点的时刻</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x=e[p[i].x].x, y=e[p[i].x].y;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">get</span>(x)) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)==<span class="hljs-built_in">get</span>(x)&amp;&amp;<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">get</span>(y)) &#123;<span class="hljs-built_in">find</span>(y);                <span class="hljs-comment">// y被合并，y所在连通块要等到(x,y)被删掉之后的lst时间才会被删除</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;++j) alive[r[j]]=lst;&#125;<span class="hljs-built_in">addedge</span>(x,y);&#125;&#125;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) <span class="hljs-keyword">if</span>(p[i].op==<span class="hljs-number">2</span>) &#123;fg=i;<span class="hljs-keyword">break</span>;&#125;    <span class="hljs-comment">// 这些点从始至终和1不连通</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">get</span>(i)) alive[i]=fg;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=w[i]*alive[i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="luogu6394-樱花还有你">luogu6394 樱花，还有你</h2><p>过于套路了。。。</p><p>放个代码就完了。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e3</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">10086001</span>;<span class="hljs-type">int</span> n, k, sum, ans, a[N], s[N], f[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) a[i]=<span class="hljs-built_in">read</span>(), sum+=a[i];<span class="hljs-keyword">if</span>(sum&lt;n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=a[<span class="hljs-number">1</span>];++i) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]&gt;=n) ++ans;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(j&gt;a[i]) (f[j]=s[j]-s[j-a[i]<span class="hljs-number">-1</span>]+mod)%=mod;<span class="hljs-keyword">else</span> f[j]=s[j];&#125;s[<span class="hljs-number">0</span>]=f[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) s[j]=(s[j<span class="hljs-number">-1</span>]+f[j])%mod;(ans+=f[n])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="luogu8365-吃">luogu8365 吃</h2><h3 id="分析-4">分析</h3><p>显然加法在乘法前面。</p><p>如果 <span class="math inline">\(a_i = 1\)</span>，那么必然选择加上<span class="math inline">\(b_i\)</span>。</p><p>注意到除了上述情况，加法最多进行 <spanclass="math inline">\(1\)</span> 次。</p><blockquote><p>证明：</p><p>我们的目的是最大化体重。</p><p>假如第一次加了 <span class="math inline">\(b_i\)</span>，第二次加了<span class="math inline">\(b_j\)</span>，钦定 <spanclass="math inline">\(b_i \le b_j\)</span>，那么收益为 <spanclass="math inline">\(b_i + b_j\)</span>。而此时所有的 <spanclass="math inline">\(a_i \neq 1\)</span>，所以选择乘上 <spanclass="math inline">\(a_j\)</span> 的收益至少是 <spanclass="math inline">\(2b_i\)</span>，显然不劣于 <spanclass="math inline">\(b_i + b_j\)</span>。</p><p>证毕。</p></blockquote><p>直接挑最大的加上显然是错的。</p><p>考虑从 <span class="math inline">\(j\)</span> 做加法的收益 <spanclass="math inline">\(d + \frac{\prod_{i=1}^n a_i}{a_j} +b_j\)</span>。其中 <span class="math inline">\(d\)</span> 为满足 <spanclass="math inline">\(a_i = 1\)</span> 的 <spanclass="math inline">\(b_i\)</span> 之和。</p><p>注意到分子会爆，但是又不能取模。考虑我们只关心相对大小，那么直接判断<span class="math inline">\(\frac{d+b_j}{a_j}\)</span> 的大小即可。</p><p>然后就做完了。</p><h3 id="code-6">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, d=<span class="hljs-number">1</span>;<span class="hljs-type">bool</span> v[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span>PII a[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i].x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i].x==<span class="hljs-number">1</span>) d+=a[i].y, v[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-type">double</span> w=d;<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-type">double</span> dlt=<span class="hljs-number">1.0</span>*(d+a[i].y)/a[i].x;<span class="hljs-keyword">if</span>(dlt&gt;w) w=dlt, p=i;&#125;(d+=a[p].y)%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]&amp;&amp;i!=p) (d*=a[i].x)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d);&#125;</code></pre></div><h2 id="luogu8552-rabbit">luogu8552 Rabbit</h2><h3 id="分析-5">分析</h3><p>直接没有原则地选点是很盲目的。</p><p>注意到如果某个点是全局最大点，那么它与任意两点相连，都能构成一次合法的操作。</p><p>考虑这样一个事实：连通块信息是很好维护的。</p><p>把上面两点看作两个独立的连通块，从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 枚举最大点，用并查集维护即可。</p><p>容易证明所有合法操作都能转化成上述形式，且不重不漏。</p><p>对于边 <span class="math inline">\((x,y)\)</span>，连边 <spanclass="math inline">\(\big(\max(x,y),\min(x,y)\big)\)</span>。按照节点编号从 <span class="math inline">\(1\)</span> 到<span class="math inline">\(n\)</span>加边，用并查集维护上述关系即可。</p><h3 id="code-7">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, ans, fa[N], remain[N];<span class="hljs-type">int</span> tot, h[N], to[N], nxt[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-number">0</span>, fa[i]=i, remain[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(<span class="hljs-built_in">max</span>(x,y),<span class="hljs-built_in">min</span>(x,y));&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=<span class="hljs-built_in">get</span>(to[i]);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(remain[y]) ++cnt;remain[x]+=remain[y];            <span class="hljs-comment">// remain[x]是x所在连通块内没有被标记的点的数量</span>fa[y]=x;&#125;<span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">2</span>) remain[x]-=<span class="hljs-number">3</span>, ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>贪心</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF402D Upgrading Array 题解</title>
    <link href="/2022/cf402d-solution/"/>
    <url>/2022/cf402d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>注意到 <span class="math inline">\(f\)</span>的过程就是唯一分解的过程。</p><p>考虑 <span class="math inline">\(g = \gcd\{a_{1 \simi}\}\)</span>，发现除去 <span class="math inline">\(g\)</span>之后，相当于原来的总和减去 <spanclass="math inline">\(f(g)\)</span>，贡献为 <spanclass="math inline">\(i \times -f(g)\)</span>。</p><p>设 <span class="math inline">\(F(i)\)</span> 为以 <spanclass="math inline">\(i\)</span> 结尾的前缀，能够产生的最大贡献。</p><p>由于可以进行多次，所以可能在让 <span class="math inline">\(a_{1 \simi}\)</span> 除去 <span class="math inline">\(g\)</span>之前，其中某些数已经被修改过了，所以枚举 <span class="math inline">\(j\in [1,i-1]\)</span>，表示前缀 <spanclass="math inline">\([1,j]\)</span> 中已经没有了 <spanclass="math inline">\(g\)</span> 这个因子，因此 <spanclass="math display">\[F(i) = \min_{j \in [0,i-1]} \{ F(j) + (i-j) \times - f(g) \}\]</span> 通过操作产生的最大贡献为 <spanclass="math inline">\(F_{\max}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, dlt, ans, a[N], f[N];<span class="hljs-type">int</span> cnt, v[N], p[N];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; bad;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=<span class="hljs-number">1e5</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;p[i]*p[i]&lt;=x;++i) <span class="hljs-keyword">if</span>(x%p[i]==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%p[i]==<span class="hljs-number">0</span>) x/=p[i], ++tot;d+=bad[p[i]]? -tot:tot;&#125;<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">1</span>) d+=bad[x]? <span class="hljs-number">-1</span>:<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">ora</span>();n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) bad[<span class="hljs-built_in">read</span>()]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) dlt+=<span class="hljs-built_in">F</span>(a[i]);<span class="hljs-type">int</span> g=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;g=<span class="hljs-built_in">gcd</span>(g,a[i]);<span class="hljs-type">int</span> d=<span class="hljs-built_in">F</span>(g);f[i]=i*(-d);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) f[i]=<span class="hljs-built_in">max</span>(f[i],f[j]+(i-j)*(-d));ans=<span class="hljs-built_in">max</span>(ans,f[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dlt+ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF847E Packmen 题解</title>
    <link href="/2022/cf847e-solution/"/>
    <url>/2022/cf847e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>最小化时间，可以考虑二分答案。</p><p>考虑将 Packmen 和物品的位置划分的成两个集合。由于 Packmen之间互不影响，所以只要分别贪心就好了。</p><p>不难想到，每个人去走的物品一定是连续的。</p><p>对于一个位置为 <span class="math inline">\(p_i\)</span> 的人 <spanclass="math inline">\(i\)</span> 和一个物品区间 <spanclass="math inline">\([l,r]\)</span>，能够在时间限制 <spanclass="math inline">\(x\)</span> 内完成，当且仅当 <spanclass="math inline">\(\Big( \min(|p_i - l|,|p_i - r|) + |r-l| \Big) \lex\)</span>。</p><p>维护 <span class="math inline">\(l\)</span> 和 <spanclass="math inline">\(r\)</span> 集合，<code>check</code>的复杂度是<span class="math inline">\(O(n)\)</span> 的。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n;<span class="hljs-type">char</span> s[N];vector&lt;<span class="hljs-type">int</span>&gt; a, b;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">can</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> t)</span> </span>&#123;<span class="hljs-type">int</span> d=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(p-l),<span class="hljs-built_in">abs</span>(p-r))+<span class="hljs-built_in">abs</span>(r-l);<span class="hljs-keyword">return</span> d&lt;=t;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i) &#123;r=l;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;r&lt;b.<span class="hljs-built_in">size</span>()&amp;&amp;<span class="hljs-built_in">can</span>(a[i],b[l],b[r],x)) ++r;l=r;&#125;<span class="hljs-keyword">return</span> l==b.<span class="hljs-built_in">size</span>();&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;*&#x27;</span>) b.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;P&#x27;</span>) a.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">5</span>*n;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1067A Array Without Local Maximums 题解</title>
    <link href="/2022/cf1067a-solution/"/>
    <url>/2022/cf1067a-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>套路题。</p><p>注意到值域是 <span class="math inline">\(200\)</span>。</p><p>设 <span class="math inline">\(f(i,j,0/1)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 位，第 <spanclass="math inline">\(i\)</span> 位放 <spanclass="math inline">\(j\)</span>，大于或小于等于第 <spanclass="math inline">\(i-1\)</span> 位的方案数。</p><p>可以钦定第 <span class="math inline">\(1\)</span> 位大于第 <spanclass="math inline">\(0\)</span> 位，第 <spanclass="math inline">\(n\)</span> 位小于等于第 <spanclass="math inline">\(n-1\)</span> 位。</p><p>转移 <span class="math display">\[f(i,j,0) = \sum_{k=1}^{j-1} \Big( f(i-1,k,0) + f(i-1,k,1) \Big)\]</span> 不管 <span class="math inline">\(k\)</span> 和 <spanclass="math inline">\(a_{i-2}\)</span> 的关系如何，都一定满足条件。<span class="math display">\[f(i,j,1) = \sum_{k=j}^{200} \Big( f(i-1,k,1) \Big) + f(i-1,j,0)\]</span> 当 <span class="math inline">\(a_{i-1} = j\)</span> 时，<spanclass="math inline">\(a_{i-2}\)</span>无论是多少都能满足条件，否则必须保证 <span class="math inline">\(a_{i-2}\ge a_{i-1}\)</span>。</p><p>当 <span class="math inline">\(a_i \neq -1\)</span>的时候，只要在转移稍加限制即可。</p><p>前缀和优化一下就过了，复杂度 <spanclass="math inline">\(O(200n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, a[N], f[N][<span class="hljs-number">205</span>][<span class="hljs-number">2</span>], s[N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>) f[<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, s[a[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i) f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, s[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i) s[i][<span class="hljs-number">0</span>]+=s[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">// for(int k=1;k&lt;a[i];++k) (f[i][a[i]][0]+=(f[i-1][k][0]+f[i-1][k][1])%mod)%=mod;</span><span class="hljs-comment">// for(int k=a[i];k&lt;=200;++k) (f[i][a[i]][1]+=f[i-1][k][1])%=mod;</span>f[i][a[i]][<span class="hljs-number">0</span>]=(s[a[i]<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+s[a[i]<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])%mod;f[i][a[i]][<span class="hljs-number">1</span>]=(s[<span class="hljs-number">200</span>][<span class="hljs-number">1</span>]-s[a[i]<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+mod)%mod;(f[i][a[i]][<span class="hljs-number">1</span>]+=f[i<span class="hljs-number">-1</span>][a[i]][<span class="hljs-number">0</span>])%=mod;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">200</span>;++j) &#123;f[i][j][<span class="hljs-number">0</span>]=(s[j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+s[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])%mod;f[i][j][<span class="hljs-number">1</span>]=(s[<span class="hljs-number">200</span>][<span class="hljs-number">1</span>]-s[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+mod)%mod;(f[i][j][<span class="hljs-number">1</span>]+=f[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>])%=mod;<span class="hljs-comment">// for(int k=1;k&lt;j;++k) &#123;</span><span class="hljs-comment">// (f[i][j][0]+=(f[i-1][k][0]+f[i-1][k][1])%mod)%=mod;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// for(int k=j;k&lt;=200;++k) &#123;</span><span class="hljs-comment">// (f[i][j][1]+=f[i-1][k][1])%=mod;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// (f[i][j][1]+=f[i-1][j][0])%=mod;</span>&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">200</span>;++j) &#123;s[j][<span class="hljs-number">0</span>]=(s[j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+f[i][j][<span class="hljs-number">0</span>])%mod;s[j][<span class="hljs-number">1</span>]=(s[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+f[i][j][<span class="hljs-number">1</span>])%mod;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[n]!=<span class="hljs-number">-1</span>) ans=f[n][a[n]][<span class="hljs-number">1</span>];<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i) (ans+=f[n][i][<span class="hljs-number">1</span>])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1312E Array Shrinking 题解</title>
    <link href="/2022/cf1312e-solution/"/>
    <url>/2022/cf1312e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>挺有启发意义的题目。</p><p>第一眼看上去像一个套路的区间 DP，但是区间想要合并必须满足值相等。</p><p>考虑设 <span class="math inline">\(g(i,j)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span> 最终合并成的值，如果不能合并为<span class="math inline">\(1\)</span> 个元素，那么为 <spanclass="math inline">\(-1\)</span>。</p><p>设 <span class="math inline">\(f(i)\)</span> 为以 <spanclass="math inline">\(i\)</span> 结尾的序列，能够划分的最短长度。 <spanclass="math display">\[f(i) = \min_{g(j,i) &gt; 0}\{ f(j-1) + 1\}\]</span> <span class="math inline">\(j\)</span> 实际上是个断点。</p><p>而 <span class="math inline">\(g(i,j)\)</span> 可以用类似于区间 DP的方式实现。</p><p>线性 DP 套一个区间 DP。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<span class="hljs-type">int</span> n, a[N], f[N], g[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-keyword">if</span>(g[i][j]) <span class="hljs-keyword">return</span> g[i][j];<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">return</span> g[i][j]=a[i];<span class="hljs-type">int</span>&amp; x=g[i][j];x=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;++k) &#123;<span class="hljs-type">int</span> p=<span class="hljs-built_in">dp</span>(i,k), q=<span class="hljs-built_in">dp</span>(k+<span class="hljs-number">1</span>,j);<span class="hljs-keyword">if</span>(p&gt;<span class="hljs-number">0</span>&amp;&amp;p==q) <span class="hljs-keyword">return</span> x=p+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dp</span>(j,i)&gt;<span class="hljs-number">0</span>) f[i]=<span class="hljs-built_in">min</span>(f[i],f[j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<span class="hljs-comment">// printf(&quot;kkk=[%lld,%lld]\n&quot;,i,j);</span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF845C Two TVs 题解</title>
    <link href="/2022/cf845c-solution/"/>
    <url>/2022/cf845c-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>离散化，然后如果某个时间同时存在至少 <spanclass="math inline">\(3\)</span> 个未结束的节目，那么无解。</p><p>差分即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, c[<span class="hljs-number">2</span>*N], d[<span class="hljs-number">2</span>*N];pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;p[i].x=<span class="hljs-built_in">read</span>(), p[i].y=<span class="hljs-built_in">read</span>();c[++m]=p[i].x, c[++m]=p[i].y;&#125;<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>)-c<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;p[i].x=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>,p[i].x)-c;p[i].y=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>,p[i].y)-c;&#125;<span class="hljs-comment">// sort(p+1,p+n+1);</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;++d[p[i].x], --d[p[i].y+<span class="hljs-number">1</span>];&#125;<span class="hljs-type">int</span> cc=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;cc+=d[i];<span class="hljs-keyword">if</span>(cc&gt;=<span class="hljs-number">3</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3594 WIL 题解</title>
    <link href="/2022/lg3594-solution/"/>
    <url>/2022/lg3594-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>显然，置零的区间长度一定为 <spanclass="math inline">\(d\)</span>，否则一定不优。</p><p>那么答案大于等于 <span class="math inline">\(d\)</span>。</p><p>暴力做法，枚举左右端点 <spanclass="math inline">\([i,j]\)</span>，贪心地减去区间里长度为 <spanclass="math inline">\(d\)</span> 的最大的一块，用前缀和搞一下，<spanclass="math inline">\(O(n^3)\)</span>。</p><p>考虑一个双指针做法，固定左端点 <spanclass="math inline">\(i\)</span>，贪心地让右端点在 <spanclass="math inline">\([i+d,n]\)</span> 中增长，维护区间内最大的长度为<span class="math inline">\(d\)</span> 的块。如果区间和大于 <spanclass="math inline">\(p\)</span> 了，那么看减去最大块之后是否合法，<spanclass="math inline">\(O(n^2)\)</span>。</p><p>考虑优化这个做法。</p><p>不难发现对于每个固定 <span class="math inline">\(i\)</span> 找 <spanclass="math inline">\(j\)</span>的过程，都要维护区间最大块，但是很多是重复的。反过来，固定右端点，维护最靠前的合法左端点，这个过程是个滑动窗口。而要维护的区间最大块，在这个过程中也是一个滑动窗口。</p><p>用单调队列维护当前 <span class="math inline">\([i,j]\)</span>区间最大块即可，复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, p, d, ans, a[N], s[N], q[N], c[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), p=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=d;i&lt;=n;++i) c[i]=s[i]-s[i-d];     <span class="hljs-comment">// c[i]表示以i结尾的，长度为d的块的和</span><span class="hljs-type">int</span> w=s[d];<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;q[l]=d;ans=d;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=d+<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-comment">// 这里写的是[j,i]</span>w+=a[i];<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;c[q[r]]&lt;=c[i]) --r;q[++r]=i;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;(w-c[q[l]])&gt;p) &#123;            <span class="hljs-comment">// 当前区间和减去最大块也不能满足</span><span class="hljs-keyword">if</span>(q[l]&lt;j+d) ++l;            <span class="hljs-comment">// q[l]&lt;j+d时，q[l]才非法</span>w-=a[j++];            <span class="hljs-comment">// 这个j就不可能作为左端点了</span>        &#125;ans=<span class="hljs-built_in">max</span>(ans,i-j+<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调队列</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Edu Codeforces Round」#134</title>
    <link href="/2022/cf1721-solution/"/>
    <url>/2022/cf1721-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1721</strong>.</p><h2 id="a.-image">A. Image</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string a, b;cin&gt;&gt;a&gt;&gt;b;a+=b;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:a) <span class="hljs-keyword">if</span>(++c[x-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>) ++ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-deadly-laser">B. Deadly Laser</h2><p>最优解一定是 <span class="math inline">\((1,1) \rightarrow (1,m)\rightarrow (n,m)\)</span> 或者 <span class="math inline">\((1,1)\rightarrow (n,1) \rightarrow (n,m)\)</span>。</p><p>前者距离 <span class="math inline">\((s_x,s_y)\)</span> 最近的距离是<span class="math inline">\(\min(s_x-1,m-s_y)\)</span>，后者是 <spanclass="math inline">\(\min(s_y-1,n-s_x)\)</span>。</p><p>如果二者都小于等于 <spanclass="math inline">\(d\)</span>，那么无解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n, m, x, y, d;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(x<span class="hljs-number">-1</span>,m-y)&lt;=d&amp;&amp;<span class="hljs-built_in">min</span>(y<span class="hljs-number">-1</span>,n-x)&lt;=d) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n+m<span class="hljs-number">-2</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-min-max-array-transformation">C. Min-Max ArrayTransformation</h2><p>对于 <span class="math inline">\(a_i\)</span>，<spanclass="math inline">\(d_i\)</span> 最小值显然是大于 <spanclass="math inline">\(a_i\)</span> 的最小的 <spanclass="math inline">\(b_i\)</span> 与它的差。</p><p>最大值则要复杂一些。例如样例 4 中，如果 <spanclass="math inline">\(d_1\)</span> 取 <spanclass="math inline">\(45\)</span>，那么 <spanclass="math inline">\(40\)</span>就没有合法决策了。而其它的数字，无论怎么选，都一定存在合法决策，贪心地取了最大的<span class="math inline">\(33\)</span>。</p><p>由于 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span> 都是有序的，所以从 <spanclass="math inline">\(n\)</span> 到 <spanclass="math inline">\(1\)</span> 考虑。<spanclass="math inline">\(40\)</span> 只能变成 <spanclass="math inline">\(55\)</span> 是因为前面所有的 <spanclass="math inline">\(b_i\)</span> 都小于 <spanclass="math inline">\(40\)</span>，而后面的数的决策区间也因此不包含<span class="math inline">\(55\)</span>。</p><p>维护最大值决策 <span class="math inline">\(j\)</span>，初始化为 <spanclass="math inline">\(n\)</span>，显然 <spanclass="math inline">\(j\)</span> 是单调不增的。对于 <spanclass="math inline">\(a_i\)</span>，当 <span class="math inline">\(b_1\sim b_{i-1}\)</span> 都小于 <span class="math inline">\(a_i\)</span>时，<span class="math inline">\([1,i-1]\)</span> 必然不能取 <spanclass="math inline">\(j \in[i,n]\)</span>，否则由于数字是一一对应的，<spanclass="math inline">\(a_i\)</span> 将无法决策。所以只要第一个大于等于<span class="math inline">\(a_i\)</span> 的是 <spanclass="math inline">\(b_i\)</span> 的话，那么令 <spanclass="math inline">\(j = i-1\)</span>，否则 <spanclass="math inline">\(d_i = b_j - a_i\)</span> 一定是最大决策。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N], b[N], d1[N], d2[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> j=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>,a[i])-b;d1[i]=b[k]-a[i];d2[i]=b[j]-a[i];<span class="hljs-keyword">if</span>(k==i) j=i<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,d1[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,d2[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-maximum-and">D. Maximum AND</h2><p>按位贪心。</p><p>答案的某一位是 <span class="math inline">\(1\)</span>，说明每个 <spanclass="math inline">\(c_i\)</span> 的这一位都是 <spanclass="math inline">\(1\)</span>，因此对于这一位，<spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 中必须存在两两对应的 <spanclass="math inline">\(n\)</span> 对 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 才行。</p><p>直接处理复杂度过高。</p><p>假设当前处理到了第 <span class="math inline">\(k\)</span>位，如果答案第 <span class="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>，那么在满足存在两两对应的 <spanclass="math inline">\(n\)</span> 对 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>之外，还要满足之前的位仍然不变，否则一定不优。</p><p>设答案为 <span class="math inline">\(d\)</span>，先让 <spanclass="math inline">\(d+2^k\)</span>，尝试将配对。<spanclass="math inline">\(a_i \&amp; d\)</span> 表示 <spanclass="math inline">\(a_i\)</span> 在此时 <spanclass="math inline">\(d\)</span> 中的有效位，<spanclass="math inline">\(b_i \&amp; d \oplus d\)</span> 表示 <spanclass="math inline">\(b_i\)</span> 的有效位关于 <spanclass="math inline">\(d\)</span> 的补集，如果它和某个 <spanclass="math inline">\(a_j \&amp; d\)</span> 相等，说明二者异或起来为<span class="math inline">\(d\)</span>，进而 <spanclass="math inline">\(a_j \oplus b_i\)</span> 一定满足第 <spanclass="math inline">\(k\)</span> 位位为 <spanclass="math inline">\(1\)</span> 和之前的所有条件。</p><p>使用<code>std::map</code>统计是否能够两两配对即可。</p><p>时间复杂度 <span class="math inline">\(O(n \log^2_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, d, a[N], b[N];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">29</span>;~k;--k) &#123;d|=<span class="hljs-number">1</span>&lt;&lt;k;p.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;++p[a[i]&amp;d];--p[(b[i]&amp;d)^d];&#125;<span class="hljs-type">bool</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(p[a[i]&amp;d]!=<span class="hljs-number">0</span>) &#123; d^=<span class="hljs-number">1</span>&lt;&lt;k; <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NowCoder Round X」#56</title>
    <link href="/2022/nxc56-solution/"/>
    <url>/2022/nxc56-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>NowCoderX56</strong>.</p><p>水。</p><h2 id="a.-阿宁的柠檬">A. 阿宁的柠檬</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> n, a, b;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,n,(a+b)*n);&#125;</code></pre></div><h2 id="b.-阿宁与猫咪">B. 阿宁与猫咪</h2><p>注意到全部填 <span class="math inline">\(1\)</span>时，烦躁值不会超过 <span class="math inline">\(2\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> m;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);&#125;</code></pre></div><h2 id="c.-阿宁吃粽子">C. 阿宁吃粽子</h2><p>贪心地将最小值放在 <span class="math inline">\(2^0\)</span>的位置，次小值放在 <span class="math inline">\(2^1\)</span> 的位置。</p><p>注意第一个 <span class="math inline">\(2^0\)</span> 的位置是 <spanclass="math inline">\(a_{10}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, a[N], ans[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">9</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;i&lt;=n;i+=<span class="hljs-number">10</span>) ans[i]=a[pos++];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;i+j&lt;=n;j+=<span class="hljs-number">10</span>) ans[i+j]=a[pos++];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div><h2 id="d.-阿宁的质数">D. 阿宁的质数</h2><p>做法很显然，但是筛不出值域那么大的一张质数表。</p><p>注意到对于 <span class="math inline">\(x = 1,2,3\ldots\)</span>，答案单调不减，且答案一定为质数。也就是最大为第 <spanclass="math inline">\(2 \times 10^5\)</span> 个质数。不难发现线性筛<span class="math inline">\([2,3.5 \times 10^6]\)</span>这个区间就行了。</p><p>然后瞎搞，预处理每个前缀的答案，用<code>std::unordered_map</code>实现的话，复杂度是<span class="math inline">\(O(n)\)</span> 的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">3e6</span>+<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> n, m, q, a[N], r[N], p[M];<span class="hljs-type">bool</span> v[M];unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; st;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">3e6</span>+<span class="hljs-number">5e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++m]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m&amp;&amp;i*p[j]&lt;=<span class="hljs-number">3e6</span>+<span class="hljs-number">5e5</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]==p[pos]) &#123;++pos;<span class="hljs-keyword">while</span>(st[p[pos]]) ++pos;r[i]=p[pos];&#125; <span class="hljs-keyword">else</span> r[i]=p[pos];st[a[i]]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,r[x]);&#125;&#125;</code></pre></div><h2 id="e.-阿宁睡大觉">E. 阿宁睡大觉</h2><p>只有完全删去夹在两个<code>Z</code>中间的<code>z</code>才会产生 <spanclass="math inline">\(4\)</span> 的贡献。</p><p>贪心地删去夹在两个<code>Z</code>中间的，长度更短的若干个<code>z</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, ans;<span class="hljs-type">char</span> s[N];vector&lt;<span class="hljs-type">int</span>&gt; rec;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=n;<span class="hljs-keyword">while</span>(s[l]==<span class="hljs-string">&#x27;z&#x27;</span>&amp;&amp;l&lt;=n) ++l;<span class="hljs-keyword">while</span>(s[r]==<span class="hljs-string">&#x27;z&#x27;</span>&amp;&amp;r) --r;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> j=i;<span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=r&amp;&amp;s[j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;Z&#x27;</span>) ++j;ans+=<span class="hljs-number">4</span>*(j-i);        <span class="hljs-comment">// [i,j]全部为Z</span>        ++j;        <span class="hljs-type">int</span> d=j;        <span class="hljs-keyword">if</span>(j&gt;r) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=r&amp;&amp;s[j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;z&#x27;</span>) ++j;rec.<span class="hljs-built_in">push_back</span>(j-d+<span class="hljs-number">1</span>);        <span class="hljs-comment">// [d,j]全部为z，且删去这部分的代价为j-d+1</span>i=j;&#125;<span class="hljs-built_in">sort</span>(rec.<span class="hljs-built_in">begin</span>(),rec.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 贪心删去代价小的</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:rec) &#123;<span class="hljs-keyword">if</span>(k&gt;=x) ans+=<span class="hljs-number">4</span>, k-=x;<span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="f.-阿宁去游玩">F. 阿宁去游玩</h2><p>注意到使用膜法对后续操作完全没有限制，那么对于每对点 <spanclass="math inline">\((x,y)\)</span>，都能找到一个花费最小的方案。</p><p>然后跑最短路即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, X, Y, Z, a[N], d[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N], w[<span class="hljs-number">2</span>*N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), X=<span class="hljs-built_in">read</span>(), Y=<span class="hljs-built_in">read</span>(), Z=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">auto</span> f=[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> a[x]==a[y]? <span class="hljs-built_in">min</span>(X,Y+Z):<span class="hljs-built_in">min</span>(Y,X+Z);&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y,<span class="hljs-built_in">f</span>(x,y));&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>贪心</tag>
      
      <tag>最短路</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NowCoder Round X」#55</title>
    <link href="/2022/ncx55-solution/"/>
    <url>/2022/ncx55-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>NowCoderX55</strong>.</p><h2 id="a.-至至子的等差中项">A. 至至子的等差中项</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> a, b;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">2</span>*b-a);&#125;</code></pre></div><h2 id="b.-至至子的按位与">B. 至至子的按位与</h2><p>从高位往低位贪心即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> a, b;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">62</span>;~i;--i) &#123;<span class="hljs-type">int</span> x=(a&gt;&gt;i)&amp;<span class="hljs-number">1</span>, y=(b&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x==y) c|=<span class="hljs-number">1ll</span>&lt;&lt;i;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,c);&#125;</code></pre></div><h2 id="c.-至至子的斐波那契">C. 至至子的斐波那契</h2><p>注意到 <span class="math inline">\(fib_{92}\)</span>是范围内最大的一项。二分查找即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> T, R, f[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">92</span>, k=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(f[mid]&lt;=x) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;k=l;<span class="hljs-type">int</span> ans=<span class="hljs-built_in">abs</span>(f[k]-x)&lt;=<span class="hljs-built_in">abs</span>(f[k+<span class="hljs-number">1</span>]-x)? k:k+<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">1</span>]=f[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">92</span>;++i) f[i]=f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>];T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-至至子的鸿门宴">D. 至至子的鸿门宴</h2><p>由于双方足够聪明，所以最终的局面一定是 <spanclass="math inline">\(a_1 = 1,a_2 = 2 , \ldots a_n = n\)</span>。</p><p>所以判断总操作数 <span class="math inline">\(\sum_{i=1}^n (a_i -i)\)</span> 的奇偶性即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=<span class="hljs-built_in">read</span>()-i;<span class="hljs-keyword">if</span>(ans&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ZZZ&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;SSZ&quot;</span>);&#125;</code></pre></div><h2 id="e.-至至子的长链剖分">E. 至至子的长链剖分</h2><p>树根一定是最大值，如果最大值不唯一，那么一定无解。</p><p>显然最终值为 <span class="math inline">\(i\)</span> 的节点一定是值为<span class="math inline">\(i+1\)</span>的节点的儿子，而儿子节点的数量一定不多于父节点，否则无解。</p><p>然后一顿瞎连就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, mx, root, cnt, h[N];vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; p[N], ans;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();mx=root=cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;h[i]=<span class="hljs-built_in">read</span>(), mx=<span class="hljs-built_in">max</span>(mx,h[i]);p[i].<span class="hljs-built_in">clear</span>();&#125;p[<span class="hljs-number">0</span>].<span class="hljs-built_in">clear</span>();ans.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(h[i]==mx) ++cnt, root=i;p[h[i]].<span class="hljs-built_in">pb</span>(&#123;h[i],i&#125;);&#125;<span class="hljs-keyword">if</span>(cnt!=<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;mx;++i)<span class="hljs-keyword">if</span>(p[i].<span class="hljs-built_in">size</span>()&lt;p[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>())  &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;mx;++i) &#123;<span class="hljs-type">int</span> sz=p[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;p[i].<span class="hljs-built_in">size</span>();++j) &#123;ans.<span class="hljs-built_in">pb</span>(&#123;p[i][j].sc,p[i+<span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(sz<span class="hljs-number">-1</span>,j)].sc&#125;);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,root);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pp:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,pp.fr,pp.sc);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="f.-至至子的公司排队">F. 至至子的公司排队</h2><p>每棵树是互相独立的，因此可以分别考虑，合并答案。</p><p>对于一棵树 <span class="math inline">\(i\)</span>，设 <spanclass="math inline">\(f_x\)</span> 为在以 <spanclass="math inline">\(x\)</span>为根的子树中，满足条件的排列方法数量。</p><p>先不考虑每个子节点子树内的情况，设子节点集合为 <spanclass="math inline">\(\{y\}\)</span>，大小为 <spanclass="math inline">\(m\)</span>。</p><p>转移方法有两种。</p><p>一，多重集的全排列。。那么对于 <spanclass="math inline">\(y_i\)</span>，相当于存在 <spanclass="math inline">\(sz_{y_i}\)</span> 个相同元素，总的元素个数为 <spanclass="math inline">\(sz_x - 1\)</span>，最后对于每个 <spanclass="math inline">\(y_i\)</span>，其内部的方案数为 <spanclass="math inline">\(f_{y_i}\)</span>，相乘即可。 <spanclass="math display">\[f_x = \prod_{i=1} f_{y_i} \frac{(sz_x - 1)!}{\prod_{i=1}^m (sz_{y_i}!)}\]</span>二，子树合并。其实我也不太明白这种东西是怎么证明的，但是看起来比较直观一些。<span class="math display">\[f_x = \prod_{i=1}^m f_{y_i} C_{sz_x&#39; - 1}^{sz_{y_i}}\]</span> 其中 <span class="math inline">\(sz_x&#39;-1 = \sum_{j=1}^isz_{y_i}\)</span>。</p><p> </p><p>最后合并不同树的时候，也可以使用上述两种方法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, cnt, ans=<span class="hljs-number">1</span>, c[N], f[N], fac[N], inv[N], sz[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> d=<span class="hljs-number">1e5</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=d;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[d]=<span class="hljs-built_in">fp</span>(fac[d],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=d<span class="hljs-number">-1</span>;~i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>, f[x]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> F=<span class="hljs-number">1</span>, g=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);sz[x]+=sz[y];(f[x]*=f[y]*<span class="hljs-built_in">C</span>(sz[x]<span class="hljs-number">-1</span>,sz[y])%mod)%=mod;<span class="hljs-comment">// (F*=f[y])%=mod, (g*=inv[sz[y]])%=mod;</span>&#125;<span class="hljs-comment">// f[x]=(F*fac[sz[x]-1]%mod*g%mod)%mod;</span>    <span class="hljs-comment">// 注释掉的是多重集全排列</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;c[i]=<span class="hljs-built_in">read</span>();tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=c[i];++j) h[j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=c[i];++j) &#123;<span class="hljs-type">int</span> p=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(p,j);&#125;<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);cnt+=c[i];(ans*=f[<span class="hljs-number">1</span>]*<span class="hljs-built_in">C</span>(cnt,c[i])%mod)%=mod;        <span class="hljs-comment">// 这也是子树合并</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>组合数学</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#816 (Div 2)</title>
    <link href="/2022/cf1715-solution/"/>
    <url>/2022/cf1715-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1715</strong>.</p><h2 id="a.-crossmarket">A. Crossmarket</h2><p>钦定 <span class="math inline">\(n \ge m\)</span>。</p><p>不难发现，最优操作方式一定是一个先走完 <spanclass="math inline">\((n-1) + (m-1)\)</span> 的路程，另一个只需要走<span class="math inline">\((m-1)\)</span> 的路程加上 <spanclass="math inline">\(1\)</span> 的传送即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;&amp;m==<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-built_in">swap</span>(n,m);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(n<span class="hljs-number">-1</span>)+(m<span class="hljs-number">-1</span>)+(m<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-beautiful-array">B. Beautiful Array</h2><p>既然是构造题，那么我们可以乱搞。</p><p>考虑如果 <span class="math inline">\(a_i &lt;k\)</span>，那么不会对序列的 beauty 产生贡献。</p><p>由于存在向下取整，所以序列的和最小是 <span class="math inline">\(k\cdot b\)</span>，如果 <span class="math inline">\(k \cdot b &gt;s\)</span>，那么无解。</p><p>让 <span class="math inline">\(a_1\)</span> 为 <spanclass="math inline">\(\min(k \cdot (b+1)-1,s)\)</span>，如果 <spanclass="math inline">\(s - a_1\)</span>之后还有剩余，那么就贪心地在后面放上不超过 <spanclass="math inline">\(k\)</span> 的数字就行了。</p><p>如果没有位置可以放的时候，<span class="math inline">\(s\)</span>仍然大于 <span class="math inline">\(0\)</span>，那么无解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, k, b, s, a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k*b&gt;s) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> t=k*(b+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(t&gt;s) t-=t-s;a[<span class="hljs-number">1</span>]=t;s-=t;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(s&gt;=k<span class="hljs-number">-1</span>) a[i]=k<span class="hljs-number">-1</span>, s-=(k<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) a[i]=s, s=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(s!=<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-monoblock">C. Monoblock</h2><p>先求出原序列的值，考虑每个数的贡献。</p><p>不太好想，举个例子。假设 <span class="math inline">\(1,2\)</span>的贡献已经计算完毕，现在要在后面加入一个 <spanclass="math inline">\(3\)</span>。不难发现，所有以 <spanclass="math inline">\(3\)</span> 结尾的前缀，<spanclass="math inline">\(1,2,3\)</span>，<spanclass="math inline">\(2,3\)</span>，<spanclass="math inline">\(3\)</span> 中都存在 <spanclass="math inline">\(3\)</span> 的 <spanclass="math inline">\(1\)</span> 个贡献，所以这部分的贡献是 <spanclass="math inline">\(3\)</span>。而由于这 <spanclass="math inline">\(3\)</span> 段都是新加入的，所以也要计算 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(2\)</span>的贡献。不难发现这就是一个相同的问题，以 <spanclass="math inline">\(2\)</span> 结尾的前缀的个数加上以 <spanclass="math inline">\(1\)</span> 结尾的前缀的个数。</p><p>而如果加入的是 <span class="math inline">\(2\)</span> 呢？则只会让以<span class="math inline">\(2\)</span> 结尾的前缀个数增加 <spanclass="math inline">\(1\)</span>，其他是相同的。</p><p>形式化地，设 <span class="math inline">\(pre\)</span> 为所有 <spanclass="math inline">\(k \in [1,i-1]\)</span>，以 <spanclass="math inline">\(k\)</span> 结尾的前缀的数量，<spanclass="math inline">\(ans\)</span> 为 <spanclass="math inline">\([1,i-1]\)</span> 的贡献。加入 <spanclass="math inline">\(a_i\)</span></p><p>假设 <span class="math inline">\(a_1,\ldots a_{i-1}\)</span>的贡献已经计算完毕，那么插入 <span class="math inline">\(a_i\)</span>时，如果 <span class="math inline">\(a_{i} \neq a_{i-1}\)</span>，那么令<span class="math inline">\(pre + i\)</span>，<spanclass="math inline">\(ans + pre\)</span>。否则令 <spanclass="math inline">\(pre+1\)</span>，<span class="math inline">\(ans +pre\)</span>。</p><p>对于修改操作，如果 <span class="math inline">\(a_i \neqa_{i-1}\)</span> 且 <span class="math inline">\(x =a_{i-1}\)</span>，那么左端点在 <spanclass="math inline">\([1,i-1]\)</span>，右端点在 <spanclass="math inline">\([i,n]\)</span> 中的区间，其贡献都会减少 <spanclass="math inline">\(1\)</span>，所以要减去 <spanclass="math inline">\((i-1) \cdot (n-i+1)\)</span>。同理，如果 <spanclass="math inline">\(a_i \neq a_{i+1}\)</span> 且 <spanclass="math inline">\(x = a_{i+1}\)</span>，那么就要减去 <spanclass="math inline">\(i \cdot (n-i)\)</span>。</p><p>反过来，如果 <span class="math inline">\(a_i = a_{i-1}\)</span> 且<span class="math inline">\(x \neq a_{i-1}\)</span> 或者 <spanclass="math inline">\(a_i = a_{i+1}\)</span> 且 <spanclass="math inline">\(x \neqa_{i+1}\)</span>，那么就要加上对应的值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, m, cnt, a[N], b[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>, pre=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]!=a[i<span class="hljs-number">-1</span>]) pre+=i, ans+=pre;<span class="hljs-keyword">else</span> ++pre, ans+=pre;&#125;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> i=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]==x) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">if</span>(x==a[i<span class="hljs-number">-1</span>]&amp;&amp;a[i]!=a[i<span class="hljs-number">-1</span>]) ans-=(i<span class="hljs-number">-1</span>)*(n-i+<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=a[i<span class="hljs-number">-1</span>]&amp;&amp;a[i]==a[i<span class="hljs-number">-1</span>]) ans+=(i<span class="hljs-number">-1</span>)*(n-i+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(x==a[i+<span class="hljs-number">1</span>]&amp;&amp;a[i]!=a[i+<span class="hljs-number">1</span>]) ans-=i*(n-i);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=a[i+<span class="hljs-number">1</span>]&amp;&amp;a[i]==a[i+<span class="hljs-number">1</span>]) ans+=i*(n-i);a[i]=x;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-2-doors">D. 2+ doors</h2><p>设 <span class="math inline">\(g(k,x)\)</span> 为 <spanclass="math inline">\(x\)</span> 二进制中的第 <spanclass="math inline">\(k\)</span> 位。</p><p>如果 <span class="math inline">\(a_i | a_j = x\)</span>，那么如果<span class="math inline">\(g(k,x)=0\)</span>，那么一定有 <spanclass="math inline">\(g(k,a_i) = g(k,a_j) = 0\)</span>。</p><p>考虑反着构造，先将每个 <span class="math inline">\(a_i\)</span>赋值为 <span class="math inline">\(2^{30} - 1\)</span>。</p><p>对于一组 <span class="math inline">\((i,j,x)\)</span>，如果 <spanclass="math inline">\(i \neq j\)</span>，那么就执行上述操作。</p><p>执行完之后，<span class="math inline">\(a_i | a_j\)</span> 必然等于<span class="math inline">\(k\)</span>，下面着手减小它的字典序。</p><p>对于一个 <span class="math inline">\(i\)</span>，枚举其为 <spanclass="math inline">\(1\)</span> 的位 <spanclass="math inline">\(k\)</span>，找到所有与 <spanclass="math inline">\(i\)</span> 有关的 <spanclass="math inline">\((j,x)\)</span>，如果上满足存在一组 <spanclass="math inline">\((j,x)\)</span>，满足 <spanclass="math inline">\(g(k,a_j) = 1\)</span> 且 <spanclass="math inline">\(g(k,x) = 0\)</span>，那么就将 <spanclass="math inline">\(g(k,a_1)\)</span> 改为 <spanclass="math inline">\(0\)</span>。</p><p>这样做会导致其他的 <span class="math inline">\((j,x)\)</span>不满足条件，但为什么是最优解呢？因为数据保证有解，由于枚举 <spanclass="math inline">\(i\)</span>是从前往后，所以减小靠前的数要优于减小靠后的数，且可以通过修改 <spanclass="math inline">\(a_j\)</span> 的方式重新满足条件。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, q, a[N];<span class="hljs-type">bool</span> v[N];vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; w[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> i=<span class="hljs-built_in">read</span>(), j=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(i==j) &#123;a[i]=x, v[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">29</span>;~k;--k) &#123;<span class="hljs-keyword">if</span>(x&gt;&gt;k&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(a[i]&gt;&gt;k&amp;<span class="hljs-number">1</span>) a[i]^=<span class="hljs-number">1</span>&lt;&lt;k;<span class="hljs-keyword">if</span>(a[j]&gt;&gt;k&amp;<span class="hljs-number">1</span>) a[j]^=<span class="hljs-number">1</span>&lt;&lt;k;&#125;w[i].<span class="hljs-built_in">push_back</span>(&#123;j,x&#125;);w[j].<span class="hljs-built_in">push_back</span>(&#123;i,x&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">29</span>;~j;--j) &#123;<span class="hljs-keyword">if</span>(!(a[i]&gt;&gt;j&amp;<span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-type">bool</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:w[i]) &#123;<span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><span class="hljs-keyword">if</span>((p.y&gt;&gt;j&amp;<span class="hljs-number">1</span>)&amp;&amp;!(a[p.x]&gt;&gt;j&amp;<span class="hljs-number">1</span>)) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(fg) a[i]^=<span class="hljs-number">1</span>&lt;&lt;j;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ#3381 函数调用 题解</title>
    <link href="/2022/loj3381-solution/"/>
    <url>/2022/loj3381-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>函数调用，满足不出现递归，本身就构成了一张 DAG。</p><p>由于乘法操作是全局乘法，所以可以提前预处理乘法操作，而加法操作最终的贡献，取决于在它之后乘上多少次。</p><p>设 <span class="math inline">\(pls_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个函数执行的加法的值，如果没有的话则为<span class="math inline">\(0\)</span>，<spanclass="math inline">\(id_i\)</span> 为第 <spanclass="math inline">\(i\)</span>个函数要执行加法的元素的编号，没有的话为 <spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(mul_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个函数对全局的乘法值，如果没有的话则为<span class="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(cnt_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个函数加法操作之后又被乘了多少。</p><p>对于函数 <span class="math inline">\(i\)</span> 要调用的函数 <spanclass="math inline">\(x\)</span>，连边 <span class="math inline">\((i\rightarrow x)\)</span>。用 DFS可以预处理出当运行完任意一个函数时，对全局的乘法操作，而函数 <spanclass="math inline">\(i\)</span> 必然在 <spanclass="math inline">\(x\)</span> 之后操作，因此 <spanclass="math inline">\(x\)</span> 加法操作的最终值依赖于 <spanclass="math inline">\(i\)</span>，因此处理 <spanclass="math inline">\(i\)</span> 要早于处理 <spanclass="math inline">\(x\)</span>，拓扑排序即可。</p><p>但是函数的调用是有序的，依次从左到右。因此必须新建立一个节点 <spanclass="math inline">\(0\)</span>，向所有调用的函数连边，并且在遍历 <spanclass="math inline">\(x\)</span> 能到达的所有点时，必须要按照倒序。</p><p>DFS 之后，<span class="math inline">\(mul_0\)</span>即为全局最终乘上的值，而对于每一个加法函数 <spanclass="math inline">\(i\)</span>，都会对 <spanclass="math inline">\(a_{id_i}\)</span> 产生 <spanclass="math inline">\(pls_i \cdot cnt_i\)</span> 的贡献。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, a[N], id[N], pls[N], mul[N], cnt[N];<span class="hljs-type">int</span> in[N], op[N];<span class="hljs-type">bool</span> v[N];vector&lt;<span class="hljs-type">int</span>&gt; p[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">return</span>;v[x]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 关于为什么这里要用v数组来判环</span>    <span class="hljs-comment">// 因为从0连边之前是DAG，但是连边之后就可能不是了</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs</span>(y);(mul[x]*=mul[y])%=mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-type">int</span> dlt=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=p[x].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;~i;--i) &#123;        <span class="hljs-comment">// 倒序遍历</span><span class="hljs-type">int</span> y=p[x][i];(cnt[y]+=cnt[x]*dlt)%=mod;            <span class="hljs-comment">// 这里的层次一定要分清楚</span>            <span class="hljs-comment">// y的加法操作只会被x影响，要按照拓扑序处理，而不是看全局乘上的值</span>(dlt*=mul[y])%=mod;<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;call.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;call.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;op[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">1</span>) id[i]=<span class="hljs-built_in">read</span>(), pls[i]=<span class="hljs-built_in">read</span>(), mul[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">2</span>) mul[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();mul[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();p[i].<span class="hljs-built_in">pb</span>(x), ++in[x];&#125;&#125;&#125;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();p[<span class="hljs-number">0</span>].<span class="hljs-built_in">pb</span>(x), ++in[x];&#125;cnt[<span class="hljs-number">0</span>]=mul[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">toposort</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) (a[i]*=mul[<span class="hljs-number">0</span>])%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">1</span>) (a[id[i]]+=cnt[i]*pls[i]%mod)%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ#3387 字符串匹配 题解</title>
    <link href="/2022/loj3387-solution/"/>
    <url>/2022/loj3387-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>规定以下讨论中，字符串的下标从 <span class="math inline">\(1\)</span>开始。</p><p>注意到 <span class="math inline">\((AB)^K\)</span>一定是一段前缀，<span class="math inline">\(C\)</span>一定是一段后缀，而 <span class="math inline">\(AB\)</span> 又一定是<span class="math inline">\((AB)^k\)</span> 的前缀，且满足连续出现 <spanclass="math inline">\(k\)</span> 次。</p><p>考虑 <span class="math inline">\(S\)</span> 的 <spanclass="math inline">\(z\)</span> 函数。</p><p>如果知道了 <span class="math inline">\(AB\)</span> 的长度和 <spanclass="math inline">\(k\)</span>，那么就能计算出对应的 <spanclass="math inline">\(C\)</span>。设当前 <spanclass="math inline">\(AB\)</span> 长度为 <spanclass="math inline">\(i\)</span>，那么最多的循环次数为 <spanclass="math display">\[\lfloor \frac{z_{i+1}}{i} \rfloor + 1\]</span> <del>感性理解一下，显然是对的</del>。</p><p>当然这是“至多”，我们可以规定循环次数为任何一个小于最多次数，大于<span class="math inline">\(0\)</span> 的整数。</p><p>注意到对于奇偶性相同的 <spanclass="math inline">\(k\)</span>，出现次数为奇数的字符个数是相等的，所以只需要分奇偶讨论。当<span class="math inline">\(k\)</span> 为奇数时，个数不变，当 <spanclass="math inline">\(k\)</span>为偶数时，不存在出现次数为奇数的字符。</p><p>设 <span class="math inline">\(g(l,r)\)</span> 为 <spanclass="math inline">\(S[l,r]\)</span>中出现次数为奇数的字符的数量。设当前 <spanclass="math inline">\(AB\)</span> 长度为 <spanclass="math inline">\(i\)</span>，<span class="math inline">\(|A| =j\)</span>。</p><p>首先一定存在 <span class="math inline">\(F(A) \leF(C)\)</span>，<span class="math inline">\(F(A) = g(1,j)\)</span>。</p><ul><li>如果 <span class="math inline">\(k\)</span> 是个奇数，那么就有 <spanclass="math inline">\(g(1,j) \le g(i+1,n)\)</span>。尽管 <spanclass="math inline">\(C\)</span>中具体有多少个出现次数为奇数的字符是未知的，但是 <spanclass="math inline">\((AB)^k\)</span> 在 <spanclass="math inline">\([i+1,n]\)</span>的出现次数一定为偶数次，所以不会产生影响，<spanclass="math inline">\(g(i+1,n)\)</span> 就是 <spanclass="math inline">\(F(C)\)</span>。</li><li>否则，由于 <span class="math inline">\((AB)^k\)</span>不存在这类字符，所以 <span class="math inline">\([1,ki]\)</span>就不存在出现次数为奇数的字符，因此 <span class="math inline">\(F(C) =g(ki+1,n) = g(1,n) \Longrightarrow g(1,j) \le g(1,n)\)</span>。</li></ul><p>如何维护这类信息？使用树状数组。设 <spanclass="math inline">\(C(x)\)</span> 表示长度小于 <spanclass="math inline">\(i\)</span> 且这类字符的个数小于等于 <spanclass="math inline">\(x\)</span> 的前缀的数量。</p><p>同时用变量 <span class="math inline">\(pre\)</span> 表示 <spanclass="math inline">\([1,i]\)</span> 中这类字符的个数，<spanclass="math inline">\(suf\)</span> 表示 <spanclass="math inline">\([i+1,n]\)</span> 中的，<spanclass="math inline">\(all\)</span> 表示 <spanclass="math inline">\(g(1,n)\)</span>。</p><p>对于 <span class="math inline">\(t = \lfloor \frac{z_{i+1}}{i}\rfloor + 1\)</span>，奇数的情况有 <span class="math inline">\(t -\lfloor \frac{t}{2} \rfloor\)</span>，偶数则有 <spanclass="math inline">\(\lfloor \frac{t}{2} \rfloor\)</span>。对于 <spanclass="math inline">\(i\)</span> <span class="math display">\[(t - \lfloor \frac{t}{2} \rfloor) \cdot C(suf) + \lfloor \frac{t}{2}\rfloor \cdot C(all)\]</span> 然后插入 <span class="math inline">\(pre\)</span> 即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)+<span class="hljs-number">2</span>;<span class="hljs-type">int</span> t, n, z[N], p[<span class="hljs-number">30</span>], q[<span class="hljs-number">30</span>], c[<span class="hljs-number">30</span>];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">for</span>(;x&lt;=<span class="hljs-number">27</span>;x+=x&amp;-x) c[x]+=y; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;z[<span class="hljs-number">0</span>]=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) z[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;z[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<span class="hljs-keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[z[i]]==s[i+z[i]]) ++z[i];<span class="hljs-keyword">if</span>(r&lt;i+z[i]<span class="hljs-number">-1</span>) l=i, r=i+z[i]<span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(i+z[i]==n) --z[i];    <span class="hljs-comment">// 由于c不是空串，所以i+z[i]必须小于n</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);n=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(p));<span class="hljs-built_in">memset</span>(q,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(q));<span class="hljs-built_in">Z</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>, pre=<span class="hljs-number">0</span>, suf=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) ++q[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i) <span class="hljs-keyword">if</span>(q[i]&amp;<span class="hljs-number">1</span>) ++suf;<span class="hljs-type">int</span> all=suf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> d=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;++p[d], --q[d];<span class="hljs-keyword">if</span>(p[d]&amp;<span class="hljs-number">1</span>) ++pre; <span class="hljs-keyword">else</span> --pre;<span class="hljs-keyword">if</span>(q[d]&amp;<span class="hljs-number">1</span>) ++suf; <span class="hljs-keyword">else</span> --suf;<span class="hljs-keyword">if</span>(i) &#123;<span class="hljs-type">int</span> t=z[i+<span class="hljs-number">1</span>]/(i+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;            <span class="hljs-comment">// 由于我的代码中i从0开始，所以要+1表示长度为i，和z[i+1]中的+1无关</span>ans+=(t-t/<span class="hljs-number">2</span>)*<span class="hljs-built_in">query</span>(suf+<span class="hljs-number">1</span>)+(t/<span class="hljs-number">2</span>)*<span class="hljs-built_in">query</span>(all+<span class="hljs-number">1</span>);            <span class="hljs-comment">// 为了防止0下标，这些都要+1</span>&#125;<span class="hljs-built_in">modify</span>(pre+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;string.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;string.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>字符串</tag>
      
      <tag>扩展KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「字符串学习笔记」#2 Z函数（扩展KMP）</title>
    <link href="/2022/notes-string-2/"/>
    <url>/2022/notes-string-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="前言">前言</h2><p>本来想着，暑假要多学点算法，结果就学了一点点……</p><p>大部分时间拿来写题了。</p><p>有点小遗憾。</p><p>不过无妨。</p><h2 id="z-函数扩展-kmp">Z 函数（扩展 KMP）</h2><h3 id="算法流程及实现">算法流程及实现</h3><p>约定：字符串下标以 <span class="math inline">\(0\)</span>为起点。</p><p>对于一个字符串 <span class="math inline">\(S\)</span>，满足 <spanclass="math inline">\(|S| = n\)</span>，它的 <spanclass="math inline">\(z\)</span> 函数定义为：<spanclass="math inline">\(z(i)\)</span> 表示 <spanclass="math inline">\(S\)</span> 和以 <spanclass="math inline">\(i\)</span> 开头的后缀 <spanclass="math inline">\(S[i,n-1]\)</span> 的最长公共前缀 (LCP)的长度。</p><p>显然有 <span class="math inline">\(z(0)=n\)</span>。</p><p>国外一般将计算该数组的算法称为 <strong>ZAlgorithm</strong>，而国内则称其为<strong>扩展 KMP</strong>。</p><p>为啥是扩展 KMP？可能是因为这两段的 LCP，某种意义上也是一个Border。</p><p>根据定义易得 <span class="math inline">\(O(n^2)\)</span> 的实现</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C++ Version</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z_function_trivial</span><span class="hljs-params">(string s)</span> </span>&#123;    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;    z[<span class="hljs-number">0</span>] = n;    <span class="hljs-comment">// 这句是我加的</span>    <span class="hljs-comment">// OI-wiki上说z[0]=0，但是z[0]=0不仅说不过去而且板子题也过不了啊</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)    <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-comment">// Code from oi-wiki.org</span></code></pre></div><p>一般情况下，当一个能求出很 NB的东西的算法复杂度过高时，就会有神犇来优化它。</p><blockquote><p>如同大多数字符串主题所介绍的算法，其关键在于，运用自动机的思想寻找限制条件下的状态转移函数，使得可以借助之前的状态来加速计算新的状态。</p></blockquote><p>就像是 KMP 算法中的 <span class="math inline">\(next\)</span>数组一样，这里考虑用 <span class="math inline">\(z(0),z(1),\ldotsz(i-1)\)</span> 来求出 <span class="math inline">\(z(i)\)</span>。</p><p>对于 <span class="math inline">\(i\)</span>，我们称区间 <spanclass="math inline">\([i,i+z(i)-1]\)</span> 是 <spanclass="math inline">\(i\)</span> 的<strong>匹配段</strong>，也可以叫Z-box。</p><p>设 <span class="math inline">\([l,r]\)</span> 为最靠右的 Z-box对应的左右端点，必须保证 <span class="math inline">\(l \lei\)</span>，初始化 <span class="math inline">\(l=r=0\)</span>.</p><p>对于 <span class="math inline">\(z(i)\)</span>，如果 <spanclass="math inline">\(i \le r\)</span>，那么由于 <spanclass="math inline">\([l,r]\)</span> 是一个匹配段，所以 <spanclass="math inline">\(s[i,r] = s[i-l,r-l]\)</span>。</p><p>因此 <span class="math inline">\(z(i) \ge \min \big(z(i-l),r-i+1\big)\)</span>。</p><p>这时候</p><ul><li>如果 <span class="math inline">\(z(i-l) &lt; r-i+1\)</span>，那么<span class="math inline">\(z(i)=z(i-l)\)</span>。</li><li>否则 <span class="math inline">\(z(i-l) \ge r-i+1\)</span>，这时候令<span class="math inline">\(z(i) = \max(0,r-i+1 )\)</span>，然后暴力递增<span class="math inline">\(z(i)\)</span>，知道不能扩展为止。求出 <spanclass="math inline">\(z(i)\)</span> 后，如果 <spanclass="math inline">\(r &lt; i+z(i)-1\)</span>，那么就令 <spanclass="math inline">\(l=i,r=i+z(i)-1\)</span>。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;z[<span class="hljs-number">0</span>]=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) z[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;z[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<span class="hljs-keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[z[i]]==s[i+z[i]]) ++z[i];<span class="hljs-keyword">if</span>(r&lt;i+z[i]<span class="hljs-number">-1</span>) l=i, r=i+z[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;</code></pre></div><h3 id="复杂度分析">复杂度分析</h3><p>对于内层<code>while</code>循环，每次都使得 <spanclass="math inline">\(r\)</span> 向后移动一位，而 <spanclass="math inline">\(r \in [0,n-1]\)</span>，因此复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p>对于外层循环，只有一次遍历，复杂度 <spanclass="math inline">\(O(n)\)</span>。</p><p>因此整个算法的复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><h2 id="应用">应用</h2><h3id="求出模式串与文本串每一个后缀的lcp">求出模式串与文本串每一个后缀的LCP</h3><p>也就是洛谷上的模板题。</p><p>类似于 KMP 算法，求出模式串的 <span class="math inline">\(z\)</span>函数，设文本串 <span class="math inline">\(|T|=m\)</span>，那么设 <spanclass="math inline">\(f(i)\)</span> 为模式串与文本串的后缀 <spanclass="math inline">\(T[i,m-1]\)</span> 的 LCP 长度，在 <spanclass="math inline">\(z\)</span> 函数的基础上处理即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exkmp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">Z</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>, r=<span class="hljs-number">-1</span>, ans=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意从l=r=-1</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) f[i]=z[i-l];        <span class="hljs-comment">// 这里是z[i-l]</span><span class="hljs-keyword">else</span> &#123;f[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<span class="hljs-keyword">while</span>(i+f[i]&lt;m&amp;&amp;s[f[i]]==t[i+f[i]]) ++f[i];<span class="hljs-keyword">if</span>(r&lt;i+f[i]<span class="hljs-number">-1</span>) l=i, r=i+f[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;</code></pre></div><h3 id="匹配所有子串">匹配所有子串</h3><p>寻找模式串 <span class="math inline">\(P\)</span> 在文本串 <spanclass="math inline">\(T\)</span> 中的所有出现 (occurrence)。</p><p>构造字符串 <span class="math inline">\(S = P + \lambda +T\)</span>，其中 <span class="math inline">\(\lambda\)</span>是一个不在二者之中出现的字符。</p><p>首先计算出 <span class="math inline">\(S\)</span> 的 <spanclass="math inline">\(z\)</span> 函数，对于任意 <spanclass="math inline">\(i \in [0,|T|-1]\)</span>，考虑以 <spanclass="math inline">\(T_i\)</span> 开头的后缀在 <spanclass="math inline">\(S\)</span> 中的函数值 <spanclass="math inline">\(k = z(i+|S|+1)\)</span>，如果 <spanclass="math inline">\(k = |S|\)</span>，那么说明有一个 <spanclass="math inline">\(P\)</span> 出现在了 <spanclass="math inline">\(T\)</span> 的第 <spanclass="math inline">\(i\)</span> 个位置。</p><p>不难发现此种方法也可以求解上面的那个问题。</p><h3 id="字符串整周期">字符串整周期</h3><p>找到给定字符串 <span class="math inline">\(|S|=n\)</span>的最小整周期。</p><p>考虑 <span class="math inline">\(S\)</span> 的 <spanclass="math inline">\(z\)</span> 函数，则其最小整周期为满足 <spanclass="math inline">\(i \mid n\)</span> 且 <spanclass="math inline">\(i+z_i = n\)</span>。</p><p>证明？感性理解~</p><p> </p><p>嗯嗯，就写这么点吧。</p><p>由于时间原因，本文没有放很多证明过程。</p><h2 id="参考">参考</h2><ul><li><a href="https://oi-wiki.org/string/z-func/">OI-wiki Z 函数（扩展KMP）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>扩展KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#815 (Div 2)</title>
    <link href="/2022/cf1720-solution/"/>
    <url>/2022/cf1720-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1720</strong>.</p><h2 id="a.-burenka-plays-with-fractions">A. Burenka Plays withFractions</h2><p><span class="math display">\[\frac{a}{b} = \frac{c}{d}\]</span></p><p><span class="math display">\[ad = cb\]</span></p><p>如果相等，答案为 <span class="math inline">\(0\)</span>。</p><p>如果某一方是 <span class="math inline">\(0\)</span>，答案为 <spanclass="math inline">\(1\)</span>。</p><p>如果两者有倍数关系，答案为 <spanclass="math inline">\(1\)</span>。</p><p>否则为 <span class="math inline">\(2\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a*d==b*c) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!a||!c) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(a*d,b*c)%<span class="hljs-built_in">min</span>(a*d,b*c)==<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-interesting-sum">B. Interesting Sum</h2><p>发现无论如何都能选择一个区间，满足区间内最大值是序列最大值或次大值，区间内最小值是序列最小值或次小值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> ans=a[n]-a[<span class="hljs-number">1</span>]+a[n<span class="hljs-number">-1</span>]-a[<span class="hljs-number">2</span>];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-corners">C. Corners</h2><p>发现第一次操作后，每次操作一定都能只消耗一个白点。</p><p>如果存在两个 <span class="math inline">\(0\)</span>能被同时操作，那么第 <span class="math inline">\(1\)</span>次操作就会消耗 <span class="math inline">\(1\)</span>个白点，否则，如果存在 <span class="math inline">\(0\)</span>，就会消耗<span class="math inline">\(2\)</span> 个，否则就会消耗 <spanclass="math inline">\(3\)</span> 个。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=j;i&lt;=k;++i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n, m, a[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%1d&quot;</span>,&amp;a[i][j]);<span class="hljs-type">int</span> cnt1=<span class="hljs-number">0</span>, dlt=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) cnt1+=a[i][j];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(!a[i][j]) &#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i<span class="hljs-number">-1</span>][j]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;!a[i+<span class="hljs-number">1</span>][j]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i][j<span class="hljs-number">-1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&lt;m&amp;&amp;!a[i][j+<span class="hljs-number">1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;j&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;j&lt;m&amp;&amp;!a[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&lt;m&amp;&amp;!a[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) dlt=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(!dlt) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(cnt1==n*m) dlt=<span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,cnt1-dlt);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d1.-xor-subsequence-easy-version">D1. Xor-Subsequence (easyversion)</h2><p>这题被 Hack 了，原因是使用<code>memset()</code>。</p><p>注意到 <span class="math inline">\(a_i \in [0,200]\)</span>。</p><p>设 <span class="math inline">\(f(i)\)</span> 为以 <spanclass="math inline">\(i\)</span> 结尾的 beautiful subsequence的最大长度，以下下标均从 <span class="math inline">\(0\)</span>开始。</p><p>初始值 <span class="math inline">\(f(i)=1\)</span>。 <spanclass="math display">\[f(i) = \max_{j \in [0,i-1]} \{ f(j) + 1 \}\]</span> 其中 <span class="math inline">\(a_j \oplus i &lt; a_i \oplusj\)</span>。</p><p>这样的复杂度是 <span class="math inline">\(O(n^2)\)</span> 的。</p><p>由于 <span class="math inline">\(a_i\)</span> 不超过 <spanclass="math inline">\(2^8\)</span>，所以 <span class="math inline">\(j\in [\max(0,i-2^8),i-1]\)</span>。</p><p>可过。</p><p>答案 <span class="math inline">\(\max_{i=0}^{n-1} f_i\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N], f[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) f[i]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;f[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,i<span class="hljs-number">-256</span>);j&lt;i;++j) &#123;<span class="hljs-keyword">if</span>((a[j]^i)&lt;(a[i]^j)) f[i]=<span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);&#125;ans=<span class="hljs-built_in">max</span>(ans,f[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d2.-xor-subsequence-hard-version">D2. Xor-Subsequence (hardversion)</h2><p><span class="math inline">\(a_i \in[0,10^9]\)</span>，上面的做法失效了。考虑优化这个 DP。</p><p>如果 <span class="math inline">\(a_j \oplus i &lt; a_i \oplusj\)</span>，那么一定存在一个 <spanclass="math inline">\(k\)</span>，满足前 <spanclass="math inline">\(k\)</span> 位中，<span class="math inline">\(a_j\oplus i = a_i \oplus j\)</span>，<spanclass="math inline">\(k+1\)</span> 位上，前者为 <spanclass="math inline">\(0\)</span>，后者为 <spanclass="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(w(k,x)\)</span> 为 <spanclass="math inline">\(x\)</span> 二进制中第 <spanclass="math inline">\(k\)</span> 位的值。</p><p>不知道为什么下面部分字体出现了问题，但是不影响观看。</p><p>如果 <span class="math inline">\(w(1 \sim k, a_j \oplus i) = w(1 \simk,a_i \oplus j)\)</span>，那么两边同时异或上 <spanclass="math inline">\(i \oplus j\)</span>，即 <spanclass="math inline">\(w(1 \sim k,a_j \oplus j) = w(1 \sim k,a_i \oplusi)\)</span>。这个转化，直接将 <spanclass="math inline">\(O(n^2)\)</span> 级别的数对变成 <spanclass="math inline">\(O(n)\)</span> 级别的了。</p><p>而 <span class="math inline">\(k+1\)</span> 位上，有 <spanclass="math inline">\(a_j \oplus j &lt; a_i \oplus i\)</span>，这表明<span class="math inline">\(w(k+1,a_i \oplus i) \oplus 1 = w(k+1,a_j\oplus j)\)</span>，这是第一个要点。</p><p>由于 <span class="math inline">\(w(k+1,a_j \oplus i) &lt; w(k+1,a_i\oplus j)\)</span>，所以 <span class="math inline">\(w(k+1,a_i \oplus j)= 1\)</span>，即 <span class="math inline">\(w(k+1,a_i) \neqw(k+1,j)\)</span>，这是第二个要点。</p><p>建立一颗 0-1 Trie 来维护这个东西，插入 <spanclass="math inline">\(a_i \oplus i\)</span>。对于每个 <spanclass="math inline">\(f(i)\)</span>，通过上述方法找到满足条件的最大的<span class="math inline">\(f(j)\)</span>。</p><p>设 <span class="math inline">\(g(x,k=0/1)\)</span> 为字典树上经过<span class="math inline">\(x\)</span> 节点，且这一位为 <spanclass="math inline">\(0/1\)</span> 的最大的 <spanclass="math inline">\(f(j)\)</span>。上文两个要点已经说明的求的满足条件的<span class="math inline">\(j\)</span> 的方法，即要过 <spanclass="math inline">\(w(k+1,a_i \oplus i) \oplus 1\)</span>这个节点，且第 <span class="math inline">\(k+1\)</span> 位与 <spanclass="math inline">\(w(k+1,a_i)\)</span> 不同。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, tot, a[N], f[N], trie[<span class="hljs-number">30</span>*N][<span class="hljs-number">2</span>], g[<span class="hljs-number">30</span>*N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(s&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];g[x][(id&gt;&gt;i)&amp;<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(g[x][(id&gt;&gt;i)&amp;<span class="hljs-number">1</span>],f[id]);        <span class="hljs-comment">// id为下标</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>, x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-type">int</span> a=(s&gt;&gt;i)&amp;<span class="hljs-number">1</span>, y=trie[x][a^<span class="hljs-number">1</span>];        <span class="hljs-comment">// y=a[i]^i^1的这一位所在的节点</span>ans=<span class="hljs-built_in">max</span>(ans,g[y][(k&gt;&gt;i)&amp;<span class="hljs-number">1</span>^<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);        <span class="hljs-comment">// k为a[i],(k&gt;&gt;i)&amp;1^1等于在这一位上，y与k不同</span><span class="hljs-keyword">if</span>(!trie[x][a]) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 没有后续的节点了，结束</span>x=trie[x][a];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) a[i]=<span class="hljs-built_in">read</span>(), f[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=tot;++i) trie[i][<span class="hljs-number">0</span>]=trie[i][<span class="hljs-number">1</span>]=g[i][<span class="hljs-number">0</span>]=g[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;f[i]=<span class="hljs-built_in">query</span>(a[i]^i,a[i]);<span class="hljs-built_in">insert</span>(a[i]^i,i);        <span class="hljs-comment">// 注意插入和查询的参数不同</span>&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#805 (Div 3)</title>
    <link href="/2022/cf1702-solution/"/>
    <url>/2022/cf1702-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1702</strong>.</p><h2 id="a.-round-down-the-price">A. Round Down the Price</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> pw[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;++i) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">10</span>;<span class="hljs-type">int</span> t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> e=<span class="hljs-built_in">log10</span>(n);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-pw[e]);&#125;&#125;</code></pre></div><h2 id="b.-polycarp-writes-a-string-from-memory">B. Polycarp Writes aString from Memory</h2><p>用<code>std::set</code>自动完成去重，随便输出即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n;<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s; cin&gt;&gt;s;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;set&lt;<span class="hljs-type">char</span>&gt; ss;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) &#123;ss.<span class="hljs-built_in">insert</span>(x);<span class="hljs-keyword">if</span>(ss.<span class="hljs-built_in">size</span>()==<span class="hljs-number">4</span>) &#123;ss.<span class="hljs-built_in">clear</span>();ss.<span class="hljs-built_in">insert</span>(x);++ans;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-train-and-queries">C. Train and Queries</h2><p>如果能从站 <span class="math inline">\(i\)</span> 到站 <spanclass="math inline">\(j\)</span>，当且仅当 <spanclass="math inline">\(i\)</span> 第一次出现的位置小于 <spanclass="math inline">\(j\)</span> 最后一次出现的位置。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, k;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a, b;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();a.<span class="hljs-built_in">clear</span>(), b.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!a[x]) a[x]=i, b[x]=i; <span class="hljs-keyword">else</span> b[x]=i;&#125;<span class="hljs-keyword">while</span>(k--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!a[x]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(a[x]&lt;b[y]? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-not-a-cheap-string">D. Not a Cheap String</h2><p>贪心地删除字典序较大的字母</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> t, p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s, ss; cin&gt;&gt;s;ss=s;p=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(ss.<span class="hljs-built_in">rbegin</span>(),ss.<span class="hljs-built_in">rend</span>());    <span class="hljs-comment">// 字典序从大到小排序</span><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) tot+=x-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ss) &#123;<span class="hljs-keyword">if</span>(tot&gt;p) ++m[x], tot-=x-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) &#123;<span class="hljs-keyword">if</span>(!m[x]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x); <span class="hljs-keyword">else</span> --m[x];&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-split-into-two-sets">E. Split Into Two Sets</h2><p>显然，你可以选择是否根据抽屉原理，得到如果存在 <spanclass="math inline">\(a_i = b_i\)</span>或者某个数字出现了两次以上，那么一定无解。</p><p>对于一组 <span class="math inline">\((a_i,b_i)\)</span>，连边 <spanclass="math inline">\((a_i \rightarrow b_i)\)</span>，<spanclass="math inline">\((b_i \rightarrow a_i)\)</span>。</p><p>以下讨论均不讨论环，断环为链即可。</p><p>从一个节点 <span class="math inline">\(x\)</span> 出发到达 <spanclass="math inline">\(y\)</span>，再从 <spanclass="math inline">\(y\)</span> 到达 <spanclass="math inline">\(z\)</span>，这说明 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(z\)</span>不能在同一组。由于没有自环，所以只要取这一条路径上的点，交替加入两个集合。如果从<span class="math inline">\(x\)</span>出发的最长路径经过的节点个数为奇数，那么一定无解。否则，一定有解。</p><p>证明：由于每个节点最多在 dominoes中出现两次，所以每个节点至多存在两条边。因此，如果 <spanclass="math inline">\(x\)</span>只有一个节点，那么显然是对的，否则由于最长路径上，除了 <spanclass="math inline">\(x\)</span>和最后一个点之外，每个点有连接了两条边，所以 <spanclass="math inline">\(x\)</span>的另一条路径一定只连接了一个点——路径末尾的点，显然也是合法的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n;vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(y)+<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i].<span class="hljs-built_in">clear</span>();<span class="hljs-type">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">push_back</span>(y), p[y].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">if</span>(x==y||p[x].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>||p[y].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>) fg=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]&amp;&amp;<span class="hljs-built_in">dfs</span>(i)%<span class="hljs-number">2</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="f.-equate-multisets">F. Equate Multisets</h2><p>注意到对于一个奇数，如果把它除以 <spanclass="math inline">\(2\)</span>下取整，那么这个奇数将不复存在。换句话说，对于偶数，两个操作是可逆的，对于奇数则是不可逆的。</p><p>因此，对于 <span class="math inline">\(2 \mid a_i\)</span>，将 <spanclass="math inline">\(a_i\)</span> 不断除以二使得 <spanclass="math inline">\(a_i\)</span> 是个奇数并加入集合。</p><p>这样做之后，如果 <span class="math inline">\(b\)</span> 能够和 <spanclass="math inline">\(a\)</span>完全相同，那么一定也能变成集合内的数。</p><p>对于 <span class="math inline">\(b_i\)</span>，如果 <spanclass="math inline">\(b_i\)</span> 不在集合中，那么不断将 <spanclass="math inline">\(b_i\)</span> 除以 <spanclass="math inline">\(2\)</span> 下取整，如果直到 <spanclass="math inline">\(b_i = 0\)</span>时仍然没有在集合中出现过，那么就无解。否则有解。</p><p>正确性显然。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N], b[N];multiset&lt;<span class="hljs-type">int</span>&gt; st;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();st.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(a[i]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) a[i]/=<span class="hljs-number">2</span>;st.<span class="hljs-built_in">insert</span>(a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(b[i]&amp;&amp;!st.<span class="hljs-built_in">count</span>(b[i])) b[i]/=<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(!b[i]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">else</span> st.<span class="hljs-built_in">erase</span>(st.<span class="hljs-built_in">find</span>(b[i]));&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="g.-passable-paths">G. Passable Paths</h2><p>CF 题面给的图都挺好用的（</p><p><img src="https://s2.loli.net/2022/08/17/lytTnbmQvXoSWzi.png" srcset="/img/loading.gif" lazyload /></p><p>对于一个集合 <spanclass="math inline">\(p\)</span>，如果能够满足条件，那么将 <spanclass="math inline">\(p\)</span>按照深度排序之后，所有节点一定依次分布在一条简单路径上。</p><p>先考虑一条深度单调减的链，举个例子 <spanclass="math inline">\(\{5,4,2,1\}\)</span>，它满足深度最大的节点 <spanclass="math inline">\(5\)</span> 和其他任何一个节点 <spanclass="math inline">\(p_i\)</span> 的 <spanclass="math inline">\(lca\)</span> 为 <spanclass="math inline">\(p_i\)</span>。</p><p>然后是深度不单调减的链，举个例子 <span class="math inline">\(\{5,4,2,3\}\)</span>。</p><p>一个想法是找到直径的两端，然后拆成两条链，满足深度单调，分别判断即可，例中为判断<span class="math inline">\(\{5,4\}\)</span> 和 <spanclass="math inline">\(\{3,2\}\)</span>。 具体做法见代码。</p><p>有一种特殊情况，<span class="math inline">\(lca\)</span>的父亲节点也在其中，那么这个做法就会 fAKe掉。一种简单的办法就是判断一下直径两端 <spanclass="math inline">\(lca\)</span>的深度是否小于等于深度最小的节点的深度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, q, p[N], dep[N], f[N][<span class="hljs-number">19</span>];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>;f[x][<span class="hljs-number">0</span>]=fa;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">18</span>;++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> dep[x]&gt;dep[y]; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) p[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+m+<span class="hljs-number">1</span>,cmp);<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(m+<span class="hljs-number">5</span>)</span></span>;s[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-keyword">if</span>(<span class="hljs-built_in">lca</span>(p[<span class="hljs-number">1</span>],p[i])==p[i]) s[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 满足这个条件，说明p[i]和p[1]在一条链上</span><span class="hljs-keyword">while</span>(pos&lt;=m&amp;&amp;s[pos]) ++pos;        <span class="hljs-comment">// 为什么出现了lca(p[1],p[i])!=p[i]? 因为到了另一条链上了</span>        <span class="hljs-comment">// 由于深度已经排序，pos就是另一个端点</span><span class="hljs-keyword">if</span>(pos==m+<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-comment">// 如果pos==m+1，说明深度单调</span>s[pos]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos+<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-keyword">if</span>(<span class="hljs-built_in">lca</span>(p[pos],p[i])==p[i]) s[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 从另一个端点开始判断</span><span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) ans&amp;=s[i];ans&amp;=dep[<span class="hljs-built_in">lca</span>(p[<span class="hljs-number">1</span>],p[pos])]&lt;=dep[p[m]];        <span class="hljs-comment">// 特判</span><span class="hljs-keyword">if</span>(ans) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>最近公共祖先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些简单DP题</title>
    <link href="/2022/DP-solution-1/"/>
    <url>/2022/DP-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="luogu2606-排列计数">luogu2606 排列计数</h2><p>这个条件相当于，<span class="math inline">\([1,n]\)</span>有多少排列满足小根堆性质。</p><p>设 <span class="math inline">\(sz_i\)</span> 为以 <spanclass="math inline">\(i\)</span> 为根的子树大小。</p><p>那么 <span class="math inline">\(1\)</span> 必定填 <spanclass="math inline">\(1\)</span>，而其他节点只需要考虑相对大小，所以对于<spanclass="math inline">\(i\)</span>，只要规定了它的子节点内部到底用哪些数字，就一定存在合法方案。</p><p>设 <span class="math inline">\(f_i\)</span> 为以 <spanclass="math inline">\(i\)</span> 为根的子树的方案数，那么 <spanclass="math display">\[f_i = C_{sz_i - 1} ^{sz_{2i}} \cdot f_{2i} \cdot f_{2i + 1}\]</span> 对于 <span class="math inline">\(i &gt; n\)</span>，规定 <spanclass="math inline">\(f_i = 1\)</span>。</p><p>数据很弱，貌似不必使用 lucas 定理。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">6</span>;ll n, p, sz[N&lt;&lt;<span class="hljs-number">1</span>], fac[N], f[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;    ll z=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%p,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) z=z*x%p;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n,ll m)</span> </span>&#123;    <span class="hljs-keyword">return</span> fac[n]*<span class="hljs-built_in">fp</span>(fac[m],p<span class="hljs-number">-2</span>)%p*<span class="hljs-built_in">fp</span>(fac[n-m],p<span class="hljs-number">-2</span>)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">lucas</span><span class="hljs-params">(ll n,ll m)</span> </span>&#123;    <span class="hljs-keyword">return</span> m? <span class="hljs-built_in">lucas</span>(n/p,m/p)*<span class="hljs-built_in">C</span>(n%p,m%p)%p:<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);    fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%p;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) sz[i]=sz[i*<span class="hljs-number">2</span>]+sz[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) &#123;        f[i]=<span class="hljs-built_in">lucas</span>(sz[i]<span class="hljs-number">-1</span>,sz[i*<span class="hljs-number">2</span>]);        f[i]=f[i]*(i*<span class="hljs-number">2</span>&lt;=n? f[i*<span class="hljs-number">2</span>]:<span class="hljs-number">1</span>)%p*(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=n? f[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]:<span class="hljs-number">1</span>)%p;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>]);&#125;</code></pre></div><h2 id="luogu2467-地精部落">luogu2467 地精部落</h2><p>山脉高度亮亮不同，而且只关心相对大小，所以问题可以转化为 <spanclass="math inline">\([1,n]\)</span>的排列中，满足波浪形分布的排列的个数。</p><p>考虑“谷”必须要接在”峰“的后面，设 <spanclass="math inline">\(f_{i,j}\)</span> 表示考虑 <spanclass="math inline">\([1,i]\)</span> 的排列中，满足最后一个数为 <spanclass="math inline">\(j\)</span>且是一个”谷“的方案数。可以这样设的原因是只关心相对大小。</p><p>枚举一个 <span class="math inline">\(k \in[1,j-1]\)</span>，那么贡献为 <spanclass="math inline">\(f_{i-1,(i-1)-k+1} =f_{i-1,i-k}\)</span>。这样做的原因是，对于一个以峰结尾的合法排列，对于其中每个元素<span class="math inline">\(p_j\)</span> 都变成 <spanclass="math inline">\((i-1)-p_j+1\)</span>，就能满足以谷结尾，且仍然合法。</p><p>如果 <span class="math inline">\((i-1)-k+1 &gt; k\)</span>，那么将<span class="math inline">\(k\)</span> 接在结尾后，交换 <spanclass="math inline">\((i-1)-k+1\)</span> 和 <spanclass="math inline">\(k\)</span>，此时一定满足结尾的元素是峰，而倒数第二个元素是谷，整个序列合法。使用上述做法之后依然是合法的。否则，直接将<span class="math inline">\(k\)</span>接在结尾就是合法的，直接使用上述做法即可。</p><p>举点例子。假如 <span class="math inline">\(k=2\)</span>，<spanclass="math inline">\(i=5\)</span>。那么 <span class="math inline">\(i-k= 3\)</span>，把 <span class="math inline">\(i-k\)</span>接在后面，假设此时排列为 <spanclass="math inline">\(4,3,2\)</span>，交换 <spanclass="math inline">\(3,2\)</span> 后的 <spanclass="math inline">\(4,2,3\)</span> 使用上述方法变成 <spanclass="math inline">\(1,3,2\)</span>，满足条件。如果 <spanclass="math inline">\(k=3\)</span>，其他条件不变，那么排列为 <spanclass="math inline">\(4,2,3\)</span>，此时使用上述方法转化成 <spanclass="math inline">\(1,3,2\)</span>，也满足条件。</p><p>那么 <span class="math display">\[f_{i,j} = \sum_{k=1}^{j-1} f_{i-1,i-k}\]</span> 复杂度为 <spanclass="math inline">\(O(n^3)\)</span>。这个式子肉眼可见很多冗余。</p><p>发现 <span class="math display">\[\sum_{k=1}^{j-1} f_{i-1,i-k} = f_{i-1,i-j+1} + \sum_{k=1}^{j-2}f_{i-1,i-k} = f_{i-1,i-j+1} + f_{i,j-1}\]</span> 于是优化到 <span class="math inline">\(O(n^2)\)</span>。</p><p>最后乘 <span class="math inline">\(2\)</span>才是总方案数，通过上述做法不难证明。</p><p>答案 <span class="math display">\[\sum_{i=1}^n f_{n,i}\]</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4205</span>;<span class="hljs-type">int</span> n, p, k=<span class="hljs-number">1</span>, ans, f[<span class="hljs-number">2</span>][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i,k^=<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j)        f[k][j]=(f[k][j<span class="hljs-number">-1</span>]+f[k^<span class="hljs-number">1</span>][i-j])%p;    <span class="hljs-comment">// 按理说j不能取i，但是当j=i时正好让第二项为0，第一项就相当于求了前缀和</span>    <span class="hljs-comment">// 所以f[k^1][n]就是答案</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(f[k^<span class="hljs-number">1</span>][n]*<span class="hljs-number">2</span>)%p);&#125;</code></pre></div><h2 id="luogu4644-cleaning-shifts">luogu4644 Cleaning Shifts</h2><p>将区间右端点排序。设 <span class="math inline">\(f_i\)</span> 为打扫<span class="math inline">\([1,i]\)</span> 时间段的最小花费，<spanclass="math inline">\(k\)</span> 为当前考虑到了第 <spanclass="math inline">\(k\)</span>个区间。由于每个区间必须全部打扫完，所以每头奶牛只能更新一个位置，<spanclass="math inline">\(f_{r(k)}\)</span>。 <span class="math display">\[f_{r(k)} = \min_{j \in [l(k)-1,r(k)]} \{ f_j+ c_k \}\]</span> 左右区间并不同时具有单调性，可以用线段树维护 <spanclass="math inline">\(f\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, l, r, f[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span> &#123; <span class="hljs-type">int</span> l, r, z; &#125; a[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(E a,E b) &#123; <span class="hljs-keyword">return</span> a.r!=b.r? a.r&lt;b.r:a.l&lt;b.l; &#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Seg</span> &#123;    <span class="hljs-type">int</span> l, r, z;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> l(x) t[x].l</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> r(x) t[x].r</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> z(x) t[x].z</span>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-built_in">z</span>(p)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">z</span>(p&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">z</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;    <span class="hljs-built_in">l</span>(p)=l, <span class="hljs-built_in">r</span>(p)=r;    <span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">z</span>(p)=f[l]; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(p&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">l</span>(p)==<span class="hljs-built_in">r</span>(p)) &#123;  <span class="hljs-built_in">z</span>(p)=y; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-type">int</span> mid=<span class="hljs-built_in">l</span>(p)+<span class="hljs-built_in">r</span>(p)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(p&lt;&lt;<span class="hljs-number">1</span>,x,y); <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x,y);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l&lt;=<span class="hljs-built_in">l</span>(p)&amp;&amp;r&gt;=<span class="hljs-built_in">r</span>(p)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">z</span>(p);    <span class="hljs-type">int</span> mid=<span class="hljs-built_in">l</span>(p)+<span class="hljs-built_in">r</span>(p)&gt;&gt;<span class="hljs-number">1</span>, ans=inf;    <span class="hljs-keyword">if</span>(l&lt;=mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(p&lt;&lt;<span class="hljs-number">1</span>,l,r));    <span class="hljs-keyword">if</span>(r&gt;mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r,&amp;a[i].z);        a[i].l=<span class="hljs-built_in">max</span>(l,a[i].l), a[i].r=<span class="hljs-built_in">min</span>(r,a[i].r);    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f)), f[l<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">if</span>(a[i].l&gt;a[i].r) <span class="hljs-keyword">continue</span>;        f[a[i].r]=<span class="hljs-built_in">min</span>(f[a[i].r],<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,a[i].l<span class="hljs-number">-1</span>,a[i].r)+a[i].z);        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a[i].r,f[a[i].r]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[r]!=inf? f[r]:<span class="hljs-number">-1</span>);&#125;</code></pre></div><h2 id="luogu2018-消息传递">luogu2018 消息传递</h2><p>一个小贪心：对于 <span class="math inline">\(x\)</span> 的子节点集合<span class="math inline">\(\{y\}\)</span>，首先传达的一定是最费时间的<span class="math inline">\(y_i\)</span>，其次是次费时间的 <spanclass="math inline">\(y_i\)</span>，否则通过邻项交换一定能证明不优。</p><p>但是传达完毕的时间并不一定是最费时间的 <spanclass="math inline">\(y_i\)</span> 所花费的时间 <spanclass="math inline">\(+1\)</span>。</p><p>设 <span class="math inline">\(f_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，所需要的最小时间。 <spanclass="math display">\[f_x = \max_{(x,y)} \{ f(y) + ord_y \}\]</span> 其中 <span class="math inline">\(ord_y\)</span> 表示 <spanclass="math inline">\(y\)</span> 是第几个被 <spanclass="math inline">\(x\)</span> 传达的点。</p><p>这样做复杂度是 <span class="math inline">\(O(n^2)\)</span> 的。</p><p>可以记忆化搜索。</p><p>还有一个优化空间的 Trick 就是，不是记忆化 <spanclass="math inline">\(f(x,fa_x)\)</span>，而是记忆化 <spanclass="math inline">\((fa_x \rightarrow x)\)</span>的这条边，空间复杂度降为 <span class="math inline">\(O(n)\)</span>。</p><h2 id="luogu1385-密令">luogu1385 密令</h2><p>注意到字典序总和不变。</p><p>设 <span class="math inline">\(f_{i,k}\)</span> 为长度为 <spanclass="math inline">\(i\)</span>，字典序总和为 <spanclass="math inline">\(k\)</span> 的字符串数量。</p><p>小把戏。</p><h2 id="cf106c-buns">CF106C Buns</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 种馅料，剩下 <spanclass="math inline">\(j\)</span> 克面粉的最大收益。</p><p>做多重背包即可。</p><p>统计答案时，枚举 <span class="math inline">\(i\)</span>，取 <spanclass="math inline">\(f_{n,i} + \frac{n-i}{c_0} \cdot d_0\)</span>的最大值即可。</p><h2 id="luogu2059-卡牌游戏">luogu2059 卡牌游戏</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为剩下 <spanclass="math inline">\(i\)</span> 个人，其中编号相对大小排第 <spanclass="math inline">\(j\)</span> 的玩家坐庄的胜率。</p><p><span class="math inline">\(f_{1,1}= 1\)</span>，推就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">60</span>;<span class="hljs-type">int</span> n, m, c[N];<span class="hljs-type">double</span> f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i]);f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;++k) &#123;<span class="hljs-type">int</span> p=c[k]%i? c[k]%i:i;<span class="hljs-keyword">if</span>(p&lt;j) f[i][j]+=f[i<span class="hljs-number">-1</span>][j-p]/m;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&gt;j) f[i][j]+=f[i<span class="hljs-number">-1</span>][i-p+j]/m;            <span class="hljs-comment">// p=j时他自己就死了，贡献为0</span>&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%% &quot;</span>,f[n][i]*<span class="hljs-number">100</span>);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="luogu3287-方伯伯的玉米田">luogu3287 方伯伯的玉米田</h2><p>每次拔高的一定是一段后缀，否则一定不优。这句话也变相说明了，对于一次拔高操作<span class="math inline">\([i,n]\)</span>，能对答案产生影响的只有 <spanclass="math inline">\(i\)</span> 能否接在之前的某处。</p><p>如果拔高的是 <spanclass="math inline">\([i,n]\)</span>，那么最终最长不下降子序列中必然包含<span class="math inline">\(i\)</span>，否则这个操作无用。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为中 <spanclass="math inline">\(i\)</span> 已经被拔高了 <spanclass="math inline">\(j\)</span> 次，以 <spanclass="math inline">\(i\)</span> 结尾的最长不下降子序列长度。 <spanclass="math display">\[f_{i,j} = \max_{k \in [1,i-1], l \in[0,j]} \{ f_{k,l} \} + 1\]</span> 其中必须满足 <span class="math inline">\(h_i + j \ge h_k +l\)</span>。</p><p>可以用二维树状数组维护前缀最大值，一维是 <spanclass="math inline">\(h_i + j\)</span>，另一维是 <spanclass="math inline">\(j\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">505</span>;<span class="hljs-type">int</span> n, m, mx, ans, a[N], f[N][M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=mx+m;i+=(i&amp;-i)) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;=m+<span class="hljs-number">1</span>;j+=(j&amp;-j))        f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],z);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i-=(i&amp;-i)) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j;j-=(j&amp;-j)) ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), mx=<span class="hljs-built_in">max</span>(mx,a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;--j) &#123;        <span class="hljs-comment">// 没有储存阶段的信息，滚动数组</span>        <span class="hljs-type">int</span> k=<span class="hljs-built_in">query</span>(a[i]+j,j+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;        <span class="hljs-comment">// j+1防止0下标</span>        ans=<span class="hljs-built_in">max</span>(ans,k);        <span class="hljs-built_in">modify</span>(a[i]+j,j+<span class="hljs-number">1</span>,k);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>概率论</tag>
      
      <tag>线段树</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#814 (Div 2)</title>
    <link href="/2022/cf1719-solution/"/>
    <url>/2022/cf1719-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1719</strong>.</p><h2 id="a.-chip-game">A. Chip Game</h2><p>根据 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(m\)</span> 的奇偶性判断即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(m%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Burenka&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Tonya&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Tonya&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Burenka&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-mathematical-circus">B. Mathematical Circus</h2><p>如果 <span class="math inline">\(k\)</span>是奇数，那么奇数加奇数为偶数，最小是 <spanclass="math inline">\(2\)</span>，而最小的偶数也是 <spanclass="math inline">\(2\)</span>，因此只要将奇数 <spanclass="math inline">\(i\)</span> 和偶数 <spanclass="math inline">\(i+1\)</span> 配对即可。</p><p>否则，如果 <span class="math inline">\(k \equiv 2 \pmod4\)</span>，那么只要将一个模 <span class="math inline">\(4\)</span> 为<span class="math inline">\(2\)</span> 的偶数加上 <spanclass="math inline">\(k\)</span>，就一定是 <spanclass="math inline">\(4\)</span> 的倍数，与任意奇数配对即可。</p><p>否则，一定有 <span class="math inline">\(4 \midk\)</span>，因此原来不是 <span class="math inline">\(4\)</span>的倍数的数无法转化成 <span class="math inline">\(4\)</span>的倍数，最终一定存在若干奇数无法配对。无解</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, k;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,i,i+<span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k%<span class="hljs-number">4</span>==<span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-type">bool</span> cur=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(!cur) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,i+<span class="hljs-number">1</span>,i);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,i,i+<span class="hljs-number">1</span>);cur^=<span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-fighting-tournament">C. Fighting Tournament</h2><p>很容易预处理出前 <span class="math inline">\(n\)</span> 局比赛中，第<span class="math inline">\(i\)</span> 个人赢了的比赛。</p><p>注意到 <span class="math inline">\(\{a\}\)</span>是一个排列，那么比完前 <span class="math inline">\(n\)</span>局后，最终一定是能力为 <span class="math inline">\(n\)</span>的人在队头，且其他人不会再赢任何一场比赛，胜利者只会是他。</p><p>模拟这个过程即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, q, a[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];deque&lt;<span class="hljs-type">int</span>&gt; d;<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pf push_front</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();d.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), d.<span class="hljs-built_in">pb</span>(i), p[i].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=d.<span class="hljs-built_in">front</span>(); d.<span class="hljs-built_in">pop_front</span>();<span class="hljs-type">int</span> y=d.<span class="hljs-built_in">front</span>(); d.<span class="hljs-built_in">pop_front</span>();<span class="hljs-keyword">if</span>(a[x]&lt;a[y]) <span class="hljs-built_in">swap</span>(x,y);d.<span class="hljs-built_in">pf</span>(x), d.<span class="hljs-built_in">pb</span>(y);p[x].<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-built_in">upper_bound</span>(p[x].<span class="hljs-built_in">begin</span>(),p[x].<span class="hljs-built_in">end</span>(),k)-p[x].<span class="hljs-built_in">begin</span>();        <span class="hljs-comment">// p[x]是有序的，可以二分查找</span><span class="hljs-keyword">if</span>(a[x]==n&amp;&amp;k&gt;n) ans+=k-n;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-burenka-and-traditions">D. Burenka and Traditions</h2><p>虽然代价式子看起来复杂，但是不难发现，处理区间长度为 <spanclass="math inline">\(1,2\)</span> 时，代价为 <spanclass="math inline">\(1\)</span>，长度为 <spanclass="math inline">\(3,4\)</span> 时，代价为 <spanclass="math inline">\(2\)</span>，以此类推。因此可以看作，花费 <spanclass="math inline">\(1\)</span> 的代价，处理 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span> 个数。</p><p>因此最多操作次数为 <spanclass="math inline">\(n\)</span>，每个数异或上他自己。</p><p>设 <span class="math inline">\(f_i\)</span> 为将 <spanclass="math inline">\([1,i]\)</span> 变成全 <spanclass="math inline">\(0\)</span> 的最小代价。</p><p>什么时候能同时处理两个数？当且仅当在 <spanclass="math inline">\(i\)</span> 时，异或前缀和 <spanclass="math inline">\(S_i\)</span> 已经出现过了，说明存在某个包含 <spanclass="math inline">\(i\)</span> 的区间的异或和为 <spanclass="math inline">\(0\)</span>。</p><p>设 <span class="math inline">\(S_j = S_i\)</span>，那么<spanclass="math inline">\([j+1,i]\)</span>每个数都出现了偶数次，通过改变异或顺序就能得到两个相同的数，消去他们代价为<span class="math inline">\(1\)</span>。 <span class="math display">\[f_{j} + i - (j+1) + 1 - 1 = f_j - j + i - 1\]</span></p><p>用<code>std::map</code>记录 <span class="math inline">\(S_j\)</span>对应的 <span class="math inline">\(f_j - j\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N];set&lt;<span class="hljs-type">int</span>&gt; st;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> suf=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;st.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!a[i]||st.<span class="hljs-built_in">count</span>(a[i]^suf)) st.<span class="hljs-built_in">clear</span>(), st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>), suf=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> st.<span class="hljs-built_in">insert</span>(suf), suf^=a[i], ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-fibonacci-strings">E. Fibonacci Strings</h2><p>先递推斐波那契数列及其前缀和对应的项数。</p><p>对于字符总数 <spanclass="math inline">\(sum\)</span>，如果它不是斐波那契数列的某项前缀和，那么无解。</p><p>否则找到它的项数 <spanclass="math inline">\(m\)</span>，从大到小依次尝试用某一类字符取填充，如果当前最多的字符也达不到要求的个数，那么无解。使用大根堆维护。</p><p>如何处理相邻的字符不能相同？对于某一类字符的个数 <spanclass="math inline">\(x\)</span>，满足 <span class="math inline">\(x&gt; fib_i\)</span>，那么填充完之后必然剩下 <spanclass="math inline">\(x-fib_i\)</span> 个字符，将其延迟插入堆即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n, s, f[<span class="hljs-number">105</span>];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">1</span>]=f[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;s=<span class="hljs-number">2</span>;p[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, p[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">100</span>;++i) &#123;f[i]=f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>];s+=f[i];p[s]=i;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();sum+=x, q.<span class="hljs-built_in">push</span>(x);&#125;<span class="hljs-type">int</span> m=p[sum];<span class="hljs-keyword">if</span>(!m) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i;--i) &#123;<span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(x&lt;f[i]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(t!=<span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(t);        <span class="hljs-comment">// 延迟入堆，i=m时使用过的字符，到了i=m-2时才能使用</span>t=x-f[i];&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1334E Divisor Paths 题解</title>
    <link href="/2022/cf1344e-solution/"/>
    <url>/2022/cf1344e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>放一张题面里的图。</p><p><img src="https://s2.loli.net/2022/08/15/HuQbB3C76AJsmWR.png" srcset="/img/loading.gif" lazyload /></p><p>能发现走一条边就是除掉或加入一个质因子。</p><p>从 <span class="math inline">\(x\)</span> 走到 <spanclass="math inline">\(y\)</span>的最短路，一定是先除掉若干质因子，再加入若干质因子。中间那个临界点是<span class="math inline">\(d=\gcd(x,y)\)</span>。</p><p>然后考虑一条节点不断变小的路径，发现它的边权和可以消去中间项，只和首位有关。因此<span class="math inline">\((x \rightarrow d)\)</span> 与 <spanclass="math inline">\((y \rightarrow d)\)</span>的最短路和具体消去质因子的顺序无关。</p><p>以 <span class="math inline">\((x \rightarrow d)\)</span> 为例。把<span class="math inline">\(\frac{x}{d}\)</span> 分解为 <spanclass="math inline">\(\prod_{i=1}^mp_i^{e_i}\)</span>，则消去质因子的方案数是 <span class="math display">\[f\Big(\frac{x}{d}\Big) =  \frac{(\sum_{i=1}^me_i)!}{\prod_{i=1}^m(e_i!)}\]</span> 最终答案就是 <spanclass="math inline">\(f\Big(\frac{x}{d}\Big) \timesf\Big(\frac{y}{d}\Big)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> D, q, cnt, d[<span class="hljs-number">100</span>], fac[<span class="hljs-number">100</span>];<span class="hljs-comment">// 虽然D很大，但是质因数个数和质因数指数都是log级别的</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>, q=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i) <span class="hljs-keyword">if</span>(x%d[i]==<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> e=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%d[i]==<span class="hljs-number">0</span>) x/=d[i], ++e;p+=e, (q*=fac[e])%=mod;&#125;<span class="hljs-keyword">return</span> fac[p]*<span class="hljs-built_in">fp</span>(q,mod<span class="hljs-number">-2</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;D=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=D;++i) <span class="hljs-keyword">if</span>(D%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span>(D%i==<span class="hljs-number">0</span>) D/=i;d[++cnt]=i;&#125;<span class="hljs-keyword">if</span>(D&gt;<span class="hljs-number">1</span>) d[++cnt]=D;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> z=<span class="hljs-built_in">gcd</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">calc</span>(x/z)*<span class="hljs-built_in">calc</span>(y/z)%mod);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6278 Haircut 题解</title>
    <link href="/2022/lg6278-solution/"/>
    <url>/2022/lg6278-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>一道很有趣，也很有益的题目（雾）。</p><h2 id="分析">分析</h2><p>注意到 <span class="math inline">\(a_i \in[0,N]\)</span>，这是很关键的一个点，可以从每个 <spanclass="math inline">\(a_i\)</span> 下手。</p><p>当 <span class="math inline">\(j= a_i\)</span> 时，所有大于 <spanclass="math inline">\(a_i\)</span> 的数都会等于 <spanclass="math inline">\(a_i\)</span>。也就是说，所有 <spanclass="math inline">\(a_i\)</span>作为较小数的逆序对，全部寄了。这样看起来很难下手。</p><p>可是退一步，当 <span class="math inline">\(j=a_i\)</span> 时，小于<span class="math inline">\(a_i\)</span> 的数不变，大于 <spanclass="math inline">\(a_i\)</span> 的数变为 <spanclass="math inline">\(a_i\)</span>，它们的相对大小不变。因此，当 <spanclass="math inline">\(j=a_i\)</span> 时，由大于 <spanclass="math inline">\(a_i\)</span> 的数 <spanclass="math inline">\(a_x\)</span> 和小于 <spanclass="math inline">\(a_i\)</span> 的数 <spanclass="math inline">\(a_y\)</span>，构成的逆序对 <spanclass="math inline">\((x,y)\)</span>，其中 <spanclass="math inline">\((x&lt;y)\)</span>，此时一定仍然成立。而对于由两个小于<span class="math inline">\(a_i\)</span>的数构成的逆序对，显然也成立。</p><p>所以如果以较小数为基准，设 <spanclass="math inline">\(S_{a_i}\)</span> 为 <spanclass="math inline">\([1,i-1]\)</span> 中大于 <spanclass="math inline">\(a_i\)</span> 的数的个数，那么当 <spanclass="math inline">\(j \ge a_i\)</span> 时，这些逆序对仍然成立。</p><p>而由上述讨论知道，其他的逆序对绝对不成立。</p><p>因此，用树状数组求出 <span class="math inline">\(S_{a_i}\)</span>。当<span class="math inline">\(j=t\)</span> 时，答案为 <spanclass="math inline">\(\sum_{k=0}^{t-1} S_k\)</span>。</p><p>由于树状数组下标必须为正整数，所以要平移一位。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, ans, a[N], s[N], c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">for</span>(;x&lt;=<span class="hljs-number">1e5</span>;x+=x&amp;(-x)) c[x]+=y; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;(-x)) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>; <span class="hljs-comment">// 平移</span><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> d=n-(a[i]<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;s[a[i]]+=<span class="hljs-built_in">query</span>(d<span class="hljs-number">-1</span>);<span class="hljs-built_in">modify</span>(d,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans+=s[i<span class="hljs-number">-1</span>]);    <span class="hljs-comment">// 由于平移了一位，所以是[2,n]</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「AtCoder Beginner Contest」#264</title>
    <link href="/2022/abc264-solution/"/>
    <url>/2022/abc264-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>ABC264</strong>.</p><h2 id="a.-atcoder.substr">A. "atcoder".substr()</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;string s=<span class="hljs-string">&quot;atcoder&quot;</span>;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, r=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(;l&lt;=r;++l) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[l]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="b.-nice-grid">B. Nice Grid</h2><p>不会结论，写了大暴力。把行折半之后大力判断。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> r=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(r&gt;=<span class="hljs-number">8</span>) r=<span class="hljs-number">16</span>-r;<span class="hljs-keyword">if</span>(r==<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">8</span>) <span class="hljs-keyword">if</span>(c&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(r&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(r==<span class="hljs-number">3</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">2</span>&amp;&amp;c!=<span class="hljs-number">14</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">5</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">2</span>&amp;&amp;c!=<span class="hljs-number">14</span>&amp;&amp;c!=<span class="hljs-number">4</span>&amp;&amp;c!=<span class="hljs-number">12</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">7</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">2</span>&amp;&amp;c!=<span class="hljs-number">14</span>&amp;&amp;c!=<span class="hljs-number">4</span>&amp;&amp;c!=<span class="hljs-number">12</span>&amp;&amp;c!=<span class="hljs-number">6</span>&amp;&amp;c!=<span class="hljs-number">10</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(r==<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">1</span>&amp;&amp;c!=<span class="hljs-number">15</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">4</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">1</span>&amp;&amp;c!=<span class="hljs-number">15</span>&amp;&amp;c!=<span class="hljs-number">3</span>&amp;&amp;c!=<span class="hljs-number">13</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">6</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">1</span>&amp;&amp;c!=<span class="hljs-number">15</span>&amp;&amp;c!=<span class="hljs-number">3</span>&amp;&amp;c!=<span class="hljs-number">13</span>&amp;&amp;c!=<span class="hljs-number">5</span>&amp;&amp;c!=<span class="hljs-number">11</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);&#125;&#125;&#125;</code></pre></div><h2 id="c.-matrix-reducing">C. Matrix Reducing</h2><p>显然对于任意 <span class="math inline">\(i\)</span>，<spanclass="math inline">\(B_i\)</span> 中每一个元素都要在 <spanclass="math inline">\(A\)</span> 中某一行 <spanclass="math inline">\(j\)</span> 全部出现，且若 <spanclass="math inline">\(i&#39; &gt; i\)</span>，则 <spanclass="math inline">\(j&#39; &gt; j\)</span>。否则无解。</p><p>然后如同</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span>    <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-number">16</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span></code></pre></div><p><span class="math inline">\(B\)</span> 中每一行的元素在 <spanclass="math inline">\(A\)</span>中对应行的位置，必须完全相同。样例中都是<code>1 3 4</code>。</p><p>就这么点东西，实现的时候有亿点细节。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> n1, m1, n2, m2, a[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>], b[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>], c[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-type">int</span> lst;multiset&lt;<span class="hljs-type">int</span>&gt; st[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n1=<span class="hljs-built_in">read</span>(), m1=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m1;++j) &#123;a[i][j]=<span class="hljs-built_in">read</span>();st[i].<span class="hljs-built_in">insert</span>(a[i][j]);        <span class="hljs-comment">// multiset维护每一行出现的数字</span>&#125;n2=<span class="hljs-built_in">read</span>(), m2=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n2;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) b[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n2;++i) &#123;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=lst+<span class="hljs-number">1</span>;j&lt;=n1;++j) <span class="hljs-keyword">if</span>(st[j].<span class="hljs-built_in">count</span>(b[i][<span class="hljs-number">1</span>])) &#123;st[j].<span class="hljs-built_in">erase</span>(st[j].<span class="hljs-built_in">find</span>(b[i][<span class="hljs-number">1</span>]));            <span class="hljs-comment">// 存在第一个元素的话就尝试找所有元素</span>            <span class="hljs-comment">// 记得找完之后删除，因为可能有重复的</span><span class="hljs-type">bool</span> ok=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;k&lt;=m2;++k)<span class="hljs-keyword">if</span>(!st[j].<span class="hljs-built_in">count</span>(b[i][k])) &#123; ok=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;                <span class="hljs-comment">// 有一个数字不存在，直接放弃这行</span><span class="hljs-keyword">else</span> st[j].<span class="hljs-built_in">erase</span>(st[j].<span class="hljs-built_in">find</span>(b[i][k]));<span class="hljs-keyword">if</span>(ok) &#123; fg=j; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=m1;++k) &#123;<span class="hljs-keyword">if</span>(b[i][j]==a[fg][k]) c[i][j]=k;                <span class="hljs-comment">// 记录位置</span>&#125;lst=fg;            <span class="hljs-comment">// 下一行要从fg+1开始找</span>&#125;&#125;    <span class="hljs-comment">// 下面这两块都是判断c[i][j]是否完全相同。</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n2;++i) &#123;<span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) &#123;<span class="hljs-keyword">if</span>(pre&gt;c[i][j]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">else</span> pre=<span class="hljs-built_in">max</span>(pre,c[i][j]);&#125;        <span class="hljs-comment">// 看有没有逆序对，有逆序对也是无解</span>&#125;    <span class="hljs-comment">// 看看对应位置，所有行是否相同</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) &#123;<span class="hljs-type">int</span> fg=c[<span class="hljs-number">1</span>][j];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n2;++i) <span class="hljs-keyword">if</span>(c[i][j]!=fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125;</code></pre></div><h2 id="d.-redocta.swapii1">D. "redocta".swap(i,i+1)</h2><p>求逆序对个数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;t&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">114514</span>;&#125;<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;string s; cin&gt;&gt;s;s=<span class="hljs-string">&quot; &quot;</span>+s;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">7</span>;++i) a[i]=<span class="hljs-built_in">trans</span>(s[i]);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">7</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">7</span>;++j) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;a[j]) ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="e.-blackout-2">E. Blackout 2</h2><p>经典套路，删边转化为倒序加边，于是乎问题变为维护连通性和连通块信息。</p><p>设 <span class="math inline">\(sz_i\)</span> 为连通块 <spanclass="math inline">\(i\)</span> 的大小，<spanclass="math inline">\(d_i\)</span> 为连通块 <spanclass="math inline">\(i\)</span> 包含的 power plants 的数量。</p><p>考虑合并两个连通块 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>，如果 <span class="math inline">\(d_i&gt; 0\)</span> 并且 <span class="math inline">\(d_j &gt;0\)</span>，那么合并之后不会产生任何贡献，因为在合并之前，<spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 之中的城市就已经连接到各自的 powerplants 了。</p><p>否则，如果 <span class="math inline">\(d_i =0\)</span> 且 <spanclass="math inline">\(d_j = 0\)</span>，那么合并之后也没有贡献。</p><p>当 <span class="math inline">\(d_i = 0\)</span> 且 <spanclass="math inline">\(d_j &gt; 0\)</span> 时，贡献为 <spanclass="math inline">\(sz_i\)</span>，否则为 <spanclass="math inline">\(sz_j\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, e, Q, dlt, u[N], v[N], q[N], d[N], fa[N], sz[N], ans[N];<span class="hljs-type">bool</span> vv[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123;<span class="hljs-keyword">if</span>(!d[x]&amp;&amp;d[y]) dlt+=sz[x];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!d[y]&amp;&amp;d[x]) dlt+=sz[y];fa[x]=y, sz[y]+=sz[x], d[y]+=d[x];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), e=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) d[n+i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) fa[i]=i, sz[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=e;++i) &#123;u[i]=<span class="hljs-built_in">read</span>(), v[i]=<span class="hljs-built_in">read</span>();&#125;Q=<span class="hljs-built_in">read</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;++i) q[i]=<span class="hljs-built_in">read</span>(), vv[q[i]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=e;++i) <span class="hljs-keyword">if</span>(!vv[i]) <span class="hljs-built_in">merge</span>(u[i],v[i]);    <span class="hljs-comment">// 合并没有被删的边</span>ans[Q]=dlt;    <span class="hljs-comment">// ans[i]表示第i次删除之后的信息，所以只需要加边[q[2],q[Q]]即可</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Q;i&gt;<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-built_in">merge</span>(u[q[i]],v[q[i]]);ans[i<span class="hljs-number">-1</span>]=dlt;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;</code></pre></div><h1 id="f.-monochromatic-path">F. Monochromatic Path</h1><h2 id="分析">分析</h2><p>显然，对于一行或者一列，修改次数只有 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(f(i,j,p=0/1,q=0/1)\)</span> 表示，从<span class="math inline">\((1,1)\)</span> 到达 <spanclass="math inline">\((i,j)\)</span>，且第 <spanclass="math inline">\(i\)</span> 行的修改次数为 <spanclass="math inline">\(p\)</span>，第 <spanclass="math inline">\(j\)</span> 列的修改次数为 <spanclass="math inline">\(q\)</span>，所需的最小代价。</p><p>通过状态记录的信息就能得出，此时 <spanclass="math inline">\((i,j)\)</span> 的数字为 <spanclass="math inline">\(c1 = a_{i,j} \oplus p \oplusq\)</span>。顺便说一句这是因为异或是异或的逆运算，异或两次等于没异或。</p><p>同时也就得到了 <span class="math inline">\((i+1,j)\)</span> 和 <spanclass="math inline">\((i,j+1)\)</span> 的颜色 <spanclass="math inline">\(c2\)</span>，分别为 <spanclass="math inline">\(a_{i+1,j} \oplus q\)</span>，<spanclass="math inline">\(a_{i,j+1} \oplus p\)</span>。</p>这样就能够转移了。若颜色相同则代价不变，否则加上修改那一行/列的代价。 $$<span class="math display">\[\begin{cases}f(i,j,p,q) \rightarrow f(i+1,j,0,q) &amp; c1 = c2\\f(i,j,p,q) + r_{i+1} \rightarrow f(i+1,j,1,q) &amp; c1 \neq c2\end{cases}\]</span><p>$$</p><p><span class="math display">\[\begin{cases}f(i,j,p,q) \rightarrow f(i,j+1,p,0) &amp; c1=c2\\f(i,j,p,q) \rightarrow f(i,j+1,p,q) &amp; c1 \neq c2\end{cases}\]</span></p><p>最终答案 <span class="math display">\[\min_{i=0}^1 \min_{j=0}^1 \{ f(n,m,i,j) \}\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-type">int</span> n, m, a[N][N], r[N], c[N];<span class="hljs-type">int</span> f[N][N][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=j;i&lt;=k;++i)</span><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) r[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%1d&quot;</span>,&amp;a[i][j]);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=r[<span class="hljs-number">1</span>], f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=c[<span class="hljs-number">1</span>];f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=r[<span class="hljs-number">1</span>]+c[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 初始值</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(p,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(q,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;=n) &#123;<span class="hljs-type">int</span> c1=a[i][j]^p^q, c2=a[i+<span class="hljs-number">1</span>][j]^q;<span class="hljs-keyword">if</span>(c1==c2) f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>][q]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>][q],f[i][j][p][q]);<span class="hljs-keyword">else</span> f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>][q]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>][q],f[i][j][p][q]+r[i+<span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;=m) &#123;<span class="hljs-type">int</span> c1=a[i][j]^p^q, c2=a[i][j+<span class="hljs-number">1</span>]^p;<span class="hljs-keyword">if</span>(c1==c2) f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">0</span>],f[i][j][p][q]);<span class="hljs-keyword">else</span> f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">1</span>],f[i][j][p][q]+c[j+<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1e15</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ans=<span class="hljs-built_in">min</span>(ans,f[n][m][i][j]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#813 (Div 2)</title>
    <link href="/2022/cf1712-solution/"/>
    <url>/2022/cf1712-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1712</strong>.</p><h2 id="a.-wonderful-permutation">A. Wonderful Permutation</h2><p>考虑到这是个排列，所以最优解一定是把 <span class="math inline">\(1\sim k\)</span> 都放在 <span class="math inline">\([1,k]\)</span>里面，因此答案是 <span class="math inline">\([1,k]\)</span> 中满足 <spanclass="math inline">\(p_i&gt;k\)</span> 的 <spanclass="math inline">\(i\)</span> 的个数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> t, n, k, a[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-keyword">if</span>(a[i]&gt;k) ++ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-woeful-permutation">B. Woeful Permutation</h2><p>如果 <span class="math inline">\(a,b\)</span> 互质，那么 <spanclass="math inline">\(\operatorname{lcm}(a,b) = a \timesb\)</span>。</p><p>由于这是个排列，而相邻两数必定互质，所以先令 <spanclass="math inline">\(p_i = i\)</span>，从大到小贪心地两两交换即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i-=<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(a[i],a[i<span class="hljs-number">-1</span>]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-sort-zero">C. Sort Zero</h2><p>由于最终序列单调不降，所以 <span class="math inline">\(0\)</span>一定是一段前缀。</p><p>考虑如果存在由重复元素围成的峰，例如<code>1 2 1</code>，那么这一段必然全部为<spanclass="math inline">\(0\)</span>；如果存在由重复元素围成的谷，例如<code>2 1 2</code>，那么这一段也必然全部为<span class="math inline">\(0\)</span>。</p><p>以上两种情况，均可以推得那一段前缀全部为 <spanclass="math inline">\(0\)</span>。</p><p>但是，取最靠后的峰或谷的末尾，就一定可行吗？</p><p>考虑</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span></code></pre></div><p>不存在峰和谷，但是由于存在逆序对导致不满足单调不降，所以必须将这个逆序对破坏掉。</p><p>也就是说，假设 <span class="math inline">\(a_{i-1}\)</span> 和 <spanclass="math inline">\(a_i\)</span> 构成了逆序对，那么 <spanclass="math inline">\(a_{i-1}\)</span> 必须为 <spanclass="math inline">\(0\)</span>，进而 <spanclass="math inline">\([1,i-1]\)</span> 必须全为 <spanclass="math inline">\(0\)</span>。</p><p>同理</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span></code></pre></div><p>有峰有谷，但是不满足由重复元素围成。考虑到有峰有谷就一定存在逆序对，那么仍然按照上面的方法就行。</p><p>最后找到全部为 <span class="math inline">\(0\)</span> 的前缀 <spanclass="math inline">\([1,d]\)</span>，答案为 <spanclass="math inline">\([1,d]\)</span> 中不同元素的数量。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N];set&lt;<span class="hljs-type">int</span>&gt; s, st;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();s.<span class="hljs-built_in">clear</span>(), st.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(a[i])&amp;&amp;a[i]!=a[i<span class="hljs-number">-1</span>]) d=i;        <span class="hljs-comment">// 如果s.count(a[i])成立，说明有重复元素</span>        <span class="hljs-comment">// 如果a[i]!=a[i-1]成立，说明这两个重复元素必然构成峰或谷</span>        <span class="hljs-comment">// 重复元素相邻的情况则不用考虑</span>s.<span class="hljs-built_in">insert</span>(a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;d+<span class="hljs-number">1</span>;--i) <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>]) &#123; d=i<span class="hljs-number">-1</span>; <span class="hljs-keyword">break</span>; &#125;    <span class="hljs-comment">// 找到最后一个逆序对的位置</span><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=d;++i) &#123;<span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(a[i])) <span class="hljs-keyword">continue</span>;++ans, st.<span class="hljs-built_in">insert</span>(a[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-empty-graph">D. Empty Graph</h2><p>一个结论：这张图的直径一定来自于两个相邻的节点。</p><blockquote><p>证明：假设直径的两个端点 <span class="math inline">\(l\)</span> 与<span class="math inline">\(r\)</span>，不满足 <spanclass="math inline">\(l+1=r\)</span>，那么将 <spanclass="math inline">\(r\)</span> 改为 <spanclass="math inline">\(r-1\)</span> 后，由于 <spanclass="math inline">\(\min_{i=l}^r{\{ a_i \}} \le\min_{i=l}^{r-1}{a_i}\)</span>，所以这时候两点之间的距离不会变小。也就是说，对于一个固定的左端点<spanclass="math inline">\(l\)</span>，不断让左右端点靠近，结果一定不会变差。</p></blockquote><p>因此可以二分直径长度 <spanclass="math inline">\(mid\)</span>，判断能否使用不超过 <spanclass="math inline">\(k\)</span>次操作使得存在某个点对之间的距离大于等于 <spanclass="math inline">\(k\)</span>。</p><p>从 <span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(i+1\)</span> 的最短路有 <spanclass="math inline">\(3\)</span> 种，一是直接走 <spanclass="math inline">\(\min(a_i,a_{i+1})\)</span>，二是从 <spanclass="math inline">\(i\)</span> 走到 <spanclass="math inline">\([i+2,n]\)</span> 中满足 <spanclass="math inline">\(a_j\)</span> 最小的 <spanclass="math inline">\(j\)</span> ，再走回 <spanclass="math inline">\(i+1\)</span>，三是从 <spanclass="math inline">\(i+1\)</span> 走到 <spanclass="math inline">\([1,i-1]\)</span> 中满足 <spanclass="math inline">\(a_j\)</span> 最小的 <spanclass="math inline">\(j\)</span> 再走回 <spanclass="math inline">\(i\)</span>。</p><p>设 <span class="math inline">\(p_i =\min_{j=1}^i{\{a_j\}}\)</span>，<span class="math inline">\(q_i =\min_{j=i}^n {\{ a_j \}}\)</span>，则第二种的长度为 <spanclass="math inline">\(2 \cdot p_{i-1}\)</span>，第三种的长度为 <spanclass="math inline">\(2 \cdot q_{i+2}\)</span>。</p><p>如何安排操作呢？仔细思考发现，操作是牵一发而动全身的。假如 <spanclass="math inline">\(a_i&lt;mid\)</span>，那么修改 <spanclass="math inline">\(a_i\)</span> 之后，必须让其他决策全部不能优于<span class="math inline">\(a_i\)</span>。即如果 <spanclass="math inline">\(a_{i+1} &lt;mid\)</span>，那么不用考虑，否则就要修改它到大于等于 <spanclass="math inline">\(a_i\)</span>。同理如果修改了 <spanclass="math inline">\(p_{i-1}\)</span>，那么还要修改其他 <spanclass="math inline">\([1,i-1]\)</span> 中满足 <spanclass="math inline">\(a_j &lt; mid\)</span> 的 <spanclass="math inline">\(j\)</span>，使得它们不对最短路产生影响。</p><p>更进一步地，所有权值小于 <span class="math inline">\(mid\)</span>的路径都要修改，而无论取哪个决策，操作数量是不会变化的。</p><p>因此设 <span class="math inline">\(c_i\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 中满足 <spanclass="math inline">\(2 \cdot a_j &lt; mid\)</span> 的 <spanclass="math inline">\(j\)</span> 的个数，<spanclass="math inline">\(d_i\)</span> 为 <spanclass="math inline">\([i,n]\)</span> 中满足上述条件的 <spanclass="math inline">\(j\)</span> 的个数。对于一个点对 <spanclass="math inline">\((i,i+1)\)</span>，将这两点之间的距离作为直径的操作数是<span class="math display">\[\Delta + c_{i-1} + d_{i+2}\]</span> 其中 <span class="math inline">\(\Delta\)</span> 为 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(a_{i+1}\)</span> 中，小于 <spanclass="math inline">\(mid\)</span> 的个数。</p><p>每次二分用 <span class="math inline">\(O(n)\)</span>的时间找到最小操作数，判断是否小于等于 <spanclass="math inline">\(k\)</span> 即可。</p><p>复杂度为 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><p>另外还有排序再贪心的方法，可以参考<ahref="https://zhuanlan.zhihu.com/p/553529151">这篇博客</a>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, k, a[N], c[N], d[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) c[i]=d[i]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;c[i]=c[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*a[i]&lt;x) ++c[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) &#123;d[i]=d[i+<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*a[i]&lt;x) ++d[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> q=(a[i]&lt;x)+(a[i+<span class="hljs-number">1</span>]&lt;x);ans=<span class="hljs-built_in">min</span>(ans,q+c[i<span class="hljs-number">-1</span>]+d[i+<span class="hljs-number">2</span>]);&#125;<span class="hljs-keyword">return</span> ans&lt;=k;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1e9</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e1.-lcm-sum-easy-version">E1. LCM Sum (easy version)</h2><p>正难则反，考虑用三元组的总数减去满足 <spanclass="math inline">\(\operatorname{lcm}(i,j,k) &lt; i+j+k\)</span>的三元组的个数。</p><p>由于 <span class="math inline">\(i,j,k\)</span> 有序，设 <spanclass="math inline">\(len = r-l+1\)</span>，则总数为 <spanclass="math display">\[\frac{len(len-1)(len-2)}{P_3^3} = \frac{len(len-1)(len-2)}{6}\]</span> 考虑到 <span class="math inline">\(i &lt; j &lt;k\)</span>，那么 <span class="math inline">\(i+j+k &lt;3k\)</span>，因此 <span class="math inline">\(\operatorname{lcm}(i,j,k)&lt; 3k\)</span>，所以 <spanclass="math inline">\(\operatorname{lcm}(i,j,k)\)</span> 只能为 <spanclass="math inline">\(k\)</span> 或者 <spanclass="math inline">\(2k\)</span>。</p><p>枚举 <span class="math inline">\(k\)</span>，再枚举 <spanclass="math inline">\(2k\)</span> 的每个约数 <spanclass="math inline">\(j\)</span>，再枚举 <spanclass="math inline">\(i\)</span>，逐一判断即可。时间限制为 <spanclass="math inline">\(3.5s\)</span>，加上剪枝就能过了。</p><p>具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, l, r;vector&lt;<span class="hljs-type">int</span>&gt; factor[<span class="hljs-number">2</span>*N]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> len=r-l+<span class="hljs-number">1</span>;<span class="hljs-type">int</span> ans=(len*(len<span class="hljs-number">-1</span>)*(len<span class="hljs-number">-2</span>))/<span class="hljs-number">6</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l+<span class="hljs-number">2</span>;k&lt;=r;++k) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:factor[<span class="hljs-number">2</span>*k]) &#123;<span class="hljs-keyword">if</span>(j&lt;l||k%j&amp;&amp;<span class="hljs-number">2</span>*j&lt;=k) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 不在区间内的就不要了</span>            <span class="hljs-comment">// k%j!=0，说明lcm(i,j,k)=2k</span>            <span class="hljs-comment">// 如果2*j&lt;=k，那么由于i&lt;j，所以i+j&lt;k，所以i+j+k&lt;2k，也就是lcm(i,j,k)&gt;i+j+k</span>            <span class="hljs-comment">// 矛盾</span><span class="hljs-keyword">if</span>(j&gt;=k) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:factor[<span class="hljs-number">2</span>*k]) &#123;<span class="hljs-keyword">if</span>(i&lt;l) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(i&gt;=j) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(k%j||k%i) ans-=(<span class="hljs-number">2</span>*k)&lt;(i+j+k);                <span class="hljs-comment">// 任何一个成立，说明lcm(i,j,k)=2k，直接判断</span><span class="hljs-keyword">else</span> --ans;                <span class="hljs-comment">// 否则lcm(i,j,k)=k，一定小于i+j+k</span>&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4e5</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>*i;j&lt;=<span class="hljs-number">4e5</span>;j+=i)factor[j].<span class="hljs-built_in">push_back</span>(i);    <span class="hljs-comment">// O(nlogn)的时间里求出[1,n]中每个数的约数</span>t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NowCoderX54F 题解</title>
    <link href="/2022/ncx54f-solution/"/>
    <url>/2022/ncx54f-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>先给一组官方题解的数据。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">10</span> <span class="hljs-number">10</span><span class="hljs-number">10</span> <span class="hljs-number">19</span> <span class="hljs-number">18</span> <span class="hljs-number">17</span> <span class="hljs-number">16</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span> <span class="hljs-number">13</span> <span class="hljs-number">12</span> <span class="hljs-number">10</span></code></pre></div><p>先考虑特殊情况，对于每个 <spanclass="math inline">\(i\)</span>，要求从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(i\)</span> 再到 <spanclass="math inline">\(n\)</span> 的最短路长度为 <spanclass="math inline">\(d_i\)</span>。那么当 <spanclass="math inline">\(i=1\)</span> 或者 <spanclass="math inline">\(i=n\)</span> 时，都相当于 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的最短路。于是 <spanclass="math inline">\(d_1\)</span> 必须等于 <spanclass="math inline">\(d_n\)</span>，且二者必须为 <spanclass="math inline">\(\min_{i=1}^n{\{d_i\}}\)</span>，否则一定无解。</p><p>于是乎我们就能搞出第一条边。</p><p><img src="https://s2.loli.net/2022/08/14/DXKlfk1MjiPTYOa.png" srcset="/img/loading.gif" lazyload /></p><p>从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(i\)</span> 再到 <spanclass="math inline">\(n\)</span>，一种做法是将 <spanclass="math inline">\(i\)</span> 作为一个中转点，单纯地 <spanclass="math inline">\(1 \rightarrow i \rightarrown\)</span>，另一种做法是 <span class="math inline">\(1 \rightarrow i\rightarrow 1 \rightarrow n\)</span>。后者的好处就是，<spanclass="math inline">\((1 \rightarrow i)\)</span> 走了两遍，如果 <spanclass="math inline">\(d_i - d_1\)</span>是个偶数，那么这就很好构造了。直接连接 <spanclass="math inline">\((1,i)\)</span>，权值为 <spanclass="math inline">\(\frac{d_i-d_1}{2}\)</span>。</p><p>形成一个大菊花。</p><p><img src="https://s2.loli.net/2022/08/14/G9xnosaItbSVvk6.png" srcset="/img/loading.gif" lazyload /></p><p>那么剩下的只有 <span class="math inline">\(2 \nmid d_i - d_1\)</span>的情况了，我们可以尝试上述第一种做法，把 <spanclass="math inline">\(i\)</span> 作为一个中转点，连边 <spanclass="math inline">\((1,i)\)</span>，<spanclass="math inline">\((i,n)\)</span>。这时候突然发现，如果 <spanclass="math inline">\((1,i)\)</span> 的权值 <spanclass="math inline">\(\Delta\)</span> 为奇数，剩下的点 <spanclass="math inline">\(j\)</span> 一定有 <span class="math inline">\(2\mid d_j - d_1 - \Delta\)</span>，于是就能将剩下的点连到 <spanclass="math inline">\(i\)</span>上，再用上面的方法了。为了防止负权，这个 <spanclass="math inline">\(i\)</span> 一定满足 <spanclass="math inline">\(d_i - d_1\)</span> 最小。</p><p><img src="https://s2.loli.net/2022/08/14/wOqJLPbCK8ym6tS.png" srcset="/img/loading.gif" lazyload /></p><p>那么如何取值最优呢？首先从 <span class="math inline">\(1\)</span>经过 <span class="math inline">\(i\)</span>的道路不止一条，就比如图中还有 <span class="math inline">\(1 \rightarrow8 \rightarrow 1 \rightarrow 10\)</span>，<span class="math inline">\(1\rightarrow 10 \rightarrow 8 \rightarrow 10\)</span>。如果 <spanclass="math inline">\(1 \rightarrow 8 \rightarrow 10\)</span>不是最优的话，那么这个方法就死掉了。</p><p>可是构造题只关注可行性，所以要想办法让 <span class="math inline">\(1\rightarrow i \rightarrow n\)</span>最优。注意到其他两种方法，本质上就是走了一遍 <spanclass="math inline">\(d_1\)</span>，走了两遍 <spanclass="math inline">\(1 \rightarrow i\)</span> 或者 <spanclass="math inline">\(i \rightarrow n\)</span>。</p><p>由于 <span class="math inline">\(d_i\)</span> 是个大于等于 <spanclass="math inline">\(d_1\)</span> 且与 <spanclass="math inline">\(d_1\)</span> 奇偶性不同的数，所以 <spanclass="math inline">\(d_i &gt; d_1\)</span>，当边权取 <spanclass="math inline">\(\lfloor \frac{d_i}{2} \rfloor\)</span> 和 <spanclass="math inline">\(\lfloor \frac{d_i}{2} \rfloor + 1\)</span>时，走两遍后，最短也是 <span class="math inline">\(d_i -1\)</span>。因此，这种情况下，只要满足 <span class="math inline">\(d_1 +d_i -1 \ge d_i\)</span>，就能保证 <span class="math inline">\(1\rightarrow i \rightarrow n\)</span> 的走法是最优的。上式解得 <spanclass="math inline">\(d_1 \ge 1\)</span>。</p><p><img src="https://s2.loli.net/2022/08/14/a9Lpl61cZOmbVnK.png" srcset="/img/loading.gif" lazyload /></p><p>如果 <span class="math inline">\(d_1 = 0\)</span> 且存在满足 <spanclass="math inline">\(2 \nmid d_i - d_1\)</span> 的 <spanclass="math inline">\(i\)</span>，这种构造思路就失效了。</p><p>设满足 <span class="math inline">\(2 \nmid d_i - i\)</span>的点为奇点 <span class="math inline">\(odd\)</span>，其余为偶点 <spanclass="math inline">\(even\)</span>，这样使用的边数为 <spanclass="math inline">\(1+even + (1 + odd) =n\)</span>，如果不存在奇点，那么就是 <spanclass="math inline">\(1+even\)</span>。</p><p>剩下的边权用 <span class="math inline">\(10^9\)</span>即可，因为这样不会影响到最短路。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, mn=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, d[N];vector&lt;<span class="hljs-type">int</span>&gt; odd, even;set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; s;<span class="hljs-comment">// 用set判断是否存在</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> d[x]&lt;d[y]; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,x,y,z);s.<span class="hljs-built_in">insert</span>(&#123;x,y&#125;);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;mn=<span class="hljs-built_in">min</span>(d[i]=<span class="hljs-built_in">read</span>(),mn);<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;i&lt;n) &#123;<span class="hljs-keyword">if</span>((d[i]-d[<span class="hljs-number">1</span>])&amp;<span class="hljs-number">1</span>) odd.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">else</span> even.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;<span class="hljs-type">int</span> nd=<span class="hljs-number">1</span>+even.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span>(odd.<span class="hljs-built_in">size</span>()) nd+=odd.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(m&gt;n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>||nd&gt;m||d[<span class="hljs-number">1</span>]!=d[n]||d[<span class="hljs-number">1</span>]!=mn||d[n]!=mn||(!mn&amp;&amp;odd.<span class="hljs-built_in">size</span>()))    <span class="hljs-comment">// 如果m超过了完全图的边数，显然也无解</span>&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,n,d[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:even) <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,x,(d[x]-d[<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>);<span class="hljs-keyword">if</span>(odd.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-built_in">sort</span>(odd.<span class="hljs-built_in">begin</span>(),odd.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-type">int</span> a=odd[<span class="hljs-number">0</span>];<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,a,d[a]/<span class="hljs-number">2</span>+d[a]%<span class="hljs-number">2</span>);<span class="hljs-built_in">add</span>(a,n,d[a]/<span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;odd.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-type">int</span> b=odd[i];<span class="hljs-built_in">add</span>(a,b,(d[b]-d[a])/<span class="hljs-number">2</span>);&#125;&#125;m-=nd;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n&amp;&amp;m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) &#123;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(&#123;j,i&#125;)) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 注意是&#123;j,i&#125;</span><span class="hljs-built_in">add</span>(j,i,<span class="hljs-number">1e9</span>);<span class="hljs-keyword">if</span>(--m==<span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> end;&#125;end:;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NowCoder Round X」#54 题解</title>
    <link href="/2022/ncx54-solution/"/>
    <url>/2022/ncx54-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>NowCoderX54</strong>.</p><h2 id="a.-sum">A. Sum</h2><p>引理：在最优解中，每次操作的 <spanclass="math inline">\(k=2\)</span>。</p><blockquote><p>证明：反证法。假设最优解中，存在一次操作 <spanclass="math inline">\(k \neq 2\)</span>。那么 <spanclass="math inline">\(k \ge 3\)</span>，当 <spanclass="math inline">\(k=3\)</span> 时，设选择的数为 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<spanclass="math inline">\(c\)</span>，那么会得到 <spanclass="math inline">\(a+b+c\)</span>，收益为 <spanclass="math inline">\(a+b+c\)</span>。如果先选择 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 得到 <spanclass="math inline">\(a+b\)</span>，再选择 <spanclass="math inline">\(a+b\)</span> 与 <spanclass="math inline">\(c\)</span>，那么会得到 <spanclass="math inline">\(a+b+c\)</span>，收益为 <spanclass="math inline">\((a+b)+(a+b+c)\)</span>。这与最优解矛盾。由于操作次数没有限制，所以引理显然成立。</p></blockquote><p>引理：在最优解中，一定先选择较大的数，再选择较小的数。</p><blockquote><p>证明：感性理解。如果选择了最大的数和一个正数，那么它被删去之后会在另一个更大数之内，此后只要选这个更大的数，原先最大的数就会不断产生贡献。如果一开始选的数不是最大的数，显然不优。</p></blockquote><p>将数列递减排序，维护前缀和 <spanclass="math inline">\(pre\)</span>，对于 <span class="math inline">\(i&gt; 1\)</span>，先令 <span class="math inline">\(pre +a_i\)</span>，如果此时 <span class="math inline">\(pre &gt;0\)</span>，那么累加答案即可。</p><p><span class="math inline">\(pre\)</span>其实是此时数列里最大的数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> t, n, a[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x&gt;y; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<span class="hljs-type">int</span> pre=a[<span class="hljs-number">1</span>], ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;pre+=a[i];<span class="hljs-keyword">if</span>(pre&gt;<span class="hljs-number">0</span>) (ans+=pre)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-gaming">B. Gaming</h2><p>将 <span class="math inline">\((l_i,r_i,s_i)\)</span> 看作是让 <spanclass="math inline">\([l_i,r_i]\)</span> 都加上 <spanclass="math inline">\(s_i\)</span>，那么对于每一个位置 <spanclass="math inline">\(i\)</span>，表示的就是必须带着第 <spanclass="math inline">\(i\)</span> 个 debuff 才能拿到的总分数，设为 <spanclass="math inline">\(c_i\)</span>。</p><p>设总分数为 <span class="math inline">\(S\)</span>，那么没有带着所有debuff 获得的最大的分，相当于带着 <spanclass="math inline">\(m-1\)</span> 个 debuff 的最大得分。</p><p>于是乎答案为 <span class="math inline">\(\max_{i=1}^m \{ S - c_i\}\)</span>。</p><p>差分维护即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans, sum, c[N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();c[l]+=s, c[r+<span class="hljs-number">1</span>]-=s;sum+=s;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;c[i]+=c[i<span class="hljs-number">-1</span>];ans=<span class="hljs-built_in">max</span>(ans,sum-c[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="c.-school">C. School</h2><p>这个也可以差分，可是值域很大，一种方法是离散化。</p><p>将几时几分转化为分钟，对于每一个禁止通话的时间段 <spanclass="math inline">\([l_i,r_i]\)</span>，在 <spanclass="math inline">\(l_i\)</span> 处 <spanclass="math inline">\(+1\)</span>，在 <spanclass="math inline">\(r_i+1\)</span> 处 <spanclass="math inline">\(-1\)</span>。某个时间能够通话，那么这个时间的位置必须是<span class="math inline">\(0\)</span>，否则一定被某个区间包含。</p><p>直接查 <span class="math inline">\(x\)</span> 的位置是否为 <spanclass="math inline">\(0\)</span>，这是差分做法。</p><p>但是还有一个更简单的方法。</p><p>不被任何区间包含，也就是说，<span class="math inline">\(x\)</span>经过起点 <span class="math inline">\(l_i\)</span> 的个数必须等于经过终点<span class="math inline">\(r_i\)</span> 的个数。</p><p>将起点和终点分别排序，二分查找 <span class="math inline">\(x\)</span>严格大于的起点个数和严格大于的终点个数，判断是否相等即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">int</span> n, h, m, q;vector&lt;<span class="hljs-type">int</span>&gt; st, ed;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), h=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> x=a*m+b, y=c*m+d;st.<span class="hljs-built_in">push_back</span>(x), ed.<span class="hljs-built_in">push_back</span>(y);&#125;<span class="hljs-built_in">sort</span>(st.<span class="hljs-built_in">begin</span>(),st.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">sort</span>(ed.<span class="hljs-built_in">begin</span>(),ed.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();x=x*m+y;<span class="hljs-keyword">auto</span> d1=<span class="hljs-built_in">lower_bound</span>(st.<span class="hljs-built_in">begin</span>(),st.<span class="hljs-built_in">end</span>(),x)-st.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">auto</span> d2=<span class="hljs-built_in">lower_bound</span>(ed.<span class="hljs-built_in">begin</span>(),ed.<span class="hljs-built_in">end</span>(),x)-ed.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">if</span>(d1!=d2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125;&#125;</code></pre></div><h2 id="d.-word">D. Word</h2><p>将差异小于等于 <span class="math inline">\(1\)</span>的字符串互相连边。设 <span class="math inline">\(s\)</span> 为 <spanclass="math inline">\(0\)</span>，<span class="math inline">\(t\)</span>为 <span class="math inline">\(n+1\)</span>，等价于求出 <spanclass="math inline">\(0 \sim n+1\)</span> 的最短路。</p><p>BFS 即可，过程中记录方案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20005</span>;<span class="hljs-type">int</span> n, m, d[N], pre[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">char</span> s[N][<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diff</span><span class="hljs-params">(<span class="hljs-type">char</span>* s1,<span class="hljs-type">char</span>* s2)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cnt+=(s1[i]!=s2[i]);<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(d));d[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(~d[y]) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;pre[y]=x;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(!x) &#123; <span class="hljs-built_in">puts</span>(s[x]+<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">print</span>(pre[x]);<span class="hljs-built_in">puts</span>(s[x]+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,s[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>,s[n+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">diff</span>(s[i],s[j])&lt;=<span class="hljs-number">1</span>) <span class="hljs-built_in">addedge</span>(i,j);&#125;<span class="hljs-built_in">bfs</span>();<span class="hljs-keyword">if</span>(!d[n+<span class="hljs-number">1</span>]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(~d[n+<span class="hljs-number">1</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d[n+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">goto</span> end; &#125;<span class="hljs-built_in">print</span>(n+<span class="hljs-number">1</span>);end:;&#125;</code></pre></div><h2 id="d.-slash">D. Slash</h2><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为当前在矩阵的 <spanclass="math inline">\((i,j)\)</span>，匹配到了 <spanclass="math inline">\(s_k\)</span>，这个字符串含有 <spanclass="math inline">\(s\)</span> 的最大值。</p><p>当 <span class="math inline">\(a_{i,j} = s_k\)</span> 时 <spanclass="math display">\[f(i,j,k) = \max_{k \in [1,|s|]}{\{ f(i-1,j,k-1),f(i,j-1,k) \}}\]</span> 如果 <span class="math inline">\(a_{i,j}\)</span> 匹配到了<span class="math inline">\(s\)</span> 的最后一位，那么下一步就要从<span class="math inline">\(0\)</span> 开始匹配 <spanclass="math display">\[f(i,j,0) = f(i,j,|s|) + 1\]</span> 之前状态的任何局面都有可能从 <spanclass="math inline">\(0\)</span> 重新开始匹配，所以 <spanclass="math display">\[f(i,j,0) = \max_{k \in [0,|s|]} {\{ f(i-1,j,k),f(i,j-1,k) \}}\]</span> 初始值乱搞就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, m, l, f[N][N][N];<span class="hljs-type">char</span> s[N], a[N][N];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>), l=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a[i]+<span class="hljs-number">1</span>);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=l;++k) &#123;<span class="hljs-keyword">if</span>(a[i][j]==s[k])f[i][j][k]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][k<span class="hljs-number">-1</span>],f[i][j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>]);&#125;f[i][j][<span class="hljs-number">0</span>]=f[i][j][l]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=l;++k)f[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">0</span>],<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][k],f[i][j<span class="hljs-number">-1</span>][k]));&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=l;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][m][i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="f.-traveling">F. Traveling</h2><p>单独写了<ahref="https://yozora0908.github.io//ncx54f-solution">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>最短路</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6569 魔法值 题解</title>
    <link href="/2022/lg6569-solution/"/>
    <url>/2022/lg6569-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>天数异常大，但是节点数很小，由于异或运算满足结合律，直接考虑矩阵优化。</p><p>将初始魔法值搞成一个向量，<span class="math inline">\(n\)</span> 行<span class="math inline">\(1\)</span> 列。 <spanclass="math display">\[\begin{bmatrix}w_1\\w_2\\\vdots\\w_n\end{bmatrix}\]</span> 考虑转移矩阵 <span class="math inline">\(A\)</span>。</p><p>要达到的目的是，如果 <span class="math inline">\((i,k)\)</span>之间有边才进行运算。那么设 <span class="math inline">\(A_{i,k}\)</span>表示 <span class="math inline">\((i,k)\)</span> 是否相连。所以 <spanclass="math display">\[w&#39;_i = \bigoplus_{k=1}^n A_{i,k} \cdot w_k\]</span> 所以 <span class="math inline">\(A_{x,y} = A_{y,x} =1\)</span>。</p><p>好像就没有然后了。</p><p>因为有多次询问，直接做的话复杂度是 <span class="math inline">\(O(qn^3\log_2 k)\)</span> 的，较高。但是由于不仅做 <spanclass="math inline">\(O(n^3)\)</span> 的矩阵乘法，还要做上面那种 <spanclass="math inline">\(O(n^2)\)</span>的矩阵向量乘法，所以可以预处理矩阵次幂，对询问进行二进制拆分优化。</p><p>复杂度 <span class="math inline">\(O \Big( n^3\log_2 \max\{a_i\} + qn^2 \log_2 \max\{a_i\} \Big)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, q, w[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(m)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; f, rec[<span class="hljs-number">35</span>];Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)c.m[i][j]^=a.m[i][k]*b.m[k][j];    <span class="hljs-comment">// 注意n比较大，不要直接for i 1-&gt;100</span><span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">mul</span><span class="hljs-params">(Mat a,Mat b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)c.m[i][<span class="hljs-number">0</span>]^=a.m[i][k]*b.m[k][<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> c;    <span class="hljs-comment">// 这是矩阵向量乘法</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;f.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) f.m[i][<span class="hljs-number">0</span>]=w[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;~i;--i) <span class="hljs-keyword">if</span>((x&gt;&gt;i)&amp;<span class="hljs-number">1</span>) f=<span class="hljs-built_in">mul</span>(rec[i],f);<span class="hljs-keyword">return</span> f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;        <span class="hljs-comment">// 编号为0~n-1</span>rec[<span class="hljs-number">0</span>].m[x][y]=rec[<span class="hljs-number">0</span>].m[y][x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">32</span>;++i) rec[i]=rec[i<span class="hljs-number">-1</span>]*rec[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">query</span>(x));&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC256G Black and White Stones 题解</title>
    <link href="/2022/abc256g-solution/"/>
    <url>/2022/abc256g-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>下面定义白色黑色石头为染白色黑色。</p><p>套路性地断环为链。如图中，把顶点拆成两个点，<spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(i&#39;\)</span>，显然 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i&#39;\)</span>的颜色必定相同，即上一条链的尾等于下一条链的首，所以每条链首尾的颜色都要记录。</p><p><img src="https://s2.loli.net/2022/08/13/2lFo64mduNpKWEI.png" srcset="/img/loading.gif" lazyload /></p><p><img src="https://s2.loli.net/2022/08/13/ulvDh5mFIis2Tet.png" srcset="/img/loading.gif" lazyload /></p><p>枚举每条链防放置石头的个数 <span class="math inline">\(k\)</span>，设<span class="math inline">\(f_{i,0/1,0/1}\)</span> 为考虑前 <spanclass="math inline">\(i\)</span>条链，它们按顺序首尾相连后形成一个长链，其中这个长链的头是黑/白色，尾是黑/白色的方案数。</p><p>只有 <span class="math inline">\(1\)</span> 条链时没有限制，相当于<span class="math inline">\(d-1\)</span>个位置（去掉首尾）染成白色，所以有 <span class="math display">\[\begin{cases}f_{1,0,0} = C_{d-1}^k\\f_{1,0,1} = f_{1,1,0} = C_{d-1}^{k-1}\\f_{1,1,1} = C_{d-1}^{k-2}\end{cases}\]</span> 考虑将 <span class="math inline">\(i-1\)</span>条链相连后，扩展成 <span class="math inline">\(i\)</span>条链的过程。一个很重要的思想是，所有的单链，本质上是相同的。</p><p>首先，对于 <span class="math inline">\(f_{i,0,0}\)</span>，必须用<span class="math inline">\(i-1\)</span> 条链相连且首是 <spanclass="math inline">\(0\)</span>的长链，接上一条首和长链的尾相同，且尾是 <spanclass="math inline">\(0\)</span> 的单链。 <span class="math display">\[f_{i,0,0} = \sum_{k=0}^1 f_{i-1,0,k} \cdot f_{1,k,0}\]</span> 对于 <spanclass="math inline">\(f_{i,1,1}\)</span>，也是差不多的。 <spanclass="math display">\[f_{i,1,1} = \sum_{k=0}^1 f_{i-1,1,k} \cdot f_{1,k,1}\]</span> 其他两种就很显然了，不再赘述。</p><p>不难发现，这个式子就是矩阵乘法的形式，正好 <spanclass="math inline">\(N\)</span> 特别大，所以可以用矩阵加速递推。</p><p>建立矩阵 <span class="math inline">\(A\)</span>。 <spanclass="math display">\[A  =\begin{bmatrix}f_{1,0,0} &amp; f_{1,0,1}\\f_{1,1,0} &amp; f_{1,1,1}\end{bmatrix}\]</span> 通过观察不难得出，求 <span class="math inline">\(i=N\)</span>时的答案，等于求 <span class="math inline">\(A^n\)</span>。</p><p>矩阵快速幂就行了。</p><p>最后，由于整个链还要接成一个环，所以首尾必须相同，即答案累加 <spanclass="math inline">\(f_{n,0,0} + f_{n,1,1}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span>  mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, d, ans, c[<span class="hljs-number">10005</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(m)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; f;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;++j)(c.m[i][j]+=a.m[i][k]*b.m[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; a%=mod;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">x</span>&lt;<span class="hljs-number">0</span>||x&gt;(d<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> c[x];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();c[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;d;++i) c[i]=c[i<span class="hljs-number">-1</span>]*(d-i)%mod*<span class="hljs-built_in">power</span>(i,mod<span class="hljs-number">-2</span>)%mod;    <span class="hljs-comment">// 递推c[d-1][i]</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=d+<span class="hljs-number">1</span>;++i) &#123;f.<span class="hljs-built_in">clear</span>();f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">C</span>(i), f.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">C</span>(i<span class="hljs-number">-1</span>);f.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">C</span>(i<span class="hljs-number">-1</span>), f.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">C</span>(i<span class="hljs-number">-2</span>);f=<span class="hljs-built_in">fp</span>(f,n);(ans+=(f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+f.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC258Ex Odd Steps 题解</title>
    <link href="/2022/abc258-solution/"/>
    <url>/2022/abc258-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>问题可以转化为，在一个 <span class="math inline">\(1 \sim S\)</span>的数轴上，把数轴划分成段若干段，每一段的长度必须是奇数，且对于 <spanclass="math inline">\(i \in [1,n]\)</span>，不能在 <spanclass="math inline">\(a_i\)</span> 处划分。</p><p>先不考虑限制条件。</p><p>设 <span class="math inline">\(f_i\)</span> 表示划分 <spanclass="math inline">\([1,i]\)</span>，且最后一段是奇数的方案数，设 <spanclass="math inline">\(g_i\)</span> 表示划分 <spanclass="math inline">\([1,i]\)</span>，且最后一段是偶数的方案数。</p><p>考虑 <span class="math inline">\(i-1 \rightarrow i\)</span>，<spanclass="math inline">\(i\)</span> 既可以单独作为一个奇数段，又可以加入<span class="math inline">\(i-1\)</span>所在的这一段，改变这一段的奇偶性，所以 <span class="math display">\[\begin{cases}f_i = f_{i-1} + g_{i-1}\\g_i = f_{i-1}\end{cases}\]</span> 答案是 <span class="math inline">\(f_{S}\)</span>。</p><p><span class="math inline">\(S\)</span> 过大，考虑矩阵加速递推。</p><p>构造向量 <span class="math inline">\(\begin{bmatrix} f_i \\ g_i\end{bmatrix}\)</span>，初始为 <spanclass="math inline">\(\begin{bmatrix} f_1 = 1 \\ g_1 = 0\end{bmatrix}\)</span>。 设转移矩阵为 <spanclass="math inline">\(A\)</span>。 <span class="math display">\[A \begin{bmatrix} f_{i-1} \\ g_{i-1} \end{bmatrix} = \begin{bmatrix} f_i\\ g_i \end{bmatrix}\]</span> 手算不难发现 <span class="math inline">\(A = \begin{bmatrix} 1&amp; 1 \\ 1 &amp; 0\end{bmatrix}\)</span>，也就是斐波那契数列的转移矩阵。</p><p>递推第 <span class="math inline">\(n\)</span> 项，转化为用 <spanclass="math inline">\(A\)</span> 的 <spanclass="math inline">\(n-1\)</span> 次幂去变化初始向量。</p><p>如果有限制，那么 <span class="math inline">\(i-1 \rightarrowi\)</span> 的这个 <span class="math inline">\(1\)</span>就必须接在前一段，所以 <span class="math display">\[\begin{cases}f_i = g_{i-1}\\g_i = f_{i-1}\end{cases}\LongrightarrowB \begin{bmatrix} f_{i-1} \\ g_{i-1} \end{bmatrix} =  \begin{bmatrix}f_i \\ g_i \end{bmatrix}\]</span> 这个转移矩阵 <span class="math inline">\(B = \begin{bmatrix} 0&amp; 1 \\ 1 &amp; 0 \end{bmatrix}\)</span>，也就是把两项交换一下。</p><p>可以对没有限制的地方分段处理。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, s, pre;<span class="hljs-comment">// pre表示上一次递推完的那一项</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(m)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; rec1, rec2, f;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;++j)(c.m[i][j]+=a.m[i][k]*b.m[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">mul</span><span class="hljs-params">(Mat a,Mat b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)(c.m[i][<span class="hljs-number">0</span>]+=a.m[i][k]*b.m[k][<span class="hljs-number">0</span>]%mod)%=mod;<span class="hljs-keyword">return</span> c;    <span class="hljs-comment">// 矩阵向量乘法</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();rec1.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=rec1.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=rec1.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, rec1.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;rec2.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=rec2.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, rec2.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=rec2.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, f.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 第1项</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> lim=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(lim&lt;=pre) <span class="hljs-keyword">continue</span>;f=<span class="hljs-built_in">mul</span>(<span class="hljs-built_in">fp</span>(rec1,lim<span class="hljs-number">-1</span>-pre),f);        <span class="hljs-comment">// 第lim项要单独处理</span>f=<span class="hljs-built_in">mul</span>(rec2,f);pre=lim;&#125;f=<span class="hljs-built_in">mul</span>(<span class="hljs-built_in">fp</span>(rec1,s-pre<span class="hljs-number">-1</span>),f);    <span class="hljs-comment">// 此时第pre项已经递推完毕，f存的是第pre+1项</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4591 碱基序列 题解</title>
    <link href="/2022/lg4591-solution/"/>
    <url>/2022/lg4591-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为使用了 <spanclass="math inline">\(i\)</span> 个串，匹配到了 <spanclass="math inline">\(S\)</span> 的前 <spanclass="math inline">\(j\)</span> 位的方案数。 <spanclass="math display">\[f_{i,j} = \sum_{S[i-m,i] = S_0} f_{i-1,i-m}\]</span> 其中 <span class="math inline">\(S_0\)</span>表示一个匹配串，<span class="math inline">\(S[i-m,i]\)</span>是这个长度为 <span class="math inline">\(m\)</span> 的匹配串的长度。</p><p>可以用 KMP 算法快速求出匹配串 <spanclass="math inline">\(S_0\)</span> 在 <spanclass="math inline">\(S\)</span> 中出现的所有位置，最终答案为 <spanclass="math inline">\(\sum_{i=0}^n f_{k,i}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, k, ans, cur, nxt[N], f[<span class="hljs-number">105</span>][N];<span class="hljs-type">char</span> s[N], p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) ++j;nxt[i]=j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) ++j;<span class="hljs-keyword">if</span>(j==m) (f[k][i]+=f[k<span class="hljs-number">-1</span>][i-m])%=mod, j=nxt[j];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>), n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,p+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">strlen</span>(p+<span class="hljs-number">1</span>);<span class="hljs-built_in">kmp</span>(i);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (ans+=f[k][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TARI TARI</title>
    <link href="/2022/memory/"/>
    <url>/2022/memory/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d93b8f6fe771973ac9f91d1200341ca53f0e94e85e53cce00df3e9278b0427ac">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f30770dd15f8965c8b50c38f101c968a7cb1e7f72e3b0b9f2ed8790f901ede2a3b9be9b3982eae8c0cdf27a04778eea9c9dfe83cf73f2526d26b096fb2b34f40d8602f5fe1b8060dae1e1d3bc8f61ff15843febb09c420579072fe72d954bd0e0048a1566e09af215e11ea155f192fb34a898fbb44c13bfaa629268c870d83f9fb0bbb6db34f3069c99ffcffba0ad0c6198fc4b709ef1d8722554ce7bf862769d74be619a6f270a81dade336524baaa9eb2e7d5f8099ab5ac4873a0fad37ddd0facdfff9f3723fca3ff7fdcef820fa798ec9c0c5fa53f99aec7ad45b259de583074067abfc8563f4f701c1f4f295f2953a78f9034fd2da69694b504aa58ca3dfb3aabff1732510232c7529d53b3e09bcc3b52d5c28ebd04c893fb0b94c92d2717e8eae7e4a00f59fc0c296166981e765d635925db95b00441f7f6f0b108d0a0b85defc13e5b8dd7dac0188b093875d973e5eafd6bc66b7f953c9beff37300e90a4d80c70ba5b3893defd0dbd6f0e6edb85ddefd900e7bdd1926f91a8046e9cdf01d88a363e233c22f93ab6edb3d5fbeae1edfd2be9c0c19424693b443830fa9f3e19dc0892c1427f14753ba5ebde3e902d634f6ee57c4828212e36cbaba090a8f8708ceebad7230cfa5ed91fe7472f580ffc6cbfefb83f6ee31a42a5c147e73db76d1e4ec8fad66ea52512c361e2fbde26fc06a919247d160eff63bc7ce4f5085f3befd12dea5d08915cc05b156aefbf9ca7152d1dbc6793e0a4048cb8afc9c7689177deb6eb0cf0e46a15bdead45bc2c0e2ecf71cc255e6069d4cb4a054dc462ad810dad44ac35d25003be141f0924df83c2a7a950ff03eac47a186aa13c716357b088c82efddaec2d3c0c9dbd184bd5e51e813a659794de91d7fc361f7e8b57094ee338a255d241e7fe32fa3a4c1f1d400a7c078b9e7596db608ea502a9ac0e4fcd2b3c175dba51441635e14db1e773d3451364df455a8a3cfc182212558a7a137a0723a988cbcdcd9e65c0f9c6fa8ebb06d8d57d8865f9e60b62a5c2406343ee340b0b4288726ac1113b2564fb0c86071aa0afbb321a07ac9a2dce1e78c8fa2002047dad73d9f00e33c9bbd6273c23f4ae541bb5611b9145fa9fedbf42df389d8e9b2f9464495b3d215294b8c76a53e8dcd7614a7086a451e5140fb981f08f610998291f546691d4596de0227e2d3fc74a2c73c565f8554e3d5fd20586ddca68c723e22cd5614c9b2ed82a9442553e9d8e0e458dcd59a434b1e3db98a6a9dc765c69474bc711904b1cee22c20f92aca4d29c18a5eca4045cd88eeb052f7aa0c3efedaada719f0fbf1bd560738cda5c246f98e22fad0585a2762bd169a082aa8254fa7daeb9efd976234bb7e2a50a10331c9c5b3ee8a2da9cfc7a62e42d754c12954fe8f61f2ab8d23b16a6ad3ab528c70622d3915b2f8732583e0fb0e6a568de5460e63772b710f1e30b89a08ee5a9722044910eb1426e8fc9d5381604239070b83f13801b165e3afbeb6921345aeab8dcdb2cee2c96b3fe2860a23695e4dd61afea2b810e7b81b668966163feffced994bb277120492d9d04934dd17c052fbd2674f5ea84c89b82d7dbec35bc40301b2f2fdf732aeda24e1da432ece8ce29b38450107baba78aa5326003a9d1a775a670fe3a68f4fff5a2f595e88876c5f22c55c713592f06fbd87314f70ba03bfc2d3f29d5ccf5a8f310355e763b1e785663c34d8b207af0f3d6cf0da46c2f2f45fa5c8d571f07bb0fc704e182158ddbec8a5435a8ba692f74b8ca12dcc6deb7f47002603d7b06edd61bc80862280d4b7ddef5e1e66262a5ff645aef9cf1ad32c57e25e58f889c78de49f033072b4338fbea743953e61eec84bbce8d9a5e555f9495db27e99c2d5fc1afdb69061d7a637f5cd046c0042c460cc124e4164c311740f0734aecaa5863dc579a3756ca925c2c26151fede5e9c78baf02f155fefad4ebdcda1e27bc2a0b1b952da967419a106963b7d6cb087d7d1668c315e7c795f06deb730e4404a8abf782ce56b164da9cad9c0fcfafb20fb5ba82e2c3eec835e0e43a2c047305dfe8255d383efea4cf00db039179c5b6d22f61a8757df39934d2537d4609fd67f81ac275eb24b9e7bc5c5697c5ed9f98ff5a34d125b42b71541a8297980196d845a15d7a83e820b84d690429f9f862eff9402bfc6be34d87fb6784447fde95e63004113d24edf3b582b37e7b5cd2ce77d0decca8437c4f3bc6a63b673afd6023f2cedccff4d689a62ceb2d34f206dd41062887ec43a11c198404f06c0173e5a0b4ae8f05bd34f3ffbcbd28bc7e4e926c7a9f05ca69bd6806d5ad275139fecd4d358282b1a4823a4283c6a2b2e048a40597309a157ed88ad5886771437c6101317900d2ab862e9b833007c4da42f96b80c6846c73da1a18f9e07287077dc8fa2580f709de11ad45cd2c22bc5d15dccdaec24d1b9c3aab1bfca2a8625806a3522cb86a9172efd9743f9017f26420e49b4f307cd479f1beff381450d7658c8002be5f30697810f2881a58a9cd680075f2367287df8b57c88f08f8159b3b163c73929bcdd2238616a0d56e9113c1d078e18928ad2a555a9e2ebf471c2036381f4fc74f7cef17c453cc6f5e52b83fde3a6c22a64d4294f0417e49128011469421ce6f0cb40b2636b4477ca046c34b1032dc81bf4cb1e78d0e0ad1c332b8469c3b9a440d40bcf2ce24d1a268742b7b3a66ff4913b07aba7a03005ae948c330c5b0f6d544efaf0c321ce7e8035122969e786a69aa749a4c07c8146517c22c73cd05d52acdd81d90f9e2a9845e0d602c8f35ab8a97422cc0c1b692c011c02513308c31a70bc4a36e4aaff24bf81f157db78b86ba1a6c84718951b4d53986711ca492349d9a34a94d46e80d55cb2cf341d3c745353c6e1aeaeddb4ef6200176e78191d909c91644a5a973b2dbf2fc6ce0fcc3d3ad7b9832f78c3e5a96f8ab86c6ae653652922d84605daa3ca0b9068d34931fb997ea5991d9aa6f6e0a1ec08e86f70594b004ba39299ee134b240068397062b54c270bfad21b588209fe9b8054aa1deaab8c8a388353b161cd59b342da457fd46a05facc4de9819845959fe3863d3528f65452669ad42b542efe7987fe25a364b28100b461b877bf42f6ac46ae326e2f1db690fbbcb8c5e63e943415fe183fb95fe4197575f61869d65dcd7f155ac1a218369110c6079573c43b92dce7e4185d21133e513761bc98fd55904e0e3c27344fee9f27042c5b4b976007417f875bed5434b0d50043c5e054e17b65c6facb3a5c8f8c82e307425bc6f78a49cb4a89dbb5b8029b156dcc351ab162ac8f8046175332afbe5c452a621bc62955c3b1de1e1de3995e4c51f3306996e2f1930493ba0a9bdabcdb0892e47b75262862e0c257f284caf4b9c5ed2c53f3eb21e73bd895dffd6f345fe971cf5d138f2e94d260bb9002850fd00c71d7a4a695139b1def406a06cc91048cff76c5101598ab7fe1e264a150a1efd803973825786ac406c79fc7f220b615d8a345452842f2cbf87ea4b6f8690e22705ffa8b6e83db1f5907c6983c0de5efdcc8c28779b567b66ebaaeaf19c4058fca6c6b5b8671a09e80fa58f80741fdbcb3b2304f138a0e20fae4920e1cdc67ae8968b829bcbc55331f219c9241a9337c3db991d2cabfae7ade82a1c58d3bf3cdde19951ac046b57f7df5535f458de06b71d755cc5711c76a14fa06839b7080a0402cf81461321eb8e6e51309994b9a6de60c3186b79c402b44743ff91a86e8b84b8bfa2aba4685e2cec8d120f83822407f238c8b9cd00e49429b4114879dd7c97a8c163171dd6fbd4ca02619e1cd6c5a96c11e792a19f46bfb123d40e0d201582ac64d3f058103d8eb409bb4cf873481ca13ddd29efc321f0b2cbfca8f5f9e7c1c0d924ca08148fe1f2a2f02265b77d357b132c8cfa4ea7909e44799ade1d3811788102fca649a674210e551ab5f5dc65f307c42de9a73071c26a5073d09150ef5b6282d93223f908592aa433db4087be7ab7522635bfdde17d86865ec050a65eed101140a5c3f48343f5953ee4059c36cfbbf355e8bb37cb8f596635d715ce5be4d0f12f900c541e4b0d28d9fd2bb3fd7ffb237d1891b7af92cfbb5479776716de94ee0443d456632e99d239ca967bfbb8871e2f96cb5fae4d31ee30c98932a41c27a183fcd98bd36a6e99ffe659b410afddbec5387fa8c8738211e32e36adb89dd2516c15b4fe3fa68ac494e0998451dc392209353198621434737b56c8cd55bcff88b1ad86f6d4230d1ccbd305ac04bdb19f4c4f6f1de5996d7bf0b08d469d700600b9a990e64a1929730d683a4c4cd3193450b3c2d69a84f55f59afd188d02abd1bef4a4e68f5b5e755ebcd967184e0ae2988dc72047bf1130e60ac3cad2f769a5126c834988377d4a2929fcecd17b0bb7724868f430641430e469ab2b74aca9e6f6d879a29cb7fc3451d303b11fc32005fadcee99083d79ba17a4452d1aab59b54778ae29fe5eee1a25bd0e7240c28737e4a802413f0ad7c4f267eab42b468e660df6a9ed802201ed67adad13119d05159ba0524d7b89efc3302501da652b63e3b4c99366d233026f701217466cbdac4e44226177ff36fa850212c1b041e8790b642c83cc841fd628840d574f186718969b553e8eeca89b771859dba206db1a9f733453e2ea5f31579c0ab005b773f0c65690b6e4ff383643bb57d124c44a68d59c43d5f8ddfc6e295b04e6b6bb413988a5fe3ac087f2aefd311bd5f9afa4535cd858e514e43433b56db1d628415f3a89cda81318c2e92c52ad47c3d7d687a8fab4200108996dfd4899ed07956df9d070b44603a064a1ac05224bf7975d0eef362d528f22f03d61557eacb6350c77f33431c64f75d20f2b6bb262e3f87452b0a566feb8d47be2772c576d4297e7449b294cf9a40acdc267feec0ed4a38d096aad9f0bc2c1155f4a4d26237b6cb6428dcab0d7be4bfd44b818ac6ac0474d9ce971c91119c0f31adb311becad1fdafc68909053304c52d48b6b64213c4c6529866276e64eb64ffdfe6d32834a2a6f1ad9d3017ab18f09de6dcb5eef3c698ed6767fa5da05e0f5a02962d7636dbf7da48c92442990213b258c1710044204dfe695376201f7c5b37f6190a02f1ae587f234ed107fb85828adcfbfc8d274b1cf63240cdf9e361fd022f769af0339087f7686f15c51d1a01e98523448a7aac75bb8f1eb0ae0f027256dd6b2ec9adafe4c82ba5c02a3920e9eac9426470469fc7653d6a44203517cb24c9a03c4eb51de8157433475a1bb77f28a3d91f7d0583baaccd8d63c70879703852c2903c4f25df5e809819a931f47bdb4d23caa657a7f5a5ddd59df4f549ea1e09740ab1a441e1faa8dd9f2d69aff7d635f9e4aea0e3444552b3da1f86f57b398160933ce826887404fc6d4ddf20d8eda5dd4c125f687142ba84a6284094d541fef2dae02bc8ac1c21b3ebb06a9e0a7d1d98925fac78eff7eeafd9b1b9666ad450d5cf20bbebe4b585ab22be4913f4cdcdbd1a046135c87ca1ec118d33f40a76679d603375a614f5db336f362a6b6030ee336ea2bfe23d42e161c76b8d7bf30e0730cd504827b259f4e3ec0edb21314b91bd77f808334a141f52031f00d0a2bc6295caa415cbbe1011762922b1baa85c57495c1c4e0de48fa75c73e599a8eb47dea96e70fc4d9d763c266445ad05403cd7649c20be173dbaae5d7491611a324e17f41ac4baf5be7595fdd21ebfc7f89afba8c4102867f5b66c28503ceff10d0cf75bfd3442b58cb5393b03e5092d607d33e4b6a631fff48b5a8ffe4b8bb2c37b5052398063224689b2dcaccef9b85190daad0a37681a8570ad7f0850a141415543bc36ecf9fcfc35314ba7f63aa231df208baf055ff0723099bf8a0fdcf07c8bb44c5caf07a5aae7763635e23da85dcc2242181cebdef94b7e8ddf40c2756203cd52718697e821efe08e1e29ea3e2dbda8431b0c8befcbbae91ea4dae114f98203d90a9a4905392c87408416249f975f7c662dd622eb221f13105cee5fddc06a3841740ca40d1ea34f0a1abb41c7d4820f2c932e823a7147984d0b79e2ad8e6bdcc6e7b2511fe9367e876f49ee5e7d665d4430215b06733c8a67dfd064abc2ca8ca15947a097555bc97a7efc7b6262889070b584fc78e92d1f0627dd516d6eb391d02c84aa53305d0ddd0fb4368c0d6406f312c9f42ac2ff27bb54f5be7095ae12593bcba15a3be7eb7be328de7eb827afd21a3fe55ebd11fe82a1ef7696a128c11f833493ca0fc3840fe2ae5f74831c772487989ebbd4ba3a0b4222b521f08c6af76a56d1a7d2ef0819931a603e518c9e45eea6e5db4d673b05881698cdddfb8a4cc4643fbe3508d4d849f81cf8a9f4dc118f2d74fa5070d49ae54c9cf200244f3dddabab499d6975c5ea5aff73e6a8db5fe039a7b9375c31659b7b5bf4fc3d3c8cd0c2b07a8cc84243972d1dc5401e999aaeee50881b5d9dddb6a48ad10c03c9c28af05c22fda1927718b3a9e36f63be3918efc2b719f13830f68c1661b817b006cc7d47d44c0c6b71db4867888d86be7b39d948a2bbcbb64f2015ea89593f25b423036829d9e9317f0121b6f51046bb964c5568138a54e15ba8bc4073f828f36a5c2104cb17e6afa69197b097a96a05660c97038ef54951c746b98eccc9be23b1ed486c1e71d1424c723ac9f6ce1bd20f6dbbb291879f42d3984d6677a2cf07592cf7b7d4479c3d84d09eb6c4d0d5ae799e912d61411748b9d41b36d35461d4e487f9ab21df7194e6c265765eafb0cc6917a9624d5cad1da004d6644865e6f13768f5061a134b6c25a4c5b0dd054386049a01300d8556021b46f4151df27e4595968f87ed9bba97840585f78289827114e1d1852f40b36731c0c19757baaccf103304fe63913d16a45a3bb4c65ea47775176a05c4181f05d0baa58b486206601bbc1c0947279ff59853c43680ea6a855abfd1508b5b7a93fc3cbb844884c0cf238b3518c1ec2314c582087c560e56bcc6f45de8f7565a111c67e17584e16a8e0453f98671dd898000b1274e80d8162ec6b8f72811dfd48c8d6490d4e3714ff091e31371cfa0dc5e78f9ff9d1f3abda4552bc3b19560112381b44e920763f814f9e2c1d15692007baf7c564c6bb300cadbfb18e9bfd4a88993d3d75e0e92135616aa9f7daddf3588268732242ab77eb921d654b47ab396b1798fda5233a0a846f12f0f1cae7d44a5fb06893a77ef3fdbcb2cff581ecc40605c37b6b395971694120aa8efee30ef6dda2044617a6e0c8670e5342520cccf2bbb4ceaaaa72bd9a906db10a204d0064a10b64ecd14e40d7f1eedff009ca4d4439d53f173948b5adadd95b20196c4e19893e1bc883b49e33c3b0f2a2f2f226975f8ad98f01cc7d55cdd5647f5427ee3d148eb557e0f142c60255ccf17abf9b2d87894a8c5597d92e1f43f2c3ab8c771c053acbe78f70b7b7375c5d4c2c72043e90abd93e2ba0ee7f01749e63903dc809995379b6a0a8d3a05b53864378b2a40437be1ebed076ecc5958fdcc432e553a48f27ab7e404a6ee0ac9fea82a46bb7799c653ab287f4e1b2e6cf846cfb729463b5541e64fc5b8601c836112f44d2cb4186ece0356a0bd8005608dece156c0faa66d7011103b5fce934090480ad193ef2422f19c9dac1aef2b55a3c4504613b876fa297d99bd4d4f8913e111560bf31b613cbb3be7f685ad8f31426fb98918d2d0f75e7b0e84d4b94f56138bf7c45d55c3d5faa0ac15649a0c341b30a8003c10a4b6a1a95c47b7ad780ef2e13c9072dbaabf2964a4e6eb8ffd10b22a48bdc96723da2aa8d45b9c62a9c51b1ea6c8e96ae94ae8ed36027b435f94395db785a9719964a90160d2d722ac9cc5f81904bfc8486ee0c97bc51aa5835a14bb90f90c66e5118ff265625b4e67bbbc194b0d66050bccb798ebfa6f44ad737f00c660a5bc5c713db7789dfac102f9424a42961fba43788049993f4ba15d851d3ffc3008a7065f0b31c1b1187d52aa2df7eac96918b00a88a65262345e3465c7944ac974ecc19303efd60d93e8ce993712cf04035b3754f96acc7f0314cda4a07d3310afd6e57e63292d2bf70112d9d95cb30505f4ccf129faf1869f8767cb15c6a4bd8ae2c6e986bad59f9e8da3bf11b69b8c61bcdd08170da2cfe487465cb50be8b6f8c17d1339e277fab47dfa2b7e7bc27a19e383c08c521353ca46d2fe60a278808c650bdfac1f5092f96a2410326f3bc0668733efd06caf82cc23a2b4b4bc7f13fe6f5d2d6b91b5dd2e78fd032b7d4e3c6671561ac465dd992bf2ac3b407b6af1d6982dbf7bdd3dea4cfb5ae70a3f73da94f307041fd60fa5fd1fa45e82b1c3732bb4cedaf1a37565fb94dc972f01eb02f63f51d44e4ed062a3e6f6e29eea41bdd5ad7c73173c31798b99e581197e558e1f1ff57e87468eb55ed7215a06aff1b9a146e187aa41727039feeb14bb1bda04e60c6077718f5256fbcbe3d17e5293695fd1445c5186c9868107a5b2b9f78078ac537552f8c9cc01c26790d4fa85808ac86afa6c1a4b1d4e97655ccadcc48bc2862098ebfcabdd6a7836c459742fb0775850efcd912d0244a82ab8d1afa5517b644ab13eaeeb92fb83a93d6706f0e8b54789e98c19ff3a3575eaf0ffd7a34a88536e85eaead4e1a4837cef57d25c91e3adfaeb7e1575520fb2391a3524853db94ea22487f29dc8e65f6128ae699b13b7e2e9eb50bb5100bbfa6ad7f8909a50ac060836555f4e9ce1bf6c4594ffb3da1c035c2f2f8cd981745c387ac23fccbdcb4f25496a76b1333a76615113442e989a8890c4cb196ac73bc0cb0bcb111f761fc74a3f51b04f990d336c760ed5819df3e9531a4a86f19cc08cb005e01a4799a1f8225cc7bfb2c70657bad036e8d9d4b89e95ba39829479e6c29fb72e46d22a6f243dbb05d9d40bb3b07a0f8b53ee53938d2f99bac0ea454e1438fa80c30dadb460578d9e65d72244d10539572a7ce0722e42ab3258ec633a5292e97f8519dce437b9ed8b02777d6d60d8523e70bf6af4beb802408798fc703dc6a863eaa4bbdc8b142ffd705e5feb8f09f872e4f2985a0876004190e0f89a664e6adaf64832c0b4cbe8d5a29c6767658ffa4f1e50b2d7faa9064100220c7f65913537a6c257bdc79e12cb6bcd7e7cb6c126810cd271bcb388f05ebc75210f41304384bfc5e7c7d57a1a65ba05a04617dc4371e04f504f1922bbf907373662d46e41e4d211b4b01a160dbca73b341c23d588b2b0b919a253e5fa8cacb07ff33a7158e29323ea94a9f7e5767be41b0b946254c222efc47bac58ebe8efefdb0b31a987c532c78b4d624a5504e747d385e45286593c7dc2a6facc3c903bdea4fbb21bbf8c9994b4f101b5e8b0469ab6e4668430623ea22f2ec916d700dd911976e00a7c23b25861b83c51f80ba78ec82c1f9b694fbe7320c839bda580dcbbafa9b600e9f5a569b0c1c80426073d69132b988e55972e134d93693ecebb6003b63ba1f4b089e7a0031a3ddd20e8abc0f7ac30e401e17f4fdb819b34b29a1ca385d35e89e4622764508ad807fe8e35f9f3a2706a235428f5aff4f9719b4fc3ab4e44c2e0b2754178bfdcebc8188ced71d9536ad695b733daf3d31cf16878076cb16b5a363ac026c06696f406c22bf34a9196fbc0e0471518bd3d5452a27ea62f55c4ac7a0bea5e54f6bcfd3cf05fdc4893e0d5e2e3472443396b0f7eefb9cb320733490b7fa153e102ebb8280bb7a4f6f33d59689d5c48bc84b75b627c813c3134d4b47ceb99c7274c13b0c62894e0c01916517b3c9d916bac371ba01ed69e73b60391dc4f523bef3efd7a1bac3499472ea38e2ff6ee3d6891eb2f72bc1fd41f4c9db6142df8a34c6c97a535ea0fef0de4ccd2d1e6cc04d8ab8371c7da85a82c491ca887ffba1a4b5e5f53c10a327cacc0c5ce99b3f5841a4908f010d0f42cfea6b86b85c7590ca4c152ee4471a0ef3980f052913095a7f8a3f022c8e20f0300d2b524b4e77d8072e9f6da15c9e4f628b4e8928767bf3d10364f7846f694a49a87e50f24bbd3ba777c1cf22b752fcdb35a2ba510c69c13d6e60316e868381647a0c387f62cfb4b6086d53a8c55f9c681fe6724daecbb2d8b5371cfce38dd438cac6a53a55abeb3c53fec619a35b07836e251ea63ca4f547dfb6df5d14b52c9bb60392b5618a0bc888e54acbe92dc6b7d66a8b138a3d117e19a987787fd99373bb1bdd69af1c32db089aad49a057d85b2cc22be85d45d3d14b239a14c32824e6fa50157c6010356d92118d94fc9899fa79299d4a03ee5eedeca879b51d9c9e415eb75a8ce8d3bba35a7887ac86ca7c75078a64c49e231d1cdac714a7f4bff293b9323bbbed7e8ccfc0dbb24144a4090a56ae984338e55b35a9c042386c84e6008a67c40c1091d0382d17614cea4704f2ce485a3f2608bf011915adb5ce7c400f20f1bf0faeb6b434469b3e0c64f4a51f8d46e138d03ba74e1a316bd74a98d030bad0e16efdb2a1110b5e160ed19e15b103ae48bd0bf90552e58dea751b657dc0af3b668fe31822ff970f92f6b804c7585593e2af0ed6996b3a56176f3e464da922c02577c7f5b0b19d025a735a67771af5a71e60bc425788c9a778c87549f2bc2b84216a75679bbe6c4e02c290b560a028617097e4ddc24c2f7bbb1320dc688066da192360be48eb38fadefdd54eca861e1784ffd97c21e9bc63679d3a3f86d2bf81c78ffd669b409c5ffd575a00f3c936acc6c0413608bebc7c9c1d4eefd310aeafa3484f2a3a586d4e93b986473ecf879b4c13c0a7759eedfe468827a5e9a6e4c92d3944325029b26451ac17f528a78fdab539a22ec237b9465d4944ebb7e0b988f2739a1fd12d2269ef6a2158b9bf2afc2443ac1c364d62e39fda87a23ae6ec9e4786362565be575d8703fab9afb2eda656d7c93a137bd6c9c242c99a8ae95e22f02235c768980b6aa6359dd3e09b275e589e34aff9abdb5861d4411dc24e4dd1396d9cfac8e10cebf0e2896ae75391d3bb181a42a0bbfcffc8c83864c9023f818130743a0608c4b000cc93330c2bba53a770dfe34401a890bcfba13114b382165411d183fdeec7dedf1f7e98e78731e1351fae7f9b31de0654ba57422d99b4c74759b5b3a822a384e6b5fb788a92bb360093f42c8d0e8d2600a2eb08af3f7f98f07ec238ca73b8a734cda7105b507416d2ad0d3785d740ff1b16b5129e39d2bcf32ec72d668ed7dd99873314be271b447301e5e54193cd10a5a462cdd1b0735625c86d439359c063936e8fc6b5540e469a81a56d8045f0f47ecc8e3f95e8c6709f53e9fcc0b6e461498a2070e165f77c3fcbc4a0e7062fe4d0f53fbe588d56fdfc7cfd221d646257bd04cd5e9fc9a2bc3d8d1f3fba879e4017351a27218cc6cddb7edd17730dfa26c688509c04f6a007544f642bf53f0fbb76f7f1ae61d9b803c9b53964a45084bd9d1533ad2aaebd8762a2faf19c807577297719d2cf46a63885b7cb5fcb1a0d9859bbb70c52fd1950ca60bbb5bed5d728eaa04111e955b62a369ae9d1a64f2dd256c89c5f80ac60ca31023f38e30f0146bd9e20f4e1469263b0220c0ae5db46f8cd2abad35e76a3c673b9dd6bd0da5c7f77acdc20f541201119b9ef49d0b1e038e6807cfba53d15ae56278058e2c920be9907f8adffe6652cbc0e6817f1bfaeca456afefabaf10d8a5dab20b7cb3e469cb1bf1e1a5fce2469378b19bb96cd9d5727b2cff8276669d179fbf627f6ce62cc01ed59ee2204ff2be673d0121bdb7982f997ed5d4783232849afed82d5c8253fb9ddce72059ff5ddde06e8062c0e40b24fbc1109806add2a0f76da119df7359ee9f73d99c49d4f45d058880cd6770cb721eae93e8b2b294542d0839a09d51084561b38da8a62db8c40fdcd8a6e044f8ddc3a743056435b37d622cc5ce6fa2772f5cb2e8af58687b3e40ab6e9385528a3dadde363d9fa501d10a39ec4e96f9d06b9148ef75e94e077ac81bb9cc38e2c04602d0fb6dea4d0a1c5d5b9a0b73d8bff6b7c76b1120c8f0f1f9b3404fe6816c107c4d92b090d203420e24040ecbca81110de7ff5e76f09b3df9991db9a4077d363ca6ec2956e137c1f8c6d19e61cdeb4198656568ce018a90d7b1807dff0d5ec9c2fd8c785c16901fe8007c074ac79fab29bdd08ce5263de692b1efa922174cea42775b13cbb2c32ec6680534f92b6867a31dd05c7cacbc8bcf8d220c050bebc92edff967f8760b8f288b2881ca0199437fc5c97a5044331603ba04fa2ebd1b2d9c6dec656525ea7e756a3c212cb18ac855bc6c51351cf71696e08d555a826b7e1b1c1d010e0444b332d4c3c4aac96ca3c02cd117a1f2e03c4f38125f0ac792172cdb2df2517b7e5f894c864042746fc0d116cf284b19048a3f06c7865a2f08a9bd545e02c894a87fdb5d0a06c6855f8ebdf695fd190c7f42865f0867e3c25166b8fe2e226c11f929feb55204511dc03c36f6a4c942ca644acc63778a0e61807d5e3aaffd0781b07fd74f6b930d908fb7bfce95974a1b2a644c82ea96117f990fb16179247f2f106fa57bc31ff0a367e26ef66883ba9c44bfcfc3c3cdffbb2e8a1afa42b2a5680cc258061eeb4af2ead8a725dbbc4af7ededfc1ece86ff0eac3dec08e6b114465663946c2f4817015d5c07a92750249eb895127a248ae4e343bdb71ccb753f9869a0f70d9eb8ee1022ef3937611a518f38aff8eaf9ba1875b61bdf21ac9cc91e2d266f7dbbd42e0d11e3eaf2c1b78135521bc1675a81c64cae540d0dc1da1635b974499fda682ec53ede05dd48b5be1fd751661a7c5647dc7996d0ba182e9c9e6d88337</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵乘法简单题 1</title>
    <link href="/2022/matrix-solution-1/"/>
    <url>/2022/matrix-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>以下是简单矩阵乘法题目大赏。</p><p>注意我这时候的矩阵乘法还没有形成固定的码风，所以代码看起来差异较大且比较别扭，见谅。</p><h2 id="luogu5343-分块">luogu5343 分块</h2><h3 id="分析">分析</h3><p>分的块长必须同时满足二人的要求，所以必然是二者的交集。</p><p>设 <span class="math inline">\(f_i\)</span> 为长度为 <spanclass="math inline">\(i\)</span> 序列的分块方案数，有 <spanclass="math inline">\(f_0 = 1\)</span>。 <span class="math display">\[f_i = \sum_{j=1}^m f_{i-a_j}\]</span> 其中 <span class="math inline">\(a_i\)</span> 是第 <spanclass="math inline">\(i\)</span> 种合法分块长度，<spanclass="math inline">\(m\)</span> 是序列 <spanclass="math inline">\(a\)</span> 的长度。</p><p>数据范围明显要用矩阵加速递推。下面放图是因为我对我当时的写法实在是无语了，与我现在的习惯大相径庭，为了便于理解就用这张图了。</p><figure><img src="https://s2.ax1x.com/2019/05/05/Ewtapd.png" srcset="/img/loading.gif" lazyloadalt="借用洛谷题解的图片，侵删" /><figcaption aria-hidden="true">借用洛谷题解的图片，侵删</figcaption></figure><p>先把 <span class="math inline">\(f\)</span> 搞成一个向量。</p><p>考虑从 <span class="math inline">\(f_{i-1}\)</span> 推得 <spanclass="math inline">\(f_i\)</span>的过程，不难发现首先要整体平移一下，也就是在转移矩阵 <spanclass="math inline">\(A\)</span> 中，有 <spanclass="math inline">\(A_{i+1,i}=1\)</span>，表示 从 <spanclass="math inline">\(f_{i-1}\)</span> 数第 <spanclass="math inline">\(i+1\)</span> 个要转移到第 <spanclass="math inline">\(i\)</span> 个的位置，于是乎 <spanclass="math inline">\(1\)</span>，也就是要求的 <spanclass="math inline">\(f_i\)</span> 空了出来。此时，表示如果 <spanclass="math inline">\(a_j\)</span> 合法，那么就让 <spanclass="math inline">\(A_{1,a_j}=1\)</span>，表示从 <spanclass="math inline">\(f_{i-1}\)</span> 数第 <spanclass="math inline">\(a_j\)</span> 个，也就是 <spanclass="math inline">\(f_{i-a_j}\)</span> 要转移到 <spanclass="math inline">\(1\)</span>，也就是 <spanclass="math inline">\(f_i\)</span> 的地方。</p><p>初始 <span class="math inline">\(f_0 = 1\)</span>，求 <spanclass="math inline">\(n\)</span> 次幂即可，注意要预处理 <spanclass="math inline">\(1 \sim 100\)</span> 的 <spanclass="math inline">\(f\)</span> 值，因为块最大是 <spanclass="math inline">\(100\)</span>，这样做不会漏掉信息。</p><p>好了，我已经受不了这奇葩的写法了。上代码，看得懂的就看，看不懂尽量别死磕这个SB 写法。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, p, q, c[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>], f[<span class="hljs-number">105</span>];bitset&lt;105&gt; a, b;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> ans[<span class="hljs-number">105</span>]; <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100</span>;j++)<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)ans[i]=(ans[i]+f[j]*c[j][i]%mod)%mod;<span class="hljs-built_in">memcpy</span>(f,ans,<span class="hljs-built_in">sizeof</span>(f));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mulself</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> ans[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>]; <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">100</span>;k++)<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100</span>;j++)ans[i][j]=(ans[i][j]+c[i][k]*c[k][j]%mod)%mod;<span class="hljs-built_in">memcpy</span>(c,ans,<span class="hljs-built_in">sizeof</span>(c));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">100</span>;++i) c[i+<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;p=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(p--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();a[x]=<span class="hljs-number">1</span>;&#125;q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();b[x]=<span class="hljs-number">1</span>;&#125;a&amp;=b;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;++i) <span class="hljs-keyword">if</span>(a[i]) c[<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// f[1]-f[100]的信息都在c里面</span>    <span class="hljs-comment">// 注意用的是bitset，a[i]是上述的下标j，i才是a[j]</span><span class="hljs-keyword">for</span>(;n;<span class="hljs-built_in">mulself</span>(),n&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">mul</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>]);&#125;</code></pre></div><h2 id="luogu3758-可乐">luogu3758 可乐</h2><h3 id="分析-1">分析</h3><p>设 <span class="math inline">\(f(i,x)\)</span> 为时刻 <spanclass="math inline">\(i\)</span>，在城市 <spanclass="math inline">\(x\)</span> 的方案数。增加一个节点 <spanclass="math inline">\(n+1\)</span> 表示自爆。 <spanclass="math display">\[f(i,x) = \sum_{(x,y) \in E} f(i-1,y)\]</span> 每次处理完一个时间，都让答案累计已经自爆的 <spanclass="math inline">\(f(i,n+1)\)</span>，最后加上 <spanclass="math inline">\(f(t,x)\)</span>，其中 <spanclass="math inline">\(x \in [1,n]\)</span>。</p><p>这样能水过原题，但是复杂度实在太高，考虑矩阵加速。</p><p>和上题相同，只不过还更简单了，<span class="math inline">\(x\)</span>与 <span class="math inline">\(y\)</span> 互相转移，<spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>和 <span class="math inline">\(n+1\)</span> 都能转移。预处理 <spanclass="math inline">\(i=0\)</span> 时的初始矩阵，求 <spanclass="math inline">\(t\)</span> 次幂即可。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">2017</span>;<span class="hljs-type">int</span> n, m, t, ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">31</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(m)); &#125;&#125; a;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">31</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">31</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">31</span>;++j)c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();a.m[x][y]=a.m[y][x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a.m[i][i]=a.m[i][n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;a.m[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 尽管没有实际意义，但是为了能够做矩阵乘法，需要让m[n+1][n+1]=1</span>t=<span class="hljs-built_in">read</span>();a=<span class="hljs-built_in">fp</span>(a,t);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) ans=(ans+a.m[<span class="hljs-number">1</span>][i])%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="luogu5337-甲苯先生的字符串">luogu5337 甲苯先生的字符串</h2><h3 id="分析-2">分析</h3><p>设 <span class="math inline">\(f(i,j)\)</span> 为写完了 <spanclass="math inline">\(s_2\)</span> 的前 <spanclass="math inline">\(i\)</span> 个字符，其中最后一个字符为 <spanclass="math inline">\(j\)</span> 的方案数。 <spanclass="math display">\[f(i,j) = \sum_{k=1}^{26} f(i-1,k) \cdot b(k,j)\]</span> 其中 <span class="math inline">\(b(k,j)\)</span>表示能不能先出现 <span class="math inline">\(k\)</span>，再出现 <spanclass="math inline">\(j\)</span>。</p><p>标准的矩阵乘法。矩阵乘法本质是对相同转移方式的处理，所以设 <spanclass="math inline">\(A_{i,j}\)</span> 为当前阶段，倒数第二个字符为<span class="math inline">\(i\)</span>，最后一个字符为 <spanclass="math inline">\(j\)</span> 的方案数。当 <spanclass="math inline">\(i=1\)</span> 时，很容易写出。不相邻的为 <spanclass="math inline">\(1\)</span>，否则为 <spanclass="math inline">\(0\)</span>。</p><p>求它的 <span class="math inline">\(n-1\)</span> 次幂就行了。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, f[<span class="hljs-number">30</span>];<span class="hljs-type">char</span> s[<span class="hljs-number">100005</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> &#123;<span class="hljs-type">int</span> m[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(m)); &#125;&#125; a;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">26</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;++j)c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-type">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;++j) a.m[i][j]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;++i) a.m[s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>][s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;a=<span class="hljs-built_in">fp</span>(a,n<span class="hljs-number">-1</span>);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;++j) (ans+=a.m[i][j])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4774 屠龙勇士 题解</title>
    <link href="/2022/lg4774-solution/"/>
    <url>/2022/lg4774-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先预处理出杀死每条龙时要使用哪一把剑，设杀死第 <spanclass="math inline">\(i\)</span> 条龙用的剑的攻击力为 <spanclass="math inline">\(atk_i\)</span>。</p><p>那么问题转化为求解 <span class="math display">\[\left\{\begin{array}{l}atk_1 \cdot x &amp;\equiv a_1 \pmod{p_1}\\atk_2 \cdot x &amp;\equiv a_2 \pmod{p_2}\\&amp;\vdots\\atk_n \cdot x &amp;\equiv a_n \pmod{p_2}\end{array}\right.\]</span> 由于 <span class="math inline">\(p_i\)</span>不一定两两互质，所以如果没有 <span class="math inline">\(atk_i\)</span>的话，就可以直接上 exCRT。这里需要多预处理几步。</p><p>数论中有一个结论：如果 <span class="math display">\[ax \equiv ay \pmod p\]</span> 那么 <span class="math display">\[x \equiv y \pmod{\frac{p}{\gcd(a,p)}}\]</span> 其实这里的能这么做是因为 <spanclass="math inline">\(\gcd(a,a)=a\)</span>，所以我们只要求出 <spanclass="math inline">\(d_i = \gcd(atk_i,a_i)\)</span>，就能化成 <spanclass="math display">\[\frac{atk_i}{d_i} x \equiv \frac{a_i}{d_i} \pmod{\frac{p_i}{\gcd(d_i,p_i)}}\]</span> 由于此时 <spanclass="math inline">\(\frac{atk_i}{d_i}\)</span> 与 <spanclass="math inline">\(\frac{p_i}{\gcd(d_i,p_i)}\)</span>必然互质，所以一定存在模 <spanclass="math inline">\(\frac{p_i}{\gcd(d_i,p_i)}\)</span> 意义下 <spanclass="math inline">\(\frac{atk_i}{d_i}\)</span> 的逆元。于是乎再次转化<span class="math display">\[x \equiv \frac{a_i}{atk_i} \pmod{\frac{p_i}{\gcd(d_i,p_i)}}\]</span> 这样就能用 exCRT 求解了。</p><p>注意到数据范围中有不少点都满足 <span class="math inline">\(p_i=1\)</span>，而模 <span class="math inline">\(1\)</span>的情况十分简单，那么就可以特判一下。</p><p>不同推式子，直接考虑实际意义。当巨龙的生命为负时，它就会一直回复一滴血直到血量为<span class="math inline">\(0\)</span>，然后去世。也就是说，只要 <spanclass="math inline">\(atk_i \cdot x \ge a_i\)</span> 就行，所以答案就是<span class="math inline">\(x = \lceil \frac{a_i}{atk_i} \rceil\)</span>取个最大值。</p><p>注意为了防止乘法溢出，要用光速乘。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, fg, a[N], p[N], sw[N], rec[N], atk[N];<span class="hljs-type">int</span> M, R, ans, t[N];multiset&lt;<span class="hljs-type">int</span>&gt; st;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);y-=a/b*x;<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> mod)</span> </span>&#123;<span class="hljs-type">int</span> x, y;<span class="hljs-built_in">exgcd</span>(a,mod,x,y);<span class="hljs-keyword">return</span> (x+mod)%mod;    <span class="hljs-comment">// 返回a在模mod意义下的逆元</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cil</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x+y<span class="hljs-number">-1</span>)/y; &#125;<span class="hljs-comment">// 向上取整函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> z=(<span class="hljs-type">long</span> <span class="hljs-type">double</span>)x/p*y;<span class="hljs-type">int</span> res=(uint)x*y-(uint)z*p;<span class="hljs-keyword">return</span> (res+p)%p;    <span class="hljs-comment">// 非常玄学的O(1)光速乘</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exCRT</span><span class="hljs-params">()</span> </span>&#123;R=t[<span class="hljs-number">1</span>], M=p[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> d=t[i]-R, g, mod, x, y;g=<span class="hljs-built_in">exgcd</span>(M,p[i],x,y);<span class="hljs-keyword">if</span>(d%g) &#123; ans=<span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>; &#125;mod=p[i]/g;x=(<span class="hljs-built_in">mul</span>(x,d/g,mod))%mod;<span class="hljs-type">int</span> P=M/g*p[i];R=(<span class="hljs-built_in">mul</span>(x,M,P)+R)%P; M=M/g*p[i]; &#125;ans=R;    <span class="hljs-comment">// 板子</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;st.<span class="hljs-built_in">clear</span>();fg=ans=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) fg+=(p[i]=<span class="hljs-built_in">read</span>())==<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) rec[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) sw[i]=<span class="hljs-built_in">read</span>(), st.<span class="hljs-built_in">insert</span>(sw[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">auto</span> p=st.<span class="hljs-built_in">upper_bound</span>(a[i]);<span class="hljs-keyword">if</span>(p!=st.<span class="hljs-built_in">begin</span>()) --p;atk[i]=*p;st.<span class="hljs-built_in">erase</span>(p), st.<span class="hljs-built_in">insert</span>(rec[i]);&#125;<span class="hljs-keyword">if</span>(fg==n) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">cil</span>(a[i],atk[i]));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> _d=<span class="hljs-built_in">gcd</span>(atk[i],p[i]), d=<span class="hljs-built_in">gcd</span>(_d,a[i]);atk[i]/=_d, a[i]/=_d, p[i]/=d;t[i]=<span class="hljs-built_in">mul</span>(a[i],<span class="hljs-built_in">inv</span>(atk[i],p[i]),p[i]);&#125;<span class="hljs-built_in">exCRT</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>扩展中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串简单题目 1</title>
    <link href="/2022/string-solution-1/"/>
    <url>/2022/string-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="luogu4391-无线传输">luogu4391 无线传输</h2><h3 id="分析">分析</h3><p>题目说的很别扭，实际上是求一个最短的 <spanclass="math inline">\(S\)</span> 的子串，满足这个子串自我拼接之后，<spanclass="math inline">\(S\)</span> 是这个拼接串的子串。也就是 <spanclass="math inline">\(S\)</span> 的最小周期。</p><p>若 <span class="math inline">\(|S|=n\)</span>，则答案为 <spanclass="math inline">\(n-next_n\)</span>。证明如下：</p><p>如下图表示 <span class="math inline">\(S\)</span> 的最大 Border相交的情况，黑色部分是字符串 <spanclass="math inline">\(S\)</span>，蓝色部分是和红色部分是 <spanclass="math inline">\(next_n\)</span>，绿色部分 <spanclass="math inline">\(T=S[1,n-next_n]\)</span>。</p><p>显然 <span class="math inline">\(T\)</span> 是 <spanclass="math inline">\(S[1,next_n]\)</span> 的一个前缀，又因为 <spanclass="math inline">\(S[1,next_n] = S[n-next_n+1,n]\)</span>，所以 <spanclass="math inline">\(T\)</span> 后面又能再拼接上一块 <spanclass="math inline">\(T\)</span>。而前面的黄色部分 <spanclass="math inline">\(S[n-next_n+1,next_n]\)</span> 是前缀 Border 的最后$next_n - (n-next_n+1) + 1 = 2 next_n - n $ 个字符，后面的黄色部分是后缀Border 的最后 <span class="math inline">\(n - 2(n-next_n) = 2next_n -n\)</span> 个字符，所以黄色这这两块是等价的。由于左边的黄色部分是 <spanclass="math inline">\(T\)</span> 的一个前缀，所有右边的黄色部分也是<span class="math inline">\(T\)</span> 的前缀，于是在第二个 <spanclass="math inline">\(T\)</span> 后面再接一个 <spanclass="math inline">\(T\)</span>，此时 <spanclass="math inline">\(S\)</span> 必然为它的子串。</p><p><img src="https://s2.loli.net/2022/08/09/TbkpgLeVFNfhUjr.png" srcset="/img/loading.gif" lazyload /></p><p>那么最大 Border不重叠呢？看下图，颜色所代表的信息与上图相同。不难发现红色部分就是等价于蓝色部分，蓝色部分是<span class="math inline">\(T\)</span> 的前缀。所以再接一个 <spanclass="math inline">\(T\)</span> 就能覆盖整个串了。</p><p><img src="https://s2.loli.net/2022/08/09/PdxqIWCZnHD4vOF.png" srcset="/img/loading.gif" lazyload /></p><p>综上，<span class="math inline">\(n-next_n\)</span> 一定是 <spanclass="math inline">\(S\)</span> 的一个周期。</p><p>而 <span class="math inline">\(next_n\)</span> 是 <spanclass="math inline">\(S\)</span> 的最大 Border，对应的 <spanclass="math inline">\(n-next_n\)</span> 就是 <spanclass="math inline">\(S\)</span> 的最小周期。</p><h2 id="luogu3435-periods-of-words">luogu3435 Periods of Words</h2><p>上题证明了，<span class="math inline">\(n-next_n\)</span> 是 <spanclass="math inline">\(S\)</span> 的最小周期，同理 <spanclass="math inline">\(i-next_i\)</span> 是前缀 <spanclass="math inline">\(S[1,i]\)</span> 的最小周期。由于 <spanclass="math inline">\(next_{next_i}\)</span> 是 <spanclass="math inline">\(S[1,i]\)</span> 的次小Border，所以只要对于一个前缀 <spanclass="math inline">\(S[1,i]\)</span>，只要找到最小的非 <spanclass="math inline">\(0\)</span> border <spanclass="math inline">\(t\)</span>，最大周期即为 <spanclass="math inline">\(i-t\)</span>。方法是令 <spanclass="math inline">\(t=i\)</span>，如果 <spanclass="math inline">\(next_t &gt; 0\)</span>，那么就不断让 <spanclass="math inline">\(t=next_t\)</span>。这个过程也是可以记忆化的。</p><h2 id="luogu4824-censoring">luogu4824 Censoring</h2><p>套路性的维护一个栈，然后如果匹配到一个 <spanclass="math inline">\(T\)</span> 串，那么那么就让栈顶减小 <spanclass="math inline">\(|T|\)</span> 即可。最后留在栈里的即为答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, top, nxt[N], f[N], stk[N];<span class="hljs-type">char</span> a[N], b[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;a[i]!=a[j+<span class="hljs-number">1</span>]) j=nxt[j];j+=a[i]==a[j+<span class="hljs-number">1</span>];nxt[i]=j;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,b+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(a+<span class="hljs-number">1</span>), m=<span class="hljs-built_in">strlen</span>(b+<span class="hljs-number">1</span>);<span class="hljs-built_in">pre</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;b[i]!=a[j+<span class="hljs-number">1</span>]) j=nxt[j];j+=b[i]==a[j+<span class="hljs-number">1</span>];f[i]=j;stk[++top]=i;<span class="hljs-keyword">if</span>(f[i]==n) top-=n, j=f[stk[top]];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=top;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,b[stk[i]]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="luogu2375-动物园">luogu2375 动物园</h2><p>要求前缀和后缀不重叠还要计数。</p><p>设 <span class="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(S[1,i]\)</span> 的 Border 的个数，也就是如果 <spanclass="math inline">\(next_i = j\)</span>，那么有 <spanclass="math inline">\(f_i = f_j +1\)</span>。</p><p>对于每一个 <span class="math inline">\(i\)</span>，找到最大的满足<span class="math inline">\(i \ge 2j\)</span> 的 Border <spanclass="math inline">\(j\)</span>，此时 <span class="math inline">\(num_i= f_j\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> t, n, ans, nxt[N], f[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;nxt[i]=j;f[i]=f[j]+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>), n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">pre</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">2</span>*j) j=nxt[j];(ans*=f[j]+<span class="hljs-number">1</span>)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="luogu3426-template">luogu3426 Template</h2><p>首先印章上的字符串一定是原串的一个 Border，但是原串的 Border不一定合法。</p><p>而如果一个 Border 合法，那么所有 Border为它的下标之间的间隔绝对小于它的长度。这样就可以完成整个串的覆盖。观察样例就能得到这两个结论。</p><p>所以答案就要从原串 <span class="math inline">\(S\)</span> 的 Border里面选择，优先考虑最小的。</p><p>设 <span class="math inline">\(ans_i\)</span> 为候选答案中第 <spanclass="math inline">\(i\)</span> 小的答案。考虑 <spanclass="math inline">\(ans_{i-1}\)</span> 不合法，但是 <spanclass="math inline">\(ans_i\)</span> 合法的情况。</p><p>由于 <span class="math inline">\(ans_{i-1}\)</span>不合法，所以要排除所有 Border 为 <spanclass="math inline">\(ans_{i-1}\)</span> 且不为 <spanclass="math inline">\(ans_i\)</span> 的下标（<spanclass="math inline">\(ans_{i-1}\)</span> 一定是 <spanclass="math inline">\(ans_i\)</span> 的 Border）。排除之后，又要再次统计Border 为 <span class="math inline">\(ans_i\)</span>的下标的间隔。可以用链表来实现快速查询和删除。</p><p>如何快速实现排除下标呢？引入一种数据结构，名为——失配树。也叫 <spanclass="math inline">\(fail\)</span> 树和 <spanclass="math inline">\(next\)</span> 树。简而言之，就是把 <spanclass="math inline">\(next_i\)</span> 向 <spanclass="math inline">\(i\)</span> 连一条边。</p><p>它的主要性质是：点 <span class="math inline">\(x\)</span> 如果是点<span class="math inline">\(y\)</span> 的祖先，那么 <spanclass="math inline">\(S[1,x]\)</span> 是 <spanclass="math inline">\(S[1,y]\)</span> 的一个 Border。如果 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>之间没有祖孙关系，那么绝不满足上述性质。</p><p>也就是说，删去所有 Border 为 <spanclass="math inline">\(ans_{i-1}\)</span> 且 Border 不为 <spanclass="math inline">\(ans_i\)</span> 的下标，只要在失配树中删去 <spanclass="math inline">\(ans_{i-1}\)</span> 子树内所有非 <spanclass="math inline">\(ans_i\)</span> 的节点即可。</p><p>从小到大枚举答案，如果某个 <span class="math inline">\(ans_i\)</span>满足了，答案就是 <span class="math inline">\(ans_i\)</span>。</p><p>参考：<ahref="https://www.cnblogs.com/dedicatus545/p/8903324.html">[POI2005][luogu3462]SZA-Template [fail树]</a></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, gap, rec, fail[N], pre[N], suf[N], ans[N];<span class="hljs-type">int</span> tot, h[N], to[N], nxt[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepre</span><span class="hljs-params">()</span> </span>&#123;fail[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=fail[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;fail[i]=j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(fail[i],i);    <span class="hljs-comment">// 每一个点都要加入失配树</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;i=fail[i]) ans[++m]=i;    <span class="hljs-comment">// 这里是从大到小存的</span><span class="hljs-comment">// for(int i=1;i&lt;=m;++i) printf(&quot;%lld\n&quot;,ans[i]);</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pre[i]=i<span class="hljs-number">-1</span>, suf[i]=i+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;suf[pre[x]]=suf[x], pre[suf[x]]=pre[x];gap=<span class="hljs-built_in">max</span>(gap,suf[x]-pre[x]);pre[x]=suf[x]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> zero)</span> </span>&#123;<span class="hljs-built_in">del</span>(x);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==zero) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">del</span>(y);<span class="hljs-built_in">dfs</span>(y,zero);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">prepre</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i;--i) &#123;<span class="hljs-built_in">dfs</span>(ans[i+<span class="hljs-number">1</span>],ans[i]);        <span class="hljs-comment">// 这个可以模拟一下，注意第一次先删去了所有根节点0所有Border不是ans[m]的节点</span><span class="hljs-keyword">if</span>(gap&lt;=ans[i]) &#123; rec=ans[i]; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,rec);&#125;</code></pre></div><h2 id="cf126b-password">CF126B Password</h2><p>既是前缀，又是后缀，又在中间出现过。</p><p>不难想到，既是前缀又是后缀，说明一定是 <spanclass="math inline">\(S\)</span> 的一个 Border，所以答案最大为 <spanclass="math inline">\(next_n\)</span>。在中间也出现过，假设出现的位置是<span class="math inline">\(i_0\)</span>，那么答案也是 <spanclass="math inline">\(S[1,i_0]\)</span> 的一个Border。因此只要从大到小寻找满足</p><ol type="1"><li>是 <span class="math inline">\(S\)</span> 的 Border。</li><li>存在至少一个 <span class="math inline">\(i \in[1,n-1]\)</span>，满足 <span class="math inline">\(next_j =i\)</span>，</li></ol><p>的最大的 <span class="math inline">\(j\)</span> 即可。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, nxt[N], v[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;nxt[i]=j;<span class="hljs-keyword">if</span>(i!=n) v[j]=<span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans=nxt[n], fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(ans) &#123;<span class="hljs-keyword">if</span>(v[ans]) &#123; fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;ans=nxt[ans];&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Just a legend&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=ans;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="cf858d-polycarps-phone-book">CF858D Polycarp's phone book</h2><p>对于每个字符串 <spanclass="math inline">\(S_i\)</span>，找到一个最短的子串，满足这个子串是且只是<span class="math inline">\(S_i\)</span> 的子串。</p><p>一个想法把所有字符串的所有子串插入集合，对于每个字符串 <spanclass="math inline">\(S_i\)</span>，从小到大枚举所有子串，在不考虑 <spanclass="math inline">\(S_i\)</span>的所有子串的情况下查看是否存在这个子串。</p><p>这个显然是不行的，考虑优化。注意到，只要把所有后缀都插入集合，枚举的时候只枚举起点，就能找到所有<span class="math inline">\(S_i\)</span> 的子串。</p><p>既然是和字符串相关，那么这个集合可以用 Trie来在一个比较优的复杂度内实现。</p><p>考虑什么时候可行。设 <span class="math inline">\(cnt_x\)</span>表示字符 <span class="math inline">\(x\)</span> 在集合中的出现次数，如果<span class="math inline">\(S_i\)</span> 的某个子串的结尾字符的 <spanclass="math inline">\(cnt\)</span> 为 <spanclass="math inline">\(0\)</span>，由于之前已经删掉了 <spanclass="math inline">\(S_i\)</span>的所有后缀，所以此时这个子串一定是唯一的，输出即可。然后再把所有后缀插入回去。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, tot, d, cnt[N], trie[N][<span class="hljs-number">15</span>];<span class="hljs-type">char</span> a[N][<span class="hljs-number">15</span>], ans[<span class="hljs-number">15</span>], t[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-type">int</span> a=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a], ++cnt[x];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-type">int</span> a=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;x=trie[x][a], --cnt[x];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;t[i]=s[i];<span class="hljs-type">int</span> a=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;x=trie[x][a];<span class="hljs-keyword">if</span>(cnt[x]==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;d) &#123;d=i+<span class="hljs-number">1</span>;                <span class="hljs-comment">//此时答案长度为i+1</span>t[i+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;                <span class="hljs-comment">// 截取t[0,i]这一段，因为puts()遇到&#x27;\0&#x27;会停止</span><span class="hljs-built_in">strcpy</span>(ans,t);<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">insert</span>(a[i]+j);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;d=<span class="hljs-number">10</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">del</span>(a[i]+j);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">find</span>(a[i]+j);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">insert</span>(a[i]+j);<span class="hljs-built_in">puts</span>(ans);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP算法</tag>
      
      <tag>失配树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「字符串学习笔记」#1 KMP算法、Trie和自动机概念</title>
    <link href="/2022/notes-string-1/"/>
    <url>/2022/notes-string-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="基础概念">基础概念</h2><p>定义 <span class="math inline">\(S\)</span> 为一个字符串，其长度为<span class="math inline">\(n=|S|\)</span>，不特殊说明的情况下，下标从<span class="math inline">\(1\)</span> 开始，<spanclass="math inline">\(S_i\)</span> 为 <spanclass="math inline">\(S\)</span> 中从左往右第 <spanclass="math inline">\(i\)</span> 个字符。</p><p><span class="math inline">\(S[l,r]\)</span> 为 <spanclass="math inline">\(S_l,S_{l+1} , \ldots S_{r}\)</span>，称为 <spanclass="math inline">\(S\)</span> 的一个子串。<spanclass="math inline">\(S[1,i]\)</span> 称为 <spanclass="math inline">\(S\)</span> 的一个前缀 (prefix)，<spanclass="math inline">\(S[i,n]\)</span> 为 <spanclass="math inline">\(S\)</span> 的一个后缀 (suffix)。</p><p>对于 <span class="math inline">\(S\)</span> 的一个子串 <spanclass="math inline">\(S_0\)</span>，满足 <spanclass="math inline">\(S_0\)</span> 不仅是 <spanclass="math inline">\(S\)</span> 的一个前缀，还是 <spanclass="math inline">\(S\)</span> 的一个后缀，那么称 <spanclass="math inline">\(S_0\)</span> 或其长度为 <spanclass="math inline">\(S\)</span> 的一个 Border。Border 不能是 <spanclass="math inline">\(S\)</span> 本身。</p><p><imgsrc="https://pic2.zhimg.com/80/v2-c3cd7adda369b334a8065b7eadf8e2cd_720w.jpg" srcset="/img/loading.gif" lazyload /></p><p>举个例子，对于一个字符串<code>s=QwQorzQwQ</code>，其中<code>QwQ</code>就是<code>s</code>的一个Border。</p><h2 id="kmp-算法">KMP 算法</h2><p>KMP算法主要来解决两个字符串的匹配问题，能够在线性时间内判断一个字符串是否为另一个字符串的子串并求出其出现位置。</p><p>对于字符串 <span class="math inline">\(S\)</span>，设 <spanclass="math inline">\(next_i\)</span> 为 <spanclass="math inline">\(S[1,i]\)</span> 中最长的 Border 的长度。</p><p>如何求出 <span class="math inline">\(next_i\)</span>？</p><p>朴素的做法是，枚举 <span class="math inline">\(j \in[1,i-1]\)</span>，判断 <span class="math inline">\(S[1,j]\)</span> 与<span class="math inline">\(S[i-j+1,i]\)</span> 是否相同，如果相同，那么<span class="math inline">\(j\)</span> 就是 <spanclass="math inline">\(next_i\)</span> 的一个“候选项”。取最大的 <spanclass="math inline">\(j\)</span> 即可。</p><p>但是复杂度奇高，不够。</p><p>引理：若 <span class="math inline">\(j_0\)</span> 是 <spanclass="math inline">\(next_i\)</span> 的一个“候选项”，那么小于 <spanclass="math inline">\(j_0\)</span> 的最大的 <spanclass="math inline">\(next_i\)</span> 的“候选项”是 <spanclass="math inline">\(next_{j_0}\)</span>。</p><blockquote><p>证明：反证法。假设存在 <span class="math inline">\(next_{j_0} &lt;j_1 &lt; j_0\)</span>，且 <span class="math inline">\(j_1\)</span> 是<span class="math inline">\(next_i\)</span> 的一个“候选项”，那么一定有<span class="math inline">\(S[1,j_1]=S[i-j_1+1,i]\)</span>。由于 <spanclass="math inline">\(S[1,j_0]=S[i-j_0+1,i]\)</span>，所以分别取 <spanclass="math inline">\(S[1,j_0]\)</span> 和 <spanclass="math inline">\(S[i-j_0+1,i]\)</span> 的后 <spanclass="math inline">\(j_1\)</span> 个字符，显然也相等，也就是 <spanclass="math inline">\(S[j_0-j_1+1,j_0] = S[1,j_1]\)</span>，从而 <spanclass="math inline">\(j_1\)</span> 是 <spanclass="math inline">\(S[1,j_0]\)</span> 的一个 Border，这与 <spanclass="math inline">\(next_{j_0}\)</span> 是 <spanclass="math inline">\(j_0\)</span> 的最大的 Border 相矛盾。由于 <spanclass="math inline">\(next_{j_0}\)</span> 是 <spanclass="math inline">\(j_0\)</span> 的前后缀，所以显然也是 <spanclass="math inline">\(next_i\)</span> 的一个 Border。</p><p>综上，命题得证。</p></blockquote><p>考虑如何求解。根据引理，当 <spanclass="math inline">\(next_{i-1}\)</span> 被计算完毕之后，就能够得到所有<span class="math inline">\(next_{i-1}\)</span> 的“候选项”。如果 <spanclass="math inline">\(j\)</span> 是 <spanclass="math inline">\(next_i\)</span> 的“候选项”，那么 <spanclass="math inline">\(j-1\)</span> 必然是 <spanclass="math inline">\(next_{i-1}\)</span>的“候选项”。这个通过手动模拟一下就能知道。</p><p>也就是说，我们可以用 <span class="math inline">\(next_{i-1}\)</span>的最大候选项 <span class="math inline">\(j\)</span> 来得到 <spanclass="math inline">\(next_i\)</span> 的最大候选项。如果 <spanclass="math inline">\(next_{i-1}=j\)</span> 且 <spanclass="math inline">\(S_i = S_{j+1}\)</span>，那么很显然，<spanclass="math inline">\(j+1\)</span> 就能够称为 <spanclass="math inline">\(next_i\)</span>的候选项，且一定是最大的。否则，对于任何 <spanclass="math inline">\(next_{i-1}\)</span>非最大的候选项，如果满足上述条件，也能变成 <spanclass="math inline">\(next_i\)</span> 的候选项。因此，只要枚举 <spanclass="math inline">\(next_{i-1}\)</span>的所有候选项，取满足条件且最大的即可。</p><p>流程。</p><p>首先有 <span class="math inline">\(next_1 = 0\)</span>，详见 Border的定义。</p><p>初始化 <spanclass="math inline">\(j=0\)</span>，表示当前匹配的长度，假设 <spanclass="math inline">\(next_{1 \sim i-1}\)</span> 都已经求解完成。如果<span class="math inline">\(j \neq 0\)</span> 且 <spanclass="math inline">\(S_i \neq S_{j+1}\)</span>，那就不断令 <spanclass="math inline">\(j=next_j\)</span>。如果 <spanclass="math inline">\(S_i = S_{j+1}\)</span> 了，那就让 <spanclass="math inline">\(j+1\)</span>。此时 <spanclass="math inline">\(next_i = j\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp">nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;    <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];    <span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;    nxt[i]=j;&#125;</code></pre></div><p>此外，如果要得到字符串 <span class="math inline">\(A\)</span> 与<span class="math inline">\(B\)</span> ($|B| |A| $) 匹配的结果，还要求出<span class="math inline">\(f\)</span>，表示一个 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 之间的广义 Border 的长度。<spanclass="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(A[1,i]\)</span> 与 <spanclass="math inline">\(B\)</span> 中以 <spanclass="math inline">\(i\)</span> 结尾的子串的最长匹配长度。形式化地<span class="math display">\[f_i = \max{\{j\}}\]</span> 其中 <span class="math inline">\(j \le i\)</span> 并且 <spanclass="math inline">\(A[1,j] = B[i-j+1,i]\)</span>。注意 <spanclass="math inline">\(next_i\)</span> 不能为 <spanclass="math inline">\(i\)</span>，但是 <spanclass="math inline">\(f_i\)</span> 能为 <spanclass="math inline">\(i\)</span>。</p><p>方法也是类似的。</p><div class="code-wrapper"><pre><code class="hljs cpp">nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;    <span class="hljs-keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="hljs-number">1</span>]) j=nxt[j];    <span class="hljs-keyword">if</span>(b[i]==b[j+<span class="hljs-number">1</span>]) ++j;    nxt[i]=j;&#125;<span class="hljs-comment">// 先求出较小串的next</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;    <span class="hljs-comment">// 这里i从1开始</span>    <span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=a[i]) j=nxt[j];    <span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==a[i]) ++j;    f[i]=j;    <span class="hljs-comment">// f[i]==m 表示b在a中出现了</span>    <span class="hljs-keyword">if</span>(j==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-m+<span class="hljs-number">1</span>), j=nxt[j];&#125;</code></pre></div><p>KMP 算法的复杂度是 <span class="math inline">\(O(N+M)\)</span>的，如果只用来求 <span class="math inline">\(next\)</span> 则是 <spanclass="math inline">\(O(N)\)</span> 的。证明略。</p><h3 id="失配树">失配树</h3><p>见 <a href="https://miku01ck.xyz//string-solution-1">这篇博客</a>的倒数第三题。</p><p>早晚会补上的。</p><h2 id="trie">Trie</h2><p>像字典那样把字符串串在一棵树上哦~</p><p>没啥可写的，直接上板子好了。</p><p>这东西念作<code>Tree</code>……</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tot, trie[N][<span class="hljs-number">26</span>];<span class="hljs-comment">// N要大于字符串个数*字符串长度</span><span class="hljs-comment">// 26是字符集</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-type">int</span> a=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;        <span class="hljs-comment">// 建立新结点</span>x=trie[x][a];&#125;    <span class="hljs-comment">// 插入一个字符串</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-type">int</span> a=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 找不到节点</span>x=trie[x][a];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">114514</span>; <span class="hljs-comment">// 返回你想要的信息</span>&#125;</code></pre></div><p>这玩意是典型的空间换时间……</p><h3 id="一个简单应用-0-1-trie">一个简单应用 0-1 Trie</h3><p>把<code>int</code>当作长度为 <span class="math inline">\(31\)</span>的字符串插入 Trie 中。</p><p>下面放板子，可以快速处理最大异或和的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tot, trie[N*<span class="hljs-number">31</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">// [数字个数*数位][每一位不是0就是1]</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-type">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(trie[x][a^<span class="hljs-number">1</span>]) ans+=(<span class="hljs-number">1</span>&lt;&lt;i), x=trie[x][a^<span class="hljs-number">1</span>];        <span class="hljs-comment">// 尽量往数字相反的地方走，这样异或值为1</span><span class="hljs-keyword">else</span> x=trie[x][a];&#125;<span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><h2 id="dfa-是个啥">DFA 是个啥？</h2><p>有限自动机 (FA)，确定有限状态自动机 (DFA)。</p><p>下面都是一些概念，<del>我甚至还没有完全理解</del>，还是太菜了。</p><p>我们通常用确定有限状态自动机 (DFA) 解决大部分字符串的问题。</p><p>DFA 可以用一个 <span class="math inline">\(5\)</span> 元组 <spanclass="math inline">\((Q,\Sigma,\delta,q_0,F)\)</span> 表示，其中 <spanclass="math inline">\(Q\)</span> 为状态集, <spanclass="math inline">\(\Sigma\)</span> 为字符集，<spanclass="math inline">\(\delta\)</span> 为转移函数，<spanclass="math inline">\(q_0\)</span> 为起始状态，<spanclass="math inline">\(F\)</span> 为终态集。</p><p>如何判断一个字符串是否能被一个 DFA 接受呢？一开始时，自动机在起始状态<span class="math inline">\(q_0\)</span> ，每读入一个字符 <spanclass="math inline">\(c\)</span> 后，状态转移到 <spanclass="math inline">\(\delta(q,c)\)</span> ，其中 <spanclass="math inline">\(q\)</span> 为当前状态。当整个字符串读完之后,当且仅当 <span class="math inline">\(q\)</span> 在终态集 <spanclass="math inline">\(F\)</span> 中时，DFA 接受这个字符串。</p><p><span class="math inline">\(Trie\)</span> 是一种最简单的 DFA。</p><p>插入每个模式串的时候，从前往后依次考虑每一位 <spanclass="math inline">\(c\)</span> ，然后记当前所在的状态 <spanclass="math inline">\(q\)</span> ，如果不存在 <spanclass="math inline">\(\delta(q,c)\)</span> 那么添加一个 <spanclass="math inline">\(\delta(q,c)\)</span> 的转移。接下来 <spanclass="math inline">\(q \rightarrow \delta(q,c)\)</span>。终态的 <spanclass="math inline">\(q\)</span> 作为 DFA 的一个 <spanclass="math inline">\(F\)</span> 的一个元素。</p><p><span class="math inline">\(Trie\)</span>能接受的所有字符串就是插入的所有的串。</p><p>至于 AC 自动机啥的，目前不会……😥</p><p>为啥你的学习笔记里面一道题都没有呢？</p><p>一是因为懒，而是因为想加进来的题目有点多……</p><h2 id="参考">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/545135464">字符串学习笔记(1)基础概念与kmp前置</a></li><li><a href="https://zhuanlan.zhihu.com/p/546135224">字符串学习笔记(2)字典树与Border树</a></li><li><ahref="https://www.cnblogs.com/Y25t/p/12459152.html">从0开始的字符串学习--KMP与失配树</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#812 (Div 2)</title>
    <link href="/2022/cf1713-solution/"/>
    <url>/2022/cf1713-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1713</strong>.</p><h2 id="a.-traveling-salesman-problem">A. Traveling SalesmanProblem</h2><p>注意到答案为 <span class="math inline">\(2 \cdot(Rx-Lx+Ry-Ly)\)</span>，其中 <span class="math inline">\(Rx\)</span>为最大的横坐标，<span class="math inline">\(Lx\)</span>为最小的横坐标，<span class="math inline">\(Ry\)</span> 与 <spanclass="math inline">\(Ly\)</span> 同理。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> t, n, x[<span class="hljs-number">105</span>], y[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> Lx=<span class="hljs-number">0</span>, Rx=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> Ly=<span class="hljs-number">0</span>, Ry=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;x[i]=<span class="hljs-built_in">read</span>(), y[i]=<span class="hljs-built_in">read</span>();Lx=<span class="hljs-built_in">min</span>(Lx,x[i]), Rx=<span class="hljs-built_in">max</span>(Rx,x[i]);Ly=<span class="hljs-built_in">min</span>(Ly,y[i]), Ry=<span class="hljs-built_in">max</span>(Ry,y[i]);&#125;<span class="hljs-type">int</span> d1=Rx-Lx;<span class="hljs-type">int</span> d2=Ry-Ly;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(d1+d2)&lt;&lt;<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-optimal-reduction">B. Optimal Reduction</h2><p>最优策略是不断“削平”，<span class="math inline">\(1,2,3 \rightarrow0,1,2, \rightarrow 0,0,1 \rightarrow 0 , 0 ,0\)</span>。</p><p>注意到如果存在一个「谷」，那么在操作中必然存在 <spanclass="math inline">\(0\)</span>把两边元素隔开，从而让操作次数增加。<span class="math inline">\(2 ,1, 3\rightarrow 1 , 0 ,2 \rightarrow 0 , 0 , 2 \rightarrow 0 , 0 ,1\rightarrow 0 , 0 ,0\)</span>。</p><p>而这个「谷」不一定非要是与相邻的两个数，比如 <spanclass="math inline">\(5 , 2 ,2 ,5\)</span> 这样的。</p><p>所以设前缀 <span class="math inline">\(\max\)</span> 为 <spanclass="math inline">\(p_i\)</span>，后缀 $$ 为 <spanclass="math inline">\(q_i\)</span>。判断是否存在一个 <spanclass="math inline">\(i\)</span>，满足 <spanclass="math inline">\(p_{i-1} &gt; a_i\)</span> 且 <spanclass="math inline">\(a_i &lt; q_{i+1}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N], p[N], q[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-type">bool</span> fg=<span class="hljs-number">1</span>;p[<span class="hljs-number">0</span>]=q[n+<span class="hljs-number">1</span>]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), p[i]=<span class="hljs-built_in">max</span>(p[i<span class="hljs-number">-1</span>],a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) q[i]=<span class="hljs-built_in">max</span>(q[i+<span class="hljs-number">1</span>],a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&lt;p[i<span class="hljs-number">-1</span>]&amp;&amp;a[i]&lt;q[i+<span class="hljs-number">1</span>]) fg=<span class="hljs-number">0</span>;&#125;<span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-build-permutation">C. Build Permutation</h2><p>考虑一个事实，对于任意正整数 <spanclass="math inline">\(n\)</span>，在 <spanclass="math inline">\([n,2n]\)</span> 区间内一定存在一个完全平方数。</p><p>那么从 <span class="math inline">\(x=n-1\)</span> 开始，找到大于<span class="math inline">\(x\)</span> 的最小的完全平方数 <spanclass="math inline">\(t\)</span>，对于 <span class="math inline">\(i \in[t-x,x]\)</span>，令 <span class="math inline">\(ans_i = t-i\)</span>即可，之后让 <span class="math inline">\(x= t-x-1\)</span>。</p><p>直到 <span class="math inline">\(x=-1\)</span> 为止。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> x=n<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(~x) &#123;<span class="hljs-type">int</span> t=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*x);t*=t;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t-x;i&lt;=x;++i) ans[i]=t-i;x=t-x<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n<span class="hljs-number">-1</span>]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-tournament-countdown">D. Tournament Countdown</h2><p>这是一道交互题，也是我的第一道交互题。</p><p>先来考虑，两个人获胜场数相同意味着什么？由于胜利者会晋级，淘汰者再也不能参加比赛，所以两个人获胜场数相同，意味着这两人必定晋级到了同一轮。</p><p>那么如果 <span class="math inline">\(a\)</span> 的获胜次数大于 <spanclass="math inline">\(b\)</span>，说明 <spanclass="math inline">\(a\)</span> 晋级到了更高的一轮，否则就反过来。</p><p>由于询问次数最多为 <span class="math inline">\(\frac{2}{3}2^n\)</span>，设 <span class="math inline">\(m= 2^n\)</span>所以有一个我想不到的结论，只要每次对 <spanclass="math inline">\(4\)</span>个人进行两次询问，就能直到哪个人晋级，从而询问数量为 <spanclass="math display">\[2 \times ( \frac{1}{4}m + \frac{1}{16}m + \frac{1}{64}m +\cdots) =\frac{2}{3}m\]</span> 等比数列求和公式——我从来都背不过的东西。</p><p>那么怎么样对 <span class="math inline">\(4\)</span>个人进行两次询问，就能得到最终晋级者呢？</p><p>对于第 <span class="math inline">\(i\)</span> 个人，其中 <spanclass="math inline">\(i\)</span> 是 <spanclass="math inline">\(4\)</span> 人中的第一个，<spanclass="math inline">\(i\)</span> 要和 <spanclass="math inline">\(i+1\)</span> 对抗，<spanclass="math inline">\(i+2\)</span> 和 <spanclass="math inline">\(i+3\)</span> 对抗。</p><p>询问 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(i+2\)</span>，如果胜利场数相同，说明二人都输给了与自己对抗的人。如果都打败了与自己对抗的人，虽然此时也相同，但是最后<span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(i+2\)</span>必然要分出胜负，所以这种情况不会发生。此时只要询问 <spanclass="math inline">\(i+1\)</span> 和 <spanclass="math inline">\(i+3\)</span> 就能找到胜利者。</p><p>否则如果 <span class="math inline">\(i\)</span> 的获胜次数大于 <spanclass="math inline">\(i+2\)</span>，就询问 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(i+3\)</span>。如果 <spanclass="math inline">\(i\)</span> 的获胜次数小于 <spanclass="math inline">\(i+2\)</span>，就询问 <spanclass="math inline">\(i+1\)</span> 和 <spanclass="math inline">\(i+2\)</span>。</p><p>综上，必然能够满足条件。</p><p>特别地，当只剩下 <span class="math inline">\(2\)</span>人时，只要询问 <span class="math inline">\(1\)</span> 次就可以了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;? &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;<span class="hljs-type">int</span> x; cin&gt;&gt;x;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;cin&gt;&gt;n;n=<span class="hljs-number">1</span>&lt;&lt;n;vector&lt;<span class="hljs-type">int</span>&gt; a, b;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">while</span>(a.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>) &#123;b.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i+=<span class="hljs-number">4</span>) &#123;<span class="hljs-type">int</span> res=<span class="hljs-built_in">ask</span>(a[i],a[i+<span class="hljs-number">2</span>]);<span class="hljs-keyword">if</span>(!res) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask</span>(a[i+<span class="hljs-number">1</span>],a[i+<span class="hljs-number">3</span>])==<span class="hljs-number">1</span>) b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">3</span>]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask</span>(a[i],a[i+<span class="hljs-number">3</span>])==<span class="hljs-number">1</span>) b.<span class="hljs-built_in">pb</span>(a[i]);<span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">3</span>]);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask</span>(a[i+<span class="hljs-number">2</span>],a[i+<span class="hljs-number">1</span>])==<span class="hljs-number">1</span>) b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">2</span>]);<span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">1</span>]);&#125;&#125;a=b;&#125;<span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()==<span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> res=<span class="hljs-built_in">ask</span>(a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span>(res==<span class="hljs-number">2</span>) a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>];&#125;cout&lt;&lt;<span class="hljs-string">&quot;! &quot;</span>&lt;&lt;a[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>交互题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「AtCoder Beginner Contest」#263</title>
    <link href="/2022/abc263-solution/"/>
    <url>/2022/abc263-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>ABC263</strong>.</p><h2 id="a.-full-house">A. Full House</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> h[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;++i) ++h[<span class="hljs-built_in">read</span>()];<span class="hljs-type">int</span> f1=<span class="hljs-number">0</span>, f2=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">13</span>;++i) &#123;<span class="hljs-keyword">if</span>(h[i]==<span class="hljs-number">3</span>) f1=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h[i]==<span class="hljs-number">2</span>) f2=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(f1&amp;&amp;f2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;</code></pre></div><h2 id="b.-ancestor">B. Ancestor</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500</span>;<span class="hljs-type">int</span> n, dep[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> pp=<span class="hljs-built_in">read</span>();p[i].<span class="hljs-built_in">push_back</span>(pp), p[pp].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dep[n]<span class="hljs-number">-1</span>);&#125;</code></pre></div><h2 id="c.-monotonically-increasing">C. Monotonically Increasing</h2><p>搜</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">50</span>;<span class="hljs-type">int</span> n, m, len, ans[N], c[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> now)</span> </span>&#123;<span class="hljs-keyword">if</span>(now==n) &#123; <span class="hljs-built_in">print</span>(ans); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos+<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;ans[now+<span class="hljs-number">1</span>]=i;<span class="hljs-built_in">dfs</span>(i,now+<span class="hljs-number">1</span>);ans[now+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div><h2 id="d.-left-right-operation">D. Left Right Operation</h2><p>不难发现，让修改的前缀和后缀交错是没有任何意义的，所以可以认为 <spanclass="math inline">\(x\)</span> 严格小于 <spanclass="math inline">\(n-y+1\)</span>。</p><p>仿照 <span class="math inline">\(DP\)</span>的套路，注意到可以直接维护 <span class="math inline">\(p_i\)</span> 表示<span class="math inline">\([1,i]\)</span> 的最小值，<spanclass="math inline">\(q_i\)</span> 表示 <spanclass="math inline">\([i,n]\)</span> 的最小值。 <spanclass="math display">\[p_i = \min\{ p_{i-1}+a_i,L \cdot i \}\]</span></p><p><span class="math display">\[q_i = \min\{ q_{i+1}+a_i,R \cdot (n-i+1) \}\]</span></p><p>找到最小的 <span class="math inline">\(p_i + q_{i+1}\)</span>即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, L, R, ans, a[N], p[N], q[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), L=<span class="hljs-built_in">read</span>(), R=<span class="hljs-built_in">read</span>();p[<span class="hljs-number">0</span>]=p[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=a[i]=<span class="hljs-built_in">read</span>(), p[i]=<span class="hljs-built_in">min</span>(p[i<span class="hljs-number">-1</span>]+a[i],L*i);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) q[i]=<span class="hljs-built_in">min</span>(q[i+<span class="hljs-number">1</span>]+a[i],R*(n-i+<span class="hljs-number">1</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;ans=<span class="hljs-built_in">min</span>(ans,p[i]+q[i+<span class="hljs-number">1</span>]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="e.-sugoroku-3">E. Sugoroku 3</h2><p>设 <span class="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(n\)</span> 的期望步数，有 <spanclass="math inline">\(f_n =0\)</span>。 <span class="math display">\[f_i = 1 + \frac{\sum_{j=1}^{a_i} f(i+j) }{a_i +1} + \frac{f_i}{a_i+1}\]</span> 含义：<span class="math inline">\(1\)</span>是投掷骰子这一步，结果是正数的总期望值是第二项，结果是 <spanclass="math inline">\(0\)</span> 意味着还要再 <spanclass="math inline">\(i\)</span> 呆一次，期望值是第三项。</p><p>简单化简 <span class="math display">\[f_i = \frac{\sum_{j=1}^{a_i}f(i+j) + a_i + 1}{a_i}\]</span> 那个和式可以用后缀和 <span class="math inline">\(O(1)\)</span>得到。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, a[N], s[N], f[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) a[i]=<span class="hljs-built_in">read</span>();f[n]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i;--i) &#123;<span class="hljs-type">int</span> S=((s[i+<span class="hljs-number">1</span>]-s[i+a[i]+<span class="hljs-number">1</span>])%mod+a[i]+<span class="hljs-number">1</span>)%mod;f[i]=S*<span class="hljs-built_in">fp</span>(a[i],mod<span class="hljs-number">-2</span>)%mod;s[i]=(s[i+<span class="hljs-number">1</span>]+f[i])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>]+mod)%mod);&#125;</code></pre></div><h2 id="f.-tournament">F. Tournament</h2><p>人数是 <span class="math inline">\(2\)</span>的整数次幂，考虑一个类似分治的做法。</p><p>由于最终一定会留下一个获胜的人，设 <spanclass="math inline">\(f_i\)</span> 为 <spanclass="math inline">\(i\)</span> 获胜的最大收益。注意 <spanclass="math inline">\(C_{i,j}\)</span> 是第 <spanclass="math inline">\(i\)</span> 个人恰好赢了 <spanclass="math inline">\(j\)</span> 场得到的收益，如果 <spanclass="math inline">\(i\)</span> 多赢了一场，那么就要获得 <spanclass="math inline">\(C_{i,j+1}\)</span>，去掉 <spanclass="math inline">\(C_{i,j}\)</span>。</p><p>考虑一个自底向上的过程 <spanclass="math inline">\(solve(l,r,d)\)</span>，表示编号在 <spanclass="math inline">\([l,r]\)</span> 中的人，此时是第 <spanclass="math inline">\(d\)</span> 场。令 <span class="math inline">\(mid= \frac{l+r}{2}\)</span>。</p><p>在更新信息之前，设 <span class="math inline">\(p =\max_{i=l}^{mid}{\{ f_i \}}\)</span>，<span class="math inline">\(q =\max_{i=mid+1}^r{\{ f_i \}}\)</span>。</p><p>由于能够自由安排比赛，假设 <spanclass="math inline">\([l,mid]\)</span> 中的人全部胜出，那么有 <spanclass="math inline">\(C_{i,d} - C_{i,d-1} \rightarrow f_i\)</span>。由于<span class="math inline">\(i\)</span>胜利之后必然有一个人告负，所以对于每个胜利者，都让打败的人在第 <spanclass="math inline">\(d-1\)</span> 层得到的收益最大即可，所以 <spanclass="math inline">\(C_{i,d} - C_{i,d-1} + q \rightarrowf_i\)</span></p><p>反过来，若 <span class="math inline">\(i \in[mid+1,r]\)</span>，<span class="math inline">\(C_{i,d} - C_{i,d-1} + p\rightarrow f_i\)</span>。</p><p>答案为 <span class="math inline">\(\max{\{f_i \}}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">16</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, c[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)+<span class="hljs-number">5</span>][N+<span class="hljs-number">5</span>], f[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)+<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> d)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">solve</span>(l,mid,d<span class="hljs-number">-1</span>), <span class="hljs-built_in">solve</span>(mid+<span class="hljs-number">1</span>,r,d<span class="hljs-number">-1</span>);<span class="hljs-type">int</span> p=<span class="hljs-number">-1</span>, q=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=mid;++i) p=<span class="hljs-built_in">max</span>(p,f[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i) q=<span class="hljs-built_in">max</span>(q,f[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=mid;++i) f[i]+=c[i][d]-c[i][d<span class="hljs-number">-1</span>]+q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i) f[i]+=c[i][d]-c[i][d<span class="hljs-number">-1</span>]+p;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1</span>&lt;&lt;n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) c[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;n,n);<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1</span>&lt;&lt;n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="g.-erasing-prime-pairs">G. Erasing Prime Pairs</h2><p>注意到，如果把奇数作为左部点，偶数作为右部点。如果一个左部点和一个右部点相加是个质数，那么在他们之间连边，这样就能形成一张二分图。而奇数与奇数，偶数与偶数的和必然不是质数，每个数能够使用多次，求它的最大多重匹配即可。</p><p>但是存在一个特例，数字 <span class="math inline">\(1\)</span>。<spanclass="math inline">\(1\)</span> 可以和自身匹配，也可以和偶数匹配。</p><p>一个错误的想法是直接将 <span class="math inline">\(1\)</span>加入图中，用最大流算法求出最大多重匹配之后，找到 <spanclass="math inline">\(1\)</span> 在残量网络中对应的边，设其容量为 <spanclass="math inline">\(w\)</span>，则让答案加上 <spanclass="math inline">\(\lfloor \frac{w}{2}\rfloor\)</span>，含义是让剩下的 <span class="math inline">\(1\)</span>两两配对。</p><p>这个想法错在可能会有剩下的 <spanclass="math inline">\(1\)</span>，这个 <spanclass="math inline">\(1\)</span>可能和没有在最大多重匹配之中的点匹配。</p><p>正确的做法是先不将 <span class="math inline">\(1\)</span>加入图中，跑出最大匹配。然后将 <span class="math inline">\(1\)</span>有关的边加入残量网络中，再跑一次最大匹配（因为 <spanclass="math inline">\(1\)</span> 自己匹配和与别的点匹配，贡献都是 <spanclass="math inline">\(1\)</span>），最后加上 <spanclass="math inline">\(\lfloor \frac{w}{2} \rfloor\)</span>即可。此时如果还有剩下的 <spanclass="math inline">\(1\)</span>，那么这个 <spanclass="math inline">\(1\)</span>既不能和其他数匹配，又不能自己匹配，只能扔掉了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-type">int</span> n, s, t, one, ans, a[N], b[N], d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[<span class="hljs-number">6</span>*N], w[<span class="hljs-number">6</span>*N], nxt[<span class="hljs-number">6</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>); &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) d[i]=<span class="hljs-number">0</span>;d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-type">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) ans+=<span class="hljs-built_in">dfs</span>(s,inf);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();s=<span class="hljs-number">0</span>, t=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">addedge</span>(s,i,b[i]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">addedge</span>(i,t,b[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(a[i]&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(!(a[j]&amp;<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-built_in">isprime</span>(a[i]+a[j])) <span class="hljs-built_in">addedge</span>(i,j,inf);&#125;ans=<span class="hljs-built_in">dinic</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">addedge</span>(s,i,b[i]), one=tot;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!(a[j]&amp;<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-built_in">isprime</span>(<span class="hljs-number">1</span>+a[j])) <span class="hljs-built_in">add</span>(i,j,inf);&#125;ans+=<span class="hljs-built_in">dinic</span>();<span class="hljs-keyword">if</span>(one) ans+=w[one<span class="hljs-number">-1</span>]/<span class="hljs-number">2</span>;    <span class="hljs-comment">// 边的编号从1开始</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>网络流</tag>
      
      <tag>数学期望</tag>
      
      <tag>分治</tag>
      
      <tag>最大流</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Edu Codeforces Round」#133 (Div 2)</title>
    <link href="/2022/cf1716-solution/"/>
    <url>/2022/cf1716-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1716</strong>.</p><h1 id="a.-2-3-moves">A. 2-3 Moves</h1><h2 id="分析">分析</h2><p>注意到 <span class="math inline">\(n=1\)</span> 的时候要使用 <spanclass="math inline">\(+3\)</span>，<spanclass="math inline">\(-2\)</span> 两次操作。</p><p>如果 <span class="math inline">\(3 \mid n\)</span>，那么全部用 <spanclass="math inline">\(3\)</span> 就好，操作数 <spanclass="math inline">\(\frac{n}{3}\)</span>。</p><p>否则当 <span class="math inline">\(n \equiv 2 \pmod 3\)</span>时，先用一次 <span class="math inline">\(2\)</span> 然后全部用 <spanclass="math inline">\(3\)</span> 即可，操作数 <spanclass="math inline">\(\lfloor \frac{n}{3} \rfloor + 1\)</span>。</p><p>否则一定有 <span class="math inline">\(n \equiv 1 \pmod3\)</span>，那么由于 <span class="math inline">\(n \neq1\)</span>，所以必定存在一个 <spanclass="math inline">\(4\)</span>，用两次 <spanclass="math inline">\(2\)</span>，剩下的一定是 <spanclass="math inline">\(3\)</span> 的倍数。不难发现操作数仍然是 <spanclass="math inline">\(\lfloor \frac{n}{3} \rfloor + 1\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) ans=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) ans=n/<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> ans=n/<span class="hljs-number">3</span>+<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-permutation-chain">B. Permutation Chain</h1><h2 id="分析-1">分析</h2><p>注意最优解中第一次肯定是从 <span class="math inline">\(1\)</span> 到<span class="math inline">\(n\)</span>，fixedness 为 <spanclass="math inline">\(n\)</span>。经过一次交换后 fixedness 必定为 <spanclass="math inline">\(n-2\)</span>，之后每一次交换都一定有办法让fixedness 减少 <span class="math inline">\(1\)</span>，最终为 <spanclass="math inline">\(0\)</span>。</p><p>直接输出 <span class="math inline">\(n\)</span>然后随便乱搞即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> t, n, ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n);<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans[i]=i;<span class="hljs-built_in">print</span>(ans);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;~i;--i) &#123;<span class="hljs-built_in">swap</span>(ans[p],ans[p+<span class="hljs-number">1</span>]);<span class="hljs-built_in">print</span>(ans);++p;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-robot-in-a-hallway">C. Robot in a Hallway</h1><h2 id="分析-2">分析</h2><p>由于本人比较懒，所以直接用网图了 awa。侵删。</p><p>由于要经过每一个格子，所以走法必定是先走蛇形然后「コ」形。<del>实在是无法形容所以直接用这个片假名orz</del>。当然也可以全部走蛇形或者全部走「コ」形，其中蛇形必然是先向下走。</p><p><imgsrc="https://pic3.zhimg.com/80/v2-a10661f2b15524cc218cb738acb3c86a_720w.jpg" srcset="/img/loading.gif" lazyload /></p><p>这张图也就说明了「コ」形路线必然确定了终点的位置。</p><p>设 <span class="math inline">\(f(i=0/1,j)\)</span> 为从起点到达 <spanclass="math inline">\((i,j)\)</span>，再向右走「コ」形最终到达 <spanclass="math inline">\((i \operatorname{xor} 1,j)\)</span>的时间。转移如下</p><ol type="1"><li>能到达 <span class="math inline">\((i,j)\)</span> 的最早时间为 <spanclass="math inline">\(a_{i,j} +1\)</span>，如果路上所有格子都能够经过，那么走到 <spanclass="math inline">\((i \operatorname{xor} 1,j)\)</span>的最早时间为还要加上 <span class="math inline">\(2 \cdot (n-j+1)-1\)</span>。</li><li><span class="math inline">\(f(i,j+1)\)</span> 差一步就走到 <spanclass="math inline">\((i \operatorname{xor} 1,j)\)</span> 了，如果此时<span class="math inline">\((i \operatorname{xor} 1,j)\)</span>可以经过，时间就要加上 <span class="math inline">\(1\)</span>。</li><li><span class="math inline">\(a_{i \operatorname{xor} 1,j} +1\)</span>，题目规定的最早时间。</li></ol><p>三种情况取最大值。</p><p>但是此时最小的 <span class="math inline">\(f(i,j)\)</span>仍然不一定是答案。就比如</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">3</span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>手算易得答案为 <span class="math inline">\(10\)</span>，但是最小的<span class="math inline">\(f(i,j)\)</span> 答案为 <spanclass="math inline">\(3\)</span>。</p><p>这是因为我们默认了从起点到 <span class="math inline">\((i,j)\)</span>的过程中畅通无阻。此时只要设当前时间为 <spanclass="math inline">\(cur\)</span>，假设后面所有点都畅通无阻就行了，时间为<span class="math inline">\(cur + 2 \cdot (n-j+1) -1\)</span>。</p><p>那么下面这组数据呢？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">4</span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">100</span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">100</span></code></pre></div><p>上面的那种解决方案失效了，可是又被 <spanclass="math inline">\(f(i,j)\)</span> 的第二种转移覆盖了。</p><p>模拟走蛇形路线，计算将每个 <span class="math inline">\(i\)</span>作为终点的时间即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[<span class="hljs-number">2</span>][N], f[<span class="hljs-number">2</span>][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) a[i][j]=<span class="hljs-built_in">read</span>();a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">-1</span>;f[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>]=f[<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j;--j) &#123;f[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a[i][j]+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*(n-j+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>,f[i][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>),a[i^<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> cur=<span class="hljs-number">0</span>, ans=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-type">int</span> i=(j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>;ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">max</span>(f[i][j],cur+<span class="hljs-number">2</span>*(n-j+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>));cur=<span class="hljs-built_in">max</span>(cur,a[i][j]+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;cur=<span class="hljs-built_in">max</span>(cur,a[i^<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><p>这不比 D 难？</p><h1 id="d.-chip-move">D. Chip Move</h1><h2 id="分析-3">分析</h2><p>问题转化一下。有一个 <span class="math inline">\(0 \rightarrown\)</span> 的数轴，从 <span class="math inline">\(0\)</span>开始跳跃任意次，第 <span class="math inline">\(i\)</span> 次跳跃的距离是<span class="math inline">\(k+i-1\)</span> 的倍数。</p><p>对于 <span class="math inline">\(x \in [1,n]\)</span>，求出跳到 <spanclass="math inline">\(x\)</span> 的方案数。</p><p>设 <span class="math inline">\(\Delta_i = k+i-1\)</span>，<spanclass="math inline">\(f(j)\)</span> 为跳到 <spanclass="math inline">\(j\)</span> 的方案数。注意到将 <spanclass="math inline">\(i\)</span> 作为阶段的话，计算 <spanclass="math inline">\(f\)</span> 的过程相当于完全背包问题。背包容量为<span class="math inline">\(j\)</span>，物品体积则为 <spanclass="math inline">\(\Delta_i\)</span>，选择 <spanclass="math inline">\(\Delta_i\)</span> 的 <spanclass="math inline">\(n\)</span> 倍就是 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(\Delta_i\)</span>。</p><p>对于每个阶段，分别累加答案即可。</p><p>注意完全背包问题是每个物品可以选择任意次，但是本题至少选择 <spanclass="math inline">\(1\)</span> 次。所以可以使用「平移」的办法，令<span class="math inline">\(i\)</span> 阶段的 <spanclass="math inline">\(f(j)\)</span> 的值等于 <spanclass="math inline">\(i-1\)</span> 阶段 <spanclass="math inline">\(f(j-\Delta_i)\)</span>的值，这样就相当于强制选择一个 <spanclass="math inline">\(\Delta_i\)</span>。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> t, n, k, f[N], ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) ans[i]=<span class="hljs-number">0</span>;f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> cur=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> dlt=k+i<span class="hljs-number">-1</span>;cur+=dlt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=dlt;--j) f[j]=f[j-dlt];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;dlt;++j) f[j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=dlt;j&lt;=n;++j) (f[j]+=f[j-dlt])%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=dlt;j&lt;=n;++j) (ans[j]+=f[j])%=mod;<span class="hljs-keyword">if</span>(cur&gt;n) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e.-swap-and-maximum-block">E. Swap and Maximum Block</h1><p>不会</p><h1 id="f.-bags-with-balls">F. Bags with Balls</h1><p>不会</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「杂题选讲」#2</title>
    <link href="/2022/tititi-solution-2/"/>
    <url>/2022/tititi-solution-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>菜死了啊。</p><p>都是些比较简单的题目，<del>可惜我做不出来</del></p><h2 id="abc261d-flipping-and-bonus">ABC261D Flipping and Bonus</h2><h3 id="分析">分析</h3><p>称正面朝上为获胜，反面朝上为失败。</p><p>一开始认为，输掉一局相当于把计数器置 <spanclass="math inline">\(0\)</span>，所以应该加入状态，设 <spanclass="math inline">\(f(i,j)\)</span> 为前 <spanclass="math inline">\(i\)</span> 局，输掉 <spanclass="math inline">\(j\)</span>局，所能得到的最大收益。这个状态最大的问题是信息缺失。你怎么知道你赢下第<span class="math inline">\(i\)</span> 局是几连胜？无法转移。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为前 <spanclass="math inline">\(i\)</span> 局，其中第 <spanclass="math inline">\(i\)</span> 局为 <spanclass="math inline">\(j\)</span> 连胜。特别地，当 <spanclass="math inline">\(j=0\)</span> 时表示输掉第 <spanclass="math inline">\(i\)</span>局。相比于上一个状态，这个状态是能够进行转移的，且没有荣誉信息，是正确的状态。</p><p>转移就比较简单了 <span class="math display">\[f(i,j) =\begin{cases}f(i-1,j-1) + x_i + b_j &amp; j &gt; 0\\\max_{k \in [0,i-1]}{\{ f(i-1,k) \}} &amp; j=0\end{cases}\]</span> 最终答案 <span class="math display">\[\max_{i \in [1,n]} {\{ f(n,i) \}}\]</span> 最后一局输掉显然不划算啊。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, m, x[N], b[N], f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) x[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> c=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();b[c]=y;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+x[i]+b[j];f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][j]);&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="abc261d-sorting-color-balls">ABC261D Sorting Color Balls</h2><h3 id="分析-1">分析</h3><p>首先明确冒泡排序的交换次数就是逆序对的个数。</p><p>注意到相同颜色的球，交换它们是不耗费代价的。</p><p>很容易想到答案即为总的逆序对个数减去同种颜色的逆序对个数。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, ans, a[N], c[N];vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">for</span>(;x&lt;=<span class="hljs-number">3e5</span>;x+=x&amp;-x) c[x]+=y; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) ans+=c[x];<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();p[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(x);p[a[i]].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> sz=p[i].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) &#123;<span class="hljs-type">int</span> dlt=<span class="hljs-built_in">query</span>(n)-<span class="hljs-built_in">query</span>(x);            <span class="hljs-comment">// 逆序对</span><span class="hljs-keyword">if</span>(!i) ans+=dlt; <span class="hljs-keyword">else</span> ans-=dlt;            <span class="hljs-comment">// i=0为原序列，否则为颜色i</span><span class="hljs-built_in">modify</span>(x,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) <span class="hljs-built_in">modify</span>(x,<span class="hljs-number">-1</span>);        <span class="hljs-comment">// 删除</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="abc262c-min-max-pair">ABC262C Min Max Pair</h2><h3 id="分析-2">分析</h3><p>注意到当 <span class="math inline">\(a_i = i\)</span> 与任何 <spanclass="math inline">\(a_j = j\)</span>，其中 <spanclass="math inline">\(i &lt; j\)</span>，配对时都满足条件。设满足 <spanclass="math inline">\(a_i = i\)</span> 的 <spanclass="math inline">\(i\)</span> 的个数为 <spanclass="math inline">\(t\)</span>，则答案一定含有 <spanclass="math inline">\(\frac{t(t+1)}{2}\)</span>。</p><p>否则若 <span class="math inline">\(a_i = j\)</span> 且 <spanclass="math inline">\(j &gt; i\)</span>，那么 <spanclass="math inline">\(a_j\)</span> 必须为 <spanclass="math inline">\(i\)</span> 才能满足条件。扫一遍即可。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> n, ans, t, a[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]==i) ++t;&#125;ans=t*(t<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;i&amp;&amp;a[a[i]]==i) ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="abc262d-i-hate-non-integer-number">ABC262D I Hate Non-integerNumber</h2><h3 id="分析-3">分析</h3><p>平均数是个整数，说明分子模分母为 <spanclass="math inline">\(0\)</span>。既然是个计数问题，考虑 DP。</p><p>这类问题的一个技巧就是，将分子模分母的结果加入状态。这样要求的问题变为了DP求出的一个子问题，在面对某些有特殊条件限制问题时有奇效，这也是为什么很多时候都要“考虑问题的简化版”。一开始我根本无法理解这种做法，后来才慢慢明白，为了DP 而去 DP，在很多时候时行不通的。</p><p>设 <span class="math inline">\(r\)</span> 为选出 <spanclass="math inline">\(r\)</span> 个数的阶段。当 <spanclass="math inline">\(r=1\)</span> 时，贡献显然为 <spanclass="math inline">\(n\)</span>。这东西加不加进状态都无所谓，反正就当个模数。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 个数，选出了 <spanclass="math inline">\(j\)</span> 个数，这 <spanclass="math inline">\(j\)</span> 个数之和模 <spanclass="math inline">\(r\)</span> 为 <spanclass="math inline">\(k\)</span> 的方案数。注意如果是模 <spanclass="math inline">\(j\)</span> 为 <spanclass="math inline">\(k\)</span> 的话，无后效性就没了。</p><p>由于存在取模，所以这类状态还是使用刷表法比较好。 <spanclass="math display">\[f(i-1,j-1,k) \rightarrow f(i,j,k+a_i \bmod r )\]</span> 答案为 <span class="math display">\[n + \sum_{r=2}^n f(n,r,0)\]</span> 注意到对于每一个阶段 <spanclass="math inline">\(r\)</span>，相当于一个 0/1 背包问题，优化掉 <spanclass="math inline">\(i\)</span> 这一维即可。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, ans, a[N], f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">2</span>;r&lt;=n;++r) &#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-built_in">min</span>(i,r);j;--j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;r;++k)(f[j][(k+a[i])%r]+=f[j<span class="hljs-number">-1</span>][k])%=mod;&#125;(ans+=f[r][<span class="hljs-number">0</span>])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="abc262e-red-and-blue-graph">ABC262E Red and Blue Graph</h2><h3 id="分析-4">分析</h3><p>提神醒脑数学题。</p><p>要求是</p><ol type="1"><li>恰好有 <span class="math inline">\(k\)</span> 个红点。</li><li>连接不同颜色点的边的数量为偶数。</li></ol><p>设这 <span class="math inline">\(k\)</span> 个红点的度数和为 <spanclass="math inline">\(Deg_k\)</span>，连接红点的边的数量为 <spanclass="math inline">\(Red\)</span>，连接不同颜色点的数量为 <spanclass="math inline">\(RedBlue\)</span>，那么由于每条连接红点的边在度数中被统计了两次，则<span class="math display">\[Deg_k = 2 Red + RedBlue\]</span> 注意到 <span class="math inline">\(Deg_k\)</span> 和 <spanclass="math inline">\(RedBlue\)</span> 同奇偶。</p><p>题目要求 <span class="math inline">\(RedBlue\)</span> 为偶数，可知<span class="math inline">\(Deg_k\)</span>是偶数。于是乎求出每个节点的度数 <spanclass="math inline">\(deg_x\)</span>，数量为 <spanclass="math inline">\(odds\)</span>。</p><p>从 <span class="math inline">\(odds\)</span> 中选出偶数 <spanclass="math inline">\(t\)</span> 个点作为红点，在其他点中任选 <spanclass="math inline">\(k-t\)</span>个点作为蓝点，组合数求方案就行了。由于红点是计数的基准，所以蓝点的选择对答案没有贡献。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, k, odd, ans, deg[N], fac[N], inv[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];&#125;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[n]=<span class="hljs-built_in">fp</span>(fac[n],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;~i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) ++odd;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i+=<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(i&lt;=odd&amp;&amp;k-i&lt;=n-odd)(ans+=<span class="hljs-built_in">C</span>(odd,i)*<span class="hljs-built_in">C</span>(n-odd,k-i)%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="nowcodert62c-莫娜与阿贝多">NowCoderT62C 莫娜与阿贝多</h2><h3 id="分析-5">分析</h3><blockquote><p>注：你的最优策略是依赖于每一步的掉落结果的。</p></blockquote><p>……</p><p>很好，和博弈论没有关系。</p><p>随机应变啊。</p><p>等等！这不就是 DP 中的最优子结构性质？</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为 <spanclass="math inline">\(i\)</span> 级物品剩下 <spanclass="math inline">\(j\)</span> 个，<spanclass="math inline">\(i+1\)</span> 级物品剩下 <spanclass="math inline">\(k\)</span> 个，能达到目标的概率。</p><p>边界是 <span class="math inline">\(f(m,i,0) = 1\)</span>，其中 <spanclass="math inline">\(i \ge n\)</span>。</p><p>当 <span class="math inline">\(j \in [0,2]\)</span> 时，无法进行合成<span class="math display">\[f(i,j,k) = f(i+1,k,a_{i+2})\]</span> 否则 <span class="math display">\[f(i,j,k) = \max\begin{cases}p \cdot f(i,j-2,k+1) + (1-p) \cdot f(i,j-3,k+1)\\q \cdot f(i,j-3,k+2) + (1-p) \cdot f(i,j-3,k+1)\end{cases}\]</span> 答案 <span class="math inline">\(f(1,a_1,a_2)\)</span>。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-type">int</span> n, m, a[N];<span class="hljs-type">double</span> p, q, f[<span class="hljs-number">10</span>][N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;p,&amp;q);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;=<span class="hljs-number">1e3</span>;++i) f[m][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;i;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">1e3</span>;++k) f[i][j][k]=f[i+<span class="hljs-number">1</span>][k][a[i+<span class="hljs-number">2</span>]];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">3</span>;j&lt;=<span class="hljs-number">1e3</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">1e3</span>;++k) &#123;<span class="hljs-type">double</span> k1=p*f[i][j<span class="hljs-number">-2</span>][k+<span class="hljs-number">1</span>]+(<span class="hljs-number">1</span>-p)*f[i][j<span class="hljs-number">-3</span>][k+<span class="hljs-number">1</span>];<span class="hljs-type">double</span> k2=q*f[i][j<span class="hljs-number">-3</span>][k+<span class="hljs-number">2</span>]+(<span class="hljs-number">1</span>-q)*f[i][j<span class="hljs-number">-3</span>][k+<span class="hljs-number">1</span>];f[i][j][k]=<span class="hljs-built_in">max</span>(k1,k2);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,f[<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>]][a[<span class="hljs-number">2</span>]]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>概率论</tag>
      
      <tag>组合数学</tag>
      
      <tag>杂题选讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NowCoderL101E 水没都市 题解</title>
    <link href="/2022/nc11247e-solution/"/>
    <url>/2022/nc11247e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p><span class="math inline">\(t\)</span> 时刻还有城镇没有被淹没，<spanclass="math inline">\(t+1\)</span> 时刻所有城镇将要被淹没。</p><p>一个思路是求出最后一个城镇被淹没的时刻 <spanclass="math inline">\(D\)</span>，然后通过魔法调整使得所有城镇至少会在<span class="math inline">\(D\)</span> 时刻被淹没。显然 <spanclass="math inline">\(D\)</span> 就是 <spanclass="math inline">\(1\)</span>到每一个点所有的路径中的最大边权取最小值，猜都能猜到是最小生成树中的最大边权，证明略。</p><p>求出 <span class="math inline">\(D\)</span> 后，我们的目标是使得<span class="math inline">\(1 \rightarrow n\)</span>所有路径中最大边权最小为 <spanclass="math inline">\(D\)</span>，否则如果比 <spanclass="math inline">\(D\)</span> 小则不满足条件，比 <spanclass="math inline">\(D\)</span> 大则显然不优。</p><p>对于一条权值为 <span class="math inline">\(w\)</span> 的边，代价为<span class="math inline">\(D - w\)</span>，其中 <spanclass="math inline">\(w &lt; D\)</span>。考虑把 <spanclass="math inline">\((x,y,D-w)\)</span>加入图中，那么问题就变成了选择权值和最小的边，使得 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(n\)</span> 不连通。原因是如果 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(n\)</span> 不连通，那么 <spanclass="math inline">\(1 \rightarrow n\)</span> 的所有路径中不存在 <spanclass="math inline">\(w &lt; D\)</span> 的边，这就达到了目的。</p><p>以 <span class="math inline">\(1\)</span> 为源点，<spanclass="math inline">\(n\)</span> 为汇点，求出图中的最小割即可。</p><p>注意这是一张无向图，加边的时候有一些细节。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">30005</span>, M=<span class="hljs-number">2e4</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-type">int</span> n, m, D, fa[N], d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> u, v, w; &#125; e[M];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(edge a,edge b) &#123; <span class="hljs-keyword">return</span> a.w&lt;b.w; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) fa[i]=i;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">get</span>(e[i].u), y=<span class="hljs-built_in">get</span>(e[i].v);<span class="hljs-keyword">if</span>(x!=y) &#123;fa[x]=y;D=<span class="hljs-built_in">max</span>(D,e[i].w);<span class="hljs-keyword">if</span>(++cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));d[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==n||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-type">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) ans+=<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,inf);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;e[i].u=<span class="hljs-built_in">read</span>(), e[i].v=<span class="hljs-built_in">read</span>(), e[i].w=<span class="hljs-built_in">read</span>();&#125; <span class="hljs-built_in">kruskal</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> u=e[i].u, v=e[i].v;<span class="hljs-keyword">if</span>(D&gt;e[i].w) <span class="hljs-built_in">addedge</span>(u,v,D-e[i].w);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dinic</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
      <tag>生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#811 (Div 3)</title>
    <link href="/2022/cf1714-solution/"/>
    <url>/2022/cf1714-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1714</strong>.</p><p>最近摸得有点厉害，主要是被自己菜到了，心态有点差……</p><p>老年人也就看看 Div 3 了。</p><h2 id="a.-everyone-loves-to-sleep">A. Everyone Loves to Sleep</h2><p>转化成分钟乱搞即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> t, n, H, M, D, ans, h[<span class="hljs-number">15</span>], m[<span class="hljs-number">15</span>], d[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), H=<span class="hljs-built_in">read</span>(), M=<span class="hljs-built_in">read</span>();D=H*<span class="hljs-number">60</span>+M;ans=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;h[i]=<span class="hljs-built_in">read</span>(), m[i]=<span class="hljs-built_in">read</span>();d[i]=h[i]*<span class="hljs-number">60</span>+m[i];<span class="hljs-keyword">if</span>(d[i]&lt;D) d[i]+=<span class="hljs-number">24</span>*<span class="hljs-number">60</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,d[i]-D);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,ans/<span class="hljs-number">60</span>,ans%<span class="hljs-number">60</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-remove-prefix">B. Remove Prefix</h2><p>从后往前寻找第一个重复数字出现的位置即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, ans, a[N];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>(), ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) &#123;++p[a[i]];<span class="hljs-keyword">if</span>(p[a[i]]&gt;<span class="hljs-number">1</span>) &#123; ans=i; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-minimum-varied-number">C. Minimum Varied Number</h2><p>注意到 <span class="math inline">\(t \in[1,45]\)</span>，说明答案最大就是 <spanclass="math inline">\(123456789\)</span>，那么要求数字最小只要贪心从后往前依次放置即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> t, n, ans[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">9</span>;i;--i) <span class="hljs-keyword">if</span>(n&gt;i) &#123;n-=i; ans[i]=i;&#125; <span class="hljs-keyword">else</span> &#123; ans[i]=n; <span class="hljs-keyword">break</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;++i) <span class="hljs-keyword">if</span>(ans[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans[i]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-color-with-occurrences">D. Color with Occurrences</h2><p>注意到颜色是可以覆盖的，所以也可以理解为“无后效性吧”。</p><p>那么设 <span class="math inline">\(f(i)\)</span> 为将 <spanclass="math inline">\([1,i]\)</span>染色用的最小次数，那么对于一个字符串 <spanclass="math inline">\(j\)</span> <span class="math display">\[f(i) = \min_{k \in [i-l_j,i-1]}{ \{ f_k + 1} \}\]</span> 其中 <span class="math inline">\(l_j\)</span> 是 <spanclass="math inline">\(j\)</span> 的长度，且必须满足 <spanclass="math inline">\(i \ge l_j\)</span> 且 <spanclass="math inline">\(t[i-l_j+1,i] = a_j\)</span>。</p><p>为啥不把 <span class="math inline">\(j\)</span>加入状态呢？复杂度是不会变化的，是冗余信息。</p><p>考虑输出方案。一开始我竟然用了一个 SB二维数组乱搞，结果还真的过了样例和第一个点，但是会 WA#2。仔细一想，输出方案实际上是把 DP的过程重现一遍，那么输出方案时需要的信息应当与状态相同，但是由于不仅要输出决策点，还要输出所用的字符串编号，所以要用两个数组。<del>我一开始就是把这两个合一了</del>。</p><p>设 <span class="math inline">\(g_1(i)\)</span> 表示决策点，<spanclass="math inline">\(g_2(i)\)</span> 表示将 <spanclass="math inline">\(i\)</span> 染色用的字符串编号。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">15</span>;<span class="hljs-type">int</span> t, n, m, f[N], l[M], g1[N], g2[N];string s, a[M];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;    <span class="hljs-comment">// i表示染色的位置</span><span class="hljs-keyword">if</span>(!i) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">print</span>(g1[i]);    <span class="hljs-comment">// i的决策点，也就是上一个染色的位置</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,g2[i],i-l[g2[i]]+<span class="hljs-number">1</span>);    <span class="hljs-comment">// 用的字符串编号的染色的位置</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<span class="hljs-built_in">memset</span>(l,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(l));<span class="hljs-built_in">memset</span>(g1,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(g1));<span class="hljs-built_in">memset</span>(g2,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(g2));cin&gt;&gt;s; n=<span class="hljs-built_in">read</span>();m=s.<span class="hljs-built_in">length</span>(), s=<span class="hljs-string">&quot; &quot;</span>+s;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i], l[i]=a[i].<span class="hljs-built_in">length</span>();f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(i&gt;=l[j]) &#123;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">substr</span>(i-l[j]+<span class="hljs-number">1</span>,l[j])==a[j]) &#123;<span class="hljs-type">int</span> p=m+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i-l[j];k&lt;i;++k) <span class="hljs-keyword">if</span>(f[p]&gt;f[k]) p=k;<span class="hljs-keyword">if</span>(f[i]&gt;f[p]+<span class="hljs-number">1</span>) f[i]=f[p]+<span class="hljs-number">1</span>, g1[i]=p, g2[i]=j;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[m]&lt;=m? f[m]:<span class="hljs-number">-1</span>);    <span class="hljs-comment">// 不难发现只要能够全部染色，次数绝不会超过m</span><span class="hljs-keyword">if</span>(f[m]&lt;=m) <span class="hljs-built_in">print</span>(m);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-add-modulo-10">E. Add Modulo 10</h2><p>注意到如果某个数模 <span class="math inline">\(10\)</span> 为 <spanclass="math inline">\(0\)</span>，那么它就不会变化，如果模 <spanclass="math inline">\(10\)</span> 为 <spanclass="math inline">\(5\)</span>，那么它只会改变一次。</p><p>它们可以归为一类——因为它们的终态都能计算出来，姑且称之为 <spanclass="math inline">\(\alpha\)</span> 类，其他称之为 <spanclass="math inline">\(\beta\)</span> 类。如果既有 <spanclass="math inline">\(\alpha\)</span> 类又有 <spanclass="math inline">\(\beta\)</span> 类，那么绝对不可能全部相等。</p><p>否则如果只有 <span class="math inline">\(\alpha\)</span>类，那么直接算出来判断是否全部相等即可。</p><p>未经特殊声明，下面的数都是模 <span class="math inline">\(10\)</span>之后的结果。</p><p>考虑这样一条路径，<span class="math inline">\(1 \rightarrow 2\rightarrow 4 \rightarrow 8\)</span>。</p><p><span class="math inline">\(3 \rightarrow 6 \rightarrow2\)</span>，<span class="math inline">\(7 \rightarrow 4\)</span>，<spanclass="math inline">\(9 \rightarrow8\)</span>，这些操作都能让本不属于这条路径的数字加入路径，且最终都会达到<spanclass="math inline">\(8\)</span>，那么可以知道一定能做到让所有的数模<span class="math inline">\(10\)</span> 相同，但是一定能全部相等吗？</p><p>注意到 <span class="math inline">\(8\)</span> 和 <spanclass="math inline">\(28\)</span>，将 <spanclass="math inline">\(8\)</span> 进行变成 <spanclass="math inline">\(28\)</span> 需要 <spanclass="math inline">\(4\)</span> 次操作，但是根本无法让 <spanclass="math inline">\(28\)</span> 变成 <spanclass="math inline">\(38\)</span>。这是因为路径中 <spanclass="math inline">\(8\)</span> 变成 <spanclass="math inline">\(8\)</span> 要进位两次，所以只有个位是 <spanclass="math inline">\(8\)</span> 的两个数的差是 <spanclass="math inline">\(10\)</span> 的偶数倍才能满足条件。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N], f1, f2;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-type">int</span> d=<span class="hljs-built_in">abs</span>(a-b);<span class="hljs-keyword">return</span> (d/<span class="hljs-number">10</span>)%<span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();f1=f2=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">5</span>) f1=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> f2=<span class="hljs-number">1</span>; &#125;<span class="hljs-keyword">if</span>(f1&amp;&amp;f2) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f1) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">5</span>) a[i]+=<span class="hljs-number">5</span>;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;a[i]!=a[i<span class="hljs-number">-1</span>]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">return</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">1</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">2</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">4</span>) &#123;a[i]-=a[i]%<span class="hljs-number">10</span>, a[i]+=<span class="hljs-number">8</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">3</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">6</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">9</span>) &#123;a[i]-=a[i]%<span class="hljs-number">10</span>, a[i]+=<span class="hljs-number">18</span>;&#125;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">pd</span>(a[i],a[i<span class="hljs-number">-1</span>])) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">return</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="f.-build-a-tree-and-that-is-it">F. Build a Tree and That IsIt</h2><p>没看，不会。😢</p><h2 id="g.-path-prefixes">G. Path Prefixes</h2><p>维护树上前缀和，记为 <span class="math inline">\(sa\)</span>，<spanclass="math inline">\(sb\)</span>。</p><p>在一条路径上，找到第一个严格大于 <spanclass="math inline">\(sa_x\)</span> 的 <spanclass="math inline">\(sb_y\)</span>，那么 <spanclass="math inline">\(sa_x\)</span> 一定严格大于之前的每一个 <spanclass="math inline">\(sb\)</span>，于是 <spanclass="math inline">\(y-1\)</span> 即为答案。<spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 都是路径上节点的编号。由于 <spanclass="math inline">\(sb\)</span> 显然是单调增的，可以二分查找。</p><p>在更新更新完 <span class="math inline">\(x\)</span>的所有子节点之后还原 <span class="math inline">\(sa_x\)</span>，<spanclass="math inline">\(sb_x\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n,  sa, sb, a[N], b[N], ans[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];vector&lt;<span class="hljs-type">int</span>&gt; ssb;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;sa+=a[x], sb+=b[x];ssb.<span class="hljs-built_in">push_back</span>(sb);ans[x]=<span class="hljs-built_in">upper_bound</span>(ssb.<span class="hljs-built_in">begin</span>(),ssb.<span class="hljs-built_in">end</span>(),sa)-ssb.<span class="hljs-built_in">begin</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);&#125;sa-=a[x], sb-=b[x];ssb.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=sa=sb=<span class="hljs-number">0</span>;ssb.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> p=<span class="hljs-built_in">read</span>();a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(p,i), <span class="hljs-built_in">add</span>(i,p);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NowCoderT62B 置换 题解</title>
    <link href="/2022/nc11202b-solution/"/>
    <url>/2022/nc11202b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="关于置换">关于置换</h2><p>根据《数学奥林匹克小丛书·组合数学》上关于置换的定义：</p><p>给定集合 <span class="math inline">\(X = \{1,2,3,\ldots ,n\}\)</span>，置换 <span class="math inline">\(\varphi\)</span> 是从<span class="math inline">\(X\)</span> 到 <spanclass="math inline">\(X\)</span> 上的一一映射，通常记为 <spanclass="math display">\[\varphi =\begin{Bmatrix}1 &amp; 2 &amp;  \ldots &amp; n\\\varphi(1) &amp; \varphi(2) &amp; \ldots &amp; \varphi(n)\end{Bmatrix}\]</span></p><p>由于是一一映射，所以这实际上是 <spanclass="math inline">\([1,n]\)</span> 的一个排列，满足 <spanclass="math inline">\(\varphi(i) = i\)</span> 的 <spanclass="math inline">\(i\)</span> 成为 <spanclass="math inline">\(\varphi\)</span> 的一个不动点。</p><p>直接感受就是，加了一堆概念得到的还只是一个排列，这么吃力不讨好的事情有啥用？但是看到这题题面之后就应该明白，「置换」本质上是一一映射，所以你可以用置换<span class="math inline">\(\varphi\)</span> 再把 <spanclass="math inline">\(\varphi\)</span> 映射一遍……</p><p>而对于「不动点」，无论如何用 <spanclass="math inline">\(\varphi\)</span>去映射，都不会改变这些元素的值。（知道这个说不定能骗点分）。</p><p>关于置换的一些性质、题目和解题方法，刘汝佳的《入门经典训练指南》上还有所涉及。</p><h2 id="分析">分析</h2><p>题意很简单，<del>然而我一开始完全没有思路</del>。注意到如果 <spanclass="math inline">\(A\)</span> 中存在不动点，那么只要检查是否与 <spanclass="math inline">\(B\)</span> 的对应位置相同即可。</p><p>手算不难发现对于一个 <span class="math inline">\(i\)</span>，从 <spanclass="math inline">\(a_i\)</span> 不断映射直到 <spanclass="math inline">\(a_i&#39; =i\)</span>，经过的数字构成了一个环，含义是无论怎么置换都会如此循环。把环中数组当作下标，把<span class="math inline">\(A\)</span> 中对应的以元素列出来，记为 <spanclass="math inline">\(p\)</span>。能够发现正好相差一位（因为 <spanclass="math inline">\(A\)</span> 把 <spanclass="math inline">\([1,n]\)</span> 映射了一次了）。如果其中不包含<span class="math inline">\(b_i\)</span>，那么必然无解。同时也把 <spanclass="math inline">\(B\)</span> 中对应的元素列出来，记为 <spanclass="math inline">\(q\)</span>。判断从 <spanclass="math inline">\(p_{x} = b_i\)</span> 的 <spanclass="math inline">\(x\)</span> 开始检查 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(q\)</span> 是否完全相同，否则无解。</p><p>假设从 <span class="math inline">\(i\)</span> 开始置换 <spanclass="math inline">\(r_i\)</span> 次才能让 <spanclass="math inline">\(a_i\)</span> 变成 <spanclass="math inline">\(b_i\)</span>，其环长为 <spanclass="math inline">\(m_i\)</span>。由于循环节的存在，最终的 <spanclass="math inline">\(k\)</span> 必定满足 <span class="math display">\[\begin{cases}k &amp;\equiv r_1 \pmod {m_1}\\k &amp;\equiv r_2 \pmod {m_2}\\&amp; \vdots\\k &amp; \equiv r_n \pmod {m_n}\end{cases}\]</span> 此时的 <span class="math inline">\(n\)</span> 为环的个数。</p><p>用扩展中国剩余定理判断是否有解即可。</p><p>注意爆 <code>long long</code>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, R, M, a[N], b[N];<span class="hljs-type">bool</span> v[N];vector&lt;<span class="hljs-type">int</span>&gt; r, m, c;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; x,<span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);y-=a/b*x;<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exCRT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// n为环的个数</span>R=r[<span class="hljs-number">0</span>], M=m[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> d=r[i]-R, g, mod, x, y;g=<span class="hljs-built_in">exgcd</span>(M,m[i],x,y);<span class="hljs-keyword">if</span>(d%g) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;mod=m[i]/g;x=((x*d/g)%mod+mod)%mod;R=x*M+R;M=M/g*m[i];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();r.<span class="hljs-built_in">clear</span>(), m.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) a[i]=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) b[i]=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]==i&amp;&amp;b[i]!=i) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(v[i]) <span class="hljs-keyword">continue</span>;v[i]=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> cur=a[i];c.<span class="hljs-built_in">clear</span>();c.<span class="hljs-built_in">pb</span>(i);        <span class="hljs-comment">// 起点</span><span class="hljs-keyword">while</span>(cur!=i) &#123;c.<span class="hljs-built_in">pb</span>(cur);v[cur]=<span class="hljs-number">1</span>;cur=a[cur];&#125;vector&lt;<span class="hljs-type">int</span>&gt; p, q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:c) p.<span class="hljs-built_in">pb</span>(a[x]), q.<span class="hljs-built_in">pb</span>(b[x]);<span class="hljs-type">bool</span> fg=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> sz=p.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;sz;++j) &#123;<span class="hljs-keyword">if</span>(p[j]==q[<span class="hljs-number">0</span>]) &#123;                <span class="hljs-comment">// q[0]=b[i]，置换j次才成为b[i]</span>fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j,pos=<span class="hljs-number">0</span>;k&lt;j+sz;++k,++pos) &#123;<span class="hljs-keyword">if</span>(p[k%sz]!=q[pos]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;r.<span class="hljs-built_in">pb</span>(j), m.<span class="hljs-built_in">pb</span>(sz);                <span class="hljs-comment">// sz是环长</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exCRT</span>(r.<span class="hljs-built_in">size</span>())) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数学</tag>
      
      <tag>扩展中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1493D GCD of an Array 题解</title>
    <link href="/2022/cf1493d-solution/"/>
    <url>/2022/cf1493d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>本题的关键是 <span class="math inline">\(\gcd_{i=1}^n\{a_i\}\)</span> 就是所有出现过的质因数，是所对应的最小次幂之积。</p><p>原序列可以看作依次插入。将 <span class="math inline">\(a_x\)</span>修改为 <span class="math inline">\(y\)</span>，本质上是除去所有在 <spanclass="math inline">\(a_x\)</span> 分解中的质因数的幂次，然后再将 <spanclass="math inline">\(y\)</span> 插入并更新。</p><p>所以用<code>std::map</code>来维护某个 <spanclass="math inline">\(a_i\)</span>中所有质因数的幂次，用<code>std::set</code>来维护某个质因数的所有幂次（目的是快速插入，快速查找最小值）。</p><p>记录 <span class="math inline">\(rec_i\)</span> 表示序列中含有质因数<span class="math inline">\(i\)</span> 的数字的个数，一旦存在 <spanclass="math inline">\(rec_i=n\)</span>，那么答案要累乘 <spanclass="math inline">\(i\)</span> 的最小次幂。</p><p>具体看代码。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, cnt, ans=<span class="hljs-number">1</span>, p[N], pr[N], rec[N];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp[N];multiset&lt;<span class="hljs-type">int</span>&gt; st[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!p[i]) p[i]=i, pr[++cnt]=i;        <span class="hljs-comment">// p[i]表示i的最小质因子</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=<span class="hljs-number">2e5</span>;++j) &#123;p[i*pr[j]]=pr[j];<span class="hljs-keyword">if</span>(i%pr[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x%=mod;<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getinv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">fp</span>(x,mod<span class="hljs-number">-2</span>); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; t;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, d=p[y];<span class="hljs-keyword">while</span>(y%d==<span class="hljs-number">0</span>) y/=d, ++a;t.<span class="hljs-built_in">push_back</span>(&#123;d,a&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tt:t) &#123;<span class="hljs-type">int</span> _p=tt.fr, _a=tt.sc;<span class="hljs-keyword">if</span>(mp[x][_p]==<span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果a[x]中没有出现过p这个因子</span>++rec[_p], st[_p].<span class="hljs-built_in">insert</span>(_a), mp[x][_p]=_a;            <span class="hljs-comment">// 维护</span><span class="hljs-keyword">if</span>(rec[_p]==n) &#123;(ans*=<span class="hljs-built_in">fp</span>(_p,*st[_p].<span class="hljs-built_in">begin</span>()))%=mod;                <span class="hljs-comment">// 这个因子是所有数的公因子，取最小幂次</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(rec[_p]==n) &#123;<span class="hljs-type">int</span> inv=<span class="hljs-built_in">getinv</span>(<span class="hljs-built_in">fp</span>(_p,*st[_p].<span class="hljs-built_in">begin</span>()));(ans*=inv)%=mod;                <span class="hljs-comment">// p已经出现过了，如果p是所有数公因子，就要先让gcd除以p的最小次幂</span>&#125;st[_p].<span class="hljs-built_in">erase</span>(st[_p].<span class="hljs-built_in">find</span>(mp[x][_p]));mp[x][_p]+=_a;st[_p].<span class="hljs-built_in">insert</span>(mp[x][_p]);            <span class="hljs-comment">// 删除原信息，维护新信息</span><span class="hljs-keyword">if</span>(rec[_p]==n) &#123;(ans*=<span class="hljs-built_in">fp</span>(_p,*st[_p].<span class="hljs-built_in">begin</span>()))%=mod;                <span class="hljs-comment">// 如果p是公因子，就要更新答案</span>&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">ora</span>();n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve</span>(i,x);&#125;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1389E Calendar Ambiguity 题解</title>
    <link href="/2022/cf1389e-solution/"/>
    <url>/2022/cf1389e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>即求 <span class="math display">\[(x-1)d + y \equiv (y-1)d + x \pmod w\]</span> 满足 <span class="math inline">\(x &lt; y\)</span> 的解 <spanclass="math inline">\((x,y)\)</span> 的个数。</p><p>化简 <span class="math display">\[xd + y \equiv yd + x \pmod w\]</span></p><p><span class="math display">\[yd - xd - x -y \equiv 0 \pmod w\]</span></p><p><span class="math display">\[(y-x)(d-1) \equiv 0 \pmod w\]</span></p><p>设 <span class="math inline">\(w&#39; =\frac{w}{\gcd(w,d-1)}\)</span>，那么有 <span class="math display">\[y-x \equiv 0  \pmod {w&#39;}\]</span> 考虑 <span class="math inline">\(y-x = k w&#39;\)</span>。当<span class="math inline">\(k\)</span> 为定值时，由于 <spanclass="math inline">\(y-x \in [1,\min(d,m)]\)</span>，所以数量为 <spanclass="math inline">\(\min(d,m) - kw&#39;\)</span>。</p><p>答案即为 <span class="math display">\[\sum_{k=1}^{\lfloor \frac{\min(d,m)}{w&#39;} \rfloor} \min(d,m) -kw&#39;\]</span> 发现这是个等差数列，直接求和即可。</p><p>首项 <span class="math inline">\(\min(d,m) - kw&#39;\)</span>，末项<span class="math inline">\(\min(d,m) - \lfloor \frac{\min(d,m)}{w&#39;}\rfloor w&#39;\)</span>，公差 <span class="math inline">\(\lfloor\frac{\min(d,m)}{w&#39;} \rfloor\)</span>。</p><p>答案 <span class="math display">\[\frac{\big(2 \min(d,m) - \lfloor \frac{\min(d,m)}{w&#39;} \rfloor w&#39;- w&#39;\big) \cdot \lfloor \frac{\min(d,m)}{w&#39;} \rfloor }{2}\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, m, d, w;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;m=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>(), w=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;w/=(<span class="hljs-built_in">gcd</span>(d<span class="hljs-number">-1</span>,w));<span class="hljs-type">int</span> mn=<span class="hljs-built_in">min</span>(m,d), cnt=mn/w;ans=(<span class="hljs-number">2</span>*(mn-w)-w*(cnt<span class="hljs-number">-1</span>))*cnt/<span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF893E Counting Arrays 题解</title>
    <link href="/2022/cf893e-solution/"/>
    <url>/2022/cf893e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>为了方便起见，用 <span class="math inline">\(n\)</span> 代替 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(m\)</span>代替 <span class="math inline">\(y\)</span>。</p><p>不难发现无论 <span class="math inline">\([1,m-1]\)</span>这些数字的符号是什么样的，只要恰当安排最后一位就一定能使结果是正数。由于每一位正负都可以选，所以这部分的方案数为<span class="math inline">\(2^{m-1}\)</span>。</p><p>考虑到值域不大，可以单独考虑每个质因子。</p><p>对于一个质因子 <span class="math inline">\(p_i\)</span>，它的次数为<span class="math inline">\(a_i\)</span>。问题转化为在 <spanclass="math inline">\([1,m]\)</span> 这 <spanclass="math inline">\(m\)</span>个位置中，每个位置分配一个数，分配的数之和等于 <spanclass="math inline">\(a_i\)</span>，求方案数。形式化地，求不定方程 <spanclass="math display">\[\sum_{i=1}^m x_i = a_i\]</span> 的非负整数解的个数，显然是 <spanclass="math inline">\(\binom{m+a_i-1}{a_i-1}\)</span>。累乘即可。</p><p>线性筛预处理质数，分解质因数时只枚举质数的复杂度是 <spanclass="math inline">\(O(\log_2n)\)</span> 的，并且常数较小。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> t, n, m, cnt, ans, fac[N], inv[N], p2[N], p[N], v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> n&lt;=m? <span class="hljs-number">1</span>:fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2e6</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=<span class="hljs-number">2e6</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, p2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, p2[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2e6</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod, p2[i]=p2[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;inv[N<span class="hljs-number">-5</span>]=<span class="hljs-built_in">fp</span>(fac[N<span class="hljs-number">-5</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-number">2e6</span>)<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-built_in">ora</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();ans=p2[m<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;p[i]*p[i]&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(n%p[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!(n%p[i])) ++a, n/=p[i];(ans*=<span class="hljs-built_in">C</span>(m+a<span class="hljs-number">-1</span>,m<span class="hljs-number">-1</span>))%=mod;&#125;<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) (ans*=m)%=mod; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>计数</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF615D Multipliers 题解</title>
    <link href="/2022/cf615d-solution/"/>
    <url>/2022/cf615d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先将 <span class="math inline">\(n\)</span> 分解为 <spanclass="math inline">\(n= \prod_{i=1}^m p_i^{a_i}\)</span>。那么 <spanclass="math inline">\(n\)</span> 的约数个数为 <spanclass="math inline">\(d(n) = \prod_{i=1}^m (a_i +1)\)</span>。</p><p>考虑每个质因子的贡献。</p><p>首先对于 <spanclass="math inline">\(p_i\)</span>，它的整数次幂作为独立的一个约数时，一定有<span class="math inline">\(p_i^1 p_i^2 \ldots p_i ^{a_i} =p_i^{\frac{a_i(a_i+1)}{2}}\)</span>。</p><p>其次，<span class="math inline">\(p_i\)</span>还可以和其他约数组合，方案数为 <spanclass="math inline">\(\frac{d(n)}{a_i +1}\)</span>。</p><p>那么 <span class="math inline">\(p_i\)</span> 能够产生的贡献为 <spanclass="math inline">\((p_i^{\frac{a_i(a_i+1)}{2}})^{\frac{d(n)}{a_i+1}}= p_i^{\frac{a_i d(n)}{2}}\)</span>，其含义为 <spanclass="math inline">\(p_i\)</span>作为一个独立的约数时，也可以和其他约数相乘成为新的约数，且在其中 <spanclass="math inline">\(p_i\)</span> 的贡献是相同的。</p><p>指数可能很大，咋办？欧拉降幂公式，由于 <spanclass="math inline">\(p_i\)</span> 和模数 <spanclass="math inline">\(10^9 +7\)</span>都是质数，这里只写出底数与模数互质的形式 <span class="math display">\[a^b \equiv a^{b \, \bmod \, \varphi(p)} \pmod p\]</span> 在本题里面，<span class="math inline">\(\varphi(10^9 +7) =10^9 +6\)</span>。</p><p>当 <span class="math inline">\(d(n)\)</span> 为奇数时，说明所有 <spanclass="math inline">\(a_i\)</span> 都是偶数，那么可以直接将所有 <spanclass="math inline">\(a_i\)</span> 除以 <spanclass="math inline">\(2\)</span>。</p><p>否则重新计算 <spanclass="math inline">\(\frac{d(n)}{2}\)</span>，方法是找到一个奇数指数<span class="math inline">\(a_i\)</span>，然后乘上 <spanclass="math inline">\(\frac{a_i+1}{2}\)</span> ，剩下的正常算即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _p first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _a second</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, d=<span class="hljs-number">1</span>, ans=<span class="hljs-number">1</span>, a[N], p[N], v[N];vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; vec;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ++v[<span class="hljs-built_in">read</span>()];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200000</span>;++i) d=d*(v[i]+<span class="hljs-number">1</span>)%(mod<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200000</span>;++i) <span class="hljs-keyword">if</span>(v[i]) vec.<span class="hljs-built_in">push_back</span>(&#123;i,v[i]&#125;);<span class="hljs-type">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) &#123;<span class="hljs-keyword">if</span>(x._a&amp;<span class="hljs-number">1</span>) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(fg) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x:vec) x._a/=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) (ans*=<span class="hljs-built_in">fp</span>(x._p,d*x._a%(mod<span class="hljs-number">-1</span>)))%=mod; &#125; <span class="hljs-keyword">else</span> &#123;d=<span class="hljs-number">1</span>;<span class="hljs-type">bool</span> t=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) &#123;<span class="hljs-keyword">if</span>(x._a&amp;<span class="hljs-number">1</span>&amp;&amp;t) t=<span class="hljs-number">0</span>, d=d*(x._a+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>%(mod<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> d=d*(x._a+<span class="hljs-number">1</span>)%(mod<span class="hljs-number">-1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) (ans*=<span class="hljs-built_in">fp</span>(x._p,d*x._a%(mod<span class="hljs-number">-1</span>)))%=mod; &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数论学习笔记」#1 扩展中国剩余定理</title>
    <link href="/2022/notes-number-theory-1/"/>
    <url>/2022/notes-number-theory-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="中国剩余定理crt">中国剩余定理（CRT）</h2><p>由于扩展中国剩余定理和中国剩余定理没啥关系，所以我们先来复习一下中国剩余定理。</p><p>同余方程组 <span class="math display">\[\begin{cases}x \equiv a_1 \pmod {m_1}\\x \equiv a_2 \pmod {m_2}\\\quad \vdots\\x \equiv a_n \pmod {m_n}\end{cases}\]</span> 当 <span class="math inline">\(m_1,m_2,\cdots ,m_n\)</span>两两互质时，对于任意正整数 <spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>，此方程组有解，如下。</p><p>设 <span class="math inline">\(M = \prod_{i=1}^n m_i\)</span>，<spanclass="math inline">\(M_i = \frac{M_i}{m_i}\)</span>。</p><p>设 <span class="math inline">\(t_i = M_i^{-1}\)</span>，在 <spanclass="math inline">\(\bmod m_i\)</span> 的意义下。</p><p>那么方程组的通解为 <span class="math inline">\(x = kM + \sum_{i=1}^na_i t_i M_i\)</span>，其中 <span class="math inline">\(k \in\mathbb{Z}\)</span>。</p><p>最小正整数解只要令 <spanclass="math inline">\(k=0\)</span>，后面那一块对 <spanclass="math inline">\(M\)</span> 取模即可。</p><p>代码</p><div class="code-wrapper"><pre><code class="hljs cpp">MM=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) MM*=m[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;    M[i]=MM/m[i];    <span class="hljs-type">int</span> x, y;    <span class="hljs-built_in">exgcd</span>(M[i],m[i],x,y);    t[i]=x;    ans=(ans+a[i]*M[i]*t[i]%MM)%MM&#125;ans=(ans%MM+MM)%MM;</code></pre></div><p>证明略。</p><h2 id="扩展中国剩余定理excrt">扩展中国剩余定理（exCRT）</h2><p>当 <span class="math inline">\(m_1,m_2,\cdots m_n\)</span>不满足两两互质时，就要用到扩展中国剩余定理了。</p><p>考虑 <span class="math display">\[\begin{cases}x \equiv a_1 \pmod {m_1}\\x \equiv a_2 \pmod {m_2}\end{cases}\]</span> 转化一下 <span class="math display">\[\begin{cases}x = k_1 m_1 + a_1\\x = k_2 m_2 + a_2\end{cases}\]</span></p><p><span class="math display">\[k_1 m_1 - k_2 m_2 = a_1 - a_2\]</span></p><p>注意到此方程有解，当且仅当 <span class="math inline">\(\gcd(m_1,m_2)\mid a_1-a_2\)</span>。</p><p>设 <span class="math inline">\(g=\gcd(m_1,m_2)\)</span>，<spanclass="math inline">\(p_1 = \frac{m_1}{g}\)</span>，<spanclass="math inline">\(p_2 = \frac{m_2}{g}\)</span>，代入得 <spanclass="math display">\[k_1 p_1 - k_2 p_2 = \frac{a_1-a_2}{g}\]</span> 由于 <spanclass="math inline">\(\gcd(p_1,p_2)=1\)</span>，此方程有解当且仅当 <spanclass="math inline">\(1 \mid \frac{a_1 - a_2}{g}\)</span>。那么一定有<span class="math inline">\(g \mid a_1 - a_2\)</span>，否则无解。</p><p>那么先求出一组特解 <span class="math display">\[p_1 x_1  + p_2 x_2  = 1\]</span> 得到 <span class="math display">\[\begin{cases}k_1 = \frac{a_2-a_1}{g} x_1\\k_2 = \frac{a_2-a_1}{g} x_2\end{cases}\]</span> 代入原式 <span class="math display">\[x = k_1 m_1 + a_1 = \frac{a_2 - a_1}{g}x_1 m_1 + a_1\]</span> 至此，得到一个解。</p><p>不妨称同余号右边的数为“同余数”。</p><p>考虑数论里一个结论，若 <span class="math inline">\(a \equiv b \pmod{m_i}\)</span>，其中 <span class="math inline">\(i \in[1,n]\)</span>，则 <span class="math display">\[a \equiv b \pmod {\operatorname{lcm}\{m_1,m_2,\cdots ,m_n\}}\]</span>因此，求出两个方程的解时，只要模数取原来两个模数的最小公倍数，就能将原来两个方程合并成一个方程。</p><p>且慢，不是还要求同余数相等吗？令他为 <span class="math inline">\(xm_1+ a_1\)</span> 即可，<del>虽然我也不知道为什么</del>。</p><p>设当前同余数为 <span class="math inline">\(R\)</span>，<spanclass="math inline">\(M\)</span> 为 <spanclass="math inline">\(m_1,m_2,\cdots,m_{i-1}\)</span>的最小公倍数，则对于一个新的方程组 <span class="math display">\[\begin{cases}x \equiv R  \pmod M\\x \equiv a_i \pmod {m_i}\end{cases}\]</span> 再次求解即可。</p><p>代码</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exCRT</span><span class="hljs-params">()</span> </span>&#123;M=m[<span class="hljs-number">1</span>], R=r[<span class="hljs-number">1</span>];    <span class="hljs-comment">// m[]是模数，r[]是同余数</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> d=r[i]-R, g, mod, x, y;g=<span class="hljs-built_in">exgcd</span>(M,m[i],x,y);        <span class="hljs-comment">// 这里求解的是 Mx+m[i]y=gcd(M,m[i])</span>        <span class="hljs-comment">// 根据等式的性质，易得等价于上文中的 p1x1+p2x2=1</span><span class="hljs-keyword">if</span>(d%g) &#123; ans=<span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>; &#125;        <span class="hljs-comment">// 无解</span>mod=m[i]/g;        <span class="hljs-comment">// 取模是因为要求最小正整数解，mod为什么这样算详见exgcd</span>x=((x*d/g)%mod+mod)%mod;        <span class="hljs-comment">// 解</span>R=x*M+R;        <span class="hljs-comment">// 更新R</span>M=(M*m[i])/g;        <span class="hljs-comment">// M取lcm</span>&#125;ans=R;    <span class="hljs-comment">// 答案</span>&#125;</code></pre></div><p> </p><p>参考：</p><ul><li><a href="https://oi-wiki.org/math/number-theory/crt/">OI Wiki中国剩余定理</a></li><li><a href="https://luckyglass.github.io/2019/OldVer5/">学习笔记 -扩展中国剩余定理</a></li><li><ahref="https://xixike.github.io/%E3%80%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">『学习笔记』中国剩余定理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>中国剩余定理</tag>
      
      <tag>扩展中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1265E Beautiful Mirrors 题解</title>
    <link href="/2022/cf1265e-solution/"/>
    <url>/2022/cf1265e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="solution-1">Solution 1</h2><p>设 <span class="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(1\)</span> 问到第 <spanclass="math inline">\(i\)</span> 个镜子，且通过了第 <spanclass="math inline">\(i\)</span> 个镜子的期望天数。</p><p><span class="math inline">\(f_0 = 0\)</span></p><p>设 <span class="math inline">\(P_i = \frac{p_i}{100}\)</span> <spanclass="math display">\[f_i = f_{i-1} + P_i  \cdot 1 + (1-P_i) \cdot (1 + f_i )\]</span></p><p><span class="math display">\[f_i = \frac{f_{i-1}+ 1}{P_i}\]</span></p><p><span class="math display">\[f_i = \frac{f_{i-1}+1}{\frac{p_i}{100}} =  \frac{(f_{i-1}+1) \cdot100}{p_i}\]</span></p><p>预处理 <span class="math inline">\(p_i\)</span> 的逆元即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, P=<span class="hljs-number">100</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> t, n, m, p[N], inv[N], f[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">read</span>();inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)%mod*P%mod*inv[p[i]]%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div><h2 id="solution-2">Solution 2</h2><p>根据期望的线性性，设 <span class="math inline">\(f_i\)</span> 表示<span class="math inline">\((i-1 \rightarrow i)\)</span>的期望步数。</p><p>设 <span class="math inline">\(S_i = \sum_{j=1}^{i-1} f_j\)</span><span class="math display">\[f_i =  P_i \cdot 1 + (1-P_i) \cdot ( 1 + \sum_{j=1}^{i-1} f_j +f_i)\]</span></p><p><span class="math display">\[f_i =  P_i + (1-P_i) \cdot (1 + S_i + f_i)\]</span></p><p><span class="math display">\[f_i = \frac{(1-P_i) \cdot S_i + 1}{P_i}\]</span></p><p><span class="math display">\[f_i = \frac{(1-\frac{p_i}{100}) \cdot S_i + 1}{\frac{p_i}{100}} =\frac{(100-p_i) \cdot S_i + 100}{p_i}\]</span></p><p>简单维护 <span class="math inline">\(S\)</span>，最后答案为 <spanclass="math inline">\(\sum_{i=1}^n f_i\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, P=<span class="hljs-number">100</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> t, n, m, p[N], inv[N], f[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">read</span>();inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(<span class="hljs-number">100</span>+(<span class="hljs-number">100</span>-p[i])*s)*inv[p[i]]%mod;(s+=f[i])%=mod;&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「杂题选讲」#1</title>
    <link href="/2022/tititi-solution-1/"/>
    <url>/2022/tititi-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>杂题选讲。</p><h2 id="cf1548a-web-of-lies">CF1548A Web of Lies</h2><h3 id="分析">分析</h3><p>发现编号为 <span class="math inline">\(i\)</span>的节点只会对编号大于 <span class="math inline">\(i\)</span>的节点造成影响。</p><p>设 <span class="math inline">\(cnt_x\)</span> 为与 <spanclass="math inline">\(x\)</span> 相连且编号大于 <spanclass="math inline">\(x\)</span> 的点的数量。如果 <spanclass="math inline">\(x\)</span> 是所在连通块编号最小的节点，那么只要<span class="math inline">\(cnt_x\neq 0\)</span>，<spanclass="math inline">\(x\)</span> 就一定被删除。发现最终剩下的一定是满足<span class="math inline">\(cnt_x = 0\)</span> 的点。维护即可。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<span class="hljs-type">int</span> n, m, cnt[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-type">int</span> ans=n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-type">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);        <span class="hljs-keyword">if</span>(++cnt[x]==<span class="hljs-number">1</span>) --ans;    &#125;    <span class="hljs-type">int</span> q; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--) &#123;        <span class="hljs-type">int</span> op, x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%&quot;</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);            <span class="hljs-keyword">if</span>(++cnt[x]==<span class="hljs-number">1</span>) --ans;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);            <span class="hljs-keyword">if</span>(--cnt[x]==<span class="hljs-number">0</span>) ++ans;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    &#125;&#125;</code></pre></div><h2 id="luogu3545-hur-warehouse-store">luogu3545 HUR-WarehouseStore</h2><h3 id="分析-1">分析</h3><p>一个错误的贪心就是，只要能卖出就尽可能卖出。反例是 <spanclass="math inline">\(b_1 = a_1 = 10^9\)</span>，<spanclass="math inline">\(a_{2 \sim n} = 0\)</span> 且 <spanclass="math inline">\(b_{2 \sim n} = 1\)</span>，其中 <spanclass="math inline">\(n &gt;2\)</span>。第一天把所有的货物都卖了，可是收益最大为 <spanclass="math inline">\(1\)</span>，显然不对。</p><p>尝试修正这个贪心。设第 <span class="math inline">\(i\)</span>天上午货物量为 <span class="math inline">\(t\)</span>，如果 <spanclass="math inline">\(t &lt; b_i\)</span> 且 <spanclass="math inline">\(b_i\)</span> 小于已经之前的最大需求量 <spanclass="math inline">\(b_j\)</span>，由于卖给谁收益都是 <spanclass="math inline">\(1\)</span> 且卖给 <spanclass="math inline">\(j\)</span> 的一定多于卖给 <spanclass="math inline">\(i\)</span> 的，所以直接令 <spanclass="math inline">\(t + (b_j - b_i)\)</span>。这样做一定不劣。</p><p>否则就遵循能买则买的原则。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">250005</span>;<span class="hljs-type">int</span> n, a[N], b[N];<span class="hljs-type">bool</span> v[N];priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t+=a[i];<span class="hljs-keyword">if</span>(t&lt;b[i]&amp;&amp;q.<span class="hljs-built_in">size</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>().first&gt;b[i]) &#123;<span class="hljs-type">int</span> d=q.<span class="hljs-built_in">top</span>().first, id=q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();v[id]=<span class="hljs-number">0</span>, t+=d, --ans;            <span class="hljs-comment">// 反悔贪心</span>&#125; <span class="hljs-keyword">if</span>(t&gt;=b[i]) &#123;            <span class="hljs-comment">// 如果反悔了，那么一定有t&gt;=b[i]</span>            <span class="hljs-comment">// 否则就直接贪心</span> t-=b[i], v[i]=<span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(b[i],i)), ++ans; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(v[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h2 id="luogu2034-选择数字">luogu2034 选择数字</h2><h3 id="分析-2">分析</h3><p>正难则反。<del>虽然正着也能做</del>。</p><p>先认为每个数字都被选择，不能有连续超过 <spanclass="math inline">\(k\)</span> 个数字被选择说明在一个长度为 <spanclass="math inline">\(k+1\)</span> 的窗口中，至少有 <spanclass="math inline">\(2\)</span> 个不被选择的数字。</p><p>选出的数字总和最大，说明不被选出的数字总和最小。</p><p>设 <span class="math inline">\(f_i\)</span> 表示在 <spanclass="math inline">\([1,i]\)</span> 中且满足条件的前提下，不选择 <spanclass="math inline">\(i\)</span> 的最小和。 <spanclass="math display">\[f_i = \min_{j \in [i-k-1,i)} {\{ f_j + a_i \}}\]</span> 单调队列优化即可。答案为 <span class="math inline">\(\max_{i\in [n-k,n]}{\{ S - f_i \}}\)</span>，其中 <spanclass="math inline">\(S=\sum_{i=1}^n a_i\)</span>。这是因为如果 <spanclass="math inline">\([n-k,n]\)</span> 这个长度为 <spanclass="math inline">\(k+1\)</span>区间内，所有数字都没选择，那么显然是不满足条件的。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100005</span>;<span class="hljs-type">int</span> n, k, sum, a[N], f[N], q[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum+=a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;i-k<span class="hljs-number">-1</span>&gt;q[l]) ++l;f[i]=f[q[l]]+a[i];<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[i]&lt;=f[q[r]]) --r;q[++r]=i;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-k;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,sum-f[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="cf1415e-new-game-plus">CF1415E New Game Plus!</h2><h3 id="分析-3">分析</h3><p><span class="math inline">\(k\)</span> 次机会把计数器变为 <spanclass="math inline">\(0\)</span>，相当于 <spanclass="math inline">\(k+1\)</span> 个初始为 <spanclass="math inline">\(0\)</span> 的局面。</p><p>贪心地将 <span class="math inline">\(\{ a\}\)</span> 递减排序。对于<span class="math inline">\(i\)</span>，找到价值最大的局面 <spanclass="math inline">\(x\)</span>，让 <spanclass="math inline">\(ans+x\)</span>，<spanclass="math inline">\(x+a_i\)</span>。最终 <spanclass="math inline">\(ans\)</span> 即为答案。</p><p>正确性？</p><p>假设所有 <span class="math inline">\(a_i\)</span> 都是正数，那么<span class="math inline">\(k+1\)</span>个局面都不会减小，那么只要不断累加一个局面即可，这样做是对的。</p><p>假设存在负数 <span class="math inline">\(a_i\)</span>，使得最大局面<span class="math inline">\(x\)</span> 会减小，那么由于答案要累加 <spanclass="math inline">\(x\)</span>，所以取出不是最大局面显然不优。由于本题明显存在的一点是“局部最优解可以推得全局最优解”，所以即便<span class="math inline">\(x\)</span>减小，如果他还是最大局面，仍然不会产生错误；否则它也不会产生贡献。这种情况下也是对的。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, ans, a[N];priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x&gt;y; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;++i) q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();ans+=x, x+=a[i];q.<span class="hljs-built_in">push</span>(x);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h2 id="cf1385d-a-good-string">CF1385D a-Good String</h2><h3 id="分析-4">分析</h3><p><span class="math inline">\(n\)</span> 为 <spanclass="math inline">\(2\)</span> 的整数次幂，显然是分治啊。</p><p>这是我除了归并排序外，第一道分治题。</p><p>设 <span class="math inline">\(solve(l,r,c)\)</span> 表示将 <spanclass="math inline">\(S_{l,r}\)</span> 变成一个 <spanclass="math inline">\(c\)</span> 好串的最小操作次数。</p><p>具体方法是从 <span class="math inline">\(mid=\frac{l+r}{2}\)</span>作为临界点，考虑两种情况。一种是将 <spanclass="math inline">\(S_{l,mid}\)</span> 全部改为 <spanclass="math inline">\(c\)</span>，<spanclass="math inline">\(S_{mid+1,r}\)</span> 改为 <spanclass="math inline">\(c+1\)</span>，另一种是反过来。</p><p>这一层的答案即为 <span class="math display">\[\sum_{i=l}^{mid} [S_i \neq c] + solve(mid+1,r,c+1)\]</span> 和 <span class="math display">\[\sum_{i=mid+1}^r [S_i \neq c] + solve(l,mid,c+1)\]</span> 取较小值即可。</p><p><span class="math inline">\(T(n) = 2 T(\frac{n}{2}) +O(n)\)</span>，带入主定理得到复杂度为 <span class="math inline">\(O(n\log_2 n)\)</span>。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> t, n;<span class="hljs-type">char</span> s[<span class="hljs-number">150000</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">char</span> c)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> s[l]!=c;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-type">int</span> cl=<span class="hljs-number">0</span>, cr=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=mid;++i) cl+=s[i]!=c;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i) cr+=s[i]!=c;cl+=<span class="hljs-built_in">solve</span>(mid+<span class="hljs-number">1</span>,r,c+<span class="hljs-number">1</span>), cr+=<span class="hljs-built_in">solve</span>(l,mid,c+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cl,cr);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-string">&#x27;a&#x27;</span>));&#125;&#125;</code></pre></div><h2 id="cf1545b-aquamoon-and-chess">CF1545B AquaMoon and Chess</h2><h3 id="分析-5">分析</h3><p><span class="math inline">\(110 \rightarrow 011\)</span>。</p><p><span class="math inline">\(011 \rightarrow 110\)</span>。</p><p>设 <span class="math inline">\(c0\)</span> 为 <spanclass="math inline">\(0\)</span> 的数量，<spanclass="math inline">\(c11\)</span> 为两个连续的 <spanclass="math inline">\(1\)</span> 的数量。注意 <spanclass="math inline">\(111\)</span> 中 <spanclass="math inline">\(c11=1\)</span>。</p><p>那么答案即为 <spanclass="math inline">\(C_{c0+c11}^{c11}\)</span>。</p><p>一共 <span class="math inline">\(c_0+c11\)</span> 个位置，填进去<span class="math inline">\(c11\)</span> 个 <spanclass="math inline">\(11\)</span> 的方案数。</p><p>不难发现，空出来的单个 <span class="math inline">\(1\)</span>是没有任何影响的，因为只要 <span class="math inline">\(11\)</span>交换过来，就能用右边的 <span class="math inline">\(1\)</span>和这个单独的 <span class="math inline">\(1\)</span> 组合成新的 <spanclass="math inline">\(11\)</span>，且 <spanclass="math inline">\(11\)</span> 的总量不变。所以，<spanclass="math inline">\(11\)</span> 可以到达任何一个 <spanclass="math inline">\(0\)</span> 的位置，加上本身的 <spanclass="math inline">\(c11\)</span> 个位置，就有了这个式子。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> t, n, m, cnt, ans, fac[N], inv[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> n&lt;=m? <span class="hljs-number">1</span>:fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e5</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[N<span class="hljs-number">-5</span>]=<span class="hljs-built_in">fp</span>(fac[N<span class="hljs-number">-5</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-number">1e5</span>)<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> c0=<span class="hljs-number">0</span>, c11=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>) ++c0;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;=n&amp;&amp;s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>) ++c11, ++i;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">C</span>(c0+c11,c11));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>分治</tag>
      
      <tag>单调队列</tag>
      
      <tag>杂题选讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5894 robots 题解</title>
    <link href="/2022/lg5894-solution/"/>
    <url>/2022/lg5894-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>二分答案，设 <span class="math inline">\(check(x)\)</span> 为能否在<span class="math inline">\(x\)</span> 的时间之内完成。</p><p>一个很显然的贪心策略就是，对于每个弱机器人，从 <spanclass="math inline">\(X_i\)</span>最小的开始，在不超时的前提下，尽可能拿走重量小于 <spanclass="math inline">\(X_i\)</span>且没有被拿走的玩具，优先选择体积最大的。而小机器人则用来收拾烂摊子，从<span class="math inline">\(Y_i\)</span>最大的开始，在不超时的前提下，尽可能拿走能够拿走且没有被拿走的玩具，优先选择体积最大的。</p><p>简单堆贪心。</p><p>正确性？感性理解，弱机器人不考虑体积，那么就在不考虑体积的情况下尽可能多拿，且从<span class="math inline">\(X_i\)</span>小的开始保证了“物尽其用”。由于有时间（拿的个数）限制，所以贪心选择体积更大的为小机器人分担压力。而小机器人则不考虑重量，负责收拾烂摊子（时间不够拿不走的，重量太大拿不走的）就好了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, a[N], b[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">toy</span> &#123; <span class="hljs-type">int</span> w, s; &#125; c[M];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(toy a,toy b) &#123; <span class="hljs-keyword">return</span> a.w&lt;b.w; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;priority_queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-comment">// 优先队列存放没有被拿走的玩具的体积</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(pos&lt;=T&amp;&amp;c[pos].w&lt;a[i]) q.<span class="hljs-built_in">push</span>(c[pos++].s);        <span class="hljs-comment">// 把能够拿走的玩具入堆</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x&amp;&amp;q.<span class="hljs-built_in">size</span>();++j) q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">// x的时间最多拿走x个玩具，贪心选择体积最大的</span>&#125;<span class="hljs-keyword">while</span>(pos&lt;=T) q.<span class="hljs-built_in">push</span>(c[pos++].s);    <span class="hljs-comment">// 这部分就是任何弱机器人都拿不走的</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i;--i) &#123;<span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x&amp;&amp;q.<span class="hljs-built_in">size</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>()&lt;b[i];++j) q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">// 在x的时间内，优先选择最大的能够拿走的玩具</span>&#125;<span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 优先队列为空，说明能够完成</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=T;++i) c[i].w=<span class="hljs-built_in">read</span>(), c[i].s=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+m+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+T+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=T;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">check</span>(l)? l:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>夏令营的一些图论题 题解</title>
    <link href="/2022/graph-solution-2/"/>
    <url>/2022/graph-solution-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>这篇文章收录了一些夏令营期间写的不是那么复杂的图论题目。</p><h2 id="cf715b-complete-the-graph">CF715B Complete The Graph</h2><h3 id="分析">分析</h3><p>注意到如果改权值为 <span class="math inline">\(0\)</span>的边，那么把它改成 <span class="math inline">\(1\)</span>一定收益最大。</p><p>于是乎用 Dijkstra 算法求出以 <span class="math inline">\(s\)</span>为起点，不含 <span class="math inline">\(0\)</span> 边情况的最短路。</p><p>如果此时 <span class="math inline">\(dis(t) &lt;L\)</span>，那么由于改边不会让这时候的最短路更大，所以一定无解。</p><p>如果 <span class="math inline">\(dis(t) =L\)</span>，那么最优解就是让改动后的边不会改变 <spanclass="math inline">\(dis(t)\)</span> 的值，将他们改为 <spanclass="math inline">\(10^{18}\)</span> 即可。</p><p>如果 <span class="math inline">\(dis(t) &gt;L\)</span>，那么就依次把一条 <span class="math inline">\(0\)</span>边改为 <span class="math inline">\(1\)</span>且加入图中，再跑最短路。如果此时 <span class="math inline">\(dis(t) \leL\)</span>，那么就让某一条边的权值加上 <spanclass="math inline">\(L-dis(t)\)</span>，此时 <spanclass="math inline">\((s \rightarrow t)\)</span> 的最短路长度为 <spanclass="math inline">\(L\)</span>。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10005</span>, inf=<span class="hljs-number">1e18</span>;<span class="hljs-type">int</span> n, m, L, s, t, cnt, fg, d[N], a[N], b[N], c[N];<span class="hljs-type">int</span> tot, h[N], to[<span class="hljs-number">200010</span>], nxt[<span class="hljs-number">200010</span>], w[<span class="hljs-number">200010</span>];<span class="hljs-type">bool</span> v[N];vector&lt;<span class="hljs-type">int</span>&gt; e; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) d[i]=inf, v[i]=<span class="hljs-number">0</span>;d[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().sc; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;); &#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sdasdsad</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;    <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span>(i&lt;fg) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],<span class="hljs-number">1ll</span>);<span class="hljs-keyword">if</span>(i==fg) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],L-d[t]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(i&gt;fg) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],inf);&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],c[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), L=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) &#123; e.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-built_in">add</span>(a[i],b[i],c[i]), <span class="hljs-built_in">add</span>(b[i],a[i],c[i]);&#125;<span class="hljs-built_in">dijkstra</span>(s);<span class="hljs-keyword">if</span>(d[t]&lt;L) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">if</span>(d[t]==L) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],inf);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],c[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(d[t]&gt;L) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;e.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-built_in">add</span>(a[e[i]],b[e[i]],<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(b[e[i]],a[e[i]],<span class="hljs-number">1</span>);<span class="hljs-built_in">dijkstra</span>(s);<span class="hljs-keyword">if</span>(d[t]&gt;L) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(d[t]&lt;=L) &#123;fg=e[i];<span class="hljs-built_in">sdasdsad</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);&#125;</code></pre></div><h2 id="cf1076d-edge-deletion">CF1076D Edge Deletion</h2><h3 id="分析-1">分析</h3><p>最短路树。</p><p>起点到所有点以及对应的最短路径构成一棵树，称为最短路树。其他的边全部删去也不会影响到达任何点的最短路。那我们可以贪心选择最短路树之外的边，如果全都删完了，那么只能从最短路树里删。</p><p>由于不包含 <span class="math inline">\(1\)</span>号节点，所以答案即为 <span class="math inline">\(\min{\{ k,n-1\}}\)</span>。</p><p>至于输出方案，遍历最短树，优先输出前 <spanclass="math inline">\(\min{\{ k,n-1 \}}\)</span>个就好了。由于建立双向边，所以对于边 <spanclass="math inline">\(i\)</span> 的边，其真实编号为 <spanclass="math inline">\(\lfloor \frac{i}{2} \rfloor\)</span>。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e18</span>;<span class="hljs-type">int</span> n, m, k, cnt, d[N], ans[N], pre[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> x, y, to; &#125;;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));d[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().sc; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, pre[y]=i, q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;); &#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(pre[y]==i) &#123;++cnt;<span class="hljs-keyword">if</span>(cnt&gt;k||cnt==n) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">min</span>(k,n<span class="hljs-number">-1</span>));<span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>); <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div><h2 id="cf1343e-weights-distributing">CF1343E Weights Distributing</h2><h3 id="分析-2">分析</h3><p>自然是将边权排序。</p><p>分别以 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>为起点进行 BFS 求出到每个节点的距离，设他们为 <spanclass="math inline">\(da(i)\)</span>，<spanclass="math inline">\(db(i)\)</span>，<spanclass="math inline">\(dc(i)\)</span>。枚举一个点 <spanclass="math inline">\(i\)</span>，前 <spanclass="math inline">\(da(i)+db(i)+dc(i)\)</span> 小的边权加上前 <spanclass="math inline">\(db(i)\)</span>小的边权即为这部分的答案，取最小值即可。</p><p>下面证明可以取到所有情况。</p><p>如果 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>在同一条简单路径上，那么最优解一定是取 <spanclass="math inline">\(i=b\)</span>，此时 <spanclass="math inline">\(db(i)=0\)</span>，将最小的边权放到这条路径上即可。</p><p>如果不在同一条简单路径上，由于树上两点之间有且仅有一条简单路径，而路径是<span class="math inline">\((a \rightarrow b)\)</span> 和 <spanclass="math inline">\((b \rightarrow c)\)</span>，所以取 <spanclass="math inline">\(i=lca(a,c)\)</span>，此时保留了 <spanclass="math inline">\((a \rightarrow c)\)</span> 的简单路径且 <spanclass="math inline">\(db(lca(a,b))\)</span> 被计算了 <spanclass="math inline">\(2\)</span>次，贪心地让这一块取最小的几个权值即可。</p><p>这题最好自己画图。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e18</span>;<span class="hljs-type">int</span> n, m, a, b, c, d[N], da[N], db[N], dc[N], w[N], sum[N];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) da[i]=<span class="hljs-number">-1</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;da[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(s); <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(da[y]==<span class="hljs-number">-1</span>) da[y]=da[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) db[i]=<span class="hljs-number">-1</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;db[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(s); <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(db[y]==<span class="hljs-number">-1</span>) db[y]=db[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) dc[i]=<span class="hljs-number">-1</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;dc[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(s); <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(dc[y]==<span class="hljs-number">-1</span>) dc[y]=dc[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-number">0</span>;tot=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ans=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">bfs1</span>(a), <span class="hljs-built_in">bfs2</span>(b), <span class="hljs-built_in">bfs3</span>(c);<span class="hljs-built_in">sort</span>(w+<span class="hljs-number">1</span>,w+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+w[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(da[i]+db[i]+dc[i]&gt;m) <span class="hljs-keyword">continue</span>;ans=<span class="hljs-built_in">min</span>(ans,sum[da[i]+db[i]+dc[i]]+sum[db[i]]);&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="cf832d-misha-grisha-and-underground">CF832D Misha, Grisha andUnderground</h2><h3 id="分析-3">分析</h3><p>不会证明，纯属找规律。</p><p>假设 <span class="math inline">\(a,b\)</span> 是起点，<spanclass="math inline">\(c\)</span> 是终点，答案为 <spanclass="math display">\[\frac{dis(a,b)+dis(a,c)-dis(a,b)}{2} +1\]</span> 枚举三种情况取最大值即可。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, q, fa[N], sz[N], dep[N], son[N];<span class="hljs-type">int</span> num, top[N];<span class="hljs-type">int</span> tot, h[N], w[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa[x]) <span class="hljs-keyword">continue</span>;fa[y]=x, dep[y]=dep[x]+<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs1</span>(y);sz[x]+=sz[y];<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">return</span> dep[x]+dep[y]<span class="hljs-number">-2</span>*dep[z];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-type">int</span> ans1=(<span class="hljs-built_in">dis</span>(x,z)+<span class="hljs-built_in">dis</span>(y,z)-<span class="hljs-built_in">dis</span>(x,y))/<span class="hljs-number">2</span>;<span class="hljs-type">int</span> ans2=(<span class="hljs-built_in">dis</span>(x,y)+<span class="hljs-built_in">dis</span>(y,z)-<span class="hljs-built_in">dis</span>(x,z))/<span class="hljs-number">2</span>;<span class="hljs-type">int</span> ans3=(<span class="hljs-built_in">dis</span>(x,y)+<span class="hljs-built_in">dis</span>(x,z)-<span class="hljs-built_in">dis</span>(y,z))/<span class="hljs-number">2</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans1,<span class="hljs-built_in">max</span>(ans2,ans3))+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,i), <span class="hljs-built_in">add</span>(i,x);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>(x,y,z));&#125;&#125;</code></pre></div><h2 id="d.-toss-a-coin-to-your-graph...">D. Toss a Coin to YourGraph...</h2><h3 id="分析-4">分析</h3><p>最大值最小，二分答案。设 <spanclass="math inline">\(check(x)\)</span> 表示只经过权值小于等于 <spanclass="math inline">\(x\)</span> 的节点，能不能满足条件。</p><p>具体实现时可以只将满足 <span class="math inline">\((x \rightarrowy)\)</span>，其中 <span class="math inline">\(a_x,a_y \le x\)</span>的边加入图中。</p><p>如果此时有环，那么在这个环上走就行了，显然是能够经过 <spanclass="math inline">\(k\)</span> 个节点的。</p><p>如果没有环，那么此时图是一个 DAG。设 <spanclass="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(i\)</span> 出发，最多能经过的节点个数。起初 <spanclass="math inline">\(f_i =1\)</span>，然后拓扑排序。 <spanclass="math display">\[f_y= \max_{(x \rightarrow y)}\{ f_x +1\}\]</span> 转移即可。如果存在 <span class="math inline">\(f_i \gek\)</span>，那么就能满足条件。</p><p>可以直接利用拓扑排序判断是否存在环。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>; <span class="hljs-type">int</span> n, m, k, a[N], b[N], f[N], deg[N];<span class="hljs-type">int</span> tot, h[N], to[N], nxt[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> u, v; &#125; e[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>(); &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=v[i]=deg[i]=<span class="hljs-number">0</span>, f[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> u=e[i].u, v=e[i].v;<span class="hljs-keyword">if</span>(a[u]&lt;=x&amp;&amp;a[v]&lt;=x) &#123;<span class="hljs-built_in">add</span>(u,v), ++deg[v];&#125;&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!deg[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();ans=<span class="hljs-built_in">max</span>(ans,f[x]);++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--deg[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">if</span>(cnt!=n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">// 存在环</span><span class="hljs-keyword">if</span>(ans&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;e[i].u=<span class="hljs-built_in">read</span>(), e[i].v=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=n;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(b[mid])) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">check</span>(b[l])? b[l]:<span class="hljs-number">-1</span>);&#125;</code></pre></div><h2 id="cf1131d-gourmet-choice">CF1131D Gourmet choice</h2><h3 id="分析-5">分析</h3><p>差分约束板子题……</p><p>如果 <span class="math inline">\(a_i = b_j\)</span>，合并 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j+n\)</span>。如果 <span class="math inline">\(a_i&lt; b_j\)</span>，连边 <span class="math inline">\((i \rightarrowj+n,1)\)</span>。否则反过来。</p><p>由于要最小化每个数，所以边权均为 <spanclass="math inline">\(1\)</span>。而这样建出来的图如果不是DAG，那么一定无解。</p><p>所以设 <span class="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 最小是多少。初始值和转移同上题。</p><p>用并查集实现合并操作，具体有些细节看代码。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-type">int</span> n, m, fa[N], deg[N], f[N], op[N][N];<span class="hljs-type">int</span> tot, h[N], to[N*N], nxt[N*N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) <span class="hljs-keyword">if</span>(!deg[i]) f[i]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-comment">// 把所有没有入度的节点入队即可，不会影响答案</span>    <span class="hljs-comment">// 只把合并后的节点入队一次，是一件吃力不讨好的事</span>    <span class="hljs-comment">// 主要是因为节点数不再是n+m了，不好判断是否存在环</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--deg[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">if</span>(cnt!=n+m) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,f[<span class="hljs-built_in">get</span>(i)],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,f[<span class="hljs-built_in">get</span>(i+n)],<span class="hljs-string">&quot; \n&quot;</span>[i==m]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) fa[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-type">char</span> c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;c);<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-built_in">merge</span>(i,j+n);<span class="hljs-keyword">else</span> op[i][j]=c==<span class="hljs-string">&#x27;&lt;&#x27;</span>? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>;        <span class="hljs-comment">// 一定要先合并</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">get</span>(i), y=<span class="hljs-built_in">get</span>(j+n);<span class="hljs-keyword">if</span>(op[i][j]&amp;&amp;x==y) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;        <span class="hljs-comment">// 已经合并的节点之间又出现了大小关系，矛盾</span><span class="hljs-keyword">if</span>(op[i][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(x,y), ++deg[y];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[i][j]==<span class="hljs-number">2</span>) <span class="hljs-built_in">add</span>(y,x), ++deg[x];&#125;<span class="hljs-built_in">toposort</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>最近公共祖先</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4678 全排列 题解</title>
    <link href="/2022/lg4678-solution/"/>
    <url>/2022/lg4678-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>显然统计贡献。</p><p>题面有个描述不清楚的地方，“相似”的不一定是一个完整的“排列”，否则这题就没法做了。不过这个笔误也启发我们思考这个东西的本质，注意到<span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 相似，当且仅当对于任意 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(A_i\)</span> 在 <spanclass="math inline">\(A\)</span> 中的相对大小与 <spanclass="math inline">\(B_i\)</span> 在 <spanclass="math inline">\(B\)</span> 中的相对大小相同。 说人话就是，<spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 离散化后是相同的。</p><p>那么最终答案一定是通过 <span class="math inline">\([1,d]\)</span>所有包含不超过 <span class="math inline">\(E\)</span>个逆序对的排列的数量来进行计算的，其中 <span class="math inline">\(d \in[1,n]\)</span>。</p><p>这是一个经典问题。设 <span class="math inline">\(f(i,j)\)</span>为包含 <span class="math inline">\(j\)</span> 个逆序对的 <spanclass="math inline">\([1,i]\)</span>的排列的个数。一个显然<del>但我不会证明</del>的结论就是把 <spanclass="math inline">\(i\)</span> 插入 <spanclass="math inline">\([1,i-1]\)</span>的任意排列中，能够增加的逆序对数量取遍 <spanclass="math inline">\([0,i-1]\)</span>，所以转移很显然 <spanclass="math display">\[f(i,j) = \sum_{k= \max(0,j-i+1)}^j f(i-1,k)\]</span> 前缀和优化即可。设 <span class="math inline">\(g(i,j)\)</span>为包含不超过<span class="math inline">\(j\)</span> 个逆序对的 <spanclass="math inline">\([1,i]\)</span> 的排列的个数，可以表示为 <spanclass="math display">\[g(i,j) = \sum_{k=0}^j f(i,k)\]</span> 得到 <span class="math display">\[f(i,j) = g(i-1,j) - \Delta\]</span> 其中当 <span class="math inline">\(j \ge i\)</span> 时，<spanclass="math inline">\(\Delta = g(i-1,j-i)\)</span>，否则 <spanclass="math inline">\(\Delta = 0\)</span>。实现的时候直接把 <spanclass="math inline">\(f\)</span> 当作 <spanclass="math inline">\(g\)</span>，求两遍即可。</p><p>对于每一个询问，不难想到等价于规定区间长度为 <spanclass="math inline">\(i\)</span>，询问离散化后为逆序对个数不超过 <spanclass="math inline">\(E\)</span> 的 <spanclass="math inline">\([1,i]\)</span> 的排列的产生方案，其中 <spanclass="math inline">\(i \in [1,n]\)</span>。</p><p>设 <span class="math inline">\(m_i = \min{( E,\frac{i \cdot (i-1)}{2})}\)</span>。</p><p>首先确定 <span class="math inline">\([1,i]\)</span> 方案数为 <spanclass="math inline">\(n-i+1\)</span>，因为要离散化，只要相对大小相同就行。比如<span class="math inline">\([2,3,4]\)</span> 和 <spanclass="math inline">\([1,2,3]\)</span>。这些方案每一种都有 <spanclass="math inline">\(g(i,m_i)\)</span> 确定满足条件的排列。</p><p>接着考虑从 <span class="math inline">\([1,n]\)</span>中构造这样的排列的方案数。在 <span class="math inline">\([1,n]\)</span>中选出 <span class="math inline">\(i\)</span> 个数，它们离散化后一定是<span class="math inline">\([1,i]\)</span>的一个排列，并且每一种选择方法对应着唯一排列方案，方案数 <spanclass="math inline">\(C^i_n\)</span>。由于乘上了 <spanclass="math inline">\(n-i+1\)</span>，所以相当于这 <spanclass="math inline">\(i\)</span> 个数的位置被固定了，所以剩下的 <spanclass="math inline">\(n-i\)</span> 个数字在 <spanclass="math inline">\(n-i\)</span> 个位置中自由排列，方案数 <spanclass="math inline">\((n-i)!\)</span>。要确定两个排列，所以要乘两边。</p><p>综上所述，对于一组 <span class="math inline">\((n,E)\)</span>，答案为<span class="math display">\[\sum_{i=1}^n f(i,m_i) \cdot (n-i+1) \cdot (C_n^i) ^2 \cdot\big((n-i)!\big)^2\]</span> 这个还是感性理解一下比较好（）。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> t, n, E, f[N][N*N/<span class="hljs-number">2</span>], fac[N], c[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">500</span>;++i) f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">500</span>;++i) &#123;<span class="hljs-type">int</span> k=i*(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+(j&gt;=i? mod-f[i<span class="hljs-number">-1</span>][j-i]:<span class="hljs-number">0</span>))%mod;k=i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) f[i][j]=(f[i][j]+f[i][j<span class="hljs-number">-1</span>])%mod;&#125;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">500</span>;++i) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">500</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x%mod; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), E=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">min</span>(E,i*(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);(ans+=f[i][k]*(n-i+<span class="hljs-number">1</span>)%mod*<span class="hljs-built_in">squ</span>(c[n][i])%mod*<span class="hljs-built_in">squ</span>(fac[n-i])%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDSC2022 游记</title>
    <link href="/2022/SDSC2022/"/>
    <url>/2022/SDSC2022/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="day-0">Day 0</h2><p>坐车去日照。</p><p>和来自烟台的 ZYC 交换了名额，来到了高级算法班。</p><p>晚上不让出去，等着派送晚餐。和来自烟台的选手们分到一个宿舍，不得不感慨自己实在是太弱了，orz。</p><p>看了一些课件，贪心啥的。</p><p>天气并不好就是了。</p><p><img src="https://s2.loli.net/2022/07/25/PdCQRTxwqJN4Zhs.jpg" srcset="/img/loading.gif" lazyload /></p><h2 id="day-1">Day 1</h2><p>上午去高级算法班上课，讲师是 hywn。分块数据结构、数论分块、莫队啥都不会，全程掉线qwq。课后与朋友交流发现这个夏令营貌似不是让我们去学新东西，而是去强化的。下午还要模拟赛，果断转去提高班了。</p><p>中午找不到回宿舍的路，frj 和 qjc 认为营员手册上的地图错了。</p><figure><img src="https://s2.loli.net/2022/07/25/TfLS9URYmnI4jDO.jpg" srcset="/img/loading.gif" lazyloadalt="手机摄像头上沾到了一点油" /><figcaption aria-hidden="true">手机摄像头上沾到了一点油</figcaption></figure><figure><img src="https://s2.loli.net/2022/07/25/yzj35OFnkKU4v8N.jpg" srcset="/img/loading.gif" lazyloadalt="小路上" /><figcaption aria-hidden="true">小路上</figcaption></figure><figure><img src="https://s2.loli.net/2022/07/25/nKvSLBiwyo6Vqrh.jpg" srcset="/img/loading.gif" lazyloadalt="qjc在撸猫" /><figcaption aria-hidden="true">qjc在撸猫</figcaption></figure><p>到达宿舍之后，我才发现自己把包忘在餐厅里了，于是飞速和 qjc回去拿。</p><figure><img src="https://s1.ax1x.com/2022/07/25/jvMkLt.jpg" srcset="/img/loading.gif" lazyload alt="再次回宿舍" /><figcaption aria-hidden="true">再次回宿舍</figcaption></figure><p>下午提高班，讲师是chz。一年后还是在这个班，这个进步速度可以垫底了吧。</p><p>90% 的内容都是栈和队列，开始是一些常规题目，觉得还可以接受，但是从 <ahref="https://luogu.com.cn/problems/P3200">luogu3200 有趣的数列</a>开始就觉得不太对劲。虽然这道是卡特兰数板子，但是明显不太好推理啊。然后<a href="https://luogu.com.cn/problems/P5698">luogu5698 算法复杂度</a>和 <a href="https://luogu.com.cn/problems/P7234">luogu7324表达式求值</a> 这两题给我整懵了，掉线。</p><p>然后讲了几道栈匹配的问题，不太懂。</p><p>接下来的内容更是重量级，「维护右链辅助建树的栈」，等等什么是右链啊！笛卡尔树和虚树？什么叫NOIP 很可能考笛卡尔树？CSP-S1 算吗？再次掉线。</p><p>维护决策单调性的栈和队列，还行，但例题 1 是 <ahref="https://luogu.com.cn/problems/P1912">luogu1912 诗人小G</a>……chz认为太难于是不讲了。后面两道题也不是就不放链接了，总之就是很难。</p><p>然后讲了左偏树的例题，但是我连左偏树都不会啊。还有可并堆以及 <ahref="https://luogu.com.cn/problems/P7476">luogu7476 苦涩</a>，<ahref="https://luogu.com.cn/problems/P7078">luogu7078 贪吃蛇</a>，二维 ST表以及<code>STL rope</code>。 Day 1 自闭了……貌似高算那边模拟赛也不是全考上午的内容？有点小后悔，不过我写到这里的时候就不后悔了。晚上去胶州一中的宿舍颓废，玩了会邦邦。见到了 frj等人，结识了一些新朋友。</p><h2 id="day-2">Day 2</h2><p>上午上机。好家伙 A 题到 L 题。</p><p>A 题貌似是 UVa 的，直接跳。B 题 <ahref="https://www.luogu.com.cn/problem/P1993">小 K 的农场</a>，C 题 <ahref="https://www.luogu.com.cn/problem/P3275">糖果</a>，D 题 <ahref="https://www.luogu.com.cn/problem/P4180">次小生成树</a>，E 题……<ahref="https://www.luogu.com.cn/problem/P5109">归程</a>？这就是提高班吗？后面都是CF 的英文题。</p><p>随便写了写，CF 的图论题还真不好调。</p><p><a href="https://www.luogu.com.cn/problem/P3275">糖果</a>在前几天增加了 Hack 数据，卡掉了 SPFA。orz</p><p>由于各种不可抗力，我们暂时还不被允许进入超商，于是就过着三点一线的生活。</p><p>下午又是 hywn讲图论，我并不怎么喜欢她讲课，在高算班也是，总感觉她啥都没讲出来，我这种原本就没学过这些的根本听不懂。不过这次讲的东西比较简单，并查集生成树LCA等，但是中途讲 魔法树的时候不免提了好几嘴树剖，我现在还不会树剖啊啊啊。/(ㄒoㄒ)/~~</p><p>竟然又讲了虚树……</p><p>后面是一些图论算法，但是莫名其妙地开始普及 bitset？</p><p>最后是差分约束系统，这个我还是比较熟悉的，我觉得她讲的不如去年的smy。</p><p>吐槽归吐槽，hywn能当两次女队也是有实力的。只不过不那么善于讲解罢了。</p><p>晚上是 hywn 的讲座，没去。由于机房停电，也没去机房。</p><p>到 ssfz 的宿舍颓废。</p><h2 id="day-3">Day 3</h2><p>上午模拟赛，三道原题。</p><p>T1 最小生成树板子。</p><p>T2问一张无向图，画最少多少笔能经过所有的边一遍。一开始误认为一笔可以重复经过边，等价于连通块个数。后来一想不对，口胡了个关于欧拉路径的做法。</p><p>T3 <a href="https://www.luogu.com.cn/problem/P7113">排水系统</a>原题，不会分数运算爆零。</p><p>T4 <a href="https://www.luogu.com.cn/problem/P2024">食物链</a>原题，扩展域并查集调了一个多小时宣告失败，爆零。</p><p>最总得分 200pts。</p><p>呜哇哭了。</p><figure><img src="https://s1.ax1x.com/2022/07/25/jvMqfg.jpg" srcset="/img/loading.gif" lazyloadalt="qjc再次撸猫" /><figcaption aria-hidden="true">qjc再次撸猫</figcaption></figure><p>下午是 sxw 讲图论，前 1h都在讲并查集，我也发现了自己的一些问题，体验还不错。</p><p>插入了 Kruskal 重构树，不太会……</p><p><img src="https://s2.loli.net/2022/07/25/Eem57nwSMbY1yKl.jpg" srcset="/img/loading.gif" lazyload /></p><p>然后简单讲解了二分图以及判定，欧拉路，Tarjan 算法。</p><p>就结束了。</p><p>晚上去了会机房，写了一道小题后发现自己写不动了，于是乎回宿舍。在 ssfz的宿舍里讨论音乐和虚拟歌姬。</p><p>没有注意晚上的讲座。</p><h2 id="day-4">Day 4</h2><p>宿舍里的卷王这几天熬夜打 CF 和Atcoder，正好我的床位就在他旁边，因此睡眠质量不是多好。每次到宿舍后都很疲惫，因此我没有打比赛。事实上全宿舍只有卷王看OI，而卷王开学上七年级……</p><p>上机。除了一道 小凯的疑惑 之外，全部都是 CF的数论题，写起来自然是十分痛苦。</p><p>下面是三道“NOIP T1/T2 难度”的题目。</p><p><a href="https://www.luogu.com.cn/problem/CF893E">CF615DMultipliers</a></p><p><a href="https://www.luogu.com.cn/problem/CF893E">CF893E CountingArrays</a></p><p><a href="https://www.luogu.com.cn/problem/CF1493D">CF1493D GCD of anArray</a></p><p>下午则是 zhq 的数论课。发现自己有很多知识点特别是同余的一些性质和Trick都没有掌握，最后浅谈一下积性函数与狄利克雷卷积，还可以，但是没完全搞懂。</p><p>饭后和 ssfz 的诸位去了超商，我选择了 1L 装的冰红茶以及若干饼干。</p><figure><img src="https://s1.ax1x.com/2022/07/25/jvMZo8.jpg" srcset="/img/loading.gif" lazyload alt="ssfz" /><figcaption aria-hidden="true">ssfz</figcaption></figure><p>没去机房，而是在 ssfz 的宿舍里写 <ahref="https://www.luogu.com.cn/problem/CF1389E">课上讲过的一道数论题</a>。今晚是唐爷爷讲金牌之路，那报告厅必然爆满，因此开通了腾讯会议转播。</p><p>宿舍里竟然有两个人同时放着转播……</p><p>为啥我老是在 ssfz 的宿舍？因为我去找qjc，顺便和其他人聊得熟络了。而我市今年只有我一个人来夏令营，实在是没有归属感、、、awa</p><p>那道题目并不难想，但是最后化简一个式子不太容易，我看题解才明白，还是太菜了。</p><h2 id="day-5">Day 5</h2><p>上午没有事，自己瞎写了两道很像的期望DP，以及一道完全没有思路的题目，<del>抄题解</del>。</p><p>中午去买了 1L 装的冰红茶！</p><p>下雨了，由于山外就在半山腰上且地形崎岖，导致积水比较多，因此我的鞋湿了qwq。下午干脆加入“拖鞋教”，直接穿拖鞋去上课。竟然有奇效。</p><p>下午是来自 SUSTech 的 smy 讲 DP。他比去年胖了一圈的同时还留起了和 lxl一样的秀发，导致我竟然没认出他来。</p><p><img src="https://s2.loli.net/2022/07/25/uoskzHiTrRpgf6y.jpg" srcset="/img/loading.gif" lazyload /></p><p>smy 讲课还是很不错的，DP的阶段、状态、决策、无后效性、转移成环、最优子结构性和子问题重叠性、复杂度计算、简单优化技巧都听得很舒服。好评。</p><p>smy很喜欢拿“简化版”的题目当作例题，他的说法是“既然是简化版的，你在心里就自动把它降级就好了。如果原题是紫的，那么简化之后可能是蓝的，绿的”。比如把<a href="https://luogu.com.cn/problems/P4042">luogu4042 骑士游戏</a>物理攻击杀死每个怪物后只会分裂出一类怪物，<ahref="https://www.luogu.com.cn/problem/CF626F">CF626F Group Projects</a>改为求最大价值而不是计数。</p><p>其中有一道例题，是洛谷月赛的题目。“啊这，洛谷月赛的题目风格和这道题不太一样吧”，回宿舍一看果然，他讲的是 50pts 做法，正解感觉完全不可做啊。</p><p>这天高算班 zhq 出的模拟赛难度极其变态，rk1 和 rk2 只有某一题的90pts，但这道题是原题，rk2 是贺的……</p><p>然而我们的 frj 成功凭借实力拿下rk3，85pts！其中某题由于题面少打了一个 0，导致 frj 少了 20pts，痛失rk1。orz，%%%。</p><h2 id="day-6">Day 6</h2><p>上午 smy 出的比赛。</p><p>T1。给你一个数，有两种操作，如果它是奇数就让他乘 3 然后加 1，否则除以2。问你多少次操作能把它变为 1，多组询问。一开始打暴力，AC 了，但是是 OI赛制，看不到。后来记忆化搜索，40pts，再后来为了过群里流出的“hack数据”，讲数组改为<code>std::map</code>，爆零qwq。某位也用了<code>std::map</code>，但是却有 40pts，不知道为什么。</p><p>T2。贪心。2 min想了一个错误贪心，想不到过了样例（smy：“数据是随的，可能很多错误做法都能骗到部分分”），但是只拿了10pts。</p><p>T3。迅速打完，忘记两种情况取 <spanclass="math inline">\(\min\)</span>，爆零。</p><p>T4。简单 DP。我的顺序是 T1 <spanclass="math inline">\(\rightarrow\)</span> T3 <spanclass="math inline">\(\rightarrow\)</span> T4 <spanclass="math inline">\(\rightarrow\)</span> T2，写完 T3 一直在刚T4，觉得比 T2 可做。写完但是考场上被莫名降智，爆零。</p><p>于是我的成绩为 10pts。</p><p>啊啊啊啊啊啊啊啊啊要疯了啊！ w(ﾟДﾟ)w</p><p>尽管很多人都会这种情况，比如宿舍卷王同学昨天比赛硬刚 T1结果全场爆零（那题全场最高分是 15 还是20），但是我从心底是很焦虑的。因为去年的考场上，我也遇到了类似的情况，我承认我一年来进步很小，但是如果重蹈覆辙的话……</p><p>我开始重审自己，重新思考一些问题，通过现有的一点点资源全力提高自己的水平，那些自问自答的话就没必要说出来了。</p><p>我会珍惜的，我会吸取经验，继续下去的。</p><p>因为去年离别时的那首歌。</p><p> </p>    <div id="aplayer-FMaRbHiH" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="454966322" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><p> </p><p>下午还是 smy 讲DP，但貌似大半的时间都在讲斜率优化了。哎，当年我看懂斜率优化的时候还以为自己真的能够做到些什么，实际上，至今我都是一个“理论知识强于做题能力”的人。</p><p>“正视自己的实力，享受 OI 的乐趣”。——<ahref="https://www.luogu.com.cn/user/385093">uniqueharry</a>.。</p><p>下午是 smy 讲 DP 优化。但是仅仅斜率优化（例题是玩具装箱）就花了2h+，还应要求现场写了代码。后面简单讲了树形 DP、状压 DP的一点东西，最后讲上午的题目。心态不太好，把上午题目搞懂了之后一直在打<span class="math inline">\(\text{Arcaea}\)</span>。</p><p>晚上朋友们都去听了 zhq 的《OI与文化课杂谈》，我独自在宿舍里，望着灰蒙蒙透着深沉蓝色的天空，像个被欺负的小孩子那样自责又坚信着自己的歪理邪说。我害怕重蹈覆辙，我害怕又一次陷入自己编织的梦里。</p><p>眼中只有空荡荡的宿舍与明晃晃的灯，不知为何，又握紧了破旧不堪还缺了封面的《进阶指南》。去年夏令营，尽管也有些许不快，但是我永远记住了最后夕阳下的不舍；是否在某一天，我也能回忆起这个月亮尚未来临的夜晚呢？</p><p>“就要结束了啊！”</p><h2 id="day-7">day 7</h2><p>我只能自己回家。</p><p>早饭后，和朋友们简单告了别，便到宿舍收拾东西。</p><p>九点的时候，从容离开了这段憧憬着的日子。</p><p><img src="https://s2.loli.net/2022/07/25/Wo4YGgPZQuLNREh.jpg" srcset="/img/loading.gif" lazyload /></p><p><img src="https://s2.loli.net/2022/07/25/rcCo3aGMUmRnSyI.jpg" srcset="/img/loading.gif" lazyload /></p><p><img src="https://s2.loli.net/2022/07/25/fs4QNhlrguJzdG6.jpg" srcset="/img/loading.gif" lazyload /></p><p>坐着公交车到车站去，再坐长途汽车到我市。中午没吃饭，又因为赶时间进了候车大厅，所以只能从里面的超市买了些零食。还有夏令营剩下的一包膜片。</p><p>4h的长途汽车，无聊到极点，我理了一遍提高班数论的课件，顺便学了狄利克雷卷积，之后看了高算班的数论和图论。但是大部分时间在睡觉。</p><p>车上遇到了我市某区某小学的一位老师，他自己来的夏令营，听他说我市一共来了2 个人（不知道包不包括我）。</p><p>到站，又是一个傍晚。</p><p>迈开酸痛的双腿，径直走向夏空中的荧光。不知为何，每当仰望它时，总是在脑海深处竭力演绎着CSP-S 2021 前一晚出现的，那群青色的地平线。</p><p>我一定，一定会在下一个故事，再次与各位相遇，在我所期待的未来中。</p><p> </p><p>The END.</p><p><img src="https://s2.loli.net/2022/07/25/hGfiESX8lavcKVn.png" srcset="/img/loading.gif" lazyload /></p><h2 id="后记">后记</h2><p>我没能做到。</p><p>但我不想为往事所困，一定有什么原因的。</p><p>功亏一篑的原因。</p><p>继续走下去吧。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022的暑假</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#806 (Div 4)</title>
    <link href="/2022/cf1703-solution/"/>
    <url>/2022/cf1703-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1703</strong>.</p><p>自从前几天开始，我就一直用 <code>#define int long long</code>了。</p><h2 id="a.-yes-or-yes">A. YES or YES?</h2><h3 id="分析">分析</h3><p>直接判断即可。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> t;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">char</span> s[<span class="hljs-number">5</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-type">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;y&#x27;</span>&amp;&amp;s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;Y&#x27;</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;s[<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;E&#x27;</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(s[<span class="hljs-number">2</span>]!=<span class="hljs-string">&#x27;s&#x27;</span>&amp;&amp;s[<span class="hljs-number">2</span>]!=<span class="hljs-string">&#x27;S&#x27;</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-icpc-balloons">B. ICPC Balloons</h2><h3 id="分析-1">分析</h3><p>对于一个字母，第一次出现就让答案 <spanclass="math inline">\(+2\)</span>，否则 <spanclass="math inline">\(+1\)</span>。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> t, n;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>();string s; cin&gt;&gt;s;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) &#123;<span class="hljs-keyword">if</span>(++p[x]==<span class="hljs-number">1</span>) ans+=<span class="hljs-number">2</span>; <span class="hljs-keyword">else</span> ans+=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-cypher">C. Cypher</h2><h3 id="分析-2">分析</h3><p>暴力还原即可。<span class="math inline">\(Up\)</span> 记为 <spanclass="math inline">\(-1\)</span>，<spanclass="math inline">\(Down\)</span> 记为 <spanclass="math inline">\(+1\)</span>，求出操作和 <spanclass="math inline">\(s\)</span>。用原来的数字加上 <spanclass="math inline">\(s\)</span>，取模即可。</p><h3 id="coed">COED</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">int</span> t, n, a[<span class="hljs-number">105</span>], c[<span class="hljs-number">105</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-type">int</span> t; <span class="hljs-type">char</span> moves[<span class="hljs-number">20</span>]; &#125; b[<span class="hljs-number">105</span>];map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i].t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,b[i].moves);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;b[i].t;++j)<span class="hljs-keyword">if</span>(b[i].moves[j]==<span class="hljs-string">&#x27;U&#x27;</span>) --s; <span class="hljs-keyword">else</span> ++s;c[i]=(a[i]+s)%<span class="hljs-number">10</span>;<span class="hljs-keyword">if</span>(c[i]&lt;<span class="hljs-number">0</span>) c[i]=(c[i]+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,c[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-double-strings">D. Double Strings</h2><h3 id="分析-3">分析</h3><p>由于每个字符串长度不超过 <spanclass="math inline">\(8\)</span>，可以看作常数。所以对于字符串 <spanclass="math inline">\(S\)</span>，枚举断点 <spanclass="math inline">\(p\)</span>，判断两个字符串是否存在即可，注意边界。</p><p>用 <code>std::map</code> 实现，复杂度 <span class="math inline">\(O(n\log_2 n)\)</span>。</p><p>一开始竟然想出了，开一颗 Trie，对于字符串 <spanclass="math inline">\(s\)</span>，快速查找有没有它的前缀单词，有的话就从那个位置截取字符串，查找是否存在。没实现好，打挂之后就睡觉了。睡前才发现字符串最大长度为<spanclass="math inline">\(8\)</span>，而且貌似快不了多少。菜死了qwq。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, tot;string s[N];map&lt;string,<span class="hljs-type">int</span>&gt; p;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;s[i], p[s[i]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;s[i].<span class="hljs-built_in">length</span>();++j) &#123;string t1=s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,j), t2=s[i].<span class="hljs-built_in">substr</span>(j,s[i].<span class="hljs-built_in">size</span>()-j);<span class="hljs-keyword">if</span>(p[t1]&amp;&amp;p[t2]) fg=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,fg);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-mirror-grid">E. Mirror Grid</h2><h3 id="分析-4">分析</h3><p>定义一个位置 <spanclass="math inline">\((x,y)\)</span>“被要求修改”，当且仅当存在一个位置旋转任意度后落在<span class="math inline">\((x,y)\)</span>，且与它本身数字不同。</p><p>不难发现，对于一个被要求修改位置 <spanclass="math inline">\((x,y)\)</span>，早修改和晚修改是等价的。</p><p><span class="math inline">\((x,y)\)</span> 顺时针旋转 90° 后的位置是<span class="math inline">\((y,n-x+1)\)</span>。对于一个 <spanclass="math inline">\((x,y)\)</span>，我们只需要枚举包括它在内的 <spanclass="math inline">\(4\)</span> 个位置，看有哪些是被要求修改的。</p><p>设 <span class="math inline">\(cnt_0\)</span> 为这四个位置中 <spanclass="math inline">\(0\)</span> 的个数，如果 <spanclass="math inline">\(cnt_0 = 0\)</span> 或 <spanclass="math inline">\(cnt_0 = 4\)</span>，没有位置被要求修改。如果 <spanclass="math inline">\(cnt_0 = 1\)</span>，那么最优决策是将这个 <spanclass="math inline">\(0\)</span> 改成 <spanclass="math inline">\(1\)</span>，需要一次操作，同理若 <spanclass="math inline">\(cnt_0 = 3\)</span>，也只需要一次操作将那个 <spanclass="math inline">\(1\)</span> 改为 <spanclass="math inline">\(0\)</span> 即可。若 <spanclass="math inline">\(cnt_0 = 2\)</span>，需要两次操作，随便改。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> t, n, ans;<span class="hljs-type">char</span> s[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-type">int</span> x=i, y=j, cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>;++k) &#123;cnt+=s[x][y]==<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-type">int</span> tx=x, ty=y;x=ty, y=n-tx+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(!cnt||cnt==<span class="hljs-number">4</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-type">char</span> o;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>) o=<span class="hljs-string">&#x27;1&#x27;</span>, ++ans;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">3</span>) o=<span class="hljs-string">&#x27;0&#x27;</span>, ++ans;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">2</span>) o=<span class="hljs-string">&#x27;0&#x27;</span>, ans+=<span class="hljs-number">2</span>;x=i, y=j;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>;++k) &#123;s[x][y]=o;<span class="hljs-type">int</span> tx=x, ty=y;x=ty, y=n-tx+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="f.-yet-another-problem-about-pairs-satisfying-an-inequality">F.Yet Another Problem About Pairs Satisfying an Inequality</h2><h3 id="分析-5">分析</h3><p>有一个我自己总结出来的小结论：在一个序列问题中，对于下标 <spanclass="math inline">\(i\)</span>，更容易统计 <spanclass="math inline">\([1,i-1]\)</span> 这部分的信息。</p><p>考虑维护一个序列，对于下标 <spanclass="math inline">\(x\)</span>，只有满足 <spanclass="math inline">\(a_x &lt; x\)</span> 才将 <spanclass="math inline">\(x\)</span> 加入。那么如果手里有一个 <spanclass="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i&lt; i\)</span>，只要在这个序列中统计小于 <spanclass="math inline">\(a_i\)</span> 的元素的数量，就是 <spanclass="math inline">\([1,i-1]\)</span> 和 <spanclass="math inline">\(i\)</span> 对答案产生的贡献。</p><p>具体地，使用<code>std::lower_bound()</code>，查找序列内第一个大于等于 <spanclass="math inline">\(a_i\)</span> 的数，设它的下标为 <spanclass="math inline">\(k\)</span>，那么贡献即为 <spanclass="math inline">\(k-1\)</span>。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, a[N];vector&lt;<span class="hljs-type">int</span>&gt; v;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();v.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;=i) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> k=<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),a[i])-v.<span class="hljs-built_in">begin</span>();        <span class="hljs-comment">// vector下标从0开始，所以不用-1</span>ans+=k;v.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="g.-good-key-bad-key">G. Good Key, Bad Key</h2><h3 id="分析-6">分析</h3><p>大胆猜想一个结论：在最优解中使用坏钥匙的，一定是一段后缀。</p><blockquote><p>证明：</p><p>邻项交换法。假设 <span class="math inline">\(i\)</span>使用了坏钥匙，<span class="math inline">\(i+1\)</span>使用了好钥匙，那么收益为 <span class="math inline">\(\lfloor\frac{a_i}{2} \rfloor + \lfloor \frac{a_{i+1}}{2} \rfloor -k\)</span>；反过来，假设 <span class="math inline">\(i\)</span>使用了好钥匙，<span class="math inline">\(i+1\)</span>使用了坏钥匙，那么收益为 <span class="math inline">\(a_i + \lfloor\frac{a_{i+1}}{2} \rfloor -k\)</span>。后者显然小于前者，所以最优解中，使用坏钥匙的一定是一段后缀，命题成立。</p></blockquote><p>从 <span class="math inline">\(0\)</span> 到 <spanclass="math inline">\(n\)</span>枚举使用坏钥匙的数量，同时也是倒序枚举好钥匙的数量。</p><p>由于每多用一把坏钥匙，后面的收益都要减半，所以使用<code>std::set</code> 来维护这个「减半集合」。设 <spanclass="math inline">\(s_i = \sum_{j=1}^i a_j\)</span>，则使用 <spanclass="math inline">\(i\)</span> 把好钥匙的收益为 $ = s_i - ik$。此时集合里维护了在 <span class="math inline">\([i+1,n]\)</span>每个箱子都使用坏钥匙后，每个箱子的收益。将 <spanclass="math inline">\(\Delta\)</span>加上所有集合里的数，就得到了总收益，取最大值即可。</p><p>如何维护？当求出使用 <span class="math inline">\(i\)</span>把好钥匙的收益后，将 <span class="math inline">\(\lfloor \frac{a_i}{2}\rfloor\)</span> 加入集合，同时将集合内所有元素都除以 <spanclass="math inline">\(2\)</span> 并下取整。由于 <code>std::set</code>不便于直接修改，可以新开一个 <code>std::set</code>来储存修改后的元素，然后交换两个集合。</p><p>由于最大的元素不超过 <span class="math inline">\(10^9\)</span>，<spanclass="math inline">\(\lfloor \log_2(10^9) \rfloor =29\)</span>，所以可以认为每个元素进出集合常数次，复杂度 <spanclass="math inline">\(O(n \log_2 n)\)</span>。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, k, a[N], s[N];multiset&lt;<span class="hljs-type">int</span>&gt; st, tmp;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;st.<span class="hljs-built_in">clear</span>();n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;~i;--i) &#123;<span class="hljs-type">int</span> dlt=s[i]-i*k;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:st) dlt+=x;ans=<span class="hljs-built_in">max</span>(ans,dlt);tmp.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">if</span>(a[i]/<span class="hljs-number">2</span>&gt;<span class="hljs-number">0</span>) tmp.<span class="hljs-built_in">insert</span>(a[i]/<span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:st) <span class="hljs-keyword">if</span>(x/<span class="hljs-number">2</span>) tmp.<span class="hljs-built_in">insert</span>(x/<span class="hljs-number">2</span>);<span class="hljs-built_in">swap</span>(st,tmp);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC259G Grid Card Game 题解</title>
    <link href="/2022/abs259g-solution/"/>
    <url>/2022/abs259g-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>既然可以不选择任何一行和任何一列，那么最大收益的最小值为 <spanclass="math inline">\(0\)</span>。</p><p>设 <span class="math inline">\(r_i = \sum_{j=1}^ma_{i,j}\)</span>，<span class="math inline">\(c_{j} = \sum_{i=1}^na_{i,j}\)</span>。如果 <span class="math inline">\(r_i &lt;0\)</span>或者 <span class="math inline">\(c_j &lt; 0\)</span>，那么选择 <spanclass="math inline">\(i\)</span> 行或 <spanclass="math inline">\(j\)</span> 列一定不优，可以直接无视。</p><p>选择 <span class="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的收益为 <spanclass="math inline">\(r_i + c_j -a_{i,j}\)</span>。由于可以选择任意多行和列，那么一个思路就是先选择所有大于等于<span class="math inline">\(0\)</span> 的 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span>，再减去重复的 <spanclass="math inline">\(a_{i,j}\)</span>。但是如果 <spanclass="math inline">\(a_{i,j} &lt; 0\)</span>，就不能选择 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span>。</p><p>考虑最小割。</p><p>将行作为左部点，列作为右部点。若 <span class="math inline">\(r_i \ge0\)</span>。从源点向左部点 <span class="math inline">\(i\)</span>连容量为 <span class="math inline">\(r_i\)</span> 边；若 <spanclass="math inline">\(c_j \ge 0\)</span>，从右部点 <spanclass="math inline">\(j\)</span> 向汇点连容量为 <spanclass="math inline">\(c_j\)</span> 的边。</p><p>对于 <span class="math inline">\(a_{i,j} \ge 0\)</span>，从 <spanclass="math inline">\(i\)</span> 向 <spanclass="math inline">\(j\)</span> 连容量为 <spanclass="math inline">\(a_{i,j}\)</span> 的边。对于 <spanclass="math inline">\(a_{i,j} &lt; 0\)</span>，从 <spanclass="math inline">\(i\)</span> 向 <spanclass="math inline">\(j\)</span> 连容量为 <spanclass="math inline">\(\infty\)</span> 的边。</p><p>在删去最小割的网络中，<span class="math inline">\(S\)</span> 与 <spanclass="math inline">\(T\)</span> 不连通，且容量为 <spanclass="math inline">\(\infty\)</span>的边一定仍然存在。也就是说，对于容量为 <spanclass="math inline">\(a_{i,j}\)</span> 的边 <spanclass="math inline">\((i,j)\)</span>，由于 <spanclass="math inline">\(r_i\)</span> 与 <spanclass="math inline">\(c_j\)</span> 都大于等于 <spanclass="math inline">\(0\)</span>，要么是 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span> 其中一个被删去，要么是 <spanclass="math inline">\(a_{i,j}\)</span> 被删去。对于容量为 <spanclass="math inline">\(\infty\)</span> 的边 <spanclass="math inline">\((i,j)\)</span>，一定是 <spanclass="math inline">\(r_i\)</span> 或者 <spanclass="math inline">\(c_j\)</span> 其中一个或者两个都被删去。</p><p>用所有大于等于 <span class="math inline">\(0\)</span> 的 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span>的和减去最小割，就得到了最大收益。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">50005</span>, inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, s, t, a[N][N], d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[M], w[M], nxt[M];<span class="hljs-type">int</span> ans, r[N], c[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-type">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> maxflow=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);<span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();s=<span class="hljs-number">0</span>, t=n+m+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;a[i][j]=<span class="hljs-built_in">read</span>();r[i]+=a[i][j], c[j]+=a[i][j];<span class="hljs-keyword">if</span>(a[i][j]&gt;=<span class="hljs-number">0</span>) <span class="hljs-built_in">addedge</span>(i,j+n,a[i][j]); <span class="hljs-keyword">else</span> <span class="hljs-built_in">addedge</span>(i,j+n,inf);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(r[i]&gt;=<span class="hljs-number">0</span>) &#123;ans+=r[i];<span class="hljs-built_in">addedge</span>(s,i,r[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(c[i]&gt;=<span class="hljs-number">0</span>) &#123;ans+=c[i];<span class="hljs-built_in">addedge</span>(i+n,t,c[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans-<span class="hljs-built_in">dinic</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「网络流 24 题」#1</title>
    <link href="/2022/netflow-24t-1/"/>
    <url>/2022/netflow-24t-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>网络流 24题，很多都是与二分图相关，「能用网络流算法求解」的题目，所以下文叙述时会更多地讨论题目的本质。</p><p>只能说，24 题毕竟也仅仅是比板子要复杂一些，就将就着看个乐呵吧。</p><h2 id="luogu2756-飞行员配对方案问题">luogu2756 飞行员配对方案问题</h2><h3 id="分析">分析</h3><p>显然，将英国飞行员和外籍飞行员分别作为二分图的左右节点，一个英国飞行员只能和一个外籍飞行员配合，满足「每个集合内部有<span class="math inline">\(0\)</span> 条边」的 0 要素和「每个点最多与<span class="math inline">\(1\)</span> 条匹配边相连」的 1 要素。</p><p>派出最多的飞机，转化为求这张二分图的最大匹配。</p><p>至于输出方案，最大流算法结束后，有流经过的点和边就是匹配点、匹配边。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, s, t, maxflow, d[N], hh[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;        c=<span class="hljs-built_in">getchar</span>();    &#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dinic</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();    s=n+<span class="hljs-number">1</span>, t=n+<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span>(x!=<span class="hljs-number">-1</span>&amp;&amp;y!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(i,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,i,<span class="hljs-number">0</span>);    n+=<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dinic</span>(s,n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,maxflow);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=m;++x) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(y==s||z) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 由于边容量为 1，所以z!=0绝对没有流经过</span>        <span class="hljs-comment">// 不能是到源点的边</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,x,y);    &#125;&#125;</code></pre></div><h2 id="luogu3254-圆桌问题">luogu3254 圆桌问题</h2><h3 id="分析-1">分析</h3><p>将单位看作左部点，餐桌看作右部点，显然这是一张二分图。</p><p>考虑转化成二分图模型。同一个单位来的代表不能在同一个餐桌就餐，那么餐桌与代表之间两两有一条边。而单位<span class="math inline">\(i\)</span> 派出 <spanclass="math inline">\(r_i\)</span> 个代表，说明它最多与 <spanclass="math inline">\(r_i\)</span> 条匹配边相连，第 <spanclass="math inline">\(j\)</span> 个餐桌能容纳 <spanclass="math inline">\(c_j\)</span> 个代表，说明它最多和 <spanclass="math inline">\(c_j\)</span>条匹配边相连。二分图多重匹配板子。</p><p>解决这个问题，只需要将源点到左部点 <spanclass="math inline">\(i\)</span> 的容量设置成 <spanclass="math inline">\(r_i\)</span>，右部点 <spanclass="math inline">\(j\)</span> 到汇点的容量设置成 <spanclass="math inline">\(c_j\)</span>，跑最大流即可。求出多重匹配后，如果匹配书不等于人数，那么无解。</p><p>输出方案时记得将编号搞到 <span class="math inline">\([1,n]\)</span>之间。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, s, t, sum, maxflow, d[N], hh[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;        c=<span class="hljs-built_in">getchar</span>();    &#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dinic</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();    s=n+m+<span class="hljs-number">1</span>, t=n+m+<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(s,i,x), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>);        sum+=x;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(i+m,t,x), <span class="hljs-built_in">add</span>(t,i+m,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>+m;j&lt;=n+m;++j)        <span class="hljs-built_in">add</span>(i,j,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(j,i,<span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dinic</span>(s,inf);    <span class="hljs-keyword">if</span>(maxflow!=sum) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=m;++x) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(y!=s&amp;&amp;!z) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,y-m);        &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="luogu2763-试题库问题">luogu2763 试题库问题</h2><h3 id="分析-2">分析</h3><p>类型作为左部点，题目作为右部点。</p><p>要选出 <span class="math inline">\(c_i\)</span> 道类型的题，就是<span class="math inline">\(i\)</span> 最多与 <spanclass="math inline">\(c_i\)</span> 条匹配边相连。</p><p>如果第 <span class="math inline">\(j\)</span> 道题可以属于 <spanclass="math inline">\(p\)</span> 类，对应的点之间连容量为 <spanclass="math inline">\(1\)</span> 的边。</p><p>对于每道题 <span class="math inline">\(j\)</span>，它最多与 <spanclass="math inline">\(1\)</span> 条匹配边相连。</p><p>仍然是多重给匹配，除了建模，其他与上题完全相同。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, k, m, s, t, cnt[N], d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> maxflow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);    <span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    k=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=n+k+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;        m+=cnt[i]=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(s,i,cnt[i]), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-type">int</span> num=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">while</span>(num--) &#123;            <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();            <span class="hljs-built_in">add</span>(x,i+k,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(i+k,x,<span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(i+k,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,i+k,<span class="hljs-number">0</span>);    <span class="hljs-type">int</span> ans=<span class="hljs-built_in">dinic</span>();    <span class="hljs-keyword">if</span>(ans!=m) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No Solution!&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=k;++x) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: &quot;</span>,x);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(y==s||z) <span class="hljs-keyword">continue</span>;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,y-k);        &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="luogu2764-最小路径覆盖问题">luogu2764 最小路径覆盖问题</h2><p>DAG 最小路径覆盖板子题，具体做法不再赘述，看代码就能懂。</p><p>更大的问题是输出方案。由于在拆点二分图上，路径必定是一个左部点和右部点交替出现。设<span class="math inline">\(p(x)=y-n\)</span>为在最大流（的分层图）中与左部点 <span class="math inline">\(x\)</span>相连的右部点，<span class="math inline">\(q(y-n)=x\)</span> 为与右部点<span class="math inline">\(y\)</span> 相连的左部点。方向都是 <spanclass="math inline">\((x \rightarrowy)\)</span>。由于右部点是左部点拆过去的，平移了 <spanclass="math inline">\(n\)</span> 位，所以要减去 <spanclass="math inline">\(n\)</span>。</p><p>初始的时候，<span class="math inline">\(p(x)=q(x)=i\)</span>。</p><p>对于一个 <span class="math inline">\(x\)</span>，如果 <spanclass="math inline">\(p(x)=x\)</span> 且没有被标记，那么说明 <spanclass="math inline">\(x\)</span> 是一条路径的尽头，直接从 <spanclass="math inline">\(x\)</span> 往前递归输出即可。具体流程如下：</p><ol type="1"><li><span class="math inline">\(x=0\)</span>，结束递归。</li><li><span class="math inline">\(x \neq 0\)</span>，如果 <spanclass="math inline">\(q(x) \neq x\)</span>，那么递归 <spanclass="math inline">\(q(x)\)</span>。</li><li>递归结束后标记 <spanclass="math inline">\(x\)</span>，不再使用。</li><li>输出 <span class="math inline">\(x\)</span>，确保是按照顺序。</li></ol><p>这么做的根据是，对于一张拆点二分图的最大匹配中，其匹配边 <spanclass="math inline">\((x,y+n)\)</span> 对应了原图中的 <spanclass="math inline">\((x,y)\)</span>。如果存在 <spanclass="math inline">\(p(x)=x\)</span>，那么说明 <spanclass="math inline">\((x \rightarrow x+n)\)</span>，即 <spanclass="math inline">\((x \rightarrow x)\)</span>，自环是不被允许的。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000</span>, M=<span class="hljs-number">6666</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, s, t, d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-type">int</span> p[N], q[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(k&amp;&amp;x!=s&amp;&amp;y!=t) p[x]=y-n, q[y-n]=x;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> maxflow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);    <span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(q[x]!=x) <span class="hljs-built_in">print</span>(q[x]);    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=q[i]=i;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(x,y+n,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(y+n,x,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(i+n,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,i+n,<span class="hljs-number">0</span>);    <span class="hljs-type">int</span> ans=<span class="hljs-built_in">dinic</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) <span class="hljs-keyword">if</span>(p[x]==x&amp;&amp;!v[x]) &#123;        <span class="hljs-built_in">print</span>(x), <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-ans);&#125;</code></pre></div><p>输出方案也可以如下（网上复制来的，不做解释）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[i];~j;j=e[j].next)&#123;        <span class="hljs-type">int</span> v=e[j].to;        <span class="hljs-keyword">if</span>(e[j].cap-e[j].flow==<span class="hljs-number">0</span>&amp;&amp;e[j].flow==<span class="hljs-number">1</span>)&#123;            pre[v-n]=i;            lst[i]=v-n;        &#125;        &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;    <span class="hljs-keyword">if</span>(!pre[i])&#123;        <span class="hljs-type">int</span> u=i;        <span class="hljs-keyword">while</span>(lst[u]!=<span class="hljs-number">0</span>)&#123;            cout&lt;&lt;u&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;            u=lst[u];        &#125;        cout&lt;&lt;u&lt;&lt;endl;    &#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;</code></pre></div><h2 id="luogu2765-魔术球问题">luogu2765 魔术球问题</h2><h3 id="分析-3">分析</h3><p>要求相邻两个数之和是完全平方数，而数据范围极小，考虑枚举。</p><p>如果将 <span class="math inline">\(x\)</span> 在 <spanclass="math inline">\(y\)</span> 上面，看作 <spanclass="math inline">\((y \rightarrow x)\)</span>的一条边，那么最终一定是一个 DAG。</p><figure><img src="https://cdn.luogu.com.cn/upload/pic/45422.png" srcset="/img/loading.gif" lazyloadalt="图源洛谷，侵删" /><figcaption aria-hidden="true">图源洛谷，侵删</figcaption></figure><p>这样每个柱子实际上代表了一条路径，这些路径两两不相交，要求球数尽可能多，变相地说明对于一定量的球，路径要尽可能少。转化为DAG 的最小路径覆盖问题。</p><p>先预处理平方。从 <span class="math inline">\(1\)</span>开始枚举最大编号，寻找能够放置的球的最大编号。把每个球的编号 <spanclass="math inline">\(x\)</span> 拆成两个点 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(x&#39;\)</span>，分为左部右部两个集合。</p><p>为了避免重复，规定只能从较小点连到较大点。对于一个数 <spanclass="math inline">\(i^2\)</span>，满足 <span class="math inline">\(i^2&gt; j\)</span> 且 <span class="math inline">\(i^2 - j &lt;j\)</span>，才连边 <span class="math inline">\((i^2 -j,j&#39;)\)</span>，容量为 <span class="math inline">\(1\)</span>。对应DAG 中 <span class="math inline">\((i^2 -j,j)\)</span> 的边。</p><p>然后和源点汇点的边容量也为 <spanclass="math inline">\(1\)</span>，跑最大流。如果最大编号 <spanclass="math inline">\(T - maxflow &gt; n\)</span>，说明需要超过 <spanclass="math inline">\(n\)</span> 个柱子，此时 <spanclass="math inline">\(T-1\)</span> 即为答案。</p><p>然后找最大流经过的路径就行了。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, s, t, ans, d[N], squ[<span class="hljs-number">1145</span>], p[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[M], nxt[M], w[M];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> maxflow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);    <span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    s=<span class="hljs-number">0</span>, t=<span class="hljs-number">5e4</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;++i) squ[i]=i*i;    <span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">lower_bound</span>(squ+<span class="hljs-number">1</span>,squ+<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>,T)-squ;        <span class="hljs-comment">// 最小的大于等于T的完全平方数</span>        <span class="hljs-built_in">add</span>(s,T,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(T,s,<span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(T+<span class="hljs-number">1e4</span>,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,T+<span class="hljs-number">1e4</span>,<span class="hljs-number">0</span>);        <span class="hljs-comment">// n不是点数，不能平移n位</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*k;++i) &#123;            <span class="hljs-type">int</span> j=squ[i]-T;            <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;T&gt;j) <span class="hljs-built_in">add</span>(j,T+<span class="hljs-number">1e4</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(T+<span class="hljs-number">1e4</span>,j,<span class="hljs-number">0</span>);        &#125;        ans+=<span class="hljs-built_in">dinic</span>();        <span class="hljs-keyword">if</span>(T-ans&gt;n) <span class="hljs-keyword">break</span>;        ++T;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,--T);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=T;++x) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(y==s||z) <span class="hljs-keyword">continue</span>;        p[x]=y<span class="hljs-number">-1e4</span>; <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 标记</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=T;++x) &#123;        <span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=x;k;k=p[k]) &#123;            v[k]=<span class="hljs-number">1</span>;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,k);        &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="luogu4014-分配问题">luogu4014 分配问题</h2><h3 id="分析-4">分析</h3><p>跑一边最小费用最大流，再跑一边最大费用最大流。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">4</span>*N*N;<span class="hljs-type">const</span> ll inf=<span class="hljs-number">0x7fffffff</span>;<span class="hljs-type">int</span> n, m, s, t, a[N][N], hh[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M], nxt[M], w[M], cst[M];ll maxcost, mincost, d[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> cost)</span> </span>&#123;    to[++tot]=y, w[tot]=z, cst[tot]=cost, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SPFA1</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;++i) d[i]=inf, v[i]=<span class="hljs-number">0</span>;    d[s]=<span class="hljs-number">0</span>, v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        v[x]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i], cost=cst[i];            <span class="hljs-keyword">if</span>(!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(d[y]&gt;d[x]+cost) &#123;                d[y]=d[x]+cost;                <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> d[t]!=inf;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SPFA2</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;++i) d[i]=-inf, v[i]=<span class="hljs-number">0</span>;    d[s]=<span class="hljs-number">0</span>, v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        v[x]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i], cost=cst[i];            <span class="hljs-keyword">if</span>(!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(d[y]&lt;d[x]+cost) &#123;                d[y]=d[x]+cost;                <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> d[t]!=-inf;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;     v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i], cost=cst[i];        <span class="hljs-keyword">if</span>(v[y]||!z||d[y]!=d[x]+cost) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    v[x]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> fg)</span> </span>&#123;    <span class="hljs-keyword">while</span>(fg? <span class="hljs-built_in">SPFA1</span>():<span class="hljs-built_in">SPFA2</span>()) &#123;        <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));        <span class="hljs-comment">// mincost+=dfs(s,inf)*d[t];</span>        fg? mincost+=<span class="hljs-built_in">dfs</span>(s,inf)*d[t]:maxcost+=<span class="hljs-built_in">dfs</span>(s,inf)*d[t];    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(h));    tot=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i+n,t,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(t,i+n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)        <span class="hljs-built_in">add</span>(i,j+n,<span class="hljs-number">1</span>,a[i][j]), <span class="hljs-built_in">add</span>(j+n,i,<span class="hljs-number">0</span>,-a[i][j]);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;        <span class="hljs-type">int</span> x=a[i][j]=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(i,j+n,<span class="hljs-number">1</span>,x), <span class="hljs-built_in">add</span>(j+n,i,<span class="hljs-number">0</span>,-x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i+n,t,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(t,i+n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">dinic</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mincost);    <span class="hljs-built_in">rebuild</span>();    <span class="hljs-built_in">dinic</span>(<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,maxcost);&#125;</code></pre></div><h2 id="luogu2774-方格取数问题">luogu2774 方格取数问题</h2><h3 id="分析-5">分析</h3><p>按照格点横纵坐标相加的奇偶性，构造二分图。由于所有格子中的数都是正数，任意两个取出的数所在的格子没有公共边，等价于先强制选择所有格子，然后删去最小的一批有冲突的格子。</p><p>最小割。</p><p>源点连向所有奇数点，容量为这个格点的数字，表示删去这个格子的代价。所有偶数点连向汇点，容量为这个格点的数字，表示删去这个格子的代价。</p><p>对于一个奇数格点，与它冲突的格点为它上下左右的偶数格点。将奇数个点与偶数个点之间连容量为<span class="math inline">\(\infty\)</span>的边。表示这两个节点互斥。</p><p>在最小割中，一定不包含边权为 <spanclass="math inline">\(\infty\)</span>的边，也就是一定没有从互斥格点取数。删掉最小割之后，网络就不连通了，说明删去的都是格点，从而一定不包含所有有冲突的格点。否则由于这两个互斥的点之间的权值为<span class="math inline">\(\infty\)</span>的边仍然存在，图是连通的。矛盾。</p><h3 id="code-6">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> n, m, s, t, d[N*N], hh[<span class="hljs-number">2</span>*N*N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[<span class="hljs-number">2</span>*N*N], to[<span class="hljs-number">4</span>*N*N], nxt[<span class="hljs-number">4</span>*N*N], w[<span class="hljs-number">4</span>*N*N];ll sum;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;q.<span class="hljs-built_in">push</span>(y);d[y]=d[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-type">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x<span class="hljs-number">-1</span>)*m+y; &#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    ll maxflow=<span class="hljs-number">0</span>, flow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">dfs</span>(s,inf)) maxflow+=flow;    <span class="hljs-keyword">return</span> maxflow;&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=n*m+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;        <span class="hljs-type">int</span> awa=<span class="hljs-built_in">read</span>();        sum+=awa;        <span class="hljs-keyword">if</span>((i+j)&amp;<span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">add</span>(s,<span class="hljs-built_in">id</span>(i,j),awa), <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j),s,<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k) &#123;                <span class="hljs-type">int</span> x=i+dx[k], y=j+dy[k];                <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="hljs-number">0</span>&amp;&amp;y&lt;=m) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j),<span class="hljs-built_in">id</span>(x,y),inf), <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(x,y),<span class="hljs-built_in">id</span>(i,j),<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j),t,awa), <span class="hljs-built_in">add</span>(t,<span class="hljs-built_in">id</span>(i,j),<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sum-<span class="hljs-built_in">dinic</span>());    <span class="hljs-comment">// 总量-最小割=最大收益</span>&#125;</code></pre></div><h2 id="luogu2045-方格取数加强版k-方格取数">luogu2045 方格取数加强版（K方格取数）</h2><h3 id="分析-6">分析</h3><p>其实这题不属于网络流 24 题，但是也挺有启发意义的，顺带讲了吧。</p><p>看起来和上题很像，实际上很多性质都不同。比如本题中就无法直接构造出一张二分图，也不能用上题的删点方法。</p><p>当 <span class="math inline">\(k=1\)</span> 时，那么将 <spanclass="math inline">\((i,j)\)</span> 作为节点，有一个点权 <spanclass="math inline">\(a_{i,j}\)</span>，向 <spanclass="math inline">\((i+1,j)\)</span> 和 <spanclass="math inline">\((i,j+1)\)</span> 连边。答案为 <spanclass="math inline">\((1,1)\)</span> 到 <spanclass="math inline">\((n,n)\)</span> 的点权最长路。</p><p>当 <span class="math inline">\(k&gt;0\)</span> 时，一共走 <spanclass="math inline">\(k\)</span> 次，那么对于节点 <spanclass="math inline">\((i,j)\)</span>，只有第一次走过时有收益，剩下 <spanclass="math inline">\(k-1\)</span> 次收益均为 <spanclass="math inline">\(0\)</span>。从 <spanclass="math inline">\((i,j)\)</span> 出发，最多可以向 <spanclass="math inline">\((i+1,j)\)</span> 和 <spanclass="math inline">\((i,j+1)\)</span> 分别走 <spanclass="math inline">\(k\)</span> 次。为了保证路径数量是 <spanclass="math inline">\(k\)</span>，可以把“走过的次数”看作容量，收益看作费用，这样就有了一个费用流模型的雏形。</p><p>但是，权值是点权，无法直接做。这就要使用一种名为「点转化边」的Trick。</p><p>将 <span class="math inline">\((i,j)\)</span> 拆成入点 <spanclass="math inline">\((i,j,0)\)</span> 和出点 <spanclass="math inline">\((i,j,1)\)</span>，连边，入点和出点之间的权值（费用）等于原来的点权，容量为能够经过的次数。具体地，费用为<span class="math inline">\(a_{i,j}\)</span>，容量为 <spanclass="math inline">\(1\)</span>；费用为 <spanclass="math inline">\(0\)</span>，容量为 <spanclass="math inline">\(k-1\)</span>。</p><p>然后从出点 <span class="math inline">\((i,j,1)\)</span> 向 <spanclass="math inline">\((i+1,j,0)\)</span> 和 <spanclass="math inline">\((i,j+1,0)\)</span> 连边，权值（费用）为 <spanclass="math inline">\(0\)</span>，容量为 <spanclass="math inline">\(k\)</span>。</p><p>下图描述了 <span class="math inline">\((x \rightarrow y \rightarrowz)\)</span>，点权分别为 <span class="math inline">\(1\)</span>，<spanclass="math inline">\(2\)</span>，<span class="math inline">\(3\)</span>的情况。</p><p><img src="https://s2.loli.net/2022/07/11/KIC3xAbdmnRL95H.png" srcset="/img/loading.gif" lazyload /></p><p>最大化权值和（总费用），最大费用最大流。</p><p>注意给节点编号，并且点转化边之后节点总量为 <spanclass="math inline">\(2 n^2\)</span>。</p><h3 id="code-7">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, M=<span class="hljs-number">200005</span>, inf=<span class="hljs-number">0x7fffffff</span>;<span class="hljs-type">int</span> n, k, s, t, hh[N], d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M], nxt[M], w[M], cst[M];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">return</span> (i<span class="hljs-number">-1</span>)*n+j+k*n*n;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> cost)</span> </span>&#123;to[++tot]=y, w[tot]=z, cst[tot]=cost, nxt[tot]=h[x], h[x]=tot;to[++tot]=x, w[tot]=<span class="hljs-number">0</span>, cst[tot]=-cost, nxt[tot]=h[y], h[y]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n*n;++i) d[i]=-inf/<span class="hljs-number">2</span>, v[i]=<span class="hljs-number">0</span>;    d[s]=<span class="hljs-number">0</span>, v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        v[x]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=to[i], z=w[i], cost=cst[i];            <span class="hljs-keyword">if</span>(!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(d[y]&lt;d[x]+cost) &#123;                d[y]=d[x]+cost;                <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> d[t]!=-inf/<span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-type">int</span> res=flow;    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i], z=w[i], cost=cst[i];        <span class="hljs-keyword">if</span>(v[y]||!z||d[y]!=d[x]+cost) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    v[x]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v)), ans+=<span class="hljs-built_in">dfs</span>(s,inf)*d[t];<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();s=<span class="hljs-number">1</span>, t=<span class="hljs-number">2</span>*n*n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">0</span>),<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,x);<span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">0</span>),<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),k<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(i&lt;n) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-built_in">id</span>(i+<span class="hljs-number">1</span>,j,<span class="hljs-number">0</span>),k,<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(j&lt;n) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-built_in">id</span>(i,j+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),k,<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dinic</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
      <tag>最大流</tag>
      
      <tag>二分图</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1542D Priority Queue</title>
    <link href="/2022/cf1542d-solution/"/>
    <url>/2022/cf1542d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>大佬们都说是显然题，套路题，可是我一开始连这是个 DP 都想不到qwq。</p><p>状态数量太多，要求的值是所有状态的和，那么可以尝试统计贡献。</p><p><span class="math inline">\(b\)</span> 是 <spanclass="math inline">\(a\)</span>的子序列，说白了就是，对于每一个操作，都能选，或者不选。那么可以对于每一个元素计算能够让它保留到最后的方案数，从而统计贡献。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为在当前基准的一个下标<span class="math inline">\(p\)</span> 之下，考虑了前 <spanclass="math inline">\(i\)</span> 个操作，其中有 <spanclass="math inline">\(j\)</span> 个元素小于 <spanclass="math inline">\(a_p\)</span> 的方案数。</p><p>如果第 <span class="math inline">\(i\)</span>个操作是删除，那么由于选不选都可以，转移为 <span class="math display">\[f(i,j) = f(i-1,j) + f(i-1,j+1)\]</span> 前者为不选，后者为选。</p><p>特别地，当 <span class="math inline">\(i &lt; p\)</span> 并且 <spanclass="math inline">\(j=0\)</span> 时，要再加上 <spanclass="math inline">\(f(i-1,j)\)</span>，一种表示一直过来都没选，这次选但是什么也不做。另一种是选了但是删没了。</p><p>当第 <span class="math inline">\(i\)</span>个操作是加入，那么也可以选或不选。</p><p>当 <span class="math inline">\(a_i &lt; a_p\)</span> 时 <spanclass="math display">\[f(i,j) = f(i-1,j) + f(i-1,j-1)\]</span> 当 <span class="math inline">\(a_i &gt; a_p\)</span>时，选不选都不会改变 <span class="math display">\[f(i,j)= f(i-1,j) + f(i-1,j)\]</span> 特别的，如果 <span class="math inline">\(a_i =a_p\)</span>，那么当 <span class="math inline">\(i&lt; p\)</span>时，放到第一种转移，当 <span class="math inline">\(i&gt;p\)</span>时，放到第二种转移。</p><p>特别地，当 <span class="math inline">\(i=p\)</span> 时，直接将 <spanclass="math inline">\(i-1\)</span> 的状态转移到 <spanclass="math inline">\(i\)</span>，因为必须选择。</p><p>最后累加 <span class="math display">\[\sum_{i=0}^n f(n,i)\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, a[N];<span class="hljs-type">char</span> s[N];ll f[N][N], ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;s[i]);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>) a[i]=<span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>;p&lt;=n;++p) &#123;<span class="hljs-type">int</span> x=a[p];<span class="hljs-keyword">if</span>(!~x) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(p==i) &#123; <span class="hljs-built_in">memcpy</span>(f[i],f[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">sizeof</span>(f[i])); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(!~a[i]) &#123;f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>])%mod;<span class="hljs-keyword">if</span>(i&lt;p&amp;&amp;!j) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j])%=mod;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]&lt;x||((a[i]==x&amp;&amp;i&lt;p))) &#123;f[i][j]=f[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">if</span>(j) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%=mod;&#125; <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>][j]%mod;&#125;&#125;ll sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (sum+=f[n][i])%=mod;(ans+=sum*x%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1540B Tree Array 题解</title>
    <link href="/2022/cf1540b-solution/"/>
    <url>/2022/cf1540b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>逆序对是由两个元素构成的，所以对于逆序对的期望个数，可以看作是每一个数对能够成为逆序对的期望的和。</p><p>直接做很不可做，而每个逆序对只与两个数有关，一般这时候就要考虑计算贡献了。</p><p>由于是在树上操作，而所有操作都要跟在第一次标记后面，且根是不固定的，所以可以枚举每一个点作为根的情况，求出所有情况的和之后再乘<span class="math inline">\(\frac{1}{n}\)</span> 就好了。</p><p>考虑 <span class="math inline">\((i,j)\)</span>，其中 <spanclass="math inline">\(i &lt;j\)</span>，什么时候能够成为逆序对。显然，当且仅当 <spanclass="math inline">\(i\)</span> 在 <spanclass="math inline">\(j\)</span>之后被标记，这个期望是多少呢？由于规定了根，而后续的操作必然是不断由根向下标记，也就是说，当<span class="math inline">\(lca(i,j)\)</span>没有被标记的时候，两点被标记的概率都为 <spanclass="math inline">\(0\)</span>。而当 <spanclass="math inline">\(lca(i,j)\)</span>被标记后，才能不断向两点所在位置扩充。</p><p>要在 <span class="math inline">\(lca(i,j)\)</span>被标记之后这个局面求 <span class="math inline">\(i\)</span> 在 <spanclass="math inline">\(j\)</span> 之后被标记的概率（权值是 <spanclass="math inline">\(1\)</span>），才能算出对答案有贡献的期望。而其他局面的概率全部为<span class="math inline">\(0\)</span>，进而期望全部为 <spanclass="math inline">\(0\)</span>。考虑到每次的根是不固定的，但是对于到<span class="math inline">\(lca\)</span>距离相同的点对，产生逆序对的概率则是一样的，所以要如下设计状态。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为在某对点的 <spanclass="math inline">\(lca\)</span> 被标记后，到 <spanclass="math inline">\(lca\)</span> 距离为 <spanclass="math inline">\(i\)</span> 的点在到 <spanclass="math inline">\(lca\)</span> 距离为 <spanclass="math inline">\(j\)</span>的点之前被标记，所能贡献的期望逆序对个数。 <span class="math display">\[f(i,j) = 1 \cdot \frac{f(i-1,j)+f(i,j-1)}{2}\]</span> 当然这个 <span class="math inline">\(1\)</span>也可以省略，那么某种意义上说 <span class="math inline">\(f(i,j)\)</span>表示的也是概率……</p><p>可以 <span class="math inline">\(O(n^2)\)</span> 预处理。</p><p>当以 <span class="math inline">\(i\)</span> 为根时，预处理查找 <spanclass="math inline">\(lca\)</span> 的倍增数组，然后 <spanclass="math inline">\(O(n^2)\)</span> 枚举点对，累加期望即可。</p><p>最后乘 <span class="math inline">\(\frac{1}{n}\)</span>。</p><p>复杂度 <span class="math inline">\(O(n^3 \log_2n)\)</span>，官方题解说可以做到 <spanclass="math inline">\(O(n^3)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>;<span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, inv2=(<span class="hljs-number">1e9</span>+<span class="hljs-number">8</span>)/<span class="hljs-number">2</span>;<span class="hljs-type">int</span> n, dep[N], fa[N][<span class="hljs-number">10</span>];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];ll ans, f[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;    ll ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) ans=ans*x%mod;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;    fa[x][<span class="hljs-number">0</span>]=fr, dep[x]=dep[fr]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;++i) fa[x][i]=fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">8</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">8</span>;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i], y=fa[y][i];    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-type">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1ll</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)        f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i][j<span class="hljs-number">-1</span>])*inv2%mod;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;j;++k) &#123;            <span class="hljs-type">int</span> l=<span class="hljs-built_in">lca</span>(j,k);            (ans+=f[dep[j]-dep[l]][dep[k]-dep[l]])%=mod;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans*<span class="hljs-built_in">fp</span>(n,mod<span class="hljs-number">-2</span>)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Edu Codeforces Round」#131 (Div.2)</title>
    <link href="/2022/cf1701-solution/"/>
    <url>/2022/cf1701-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1701</strong>.</p><h2 id="a.-grass-field">A. Grass Field</h2><h3 id="分析">分析</h3><p>有 <span class="math inline">\(0\)</span> 个草地，答案为 <spanclass="math inline">\(0\)</span>。</p><p>有 <span class="math inline">\(1 \sim 3\)</span> 个草地，答案为 <spanclass="math inline">\(1\)</span>。</p><p>有 <span class="math inline">\(4\)</span> 个草地，答案为 <spanclass="math inline">\(2\)</span>。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">int</span> t, a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;++j) a[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> cnt0=<span class="hljs-number">0</span>, cnt1=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;++j) &#123;<span class="hljs-keyword">if</span>(a[i][j]) ++cnt1; <span class="hljs-keyword">else</span> ++cnt0;&#125;<span class="hljs-keyword">if</span>(!cnt1) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt1&lt;<span class="hljs-number">4</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-permutation">B. Permutation</h2><h3 id="分析-1">分析</h3><p>对于区间 <span class="math inline">\([1,n]\)</span>，其中 <spanclass="math inline">\(n \neq 1\)</span>，那么当 <spanclass="math inline">\(d = 2\)</span>的时候，成倍数关系的数对是最多的。直接输出 <spanclass="math inline">\(2\)</span> 即可。</p><p>然后先把所有 <span class="math inline">\(1\)</span> 和 <spanclass="math inline">\([2,n]\)</span>之间的所有偶数加入排列，并把每个加入排列的数打标记。之后对于每个没有被打标记的数，用类似埃氏筛的方式筛去它和它的<span class="math inline">\(2\)</span> 次幂倍并加入排列。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, cnt, n, p[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2\n&quot;</span>);<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i&lt;&lt;=<span class="hljs-number">1</span>) v[i]=<span class="hljs-number">1</span>, p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j&lt;&lt;=<span class="hljs-number">1</span>) v[j]=<span class="hljs-number">1</span>, p[++cnt]=j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,p[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-schedule-management">C. Schedule Management</h2><h3 id="分析-2">分析</h3><p>工人工作是同时进行的，不论是贪心还是 DP 都做不了，我还是太弱了……</p><p>二分答案转判定，明明想到了的，却没写出来……</p><p>二分一个 <span class="math inline">\(mid\)</span>，表示用 <spanclass="math inline">\(mid\)</span> 小时能否完成 <spanclass="math inline">\(m\)</span>个任务。对于每个工人，所有任务只有两种类型：精通的和不精通的。所以一个很显然的贪心策略就是，每一个任务都优先让精通它的工人去完成。记录<span class="math inline">\(cnt_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个工人精通的任务数量。</p><p>当 <span class="math inline">\(cnt_i &lt; mid\)</span> 时，<spanclass="math inline">\(i\)</span> 不仅能够用 <spanclass="math inline">\(cnt_i\)</span>小时完成所有精通的任务，还有时间完成其他的任务，可是其他的任务只能用<span class="math inline">\(\frac{1}{2}\)</span>的效率来完成，所以这种情况下一共能完成的任务数量为 <spanclass="math inline">\(cnt_i + \frac{mid - cnt_i}{2}\)</span>。</p><p>否则只能够完成 <span class="math inline">\(cnt_i\)</span>个任务。</p><p>是不是一想就明白了呢？我还是趁早退役咯~</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, m, a[N], cnt[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;ll tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(cnt[i]&lt;x) tot+=cnt[i]+(x-cnt[i])/<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> tot+=x;&#125;<span class="hljs-keyword">return</span> tot&gt;=m;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cnt));n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) ++cnt[a[i]=<span class="hljs-built_in">read</span>()];<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) r=<span class="hljs-built_in">max</span>(r,cnt[i]*<span class="hljs-number">2</span>);<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-permutation-restoration">D. Permutation Restoration</h2><h3 id="分析-3">分析</h3><p>下文除法均向下取整。</p><p>对于每个 <spanclass="math inline">\(b_i\)</span>，都有一个「决策区间」。意思是，只要<span class="math inline">\(a_i\)</span>属于这个区间，那么就一定满足条件。</p><p>考虑求出这个区间，当 <span class="math inline">\(b_i\)</span> 为<span class="math inline">\(0\)</span> 的时候，只需要保证 <spanclass="math inline">\(i &lt; a_i\)</span> 就好了，所以决策区间的左端点是<span class="math inline">\(i+1\)</span>，右端点一定是 <spanclass="math inline">\(n\)</span>。</p><p>当 <span class="math inline">\(b_i &gt; 0\)</span>时，其左右端点一定在 <span class="math inline">\([1,i]\)</span>里面，那就查找最小的使得 <span class="math inline">\(\frac{i}{x} \leb_i\)</span> 的 <span class="math inline">\(x\)</span> 作为做端点（因为<span class="math inline">\(x\)</span> 越小左式越大），查找最大的使得<span class="math inline">\(\frac{i}{x} \ge b_i\)</span> 的 <spanclass="math inline">\(x\)</span> 作为右端点（因为 <spanclass="math inline">\(x\)</span> 越大左式越小）。可以使用二分查找。</p><p>打表发现，如果 <span class="math inline">\(b_i &gt;0\)</span>，那么左端点为 <span class="math inline">\(\frac{i}{b_i +1}+1\)</span>，右端点为 <spanclass="math inline">\(\frac{i}{b_i}\)</span>。证明？不会。</p><p>然后贪心，对于一个 <spanclass="math inline">\(i\)</span>，将所有以它为左端点的元素加入决策集合，排除所有右端点小于<span class="math inline">\(i\)</span> 的元素，找到右端点最小的 <spanclass="math inline">\(x\)</span> 并令 <span class="math inline">\(a_x =i\)</span>。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fst first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sec second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, m, b[N], d[N], ans[N];priority_queue&lt;PII &gt; q;vector&lt;<span class="hljs-type">int</span>&gt; v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span>&amp; l,<span class="hljs-type">int</span>&amp; r)</span> </span>&#123;<span class="hljs-type">int</span> L=a, R=b;<span class="hljs-keyword">while</span>(L&lt;R) &#123;<span class="hljs-type">int</span> mid=(L+R)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(b/mid&lt;=x) R=mid; <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>; &#125;l=L;L=a, R=b;<span class="hljs-keyword">while</span>(L&lt;R) &#123;<span class="hljs-type">int</span> mid=(L+R+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(b/mid&gt;=x) L=mid; <span class="hljs-keyword">else</span> R=mid<span class="hljs-number">-1</span>;&#125;r=L;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> l, r;<span class="hljs-keyword">if</span>(!b[i]) &#123; l=i+<span class="hljs-number">1</span>, r=n; <span class="hljs-keyword">goto</span> record; &#125;<span class="hljs-comment">// bsearch(1,i,b[i],l,r);</span>l=i/(b[i]+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>, r=i/b[i];record: v[l].<span class="hljs-built_in">pb</span>(i), d[i]=r;<span class="hljs-comment">// printf(&quot;b[%d]=%d l: %d r: %d\n&quot;,i,b[i],l,r);</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();++j)q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-d[v[i][j]],v[i][j]));<span class="hljs-keyword">if</span>(-q.<span class="hljs-built_in">top</span>().fst&lt;i) q.<span class="hljs-built_in">pop</span>();ans[q.<span class="hljs-built_in">top</span>().sec]=i, q.<span class="hljs-built_in">pop</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]), v[i].<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-text-editor">E. Text Editor</h2><p>没看，不会。</p><h2 id="f.-points">F. Points</h2><p>没看，不会。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1271D Portals 题解</title>
    <link href="/2022/cf1271d-solution/"/>
    <url>/2022/cf1271d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>不难发现，对于一个城堡，早驻守不如晚驻守。因为驻守早了完全没有额外收益，驻守晚了也没有额外代价。所以对于每个城堡<span class="math inline">\(x\)</span>，记录 <spanclass="math inline">\(d(x)\)</span> 为 <spanclass="math inline">\(x\)</span>的最晚可控制时间。也就是它必须在哪一个城堡被攻下之前，必须派兵驻守。特别的，如果某个城堡是独立的，令这个时间为它自身的编号。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为已经攻下了前 <spanclass="math inline">\(i\)</span> 个城堡，攻打第 <spanclass="math inline">\(i\)</span> 个城堡之后还剩下 <spanclass="math inline">\(j\)</span> 个人，所能获得的最大收益。对于 <spanclass="math inline">\(i=0\)</span> 的所有状态，它们的初始值为0，其余为负无穷。</p><p>设 <span class="math inline">\(A=\max_{i=1}^n{ \{ a_i\}}\)</span>，<span class="math inline">\(B=\max_{i=1}^n{\{ b_i\}}\)</span>。</p><p>对于攻打城堡，就像背包问题一样 <span class="math display">\[f(i,j+b_i) = \max_{j \in [a_i,A+B]}{\{ f(i-1,j) \}}\]</span> 对于派兵驻守，则是要贪心地按照 <spanclass="math inline">\(d(x)\)</span>递增的顺序来求解。排序后，已经驻守过的城堡不需要再次驻守，所以维护一个指针<span class="math inline">\(pos\)</span>，每驻守一个，<spanclass="math inline">\(pos+1\)</span>，驻守的时间 <spanclass="math inline">\(x\)</span> 的时间必须是 <spanclass="math inline">\(d(x)\)</span>。转移也是很简单的 <spanclass="math display">\[f(i,j) = \max_{j \in [0,A+B-1]}{\{ f(i,j+1) + c_{pos} \}}\]</span> 答案就是 <span class="math inline">\(\max_{i \in [0,A+B]}{\{f(n,i) \}}\)</span>。</p><p>大佬们都说这题比较简单，可是蒟蒻我感觉并不那么容易。首先虽然容易想到是以「占领的城堡数」和「人数」为状态的内容，但是由于它涉及2种转移，边界处理和转移顺序较为麻烦，所以使用了填表法和刷表法混用的方式。</p><p>第一种转移应当先于第二种转移，因为前者完成之后，后者以来的状态已经计算完毕。尽管第二种转移实质上也是0/1 背包（每个城堡占领不占领），但是 <spanclass="math inline">\(j\)</span> 依赖 <spanclass="math inline">\(j+1\)</span>的状态，所以倒序循环是错的，只能通过用另一种转移来计算。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, m, k, a[N], b[N], c[N], d[N];ll f[N][N];pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();        d[i]=i;        B+=b[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        d[y]=<span class="hljs-built_in">max</span>(d[y],x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">make_pair</span>(d[i],c[i]);    <span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x7f</span>,<span class="hljs-built_in">sizeof</span>(f));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a[i];j&lt;=k+B;++j)            <span class="hljs-keyword">if</span>(j+b[i]&lt;=k+B) f[i][j+b[i]]=<span class="hljs-built_in">max</span>(f[i][j+b[i]],f[i<span class="hljs-number">-1</span>][j]);        <span class="hljs-keyword">while</span>(pos&lt;=n&amp;&amp;p[pos].first==i) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;k+B;++j) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][j+<span class="hljs-number">1</span>]+p[pos].second);            ++pos;        &#125;    &#125;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k+B;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图匹配简单题 题解</title>
    <link href="/2022/graph-solution-1/"/>
    <url>/2022/graph-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>写一下近期写的简单二分图题目的题解。</p><h2 id="luogu3967-匹配">luogu3967 匹配</h2><h3 id="分析">分析</h3><p><span class="math inline">\(TJOI\)</span> 板子题 <spanclass="math inline">\(\times 1\)</span>。</p><p>找出所有完美匹配的交集，意思是无论任何完美匹配都包含这些边，反过来，如果没有这些边中任意一边，都不存在完美匹配。</p><p>由于数据范围小，直接用 DFS 版的 <spanclass="math inline">\(KM\)</span>算法求出带权最大匹配。然后枚举每一条匹配边， 把它的边权置为 <spanclass="math inline">\(0\)</span>，表示删去它。如果此时求出的带权最大匹配小于之前求出的带权最大匹配，那么这条边就是必须包含的边。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">150</span>, inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<span class="hljs-type">int</span> n, dlt, match[N], t[N], w[N][N], la[N], lb[N], slack[N];ll Ans;<span class="hljs-type">bool</span> va[N], vb[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> x, y; &#125; p[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;va[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=n;++y) <span class="hljs-keyword">if</span>(!vb[y]) &#123;<span class="hljs-keyword">if</span>(la[x]+lb[y]==w[x][y]) &#123;vb[y]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) &#123;match[y]=x; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> slack[y]=<span class="hljs-built_in">min</span>(slack[y],la[x]+lb[y]-w[x][y]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">KM</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;la[i]=-inf, lb[i]=<span class="hljs-number">0</span>;match[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) la[i]=<span class="hljs-built_in">max</span>(la[i],w[i][j]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">memset</span>(va,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(va)), <span class="hljs-built_in">memset</span>(vb,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vb));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) slack[j]=inf;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">break</span>;dlt=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!vb[j]) dlt=<span class="hljs-built_in">min</span>(dlt,slack[j]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(va[j]) la[j]-=dlt;<span class="hljs-keyword">if</span>(vb[j]) lb[j]+=dlt;&#125;&#125;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=la[i]+lb[i];<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i][j]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,Ans=<span class="hljs-built_in">KM</span>());<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) t[i]=match[i];    <span class="hljs-comment">// match在之后的KM算法中要被修改，所以记录原来的匹配边，</span><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=t[i], y=i, d=w[x][y];w[x][y]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">KM</span>()&lt;Ans) &#123;p[++tot].x=x, p[tot].y=y;&#125;w[x][y]=d;&#125;<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+tot+<span class="hljs-number">1</span>);    <span class="hljs-comment">// 要求排序再输出</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,p[i].x,p[i].y);&#125;</code></pre></div><h2 id="luogu4304-攻击装置">luogu4304 攻击装置</h2><h3 id="分析-1">分析</h3><p><span class="math inline">\(TJOI\)</span> 板子题 <spanclass="math inline">\(\times 2\)</span>。这个貌似和网络流 24题中的骑士共存问题很想，不是那么板，但是只要会跑最大匹配就能过。</p><p>首先观察这个东西的攻击范围，不难发现，对于 <spanclass="math inline">\((x,y)\)</span>，它能够攻击的点的横纵坐标相加一定与<span class="math inline">\(x+y\)</span>异奇偶。于是乎直接将横纵坐标相加为奇数的看作左部点，偶数的为右部点。为了防止重复计数，钦定如果<span class="math inline">\((x,y)\)</span>为左部点且能够放置，那么由它向能够攻击到的右部点连边。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/1q57l20q.png" srcset="/img/loading.gif" lazyloadalt="借用洛谷题解上的图片，侵删" /><figcaption aria-hidden="true">借用洛谷题解上的图片，侵删</figcaption></figure><p>由于放置的装置不能互相攻击，等价于选出这张二分图的最大独立集。用能够放置的点数减去最大匹配的边数即可。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T=<span class="hljs-number">205</span>, N=<span class="hljs-number">400005</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, dy[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-type">int</span> n, m, times, a[T][T], g[T][T], v[N];<span class="hljs-type">int</span> tot, match[N], h[N], to[<span class="hljs-number">8</span>*N], nxt[<span class="hljs-number">8</span>*N];<span class="hljs-comment">// 8倍空间</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(v[y]==times) <span class="hljs-keyword">continue</span>;        v[y]=times;        <span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) <span class="hljs-keyword">return</span> match[y]=x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xiongyali</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>((i+j)&amp;<span class="hljs-number">1</span>&amp;&amp;g[i][j]) &#123;        <span class="hljs-comment">// 从左部点 DFS</span>        ++times;        res+=<span class="hljs-built_in">dfs</span>(g[i][j]);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%1d&quot;</span>,&amp;a[i][j]);        <span class="hljs-keyword">if</span>(!a[i][j]) g[i][j]=++m;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)         <span class="hljs-keyword">if</span>(g[i][j]&amp;&amp;(i+j)&amp;<span class="hljs-number">1</span>)  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">8</span>;++k) &#123;            <span class="hljs-comment">// 放置重复，只从左部点开始连边</span>            <span class="hljs-type">int</span> x=i+dx[k], y=j+dy[k];            <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>&amp;&amp;y&gt;<span class="hljs-number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=n&amp;&amp;g[x][y]) <span class="hljs-built_in">add</span>(g[i][j],g[x][y])；        &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,m-<span class="hljs-built_in">xiongyali</span>());&#125;</code></pre></div><h2 id="luogu3033-cow-steeplechase">luogu3033 Cow Steeplechase</h2><h3 id="分析-2">分析</h3><p>首先两条线段如果平行，那么必定没有交点。那么把竖着的线段作为左部点，横着的线段作为右部点。那么同一个点集内没有边，左部点<span class="math inline">\(i\)</span> 与右部点 <spanclass="math inline">\(j\)</span>最多有一条匹配边，符合二分图匹配模型。</p><p>钦定 <span class="math inline">\(x_{i,1} \le x_{i,2}\)</span>，<spanclass="math inline">\(y_{i,1} \le y_{i,2}\)</span>。</p><p>对于线段 <spanclass="math inline">\((x_{i,1},y_{i,1})\)</span>，<spanclass="math inline">\((x_{i,2},y_{i,2})\)</span> 和 <spanclass="math inline">\((x_{j,1},y_{j,1})\)</span>，<spanclass="math inline">\((x_{j,2},y_{j,2})\)</span>，它们相交的条件是</p><ol type="1"><li><span class="math inline">\(i\)</span> 是竖着的边，<spanclass="math inline">\(j\)</span> 是横着的边。那么要满足 <spanclass="math inline">\(x_{i,1} \ge x_{j,1}\)</span> 且 <spanclass="math inline">\(y_{i,1} \le y_{j,1}\)</span> 且 <spanclass="math inline">\(x_{i,2} \le x_{j,2}\)</span> 且 <spanclass="math inline">\(y_{i,2} \ge y_{j,2}\)</span>。</li><li><span class="math inline">\(i\)</span> 是横着的边，<spanclass="math inline">\(j\)</span>是竖着的边。那么就把上面的符号反过来。</li></ol><p>选出最多的不相交线段，等价于二分图最大独立集。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, x1[N], y11[N], x2[N], y2[N];<span class="hljs-type">int</span> tot, match[N], h[N], to[N], nxt[N];<span class="hljs-type">bool</span> l[N], v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(v[y]) <span class="hljs-keyword">continue</span>;        v[y]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) <span class="hljs-keyword">return</span> match[y]=x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xiongyali</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(l[i]) &#123;        <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));        res+=<span class="hljs-built_in">dfs</span>(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        x1[i]=<span class="hljs-built_in">read</span>(), y11[i]=<span class="hljs-built_in">read</span>();        x2[i]=<span class="hljs-built_in">read</span>(), y2[i]=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span>(x1[i]&gt;x2[i]) <span class="hljs-built_in">swap</span>(x1[i],x2[i]);        <span class="hljs-keyword">if</span>(y11[i]&gt;y2[i]) <span class="hljs-built_in">swap</span>(y11[i],y2[i]);        <span class="hljs-keyword">if</span>(x1[i]==x2[i]) ++m, l[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// m是左部点数量，也就是竖着的边</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;        <span class="hljs-keyword">if</span>(l[i]&amp;&amp;!l[j]) &#123;            <span class="hljs-keyword">if</span>(x1[i]&gt;=x1[j]&amp;&amp;y11[i]&lt;=y11[j]&amp;&amp;x2[i]&lt;=x2[j]&amp;&amp;y2[i]&gt;=y2[j])                <span class="hljs-built_in">add</span>(i,j+m);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!l[i]&amp;&amp;l[j]) &#123;            <span class="hljs-keyword">if</span>(x1[i]&lt;=x1[j]&amp;&amp;y11[i]&gt;=y11[j]&amp;&amp;x2[i]&gt;=x2[j]&amp;&amp;y2[i]&lt;=y2[j])                <span class="hljs-built_in">add</span>(j,i+m);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-<span class="hljs-built_in">xiongyali</span>());&#125;</code></pre></div><h2 id="luogu4589-智力竞赛">luogu4589 智力竞赛</h2><h3 id="分析-3">分析</h3><p><span class="math inline">\(TJOI\)</span> 板子题 <spanclass="math inline">\(\times 3\)</span>。</p><p>首先明确，每个人答题顺序一定是一条简单路径，可以有人答相同的题目。而且所有题目构成一个DAG。</p><p>好了，DAG 最小路径可重复点覆盖。</p><p>二分答案，找到一个 <span class="math inline">\(mid\)</span>表示只能回答价值小于 <span class="math inline">\(mid\)</span>的问题。如果求得的路径条数小于 <spanclass="math inline">\(n+1\)</span>（亲友团加上小明），那么说明可行。特别的，如果回答所有问题也能满足条件的话，输出<code>AK</code>。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, T, a[N][N], d[N], match[N], v[N], vis[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=m;++y) <span class="hljs-keyword">if</span>(vis[y]!=T&amp;&amp;a[d[x]][d[y]]) &#123;        vis[y]=T;        <span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) <span class="hljs-keyword">return</span> match[y]=x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) match[i]=d[i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(v[i]&lt;x) d[++cnt]=i;    <span class="hljs-type">int</span> ans=cnt;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i)  &#123;        ++T; ans-=<span class="hljs-built_in">dfs</span>(i);    &#125;    <span class="hljs-keyword">return</span> ans&lt;=n+<span class="hljs-number">1</span>;&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        r=<span class="hljs-built_in">max</span>(r,v[i]=<span class="hljs-built_in">read</span>()); <span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">while</span>(k--) &#123;            <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();            a[i][x]=<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;++k)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)                a[i][j]|=a[i][k]&amp;a[k][j];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(inf)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;AK&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">while</span>(l&lt;r) &#123;        <span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1349A Orac and LCM 题解</title>
    <link href="/2022/cf1349a-solution/"/>
    <url>/2022/cf1349a-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p><span class="math display">\[\gcd_{i,j \in [1,n] \text{ and } i&lt; j} \{\operatorname{lcm}(a_i,a_j)  \}\]</span></p><p><span class="math display">\[\gcd_{i,j \in [1,n] \text{ and } i &lt; j} \{  \frac{a_i\cdot  a_j}{\gcd(a_i,a_j)} \}\]</span></p><p>两两元素的最大公约数就是整个序列的最大公约数。<spanclass="math inline">\(\gcd(ka,kb)=k \gcd(a,b)\)</span>。 <spanclass="math display">\[\frac{\gcd_{i,j \in [1,n] \text{ and } i &lt; j} \{a_i,a_j \} }{\gcd \{a_1,a_2 \ldots a_n \}}\]</span> 对于 <span class="math inline">\(i \in[1,n]\)</span>，它对分数线上面的式子的贡献是 <spanclass="math inline">\(\gcd(a_i,a_{i+1} \ldotsa_{n})\)</span>，预处理后缀 <span class="math inline">\(\gcd\)</span>即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n;ll a[N], d[N];<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> x/<span class="hljs-built_in">gcd</span>(x,y)*y; &#125;<span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;ll a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ll ans=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) d[i]=<span class="hljs-built_in">gcd</span>(a[i],d[i+<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">gcd</span>(ans,a[i]*d[i+<span class="hljs-number">1</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/d[<span class="hljs-number">1</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#804 (Div. 2)</title>
    <link href="/2022/cf1699-solution/"/>
    <url>/2022/cf1699-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p><strong>CF1699</strong>.</p><h2 id="a.-the-third-three-number-problem">A. The Third Three NumberProblem</h2><h3 id="分析">分析</h3><p>首先判断无解。</p><p>异或运算可以看作二进制「不进位加法」，而在二进制加法中，第一位也不会存在进位，所以<span class="math inline">\((a \oplus b) + (b \oplus c) + (a \oplusc)\)</span> 与 $(a+b) + (b + c) + (a + c) = 2(a+b+c) $ 奇偶性相同。所以<span class="math inline">\(n\)</span> 必然是个偶数，当 <spanclass="math inline">\(n\)</span> 为奇数时无解。</p><p>考虑 <span class="math inline">\(a,b,c\)</span> 可以相同且能够取<span class="math inline">\(0\)</span>，而 <span class="math inline">\(0\oplus x = x\)</span>，那么只要取 <spanclass="math inline">\(a=0\)</span>，<spanclass="math inline">\(b=0\)</span>，<span class="math inline">\(c =\frac{n}{2}\)</span> 就能够满足条件。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> t, n;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n/<span class="hljs-number">2</span>);    &#125;&#125;</code></pre></div><h2 id="b.-almost-ternary-matrix">B. Almost Ternary Matrix</h2><h3 id="分析-1">分析</h3><p>很关键的一点，<span class="math inline">\(n\)</span> 与 <spanclass="math inline">\(m\)</span> 都是偶数。</p><p>称如下矩形为 <span class="math inline">\(1\)</span> 类矩形。</p><p><img src="https://s2.loli.net/2022/07/05/M6ODlKLtgupzB5I.png" srcset="/img/loading.gif" lazyload /></p><p>称如下矩形为 <span class="math inline">\(2\)</span> 类矩形。</p><p><img src="https://s2.loli.net/2022/07/05/AnOC8UNtj64hYiK.png" srcset="/img/loading.gif" lazyload /></p><p>那么，无论 <span class="math inline">\(n\)</span> 与 <spanclass="math inline">\(m\)</span> 取何值，<span class="math inline">\(n\times m\)</span> 的矩阵必然能够由若干 <spanclass="math inline">\(1\)</span> 类与 <spanclass="math inline">\(2\)</span> 类矩形构成。不难发现，对于单个的 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span> 类矩形，一定满足条件。如果在 <spanclass="math inline">\(1\)</span> 类矩形的左边或右边拼上一个 <spanclass="math inline">\(2\)</span>类矩形，仍然满足条件，反之亦然；如果在一个 <spanclass="math inline">\(1\)</span> 类矩形的上方或下方拼上一个 <spanclass="math inline">\(2\)</span> 类矩形，仍然满足条件，反之亦然。</p><p>那么对于每 <span class="math inline">\(2\)</span> 行，每 <spanclass="math inline">\(2\)</span> 列，交替填入 <spanclass="math inline">\(1\)</span> 类或 <spanclass="math inline">\(2\)</span> 类矩形就得到答案了。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> t, m, n, ans[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-type">const</span> <span class="hljs-type">int</span> SB1[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=&#123;    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> SB2[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=&#123;    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ans));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,fg1=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>,fg1^=<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,fg2=<span class="hljs-number">1</span>;j&lt;=m;j+=<span class="hljs-number">2</span>,fg2^=<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 注意原本两行算一行，两列算一列</span>            <span class="hljs-keyword">if</span>(fg1&amp;&amp;fg2||!fg1&amp;&amp;!fg2) &#123;                <span class="hljs-comment">// 在奇数行中，奇数个放 1 类</span>                <span class="hljs-comment">// 在偶数行中，偶数个放 1 类</span>                ans[i][j]=SB1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], ans[i][j+<span class="hljs-number">1</span>]=SB1[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];                ans[i+<span class="hljs-number">1</span>][j]=SB1[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=SB1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fg1&amp;&amp;!fg2||!fg1&amp;&amp;fg2) &#123;                <span class="hljs-comment">// 在奇数行中，偶数个放 2 类</span>                <span class="hljs-comment">// 在偶数行中，奇数个放 2 类</span>                ans[i][j]=SB2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], ans[i][j+<span class="hljs-number">1</span>]=SB2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];                ans[i+<span class="hljs-number">1</span>][j]=SB2[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=SB2[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i,<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i][j]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve1</span>();&#125;</code></pre></div><h2 id="c.-the-third-problem">C. The Third Problem</h2><h3 id="分析-2">分析</h3><p><spanclass="math inline">\(\operatorname{MEX}\)</span>，完全不会啊！</p><p>首先对于任意 <span class="math inline">\(l,r \in [1,n]\)</span>，满足<span class="math display">\[\operatorname{MEX}([a_l,a_{l+1},\ldots,a_r])=\operatorname{MEX}([b_l,b_{l+1},\ldots,b_r])\]</span> 这表明，假如他们的值为 <spanclass="math inline">\(x\)</span>，那么 <spanclass="math inline">\([1,x-1]\)</span> 一定都在 <spanclass="math inline">\([l,r]\)</span> 中出现过了。</p><p>设 <span class="math inline">\(p(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 在 <spanclass="math inline">\(a\)</span> 中的位置，由于是 <spanclass="math inline">\([0,n-1]\)</span>的排列，所以为了防止混淆，下文无论是数字都是 <spanclass="math inline">\([0,n-1]\)</span> 中的。</p><p>尝试直接构造 <span class="math inline">\(b\)</span>。首先，<spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 中 <spanclass="math inline">\(0\)</span> 的位置是不能变化的，否则 <spanclass="math inline">\(\operatorname{MEX} ([a_{p(0)},a_{p(0)}])\)</span>必然不同于 <span class="math inline">\(\operatorname{MEX}([b_{p(0)},b_{p(0)}])\)</span>。<span class="math inline">\(1\)</span>的位置也不能变化，可以轻松构造例子，不再赘述。</p><p>设当前区间为 <span class="math inline">\(l,r\)</span>，假设 <spanclass="math inline">\(p(0)&lt; p(1)\)</span>，起初 <spanclass="math inline">\(l=p(0)\)</span>，<spanclass="math inline">\(r=p(1)\)</span>。</p><p>如果 <span class="math inline">\(p(2) \in [l,r]\)</span>，那么 <spanclass="math inline">\(2\)</span> 放在哪里都可以。因为此时这个区间的<span class="math inline">\(\operatorname{MEX}\)</span> 已经和 <spanclass="math inline">\(0,1,2\)</span> 无关了，由于 <spanclass="math inline">\(0,1\)</span> 已经被确定，方案数累乘 <spanclass="math inline">\((r-l+1) -2\)</span>。如果 <spanclass="math inline">\(p(2)&lt;p(0)\)</span> 或者 <spanclass="math inline">\(p(2)&gt;p(1)\)</span> 呢？那就令 <spanclass="math inline">\(l=p(2)\)</span> 或者 <spanclass="math inline">\(r=p(2)\)</span>。同时对方案数没有贡献，因为只要<span class="math inline">\(2\)</span> 不在 <spanclass="math inline">\(b_{p(2)}\)</span>的位置，一定不合法，同样很容易找出例子。</p><p>接下来，如果 <span class="math inline">\(p(3) \in[l,r]\)</span>，那么分两种情况讨论</p><ul><li>在上一轮中，<span class="math inline">\(p(2) \in[l&#39;,r&#39;]\)</span>，那么此时 <spanclass="math inline">\([l&#39;,r&#39;] = [l,r]\)</span>，确定了 <spanclass="math inline">\(0,1,2\)</span> 的位置，<spanclass="math inline">\(3\)</span> 只有 <spanclass="math inline">\((r-l+1) - 3\)</span> 种选择，累乘即可。</li><li>在上一轮中，<span class="math inline">\(p(2) \notin[l,r]\)</span>，那么区间的边界一定会变化并让 <spanclass="math inline">\(p(2)\)</span> 在新区间的一端，仍然确定了 <spanclass="math inline">\(0,1,2\)</span>，累乘 <spanclass="math inline">\((r-l+1)-3\)</span>。</li></ul><p>如果 <span class="math inline">\(p(3) \neq[l,r]\)</span>，修改区间就行了。</p><p>以此类推，最终就能得到答案。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> t, n, a[N], p[N];ll ans;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    ans=<span class="hljs-number">1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), p[a[i]]=i;    <span class="hljs-type">int</span> l=p[<span class="hljs-number">0</span>], r=p[<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l,r);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">if</span>(p[i]&lt;l) l=p[i];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[i]&gt;r) r=p[i];        <span class="hljs-keyword">else</span> &#123;            (ans*=(r-l+<span class="hljs-number">1</span>)-i)%=mod;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-almost-triple-deletions">D. Almost Triple Deletions</h2><p>先证明一个结论，如果一个区间 <spanclass="math inline">\([l,r]\)</span>，满足 <spanclass="math inline">\(a_l \ldots a_r\)</span>能够用题目中的操作完全删去，那么一定满足 <spanclass="math inline">\(r-l+1\)</span> 是偶数且 <spanclass="math inline">\([l,r]\)</span>中出现次数最多的数，其出现次数不超过 <spanclass="math inline">\(\frac{r-l+1}{2}\)</span>。</p><blockquote><p>证明：</p><p>每一次操作只能选择 <span class="math inline">\(2\)</span> 个数，如果<span class="math inline">\(r-l+1\)</span>是个奇数，显然不行。而每次操作只能选择 <spanclass="math inline">\(2\)</span> 个不同的数，如果某个数出现次数超过了<spanclass="math inline">\(\frac{r-l+1}{2}\)</span>，那么将这个数与一个与它不想等的数两两配对后，会只剩下这个数，无法进行操作。</p></blockquote><p>考虑 <span class="math inline">\(DP\)</span>。</p><p>设 <span class="math inline">\(f(i)\)</span> 为由 <spanclass="math inline">\([1,i-1]\)</span> 某些子序列和 <spanclass="math inline">\(a_i\)</span> 构成的最终序列的长度。初始时，如果<span class="math inline">\([1,i-1]\)</span> 能够完全删去，<spanclass="math inline">\(f(i)=1\)</span>，表示长度为 <spanclass="math inline">\(1\)</span> 的序列。否则 <spanclass="math inline">\(f(i)=0\)</span>，表示长度为 <spanclass="math inline">\(0\)</span> 的子序列。</p><p>转移，枚举 <span class="math inline">\(j \in [i+1,n+1]\)</span>，如果<span class="math inline">\(a_i = a_j\)</span> 并且 <spanclass="math inline">\([i+1,j-1]\)</span> 这一段能够完全消掉，那么就能将<span class="math inline">\(a_j\)</span> 放在 <spanclass="math inline">\(a_i\)</span> 后面，<spanclass="math inline">\(f(j) = f(i) +1\)</span>。需要注意的是 <spanclass="math inline">\(i\)</span> 必须满足 <spanclass="math inline">\(f(i) &gt; 0\)</span>，因为最终序列只能由相同数字构成，而上述转移让 <spanclass="math inline">\(j\)</span> 从 <spanclass="math inline">\(i+1\)</span> 开始，默认了 <spanclass="math inline">\([i,i-1]\)</span> 这部分能被消去。</p><p>特别地，当 <span class="math inline">\(j=n+1\)</span> 时，如果 <spanclass="math inline">\([i+1,n]\)</span> 能被消去，就让 <spanclass="math inline">\(f(n+1)=f(i) +1\)</span>。最终答案是 <spanclass="math inline">\(f(n+1)-1\)</span>。</p><p>为啥要这么干？因为状态时这样设计的，核心思想是将两个想等元素之间所有元素消除之后，让这两个元素使得答案序列长度<span class="math inline">\(+1\)</span>。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> t, n, a[N], f[N], cnt[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cnt[i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    f[<span class="hljs-number">0</span>]=f[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> most_element=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) &#123;        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>&amp;&amp;most_element&lt;=(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>) f[i]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> f[i]=<span class="hljs-number">0</span>;        most_element=<span class="hljs-built_in">max</span>(most_element,++cnt[a[i]]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> awa=<span class="hljs-number">1</span>;awa&lt;=n;++awa) cnt[awa]=<span class="hljs-number">0</span>;        most_element=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(f[i]) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n+<span class="hljs-number">1</span>;++j) &#123;            <span class="hljs-keyword">if</span>((j-i)%<span class="hljs-number">2</span>&amp;&amp;most_element&lt;=(j-i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>&amp;&amp;(a[i]==a[j]||j==n+<span class="hljs-number">1</span>))                f[j]=<span class="hljs-built_in">max</span>(f[j],f[i]+<span class="hljs-number">1</span>);            most_element=<span class="hljs-built_in">max</span>(most_element,++cnt[a[j]]);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-three-days-grace">E. Three Days Grace</h2><p>太菜了看都没看。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF359B Permutation 题解</title>
    <link href="/2022/cf359b-solution/"/>
    <url>/2022/cf359b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>小清新构造题。</p><p>不难发现，对于一个有序序列，假设是 <span class="math display">\[[1,2,3,4,5,6]\]</span> 那么 <span class="math display">\[\sum_{i=1}^3 | a_{2i} - a_{2i-1} | = | \sum_{i=1}^3  a_{2i} - a_{2i-1} |= 3\]</span> 把 <span class="math inline">\(2\)</span> 提前， <spanclass="math display">\[[2,1,3,4,5,6]\]</span> 发现得到的结果是 <span class="math inline">\(2\)</span>。</p><p>把 <span class="math inline">\(3\)</span> 提前， <spanclass="math display">\[[3,1,2,4,5,6]\]</span> 发现得到的结果是 <span class="math inline">\(4\)</span>。</p><p>把 <span class="math inline">\(j\)</span> 提前，<spanclass="math inline">\(a_2-a_1=1 - j =-(j-1)\)</span>，而在左式中直接绝对值没了，对答案贡献 <spanclass="math inline">\(j-1\)</span>，而右式则会让答案减少 <spanclass="math inline">\(j-1\)</span>。其他的都是一一对应的，一减就没了。那么把<span class="math inline">\(j\)</span> 提前的答案就是 <spanclass="math inline">\(2 \cdot (j-1)\)</span>。</p><p>直接把 <span class="math inline">\(k+1\)</span>提前，其他的顺序输出。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n, k;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k), n&lt;&lt;=<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,k+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k+<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,i,<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4852 yyf hates choukapai 题解</title>
    <link href="/2022/lg4852-solution/"/>
    <url>/2022/lg4852-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>不是那么显然的 DP。</p><p>对于每一次连抽，只会累计开始连抽的那张卡的欧气值，损失之后 <spanclass="math inline">\(c-1\)</span>张卡的欧气值。而单抽则不会损失欧气值。题目要求最大化欧气值，那么就是要尽量减小连抽损失的欧气值。</p><p>形式化地，对于一次在 <span class="math inline">\(i\)</span>位置开始的连抽，得到 <span class="math inline">\(a_i\)</span>，损失<span class="math inline">\(\sum_{j=i+1}^{i+c-1} a_i\)</span>的欧气。对于 <span class="math inline">\(j\)</span> 位置的单抽，只会得到<span class="math inline">\(a_j\)</span> 的欧气值。设 <spanclass="math inline">\(b_i = \sum_{j=i+1}^{i+c-1}a_i\)</span>，那么目标为最小化选出的 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(b_i\)</span>。可以用前缀和预处理。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为进行了 <spanclass="math inline">\(j\)</span> 次连抽，其中第 <spanclass="math inline">\(j\)</span> 次连抽从 <spanclass="math inline">\(i\)</span> 开始，且 <spanclass="math inline">\([1,i-1]\)</span> 已经抽完了，所能选出 <spanclass="math inline">\(j\)</span> 个 <spanclass="math inline">\(\{b\}\)</span> 中元素的最小值。</p><p>思路是枚举上一次连抽的位置，由于两次连抽中间必然全是单抽且不成超过<span class="math inline">\(d\)</span> 次，而连抽必须抽 <spanclass="math inline">\(c\)</span> 个，那么对于 <spanclass="math inline">\(f(i,j)\)</span>，上一次连抽的位置 <spanclass="math inline">\(i&#39; \in[i-c-d,i-c]\)</span>。确定位置之后，直接加上 <spanclass="math inline">\(b_i\)</span> 就行。</p><p><span class="math display">\[f(i,j) = \min_{i&#39; \in [i-c-d,i-c]} \{ f(i&#39;,j-1)  + b_i \}\]</span></p><p>设 <span class="math inline">\(len = n \times c +m\)</span>，则复杂度为 <span class="math inline">\(O(n \cdotlen^2)\)</span>。</p><p>对于 <span class="math inline">\(i &gt; i_0\)</span>，<spanclass="math inline">\(i\)</span> 的合法决策区间的左右端点必然严格大于<span class="math inline">\(i_0\)</span>的合法决策区间的左右端点，直接单调队列优化。</p><p>对于能够成为答案的 <spanclass="math inline">\(f(i,n)\)</span>，必须满足<spanclass="math inline">\(i \in [1,len-c+1]\)</span> 且 <spanclass="math inline">\(len-(i+c-1) \led\)</span>，即最后一次连抽后单抽不能超过 <spanclass="math inline">\(d\)</span> 次。</p><p>最终答案 <span class="math inline">\(\sum_{i=1}^n a_i -\max\{f(i,n)\}\)</span>。</p><p>复杂度 <span class="math inline">\(O(n \cdot len)\)</span> 。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200005</span>;<span class="hljs-type">int</span> n, m, c, d, a[N], q[N], pre[N][<span class="hljs-number">45</span>];ll s[N], b[N], f[N][<span class="hljs-number">45</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> t)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!i) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">print</span>(pre[i][t],t<span class="hljs-number">-1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();    <span class="hljs-type">int</span> len=c*n+m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len-c+<span class="hljs-number">1</span>;++i) b[i]=s[i+c<span class="hljs-number">-1</span>]-s[i];    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=d+<span class="hljs-number">1</span>;++i) f[i][<span class="hljs-number">1</span>]=b[i];    <span class="hljs-comment">// 注意第一次连抽的位置区间是[1,d+1]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) &#123;        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len-c+<span class="hljs-number">1</span>;++i) &#123;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;i-c-d) ++l;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;i-c&gt;<span class="hljs-number">0</span>&amp;&amp;f[i-c][j<span class="hljs-number">-1</span>]&lt;f[q[r]][j<span class="hljs-number">-1</span>]) --r;            <span class="hljs-keyword">if</span>(i-c&gt;<span class="hljs-number">0</span>) q[++r]=i-c;            <span class="hljs-keyword">if</span>(l&lt;=r&amp;&amp;q[l]&gt;=i-c-d&amp;&amp;q[l]&lt;=i-c) f[i][j]=f[q[l]][j<span class="hljs-number">-1</span>]+b[i], pre[i][j]=q[l];        &#125;    &#125;    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;    ll ans=<span class="hljs-number">1e15</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len-c+<span class="hljs-number">1</span>;++i) &#123;        <span class="hljs-type">int</span> j=i+c<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(len-j&lt;=d&amp;&amp;ans&gt;f[i][n]) ans=f[i][n], p=i;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s[len]-ans);    <span class="hljs-built_in">print</span>(p,n);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#5 网络流定义与最大流</title>
    <link href="/2022/notes-graph-5/"/>
    <url>/2022/notes-graph-5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="定义">定义</h2><p>一个网络 <span class="math inline">\(G= (V,E)\)</span>是一张有向图，对于每条有向边 <span class="math inline">\((x \rightarrowy)\)</span> 都有一个权值 <spanclass="math inline">\(c(x,y)\)</span>，称之为这条边的<strong>容量</strong>。另外，存在特殊节点<span class="math inline">\(S\)</span>，称为<strong>源点</strong>；<spanclass="math inline">\(T\)</span>，称为<strong>汇点</strong>。</p><p>设函数 <span class="math inline">\(f(x,y)\)</span>，其定义域为 <spanclass="math inline">\(x,y \in V\)</span>，满足</p><ol type="1"><li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 <spanclass="math inline">\(f(x,y) \le c(x,y)\)</span></li><li>斜对称性：每条边的流量与其相反边的流量之和为 0，即 <spanclass="math inline">\(f(x,y) = -f(y,x)\)</span></li><li>流守恒性：从源点流出的流量等于汇点流入的流量，即 <spanclass="math inline">\(\sum_{(u ,x) \in E} f(u,x) = \sum_{(x,v) \in E}f(x,v)\)</span></li></ol><p>那么称 <span class="math inline">\(f\)</span>为这个网络的<strong>流函数</strong>，对于边 <spanclass="math inline">\((x \rightarrow y)\)</span>，<spanclass="math inline">\(f(x,y)\)</span>称为它的<strong>流量</strong>，<spanclass="math inline">\(c(x,y)-f(x,y)\)</span>称为它的<strong>剩余容量</strong>。</p><p>整个网络的流量为<strong>从源点发出的所有流量之和</strong>，即 <spanclass="math inline">\(\sum_{(S,x) \in E} f(S,x)\)</span>。</p><p>由于流量守恒性质，可以知道<strong>除了源点与汇点之外，其他的节点不储存流，「流」只是从源点流出，流经整个网络，最终归于汇点</strong>。</p><h2 id="最大流">最大流</h2><p>对于一个网络，有很多合法的流函数，但是使得整个网络的流量最大的流函数<span class="math inline">\(f\)</span>，也就是 <spanclass="math inline">\(\sum_{(S,x) \in E} f(S,x)\)</span>，这样的流函数<span class="math inline">\(f\)</span>称为该网络的<strong>最大流</strong>。</p><h3 id="edmonds-karp-算法">Edmonds-Karp 算法</h3><p>是 Ford-Fulkerson 方法基于 BFS 的一个实现。</p><p>如果存在一条从源点 <span class="math inline">\(S\)</span> 到汇点<span class="math inline">\(T\)</span>的路径，满足每一条边的剩余容量都大于 <spanclass="math inline">\(0\)</span>，那么称这条路径为一条<strong>增广路</strong>，注意不同于二分图匹配中的增广路。</p><p>如果让更多的流沿着 <span class="math inline">\(S\)</span> 流到 <spanclass="math inline">\(T\)</span>，那么就能使网络流量增大，且这个值为路径上最小的剩余容量。Edmonds-Karp算法的思想是利用 BFS不断寻找增广路，知道网络中不存在增广路。此时不可能增加网络的流量，那么必然得到了最大流。</p><p>具体流程如下</p><p>在寻找增广路的过程中，只考虑 <span class="math inline">\(f(x,y) &lt;c(x,y)\)</span> 的边，用 BFS 找到任意 <spanclass="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的路径， 计算出路径上最小的剩余容量<span class="math inline">\(minf\)</span>，同时累加总流量。</p><p>如果存在一条边满足 <span class="math inline">\(f(x,y) &gt;0\)</span>，那么它的反向边有 <span class="math inline">\(f(y,x) &lt;0\)</span>，此时 <span class="math inline">\(f(y,x) &lt;c(y,x)\)</span>，由于 <span class="math inline">\(c(x,y) =c(y,x)\)</span>，那么反向边也有可能成为增广路的一部分，应该考虑边集<span class="math inline">\(E\)</span>中每条边的反向边。我一开始有一个小问题，网络不是有向图吗？为什么也能用反向边呢？后来想明白了，并不是网络中真的有了反向边，对于<span class="math inline">\((x \rightarrowy)\)</span>，选择它的反边相当于把通过它的流退了回来，并且能够发现新的增广路。</p><p>图解。</p><figure><img src="https://s2.loli.net/2022/07/03/16qMpVeyK2LswTm.png" srcset="/img/loading.gif" lazyloadalt="一个普通的网络" /><figcaption aria-hidden="true">一个普通的网络</figcaption></figure><p>初始状态，钦定 <span class="math inline">\(1\)</span> 为源点，<spanclass="math inline">\(6\)</span> 为汇点。</p><p>手动 BFS 找到一条增广路 <span class="math inline">\((1 \rightarrow 2\rightarrow 5 \rightarrow6)\)</span>，同时发现无法再找到增广路了。将增广路上的边都增加上最小的剩余容量<span class="math inline">\(2\)</span>。最大流是 <spanclass="math inline">\(2\)</span> 吗？</p><p><img src="https://s2.loli.net/2022/07/03/mLOMUrCnN5JKicV.png" srcset="/img/loading.gif" lazyload /></p><p>建立反向边，发现新的增广路 <span class="math inline">\((1 \rightarrow4 \rightarrow 5 \rightarrow 2 \rightarrow 3 \rightarrow6)\)</span>，其中只有 <span class="math inline">\(2\)</span>走的是原来边的反向边。将路径上走正向边都加上最小剩余容量 <spanclass="math inline">\(1\)</span>，走反向边的都减去最小剩余容量 <spanclass="math inline">\(1\)</span>。可以验证这条增广路是合法的，且最大流又增加了<span class="math inline">\(1\)</span>。</p><p><img src="https://s2.loli.net/2022/07/03/45KP8yjOaHYidJN.png" srcset="/img/loading.gif" lazyload /></p><p>注意画出的红蓝箭头指的是两条增广路，不是网络的真是流向，但是根据增广路可以构造出合法的流向。由于<span class="math inline">\((2 \rightarrow 5)\)</span> 减去了 <spanclass="math inline">\(1\)</span>，但是在 <span class="math inline">\((2\rightarrow 3)\)</span> 又加上了 <spanclass="math inline">\(1\)</span>，所以总流量不变， <spanclass="math inline">\((1 \rightarrow 2)\)</span>的流能通过<strong>分流</strong>的方式到达汇点。<spanclass="math inline">\((1 \rightarrow 2)\)</span> 分流导致原来走的 <spanclass="math inline">\((5 \rightarrow 6)\)</span>也腾出了空间，正好能容纳 <span class="math inline">\((4 \rightarrow5)\)</span> 流过来的部分。图中写出来的边权 <spanclass="math inline">\(f(x,y)/c(x,y)\)</span> 是正向边的流量。</p><p>图中流的路径为 <span class="math inline">\((1 \rightarrow 4\rightarrow 5 \rightarrow 6)\)</span>，<span class="math inline">\((1\rightarrow 2 \rightarrow 5 \rightarrow 6)\)</span> 和 <spanclass="math inline">\((1 \rightarrow 2 \rightarrow 3 \rightarrow6)\)</span>，每条流量都为 <spanclass="math inline">\(1\)</span>。这样做才能求得最大流 <spanclass="math inline">\(3\)</span>。</p><p>还有一点，EK 算法遍历的是网络中所有节点和剩余容量大于 <spanclass="math inline">\(0\)</span>的边构成的子图，称为<strong>残量网络</strong>。代码中的边权都是<strong>残量网络的边权</strong>，也就是还能容纳多少。对于一条正向边<span class="math inline">\((x \rightarrow y)\)</span>，容量为 <spanclass="math inline">\(z\)</span>。初始还能容纳 <spanclass="math inline">\(z\)</span>，所以加边<code>add(x,y,z)</code>，而其反向边则是<code>add(y,x,0)</code>，只有正向边减少才能为反向边腾出空间。</p><p>于是乎 EK 算法就没有悬念了，上代码。</p><p>复杂度 <spanclass="math inline">\(O(nm^2)\)</span>，实际远远达不到这个上界，<del>但依然很慢</del>，大概能处理<span class="math inline">\(n=10^3 \sim 10^4\)</span> 规模的网络。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x7fffffff</span>, N=<span class="hljs-number">205</span>, M=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, m, s, t, pre[N], F[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>], w[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-comment">// 注意tot=1</span><span class="hljs-type">bool</span> v[N];ll maxflow;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 快读</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));    <span class="hljs-comment">// v[i]表示i是否被访问过</span>v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);F[s]=inf;    <span class="hljs-comment">// 源点为正无穷</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(v[y]||!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 被访问过或者剩余容量为0</span>F[y]=<span class="hljs-built_in">min</span>(F[x],z);pre[y]=i;            <span class="hljs-comment">// 记录增广路上的边</span>v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            <span class="hljs-comment">// 到达汇点，找到增广路</span>&#125; &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 不存在</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> x=t;<span class="hljs-keyword">while</span>(x!=s) &#123;<span class="hljs-type">int</span> i=pre[x];w[i]-=F[t], w[i^<span class="hljs-number">1</span>]+=F[t];        <span class="hljs-comment">// 正向边剩余容量减少，反向边剩余容量增加</span>x=to[i^<span class="hljs-number">1</span>];        <span class="hljs-comment">// 因为从tot=1开始储存，所以i^1定位到i的反向边</span>&#125;maxflow+=F[t];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);        <span class="hljs-comment">// 反向边权值（剩余容量）最初为0</span>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-built_in">update</span>();    <span class="hljs-comment">// 存在增广路就更新</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,maxflow);&#125;</code></pre></div><h3 id="dinic-算法">Dinic 算法</h3><p>EK 算法每轮可能会遍历整个残量网络，但是最多找出 1条增广路，效率较低。</p><p>设 <span class="math inline">\(d(x)\)</span> 为起点到 <spanclass="math inline">\(x\)</span>最小的边数，称为<strong>层次</strong>。在残量网络中，满足 <spanclass="math inline">\(d(y) = d(x) +1\)</span> 的边 <spanclass="math inline">\((x \rightarrow y)\)</span>构成的子图称为<strong>分层图</strong>，这显然是一张 DAG。使用 BFS很容易实现。</p><p>Dinic 算法基于分层图，其流程如下：</p><ol type="1"><li>在残量网络上使用 BFS 求出节点的层次，构造分层图。</li><li>在分层图上寻找任意一条增广路，进行增广，并将答案加上增广流量。</li><li>貌似一次 DFS 能够找出所有增广路。</li><li>如果无法再次建立分层图，当前流量即为最大流。</li></ol><p>一个重要的优化是<strong>当前弧优化</strong>。定义点 <spanclass="math inline">\(x\)</span> 的当前弧为 DFS 过程中遍历过的 <spanclass="math inline">\(x\)</span>的最后一条出边。首先如果一条边被增广过了，那么他便不会再次被增广，如果再遍历这些边的话相当浪费时间，所以对于节点<span class="math inline">\(x\)</span>，每遍历一条边，都让再次访问 <spanclass="math inline">\(x\)</span>时从这条边开始，且不去遍历之前的边。具体实现看代码。</p><p>此外，还有一个优化。递归完回溯时，如果返回的是0，说明已经增广完毕，直接将这个点移出分层图。</p><p>效率高于 EK 算法，复杂度为 <spanclass="math inline">\(O(n^2m)\)</span>，但是很难达到这个上界，能够处理<span class="math inline">\(n = 10^4 \sim 10^5\)</span> 规模的网络。用Dinic 算法求解二分图最大匹配的复杂度为 <span class="math inline">\(O(m\sqrt n)\)</span>，实际表现更快。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x7fffffff</span>, N=<span class="hljs-number">205</span>, M=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> n, m, s, t, hh[N], d[N];<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>], w[M&lt;&lt;<span class="hljs-number">1</span>];ll maxflow;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 省略快读</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];        <span class="hljs-comment">// hh[]要把h[]复制一份</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;q.<span class="hljs-built_in">push</span>(y);d[y]=d[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> flow)</span> </span>&#123;     <span class="hljs-comment">// flow表示当前增广路的最小剩余容量</span><span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-comment">// 到达汇点或者增广完毕</span><span class="hljs-type">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-comment">// i是个引用，当前弧优化</span>       <span class="hljs-comment">// i变为nxt[i]时也直接让h[x]变为nxt[i]，最终导致从x出发直接到达它的当前弧</span><span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 不是分层图中节点或者不再残量网络中就不搜索</span><span class="hljs-type">int</span> k=<span class="hljs-built_in">dinic</span>(y,<span class="hljs-built_in">min</span>(res,z)); <span class="hljs-comment">// 取最小值</span><span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-comment">// 优化。移出分层图</span><span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;        <span class="hljs-comment">// 加这句话快在洛谷的板子 700ms -&gt; 50ms</span>&#125;<span class="hljs-keyword">return</span> flow-res;    <span class="hljs-comment">// 返回的其实就是所有k的和，表示从这个点出发能够增广的值之和</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dinic</span>(s,inf);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,maxflow);&#125;</code></pre></div><h3 id="二分图最大匹配">二分图最大匹配</h3><p>对于一张 <span class="math inline">\(n\)</span> 个节点，<spanclass="math inline">\(m\)</span> 条边的二分图，可以新增一个源点 <spanclass="math inline">\(S\)</span> 和一个汇点 <spanclass="math inline">\(T\)</span>，从 <spanclass="math inline">\(S\)</span> 到每个左部节点连有向边，从每个右部节点到 <span class="math inline">\(T\)</span> 连有向边，原本的<span class="math inline">\(m\)</span>条边看作左部节点到右部节点的有向边，形成一张 <spanclass="math inline">\(n+2\)</span> 个节点，<spanclass="math inline">\(m+n\)</span> 条边的网络。</p><p>把网络中每条边的容量都设为1，该二分图最大匹配数就等于网络的最大流量。求出最大流后，所有存在「流」经过的点和边就是匹配点、匹配边。</p><p>如果要求该二分图的多重匹配，只需要把 <spanclass="math inline">\(S\)</span> 到左部节点 <spanclass="math inline">\(i\)</span> 的有向边容量设置为匹配数量上限 <spanclass="math inline">\(kl_i\)</span>，右部点到 <spanclass="math inline">\(j\)</span> 到 <spanclass="math inline">\(T\)</span> 的有向边容量设置为匹配数量上限 <spanclass="math inline">\(kr_j\)</span>。</p><p>参考：</p><ul><li><p><ahref="https://blog.csdn.net/qq_39670434/article/details/80952337">最大流算法之一——EK算法</a>by 千杯湖底沙</p></li><li><p><a href="https://oi.men.ci/dinic-notes/">Dinic 学习笔记</a> byMenci</p></li><li><p><ahref="https://2745518585.github.io/post/maximum-flow-Dinic">最大流Dinic</a> by 赵悦岑</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最大流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1338B Edge Weight Assignment 题解</title>
    <link href="/2022/cf1338b-solution/"/>
    <url>/2022/cf1338b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>没错还是构造……</p><p>明确某个数异或另一个数偶数次，结果仍然是它本身。</p><p>再明确所有的数字都是正整数，不能用 <spanclass="math inline">\(0\)</span>。</p><p>任意两个叶子之间的路径权值的异或和为 <spanclass="math inline">\(0\)</span>，如果它们之间的距离是偶数的话，那么都填同一个数就好了。最小数量为<span class="math inline">\(1\)</span>。</p><p>如果存在某两个叶子之间的距离不为偶数，如下图 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(5\)</span>。</p><p><img src="https://s2.loli.net/2022/07/02/pLqGWyH7XKi9hul.png" srcset="/img/loading.gif" lazyload /></p><p>钦定 <span class="math inline">\((1 \rightarrow 3)\)</span> 的权值为<span class="math inline">\(39\)</span>，那么如果 <spanclass="math inline">\((3 \rightarrow 4)\)</span> 或者 <spanclass="math inline">\((4 \rightarrow 5)\)</span> 任何一个是 <spanclass="math inline">\(39\)</span>，<span class="math inline">\(39\operatorname{xor} 39 =0\)</span>，结果都是另一条边的权值。所以假如<span class="math inline">\((4 \rightarrow 5)\)</span> 是 <spanclass="math inline">\(815\)</span>，那么 <span class="math inline">\((3\rightarrow 4)\)</span> 只有是 <span class="math inline">\(39\operatorname{xor} 815=776\)</span> 才能满足异或和为 <spanclass="math inline">\(0\)</span>。</p><p>其实这就相当于把两条边「合并」为一条边，权值为它们的异或值，这样奇数距离就转化成了偶数。至于更长的奇数距离的情况，依旧这样去做，不难发现这种情况下最少使用<span class="math inline">\(3\)</span> 种权值。</p><p>那么最多呢？直接做不好想，考虑从它的补集入手。如果没有任何限制，那么一定是每一条边一个权值，共有<span class="math inline">\((n-1)\)</span>种。然后再减去会「因为某些边权的确定而被动确定的边」就行了。</p><p>依旧是上图，假如上述权值不变，那么 <span class="math inline">\((2\rightarrow 3)\)</span> 能够填什么呢？<span class="math inline">\((1\rightarrow 5)\)</span> 和 <span class="math inline">\((2 \rightarrow5)\)</span>，在 <span class="math inline">\((3 \rightarrow 5)\)</span>这一段是重叠的，只有 <span class="math inline">\((2 \rightarrow3)\)</span> 的权值与 <span class="math inline">\((1 \rightarrow3)\)</span> 相同，才能让异或和为 <spanclass="math inline">\(0\)</span>。不难发现，对于同一个父亲的叶子节点，它们与父亲之间的边只能是一种。假如一个点<span class="math inline">\(x\)</span> 有 <spanclass="math inline">\(t_x\)</span> 个叶子节点，其中 <spanclass="math inline">\(t_x-1\)</span>条边的权值一定是与剩下那一条相同的。</p><p>综上所述，权值最多的情况，就是 <span class="math display">\[n-1 - \sum_{x \in V \text{ and } t_x \ge 1} t_x -1\]</span> 注意如果 <span class="math inline">\(t_x=1\)</span>，贡献是<span class="math inline">\(0\)</span>，如果 <spanclass="math inline">\(t_x=0\)</span> 也没有贡献。</p><p> </p><p>因为是无根树，所以要钦定根节点。</p><p>对于寻找最小数量，可以找到一个叶子节点作为根，判断它到其他叶子节点的距离是否都是偶数，是的话答案为<span class="math inline">\(1\)</span>，否则为 <spanclass="math inline">\(3\)</span>。因为树的奇妙性质所以不会存在某个叶子和另一个叶子到「根」的距离是偶数，但是它们之间的距离是奇数的问题。</p><p>在寻找最大值时，如果还从叶子节点开始搜索的话会产生遗漏，所以从以一个非叶子节点为根，统计<span class="math inline">\(t_x\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, sum;<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> dis)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!nxt[h[x]]&amp;&amp;dis&amp;<span class="hljs-number">1</span>) flag=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 与某个叶子节点距离为奇数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(y,x,dis+<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs2</span>(y,x);        t+=!nxt[h[y]];        <span class="hljs-comment">// !nxt[h[y]]=1，叶子</span>    &#125;    <span class="hljs-keyword">if</span>(t) sum+=t<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1 1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    &#125;    <span class="hljs-type">int</span> root=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;!root&amp;&amp;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!nxt[h[i]]) root=i;    <span class="hljs-comment">// 叶子节点</span>    <span class="hljs-built_in">dfs1</span>(root,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    root=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;!root&amp;&amp;i&lt;=n;++i) <span class="hljs-keyword">if</span>(nxt[h[i]]) root=i;    <span class="hljs-comment">// 非叶子节点</span>    <span class="hljs-built_in">dfs2</span>(root,<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,flag? <span class="hljs-number">1</span>:<span class="hljs-number">3</span>,n-sum<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1416B Make Them Equal 题解</title>
    <link href="/2022/cf1416b-solution/"/>
    <url>/2022/cf1416b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p><del>构造题使人神清气爽</del>。</p><p>先判断无解的情况，如果 <span class="math inline">\(n \nmid\sum_{i=1}^n a_i\)</span>，那么显然无解。</p><p>做构造题不能只局限于样例给出的方法，因为它们一般都是特殊情况，而我们的目标是使用一般方法进行构造。</p><p>注意到无论怎么操作，元素的总和是不变的，我们可以尝试把所有值移动到一个元素上，然后因为<span class="math inline">\(n \nmid \sum_{i=1}^na_i\)</span>，所以一定能够用 <span class="math inline">\((n-1)\)</span>次操作平均分。</p><p>如果这么做，那么必然除了那个元素，其他的元素都是 <spanclass="math inline">\(0\)</span>。对于一个操作 <spanclass="math inline">\((i,j,x)\)</span>，如果想让 <spanclass="math inline">\(a_i\)</span> 置为 <spanclass="math inline">\(0\)</span>，那么必须满足 <spanclass="math inline">\(i \mid a_i\)</span>。对于 <spanclass="math inline">\(i \nmid a_i\)</span> 的情况，则要事先将 <spanclass="math inline">\(a_i\)</span> 增大到满足 <spanclass="math inline">\(i \mid a_i\)</span>。</p><p>增大多少呢？<span class="math inline">\(i-a_i \bmodi\)</span>，这是显然的。如果操作是 <spanclass="math inline">\((j,i,x)\)</span>，想让 <spanclass="math inline">\(a_i\)</span> 变大，其值必定是 <spanclass="math inline">\(j\)</span>的倍数。为了能够增加任意值，钦定都移动到 <spanclass="math inline">\(a_1\)</span> 上。</p><p>那么对于 <span class="math inline">\(i \nmid a_i\)</span>，必定先使用<span class="math inline">\((1,i,k)\)</span>，其中 <spanclass="math inline">\(k = i - a_i \bmod i\)</span>。那么将 <spanclass="math inline">\(a_i\)</span> 清零，使用 <spanclass="math inline">\((i,1,\frac{a_i}{i})\)</span>。如此至多使用 <spanclass="math inline">\(2 \cdot (n-1)\)</span> 次操作，再使用 <spanclass="math inline">\((n-1)\)</span> 次 <spanclass="math inline">\((1,i,ave)\)</span>，其中 <spanclass="math inline">\(ave = \frac{\sum_{i=1}^na_i}{n}\)</span>。总操作数 <span class="math inline">\(3 \cdot(n-1)\)</span>，满足条件。</p><p>有一个疑问，<span class="math inline">\(a_i\)</span>难道不会在残酷的修改中变为负数吗？假如 <spanclass="math inline">\(a_2\)</span> 就需要进行增加操作，必然 <spanclass="math inline">\(a_i\)</span> 要减小一个值。但是这个值是 <spanclass="math inline">\(2 - a_2 \bmod 2\)</span>，由于 <spanclass="math inline">\(2 \nmid a_2\)</span>，所以这个值一定是 <spanclass="math inline">\(1\)</span>。而 <span class="math inline">\(a_i \in[1,10^5]\)</span>，所以绝对不是负数。</p><p>而后至少要增加 <span class="math inline">\(2\)</span>（将 <spanclass="math inline">\(a_2\)</span> 置 <spanclass="math inline">\(0\)</span>），所以当修改 <spanclass="math inline">\(a_3\)</span> 时，<spanclass="math inline">\(a_1\)</span> 至少是 <spanclass="math inline">\(3\)</span>，如果要让 <span class="math inline">\(3\mid a_3\)</span>，那么 <span class="math inline">\(a_1\)</span>减少的量又一定小于 <span class="math inline">\(3\)</span>，接着加上至少<span class="math inline">\(3\)</span>。如此类推，不会出现小于 <spanclass="math inline">\(0\)</span> 的情况。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, a[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> i, j, x; &#125;;vector&lt;node&gt; ans;<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;    ans.<span class="hljs-built_in">clear</span>();    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum+=(a[i]=<span class="hljs-built_in">read</span>());    <span class="hljs-keyword">if</span>(sum%n) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-type">int</span> ave=sum/n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;        <span class="hljs-type">int</span> k=a[i]%i;        <span class="hljs-keyword">if</span>(k) k=i-k;        ans.<span class="hljs-built_in">pb</span>(&#123;<span class="hljs-number">1</span>,i,k&#125;);        a[<span class="hljs-number">1</span>]-=k, a[i]+=k;        <span class="hljs-comment">// 如果k=0，这一步可以没有，但是下一步必须要有</span>        ans.<span class="hljs-built_in">pb</span>(&#123;i,<span class="hljs-number">1</span>,a[i]/i&#125;);        a[<span class="hljs-number">1</span>]+=a[i], a[i]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) ans.<span class="hljs-built_in">pb</span>(&#123;<span class="hljs-number">1</span>,i,ave&#125;);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans.<span class="hljs-built_in">size</span>());    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,a.i,a.j,a.x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1542B Plus and Multiply 题解</title>
    <link href="/2022/cf1542b-solution/"/>
    <url>/2022/cf1542b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>等价于判断 <span class="math inline">\(n\)</span> 能否写成如下形式<span class="math display">\[n = a^x + by\]</span> 多乘个 <span class="math inline">\(a\)</span> 或者多加个 <spanclass="math inline">\(b\)</span> 仍然形如这样。</p><p>这就相当于 <span class="math display">\[n \equiv a^x \quad (\bmod b)\]</span> 因为 <span class="math inline">\(y\)</span>是个未知数，可以利用这个转化同余方程。或者说，<spanclass="math inline">\(x \equiv y \quad (\bmod b) \iff b \mid(x-y)\)</span>。注意这里的 <span class="math inline">\(x,y,b\)</span>是任意的。</p><p>这个就很简单了，枚举 <span class="math inline">\(x\)</span>，满足<span class="math inline">\(a^x \in [1,n]\)</span>，判断 <spanclass="math inline">\(a^x \bmod b\)</span> 是否等于 <spanclass="math inline">\(n \bmod b\)</span>。</p><p>为什么只用枚举使得 <span class="math inline">\(a^x \in [1,n]\)</span>的 <span class="math inline">\(x\)</span>？因为 <spanclass="math inline">\(a,b \in \mathbb{Z^+}\)</span>，那么如果 <spanclass="math inline">\(a^x\)</span> 大于 <spanclass="math inline">\(n\)</span> 的话，就不可能了。</p><p>注意特判，当 <span class="math inline">\(a=1\)</span> 时，等价于<span class="math inline">\(n \equiv 1 \quad (\bmodb)\)</span>，如果成立的话，有两种情况。第一种可以直接判断 <spanclass="math inline">\(n \bmod b\)</span> 是否为 1，第二种，如果 <spanclass="math inline">\(b=1\)</span>，那么 <spanclass="math inline">\(n\)</span> 为任何数时都成立。其他情况都无解。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">long</span> <span class="hljs-type">long</span> T, n, a, b;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;a,&amp;b);    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span>(n%b==<span class="hljs-number">1</span>||b==<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> y=n%b;    <span class="hljs-keyword">for</span>(ll x=<span class="hljs-number">1</span>;x&lt;=n;x*=a) &#123;        <span class="hljs-keyword">if</span>(x%b==y) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5535 &amp; luogu1414 题解</title>
    <link href="/2022/lg5535-1414-solution/"/>
    <url>/2022/lg5535-1414-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="luogu5535-小道消息">luogu5535 小道消息</h2><h3 id="分析">分析</h3><p>关于伯特兰·切比雪夫定理，我们只需要用百科里说的“较弱”的说法。</p><p>对于整数 <span class="math inline">\(n \ge1\)</span>，至少存在一个质数 <spanclass="math inline">\(p\)</span>，满足 <span class="math inline">\(p \in(n,2n)\)</span>。</p><p>有什么用？</p><p>首先 <span class="math inline">\(k \in[1,n]\)</span>，由于每个人衣服上的数是下标 +1，那么第 <spanclass="math inline">\(k\)</span> 个人衣服上的数就满足 <spanclass="math inline">\(k+1 \ge 1\)</span>。从而 <spanclass="math inline">\((k+1,2k+2)\)</span>，也就是 <spanclass="math inline">\([k+2,2k+1]\)</span> 之中必定有一个质数。</p><p>如果 <span class="math inline">\(k+1\)</span>是个质数，那么显然除了它的倍数之外的数，与它的最大公约数都为1。那么只要保证它的最小倍数 <span class="math inline">\(2k +2 &gt;n+1\)</span> 就能 1 天就传达完成。</p><p>那如果 <span class="math inline">\(k+1\)</span>不是质数呢？<del>根据质数的分布</del>传给上面那样的质数就行了，2天。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, k;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isprime</span>(k+<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-number">2</span>*k+<span class="hljs-number">2</span>&gt;n+<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);&#125;</code></pre></div><h2 id="p1414-又是毕业季ii">P1414 又是毕业季II</h2><h3 id="分析-1">分析</h3><p>定义 <span class="math inline">\(p_i\)</span> 表示质因数 <spanclass="math inline">\(i\)</span> 在每个能力值中出现的次数。</p><p>明确对于 <span class="math inline">\(k=i,j\)</span> 其中 <spanclass="math inline">\(i &gt;j\)</span>，所输出的最大默契程度必然是单调不增的。因为多选一个人不会让最大公约数变大。</p><p>当 <span class="math inline">\(k=1\)</span>时，答案是最大的能力值，设其为 <spanclass="math inline">\(mx\)</span>。那么就令 <spanclass="math inline">\(ans=mx\)</span>，如果 <spanclass="math inline">\(p_{ans} &lt; i\)</span>，那么让 <spanclass="math inline">\(ans-1\)</span>，这样一定是最大的。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, a[N], p[M];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), mx=<span class="hljs-built_in">max</span>(mx,a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=a[i];++j) <span class="hljs-keyword">if</span>(a[i]%j==<span class="hljs-number">0</span>) &#123;            ++p[j];            <span class="hljs-keyword">if</span>(j*j!=a[i]) ++p[a[i]/j];        &#125;    &#125;    <span class="hljs-type">int</span> ans=mx;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">while</span>(p[ans]&lt;i) --ans;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF482A Diverse Permutation 题解</title>
    <link href="/2022/cf482a-solution/"/>
    <url>/2022/cf482a-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>话说这题为啥要写题解啊？</p><p>因为，我最最最最不擅长的构造题，我最最最最期望的「构造作战」，还是要从水题开始攻克吧。</p><p>如何构造 <span class="math inline">\(k\)</span> 种差值呢？ <spanclass="math display">\[[1,k+1,2,k,3,k-1 \cdots]\]</span> 这样构造的差值是 <span class="math inline">\(k,k-1,k-2\cdots\)</span>，那么就可以用 <span class="math inline">\(k+1\)</span>个数字构造出 <span class="math inline">\([1,k]\)</span>中所有的差值。</p><p>照这样，维护两个指针 <span class="math inline">\(i=1\)</span> 与<span class="math inline">\(j=k+1\)</span>，这样就确定了一个差值。然后让<span class="math inline">\(i+1\)</span>，<spanclass="math inline">\(j-1\)</span>，又确定一个差值，知道 <spanclass="math inline">\(i \ge j\)</span>。如果这样操作之后出现了 <spanclass="math inline">\(i=j\)</span> 的情况，那么就说明 <spanclass="math inline">\(k+1\)</span> 是个奇数，进而 <spanclass="math inline">\(k\)</span> 是偶数。由于一轮确定 2 个数，假设进行了<span class="math inline">\(t\)</span> 轮，那么就有了 <spanclass="math inline">\(2t\)</span> 个数确定了 <spanclass="math inline">\(2t-1\)</span>个差值，这显然是个奇数。所以还要再补上一个 <spanclass="math inline">\(i\)</span>。</p><p>那么后面的怎么搞呢？我们只用到了 <spanclass="math inline">\([1,k+1]\)</span> 的数，且一定全部用完并包含 1这个差值。那么只要顺序输出 <span class="math inline">\([k+2,n]\)</span>所有的数就能满足条件。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, k, ans[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, j=i+k;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d &quot;</span>,i++,j--);        <span class="hljs-keyword">if</span>(i&gt;=j) &#123;            <span class="hljs-keyword">if</span>(i==j) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k+<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,i,<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2294 狡猾的商人 题解</title>
    <link href="/2022/lg2294-solution/"/>
    <url>/2022/lg2294-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="solution1-带权并查集">solution1 带权并查集</h2><p>给出的信息是区间和的形式，搞个前缀和数组 <spanclass="math inline">\(a_i\)</span>，表示 <spanclass="math inline">\([1,i]\)</span> 月的总收益。</p><p>假如知道 <span class="math inline">\([x,y]\)</span> 月的收益与 <spanclass="math inline">\([y,z]\)</span> 月的收益，那么就能推出 <spanclass="math inline">\([x,z]\)</span> 月的收益。这时候如果后来的 <spanclass="math inline">\([x,z]\)</span>月的信息产生冲突，那么必定是假的。</p><p>由于不同区间的信息具有可合并性和传递性，考虑带权并查集。</p><p>首先明确 <span class="math inline">\(a_i\)</span> 此时表示 <spanclass="math inline">\([fa(i),i]\)</span>的和。这是带权并查集的固定套路。</p><p>当给出一个区间信息 <span class="math inline">\((u,v,w)\)</span> 表示<span class="math inline">\([u,v]\)</span> 这一段的和为 <spanclass="math inline">\(w\)</span> 时，找到 <spanclass="math inline">\(x=fa(u-1)\)</span>，<spanclass="math inline">\(y=fa(v)\)</span>。</p><p>如果 <span class="math inline">\(x \neq y\)</span>，那么令 <spanclass="math inline">\(fa(y)=x\)</span>，也就是将这两段区间合并。关键在于如果处理合并后区间的和。</p><p><img src="https://s2.loli.net/2022/06/30/9EuZjHrnCLa7vR2.png" srcset="/img/loading.gif" lazyload /></p><p>很明确了。更新 <span class="math inline">\(a_y =a_{u-1}+w-a_v\)</span>。</p><p>如果上图中 <span class="math inline">\(x\)</span> 在 <spanclass="math inline">\(y\)</span> 的右边也没有问题，只不过 <spanclass="math inline">\(a_y\)</span> 是个负数，理论上也是讲得通的。</p><p>如果 <span class="math inline">\(x=y\)</span>，那么直接判断 <spanclass="math inline">\(a_v - a_{u-1}\)</span> 是否等于 <spanclass="math inline">\(w\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">5005</span>;<span class="hljs-type">int</span> T, n, m;<span class="hljs-keyword">namespace</span> union_set &#123;    <span class="hljs-type">int</span> a[N], f[N];    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x==f[x]) <span class="hljs-keyword">return</span> x;        <span class="hljs-type">int</span> t=<span class="hljs-built_in">get</span>(f[x]);        a[x]+=a[f[x]];        <span class="hljs-comment">// 路径压缩必定要做的事</span>        <span class="hljs-keyword">return</span> f[x]=t;    &#125;     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;        n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) f[i]=i, a[i]=<span class="hljs-number">0</span>;        <span class="hljs-type">bool</span> fg=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(m--) &#123;            <span class="hljs-type">int</span> u=<span class="hljs-built_in">read</span>(), v=<span class="hljs-built_in">read</span>(), w=<span class="hljs-built_in">read</span>();            <span class="hljs-type">int</span> x=<span class="hljs-built_in">get</span>(u<span class="hljs-number">-1</span>), y=<span class="hljs-built_in">get</span>(v);            <span class="hljs-keyword">if</span>(x==y) &#123;                <span class="hljs-keyword">if</span>(a[v]-a[u<span class="hljs-number">-1</span>]!=w) fg=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> f[y]=x, a[y]=a[u<span class="hljs-number">-1</span>]-a[y]+w;        &#125;        <span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;true&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>);    &#125;&#125;;</code></pre></div><h2 id="solution2-差分约束系统">solution2 差分约束系统</h2><p>这个更显然了。但是给出了是 <span class="math inline">\([u,v]\)</span>区间和一定是 <span class="math inline">\(w\)</span>。那么直接转化 <spanclass="math inline">\(X_v - X_{u-1} = z\)</span>，<spanclass="math inline">\(X_{u-1} - X_v =-z\)</span>。由于是直接等于，那么直接添加双向边<code>add(u-1,v,z)</code>和<code>add(v,u-1,-z)</code>。</p><p>SPFA 跑最短路，判负环。</p><p>图不一定连通，那就搞一个超级源点 <spanclass="math inline">\(n+1\)</span>，对于节点 <spanclass="math inline">\(i \in[0,n+1]\)</span>，连接<code>add(n+1,i,0)</code>。注意 <spanclass="math inline">\(u-1\)</span> 能取到 0，所以不能用 0当超级源点。</p><p>有负环说明账本是假的。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> cfys &#123;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-type">int</span> dep[N], d[N], v[N];    <span class="hljs-type">int</span> cnt, h[N], to[M], nxt[M], w[M];    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; to[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) d[i]=inf, v[i]=<span class="hljs-number">0</span>, dep[i]=<span class="hljs-number">0</span>;        d[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(n+<span class="hljs-number">1</span>), v[n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;            <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();            v[x]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;                <span class="hljs-type">int</span> y=to[i], z=w[i];                <span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;                    d[y]=d[x]+z;                    <span class="hljs-keyword">if</span>(++dep[y]&gt;n+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 0到n一共n+1个节点</span>                    <span class="hljs-comment">// 最短路长度超过n+1说明存在负环</span>                    <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;        cnt=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(h));        n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">while</span>(m--) &#123;            <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();            <span class="hljs-built_in">add</span>(x<span class="hljs-number">-1</span>,y,z), <span class="hljs-built_in">add</span>(y,x<span class="hljs-number">-1</span>,-z);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(n+<span class="hljs-number">1</span>,i,<span class="hljs-number">0</span>);        <span class="hljs-built_in">puts</span>(<span class="hljs-built_in">SPFA</span>()? <span class="hljs-string">&quot;true&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>);    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>差分约束系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Summertime Record</title>
    <link href="/2022/Summertime-Record/"/>
    <url>/2022/Summertime-Record/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="79a372ec5e20db847e90acc3fa023e97a3fd08a2d7302f264280d43dff82074c">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f330deefec7ad7120197c11d8126f68ba5f6e0fe5188875c111ed75cce422ade25e5cac84961354034073e1edd6842c7850df0a08b6e8abf5458794a60b751a1d81bef5c1a1c8df15f4929d6235ff6ea17818b3c0e686194077e6b1444b7372b9c12f27d24fb4feacf4707656319a7eafc2da116f41072939d7e2dd10b15f00454664eb7f9bb7b58d983953753592d0322e0b4c6ee4214bed172c214140c15969e67b5ed419e3a2bf8f193a2891f5e88b463d4f6a9a3e1202ec7f0cd21cb356755dfbadeb7c12880ee269b9acba093ac2514c53d776d0c130ef3ee16b89a27045a76cb4788e53afe9b73b8cfb2ed3608f5b7509b66137e7120914189ab592a78b044de2a352ca519f71fc54ba08d3b69a0afb172bb849141124c3b4e9e67caa72e4d1b1bd1913f251c0e86a442cd3d4c93cbaafc5033103d0de497d59be5104d2dbcbde28ae18b2897b47ea0f9b23734f0f682cc2533976552af183d41637cd24df077140091b7038c3c3e453b44789ff95f5f4abf6bc430c1b207dd9ba6a2db6308a9472b5aeb5da8c9ebafb07db4332469caf2c300e57b9c2bf3c9fae7435fecacbb9eb53def6c1761094a9953285677c849d542e58a2f78c24baa0f7aadb2916084bf3e5a25b7935bee9b7e402bffb5ace42072d3058dd7fa235386dc6aad6f4fc484c9062ecf2d452aae9d94e9f4979939ef34f044666d7472bedd8fd3d9d5be29f2e5ef75e7a30b9a20fc57ed6e6765e60386135dfba0801b2873aef43a6bde14f951b32fbd25b984b1e535787bb3208374b7902f531b12bc791e0bc639cb4ca8f319d205fd4f1b3978a18588f7faf9fd2e045af05fc2b6da32bf267b04e2c6ce43555ef477bfd394bd727982af606d55de5f6b0f1035e2e9803f186977c30606e4d26e2820d491869fe8ad2a81eea6d8d8fa56c981b15ab7e701f9f0e2618e976ec7665a251d5b06e8218a859ca7cbe95c75587110e2367b552dc33690238d5b2186ae3d70291cd40c16f5c9a7e25acfa3823cd631513f1c8a27a62ce3f79d1945f9dfd56db75db8e8d3dfbcdefeab6ccfbc47e558c35b8baeb2467f10e9f423cac1ef78f46044e28771403cdcaf7e2ddd37d2c3e599352d275fe326f2b89b33dbd848b1ae7f9ecb67fc600cac13c18a551e696c4f054a0731c19f3a2891ff7ce2760578abbfad0d02e7bfc29c2a2d49ad9bda8afa15fa61531cd40dfb348e9faf8b22a3f21afb18594ea8c11959c736cbceb02e77297537a127098be253caa51949ebf67183f291b8a8583493bc0ed02169e1e262b15e378183948ddce9f1783b0fdc374925a02f43e41bb4a609f6136ae2513037d71fb944f0ccd1c0ef5191057659de824762ca0278f440abad483b94bea75ace877aeb263a855070006f4b6bef070fd999e66d59c5b1dcee2dd6500d1b98b312c16167604793a864323644a4b1a3dc376c4962d140f3e29b49738b276dc04e842a6dc866ed2813200f0ee370c79e16add94c0c82d510d2821fec17e6fef97c229d089f0af5fa4f9206d5137d1827d85dffeb68f1e1f1ed1d38b20726fc22034c29d8fc3afa3c87de067066c5b1f4a081e74570751efe90279c07bd4f71f14b0723db738848495bcc5b0bc1ff6dce1bf62a20a11e21379e36f297a671c1bb48c7af477e5f0c521460ee5990cefe017540488d14d333a98728467454dcb07845b679a6b53f9a0e8c8bcfa404004c6b889791ff43beeefe2886417e371204bd54d0be20d0ecbd5a1323cf82a7bbb85947b25b4855f6df2f0c65e1390ee71b20345d4e2a7ba9ba4f2f3c18d1b25ad20b9f32428fb87f59f5861eb22c977716badcbe6601a485f35b8978726361927247dfd9fd16193fa46b4a9ba68c6babc0cd51651790039dd9f556db532676b086c7a1aa9eafa4934cea3c415d1313b8d6cd2785723038804f1d7743e46e0b3662c0149b252a2388176d9a1437556b7ac0df4f5a1f4704c52757ea5ad1e690718cdeabcd9404df11cceb4721ac2ca06e47ce1b098cda6227bcf0cbf5bcf71852129f821d1dfbf6afc32fd9e938ff553fee664fe02ceb17c0504cf7b4259551e2614e0d7070d1569d834da39943d278d601f66677a1ad92dd18c5307d55b8b5122731ff943f9bbee15132b4c430c184d99e379cb814a19c33456461578ee2a69e23d7c514e0f47dd7a1f6c0420441c1be4eb7b6dd03f3feff0765b383eff20f36865f56355b9d570c39fd58d7389b805e9ae0ad12f47110aa25d6c3e322570e46e3cd512e87d9ceb95be70df01fd2a70272e91f931f8448c5aa8a9e3a66ecc2a104eb82f35abf58138d7794efb307802665089d6cb91007e470d058859119d42da432cd2db34dd2280da825a6ca42a3091ca56a703c73d7db18179262ffaec90641225f4e82b833ab7ac2a7f02adebca1098803e4c562b0eb61b17731a65e52b3fd3bcd5452da06cb944522f25e9e6712b511bb5c42003a1f9213dccaf3bbb9b097d2849a9efb5ed48840022ec65f77d441fd8bca993a094689cceb74935f2310f394df849c1174a520610364e6b6cd8c573619d1d3a037a50ad443a943163a3d2773dccc834d413716ec86cae01a5ed58b0317305741dcbfc8bc488b0c4952e8bda8e21142ff68f654677a8038db7ad7d7a30dd431c6deee89095b10c22a858d9e8f4f73f8e78a645447f84b931a06a72dbe38678333018bb9f8ebfc0c03dad3baf05dc88fce1620e241a555f7c27d8a5ce561d84ac6c8f5218b7a9ffc57ce0d8003f8c3cb511f10b734879473d97a929d903c14534a2e199ff415ea8072457bf985f88c5b459c25b824918c9ac6d308714eba2dd876c6335647628b94d3adebac4e7a5935a8a612ce469bce7dbbfa014e1ee9da6986f017bc171164f23d3f94ebc5a8412e086b4ec97cf22d29</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作战，可能要失败了</title>
    <link href="/2022/before-failed/"/>
    <url>/2022/before-failed/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="37182f2b10f6347126532ba36c6975b980f0dc74da0317a57b8943453a3e5bf9">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bc5b7cd4f87baec3fd3e832a2262ad5bb4e54a69e5f79e2740b28436eb16a625322cf7c44f48a3dfef555fa1fa5c0374a4807959f4e79b8434393459190babd54289591efdc243d37e5fd015e9f5d41ea293f4e0ce207aa1662340e999e17e7862bf9dccdee6661d1152dea597bcefc21f864249576fac1fca28774fb86b481ffed27de5ab17032179518e27bb4cb35c032dbbbccbae0d9b20bffc505b36d9f80ae7e885222bb362bc3f3333c36c1dcff03789b373ff740af6ab6c6c951c2f4a8f6bf69724f6adf7e3eacf9cb8eb1f7a6768abe28e9c47851d00014da77ddc01e85b781a6873522e148751d4ec8475c892e40c74204e0e742ba0012b72bf7705529ebf87cefa4bcecac68a7490a03e0903075b9b560a8cc86be8a8007b7883211de27044ef98547d6654bb964925fd5463b2f8d0b37fce62ec344ad55e9dd382dcf915e8bb6c3a05bba6fb5efcc70330d87242b118c8ce8c577424b0c00dda19cb24e8ecb49061bc9de2ce1c1b9d40effe11d9ae8c2ff08e44ac5733353e6a57563fbc9e56ba72e458bede16434d9b360ecb576cb91f03f47c9456b43549373d403cdbf9682abb8e9955e3eb46c096fc7cdc60588e3551a1bb5ea80326f4183437117abf847774bba19044e8a7e38d40b44267df6f670449e45bf82ee6039c659ffff3055d833f314b2a1d6bd211ddf01ef8676b20676f87ae0a1639c1dcce9e0cc3593657881d7d9519f95190eb139ea4c091e137d2ec9097e3076fc8dac09420335679604e073a3828a3a86f0bdfc2b19cb3de5a2ebfd21aeff77a8f6a197647a724ef26dba3f57d4af73ac2686fdf9c7338d74e7021ceb0fbacb59c64795fa2a099427cb8f3078474e350d711748117283d95e7477412cadcf0ba85e3c45aa9d30dd0518d67c6a520ea60e449922b528ba82ffe77abf934dac07ffebfb7508d83a916543d283366c1827ff4112911f0a14ef1c6ca10814a850694ff0fe6e7e21220e094f19639dd69ad0ee591eb5c319ccb96c29ad9c1c95d508b4b89b65eba13aba307b1a8a0921f7885ad875f5cb1c53d68a2de1d1969c4ade4c300dbb6e61e17d47ca5510a3b21fdf8eca07e708ff93b5e6fa093ee7e8bf4b46c7172206449ee276bd1b0f7979002042b424cb9ae3f27cee52a773c64ebfbb9b635ca570</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#10 最后的作战</title>
    <link href="/2022/yume-10/"/>
    <url>/2022/yume-10/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d5991906a87060b331b9a61fef6abc9ae61ad45cb3087c0270fd739c713e4316">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f3b273c7efbe8bb66d0780cc6b29368875b4fe1ef937b8f28c04e2f2490d9cdd2a32f8fb264414ba90ac6132051d29a9051d6a9a18b4c5d2b5de93e4d92aaf6ada90ca6755dd4680fd86daa92e8d2fa11c4f999cf449b81ad4aba7d625989d1509dc3d90bc0a5e4bd49598b613f5b8dd3cbd22931b654aacd198d8a2dd2136d71c050294219249e4a1b116332955e1eb18f02ce111f860ff7ec95b64044a82ba0cca9b9012d7c127e5ec6a5aa0aba80365a8054bb3677b5bb3594fd5b0def15c2b43220a4c47fcd1ff8650136b4636df58b716e8b9ef3dd0248b6e8bf87c11037470e731b7712d2fb9c6aed69934583d4e372644be11b5390d4af98b346cb0e28eba571ee0d1d4047a4b2fd03bca6df7762b95ad008cba5f7d59c67615891ab86a4ee21d04c94c700a09765a78c69962e5c97dd0aa4c7909a2aba14226a41d6448f1f279cf4fdb9321a9e03b7f1d67f274c8cfa42d9994cb0d25aa87fdfd2b995d2fb57508372d3a451ee2d1214cba36b2502aef20398627edcc152b5eb9052b18aa4dc597349ff86f0fa5dfff23168e6822f7019deb86c3ddd6027bf96ed42d7769ef41e50b33874846873b2a151c2bd559a6ef60deb62194e87814e402b88335e017161b7996a9e54d4502380f8fa5047ad2d7865286c5406bdc4348b3045bbb713d8cc7e2f298c073ef66c9c71130de501c4dabac7369d1ae5c0bd59212ca789b78ba730173b1ec187dd444eaeece261fde0e494b1240a897e5ce9d00aa49242d0c2e470315a229c0f4f1da0238df0610a32161706a6dded3071c574564b7d1985edf986f1a7e0f49359201cbadc7eff40237e5d3e9ee45ed2573566b36aa05d766cef8de530d4c4f16619209667c929fdc5c59164faef70a18de2f8a619d7ad634a9a97a1514a668d46f7ea1a88e9ff9e1ca61dbb9eabc810b70a84b24c1040d8c64e217bb8f9687831ee7ded4fec3fc21b3dd47cf00f6d2ba85d38facfd870c2e5c63e52a05c0c6c990fc5c2cacda12df6e476001c0859143cf242a661c4283dd9938e6ff033e84c73d70760da32e5139ff0a5a6d9cd209304561295fe996f25f901134c6df7b709fc21c8648728083ef03db5a021706246fa19861355522023ad1de5eb7b9c22b1f72396107dcde0e79c0661cb9cab72fe6e63629ae612910934ced40c180c08afdf78a5f365372aac6dbca030fd1d7a3a9175646918005dddcc08596d75a130250743203b4808ec09d0f62c34391f962a65d7172de8ffb0c39a0bba2082f9a59745c41dd77e33da1bfbd4bf7d437ca8ee238e7382ad27c20460088678bd5ce97c35a80320ffe575e667cc34b5a228262081ea5794eb10f2fae61f543df4a1b2edf7e0883dc00278aeeec8f2946748f896261ce6c06b5295a1df340a2196358c6ab8a7ac39ea3c39d5c5301c501733a1383b6b0d8ab14d9373aa58fc9edfb9a0091ef1774bfc6eaeda969717925184bfd990c59047d4f980fea1db7fb04b4459521e598cfa55bad82b538abafeabf2448ab1a76819aaeba41d2588d968e8ca220fd0bcce9bd4a98da1cb2415a1b0b61d83d348e480c19dfb90b95dc01793a3b077a137d96b69704d753aef896ff430b7b695f1fcfd2743a80c9f97b257cca271abdda3a57e3342dd7374c9d37db6d4f8c95a894447ba2e82ea6fbbdf92bf485d258ec548d9c1df48674a6e6f5e35da2dfc24b8b14be1ed243cb068a2609e7401f904b80d775400eaad830334eed0604ccc875d63970619c41b74aa4e5f9ba905fd08cfc357e8dede61ae03bff137f9ebdde0bfa568befdea91f5026e42da285c880a2047d2e0e45a085ce02073d83f54d88551fd9d01babbc2b02a618c71b95f51ed5402abcc4af5dc261ae759d38c3a042d976686851d362f05aba2da959ea7888eadb0a2a997a58a896ff5448a3181d179a6a4b5cb01f8a6e7b9a3cce9fd191738de045dba5309371f307f5da2293642fde4a7408643374ad6ce555eb24e054e198788e64fe560d17daef208a098432c0ba60c97bfd0f0efab8023ab657a363523a9fcf984b0fac416ec657f0f7f6722815b344fecbec9c87cfb45121a3de4f34495fc4e9d8972d6afc07c1d1d6781d56c0338a0cacc848643da3337729aa097488b15e3f702ba32402776820ac05c846dfacb402b6f06c0ff3729f3eddd9e31090b11916a812a9493b9b923e1f14ab8877ac5b75ad351285821ae33ff9871b809b18d459b078b6d3402133327c05f53232fd3625cd0ce8063bad2653fd352562b83dad3238e29b03cd3da0f760ede6d26e7c3e7d1b91920ce81b04a69529bd68d30818e778415a5368d9aea49bba3129de8662e66bfa0e496525c6708e54ebfd82be610fbd29df9e86bce1ff3cd00428a8adc28e4ce4a1398faf1f2995eaf1b49ba7600a0e33b031365649ac86a2f0087703b03c26db0b655e3e762849b2be41ba99976401ef769ab20c9b028c7bbc13e924731e8604d7b6bf7ff5dda1ab12212bb02d5e2d8e4dd1830b4b407a1e2506ce3e16c2f386562ef74080dbb786b69165cd1e11420175123306f34aaf21585113e750ceb5e989af11ec3a5d8eec69f8a8135cb2a5d108637cf6facdff609a513585e0b91688ccd4b89d76b36e3a21674edacdb9d68182c1307836ab224693231f90644ad5c610256904f99a6069f37013b32ec652ebff5c33dd3ec1be76d4c3b5ebb532ef7973a7c8b420dabbcf193bca722ba7ce22d0139a0687f8c17c38101fe23d9b07f77bd9eda1306e8cc824e77f01a5baa550ab24eeb7823a52672bc258a666bd00a536758296b5ce831ecfa628bc390b1ba3a1e6380b45c1f98f0de0489a9526e3c96c0455b97d9114a1b32753f017ef16146aceeab7712c4fa0f746f6dd77847c36e8384ab184c3cf98cdb3ede68430ce1631820282d692b0900100fe26e9c5f7142f9a0bcf946cdc09357f9211123ace9ab06ca129d7d8f9a5663d0c5ba935f4215a16fe10b4685fa9ac841bcff970854d72ba16de5ae3ab87f731dfdb48a0338cb526fab55fb2700267b2a4b9216da396b586c486918e56ec559e648d2f7c6f2031eb983198bac84917818a22a18849c19988dff42ff7f2c013642931ff4cc4b2ef9e16f25c9913721fc65ee832501a1b154647ece366db29f20e5ed8bbad86b850121f25033edc3702e7eaf56d2088eb65fd82cee8541eee55a209d377e414dace8e41b2287d86a771afdfac88820ab45e9eac1ca5c00bac01c3846af5577f6037cb7e40d5320f31cb0beab2916acd95607f4abc5b7c41792c383b05d0bdb4bd6b2265d5e8af29bcda40c4e5cdb7d86f4d7a9a5dc99f4a070c54fa864de0833de398d9cd18732aec19e9ddfbd147ab606ca9283218a1c77084df18f3b214f8e4dfc03e7d0a5f85a9ac9cf52dff4f6ba432aec2deb01aa4dd1fb43707968484a3a96f79e52a29e82cec2a91a55bd60b0d6d05f321961b9f97858186c11b428f982ece604e3364bf50a90a7189cfbabe97d3a32f56d90b47834ed9090912dc1b81234ccc25504d4c10a6c19e966df43547762ecf60d28a4245d5f7c676d57471c44e57695a56d9bd8167606e81e614496a7d50f252c80bdf1f68f7f18247826daa2d36e9e218e442e988a446b15dc5362e1e78db77bc8a15c8b0b0771d05caf82f136a66b0c8186c719ee86a85d6f6f5bbe74e0dfd61916d6bb8dd5de9a4be2dd127e729e48182ff68076a1af4e8b48a338aa1b33ba5365a7f3adb6a33c435d56bc55d1c973746c4a00b51f9c387b2911196bdb2bab6808886292e91ecf9916bc53a77c352fbe617d620d331985cc4700250ae319716c36aa2571dcfe01ab9312603a4b3c24f009361e9d10c809915282bfbd0eba63c61109b7aab553cc028a2fdd4dec41133a81855587ff8172ae8a36b1964abf60ccd368b351b7370145555500c9a37b1ed2d5ed0a9e45f421f8c1305432f8a2d5341d7f6ed36909fbb08903326fa7595936144854ba4a84e2d8667d0f42de10df03e43b4a948106a42f474f50687423f4660b2dbb3502676d9b16442163bbadb97e267630974626e057b6cf96b96ed4bf3ce188157c40d8fde9b0fb523809b20f8f98095f7621905dd4c19ea4219d7ee3cd0c6d7dfb81348e879b1b454c38b909e415ba4900d37ef3f41d0cfc7089db1b257bb6fc26bc7c9622cae539b1647356b944a9dc33599169152df4cbf15da011c8e61b64e22ba7af73a0fc4dc305070d5469488f5c88a8f2af5d65494c72690c2fe4dca742ca189f94dcaefb35f4a33530535e789754f4b1f0bb846785a11118261173a578f3c30703ec81f337c9ce24e3ef1a2d5f1d7d2776d83251c3d1bc1e3d7b06502c3e8fcee2a5ac0fdd9f7081e1c9ff82d72f201ca6eee6b77c487e3bf713005cca1f39aaa748683e510725160fd573b43ecc1100e1aa61fe5d660ee8941e1236310f8b3e6f270108fe4f6cdc1db99ef5ba5c2ba3fbd4708911835082868cb481a5dd4231cdc037da151f6da9b212c4a638389284867d82cf0b9cf28157194403abb31b34bb800c6b724453ae95dbb7c05cdc6d6234a5b33ed62ab518619f419343c95c4599e618523b10470d96af45e634ed2fa18e96ba45709d2539664185e2249f1ef9e46b14d5d1944b6cebc9b5ab0e3ead49d197a1c82e121b6561f25cf90e0b1c6ce427e07a605658fc6d2d46160748c52636eb31ab46caaa5b80228435c1587c6f7c82a6eec7963585d1e42cc4f0597047e9d015d070d6ff92e725ffef6c3ab4d6ac2afc3d02341d263bac228df7a8c8a622ffab145355ba1a3d1f6fba4abed1555390d0ae2b5d4838611867f53a8e044367f5ae5e45071ec43830c5564495dc22e36a6d5202689006a9e34f2e6392e1025da7fcae325da51f41aee61a9895e4c483553ebee86fa2445e82b326ae5f3c38dac5b98db43fc97a7417af8e48ef898553a6fb11adf1f3f8147bfa6042becf05fd84430db6d00951ef783becbb5de5467c8ef37c7284dd2ce8ed262b7b59a9ef8b905bd5120108eaff83d23a275e514e13801e03629904ab4643909cf0e8b1c8bc19d174d33a3827ca41cf4e5f3768378a7148c841c8e9db6e122cfe936a104b53ad0118a3a4a05fbe569318d1c71efe24cbc4ef5d47443e1ea7aae19965c658df35817a258ece53701eb5110dcb68d693668fc52568eb182ada62763fd717eff4c68a74ae417dc76e23a2d82f0405279f5555e611005520d0a14d818dc3ef3115fb13c6aceb294a071a2c764dda02cbe3a94425030a79bdb0501324ea87075aceed66a28d043de8b4d2ebb9fda88b433459a8af3b6004baf3dddfc65720cc43dd7de0463f093ef89ba32a42eec89ea37ccc6c33b7e9ad868ce80523aa1a3eb5804addd0ce0882a38554c9d131474c6cf4d9b3de18dc10d1a45a4c3e9ecc4679e72f16dceb38984d4ceb6bd9e4962c3e7ac7aeb76782cbe89acf27adb9551ce689fb93fe29eb87d20afea8278b6dcab92ec3df57ecf5b5a2987b0690419a43cc5a98f32817400a7ff29b1a63f67742529830b291ba28eb57001ad8470c7311fb7b7f5dd307ef23095be92c626e9a8d635c5538401d9bde9e92759867b8405987737a013d16b3daa279f6175d508ec12277c666b0058247ee6eb43c421a3a6ab580ab56a3970ba944df7de2bca025719b38ee40e39f5e557f5192506bc95e47b329c5c0562b3a677c3ac52255080b1f0682094c6f0e37dea1e48c2d05d0288b6563aa8b282e5a7c95a78a3c40ada780895b0097ebe5190140f476ee3ed08e7f490f22385e0155075340fda03fb61161ed662580915367fb08a7dab62c8d331e2f05c9d7f99b4cb326393a8a5f344e636947597dd6a375b30394b2f86c3cc3c771814733181f272d2d5260d53c073eb3deb67d621cd0e3571daa2ed218449138e92f1608d06e09505b2d9127f5a34f68987e9745ec0c92ec4ab201dd87842d3c6d623893989a54afcedc2f706896652d1daab85ed633b930af88a67add79ea3662ad292b69dd66c77c39a6f225a1e387905230e6989892d5950de394f16eae21dfd49cfc5517ba6f26a3bec9de70f090de2301dc2616de52a2a75e2c6ee245518465a4efbd587cc343e30962138a7cb9fb5eb0d2b8383a089fde2c01106aa52a8f4020b9fe166f056b2b8c7433906c603f77907d362dbd06c881bc5c763c13e292d56df62d0cf9a38ea1d1b93d25afff75702e9a094d4192b22f0f15b06c263016c94f8a4d8169acd28d7050819fe571af14da812798d00ee1bf0e09ca022e84cf6c80d4b6deec71332de15bafcb9e82661f094246161ddbbb7212098253a857f7d5ce40fe5ef5715b77a4ccdf3268b2b113c7826d5e9cc0e44fa232a1c2a5800367e9ce770377372c6426042c7a95eea562e21f0048e6af5f7247e35cd9eb07465a1f089065f2d7ef977604fde34cf195d4025c2eb0759a92e1e38d0ee2d46e6c49cb4f39dde98a952c2d46312e2fd452da17677687f27d5a7c66e2120da79eb7203901a9313fef273f00ecdad1ca019cdb79cc092c6d98376b4075be4fc67129bf5b91908019ae4104431e8e42a16d603bb0e0eabc071f4dda8083bbfe367f5380bf078592a19cb881dcc9bd1f0f532691f5570c9d334a02eecb1015d1931c15736f31418d584d4dabb708dd1147fe5affbd120b2d9e3469b4bd3d7822e30b4c30dbb7a8349cf3f2b0399b799563e3e704f7ff12d62a7efecc4c4732fb07cc054abd00462a1b45932f8ad3cd48d0543722e772e2fdd659a9d77ae9eea9df853e007506164b5c7cb1b25d4c6e3fba28d70dd8e1dd93267eec4ae413a61de53bfba2e75d517b0808d878703cdbaf58b9bf14844f1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#4 二分图相关</title>
    <link href="/2022/notes-graph-4/"/>
    <url>/2022/notes-graph-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="二分图最小点覆盖">二分图最小点覆盖</h2><p>给定一张二分图，求出一个最小的点集 <spanclass="math inline">\(S\)</span>，使得图中任意一条边都至少有一个端点在<span class="math inline">\(S\)</span>中。这个问题称为<strong>二分图的最小点覆盖</strong>，简称<strong>最小覆盖</strong>。</p><h3 id="textkonig-定理"><spanclass="math inline">\(\text{k\&quot;onig}\)</span> 定理</h3><p>二分图最小覆盖包含的点数等于此图最大匹配包含的边数。</p><p>看证明过程时，请牢记增广路，最大匹配，匹配点，匹配边的定义，不然像我这种不太聪明的可能会多想很多没用的东西。</p><blockquote><p>证明：</p><p>二分图的最大匹配是所有此图边的子集，且其中的边两两没有共同端点。那么最小覆盖中必然包含最大匹配中每一条边的任意一个端点，不然存在一条最大匹配中的边满足任意一个端点都不在其中。也就是最小覆盖包含的点数大于等于最大匹配包含的边数。</p><p>如下进行构造。</p><ol type="1"><li>求出二分图最大匹配。</li><li>从左部每一个非匹配点进行 DFS寻找增广路，必定失败，同时标记访问过的点。</li><li>取左部未被标记的点、右部被标记的点。得到最小覆盖。</li></ol><p>以下证明它的正确性。由于出发点是左部非匹配点，那么左部匹配点一定没有被标记。而右部被标记的一定是匹配点，否则就找到了一条增广路，与已经求出最大匹配相矛盾。这样选出的点数恰好是最大匹配的边数。</p><p>以下证明它能够覆盖所有的边。分类讨论。</p><ol type="1"><li>连接两个匹配点的边，只会有一个端点被选择，即被覆盖。这是因为求出最大匹配的DFS中匹配点与非匹配点必然是交替访问的，而由于左边选没有标记的，右边选有标记的，所以绝对不会出现下图中选择<span class="math inline">\(1\)</span> 与 <spanclass="math inline">\(A\)</span>的情况。进一步知道，对于一条匹配边，它的两个端点必然只选其中一个。</li><li>连接两个非匹配点的边。求出最大匹配后便不存在了，不然就是一条增广路。</li><li>连接左部非匹配点 <span class="math inline">\(u\)</span>，右部匹配点<span class="math inline">\(v\)</span>。<span class="math inline">\((u\rightarrow v)\)</span> 一定被访问，<spanclass="math inline">\(u\)</span> 一定不被选中，<spanclass="math inline">\(v\)</span> 一定被选中，被覆盖。</li><li>连接左部匹配点 <span class="math inline">\(u\)</span>，右部非匹配点<span class="math inline">\(v\)</span>。如果 <spanclass="math inline">\(u\)</span> 被访问了，那么沿着 <spanclass="math inline">\((u \rightarrow v)\)</span>一定能找到一条增广路，矛盾。所以 <span class="math inline">\(u\)</span>一定不被访问，进而二者没有被标记。那么就一定选择 <spanclass="math inline">\(u\)</span>，一定不选择 <spanclass="math inline">\(v\)</span>，被覆盖。</li></ol></blockquote><p>图片侵删。</p><p>红色边为最大匹配，红色点为最小覆盖。</p><p><img src="https://img-blog.csdnimg.cn/2020031711564475.png" srcset="/img/loading.gif" lazyload /></p><h2 id="二分图最大独立集">二分图最大独立集</h2><h3 id="一般图情况">一般图情况</h3><p>给定一张无向图，求出一个点集，满足任意两点之间没有边相连，称之为这张图的一个<strong>独立集</strong>。包含点最多的那个称为<strong>最大独立集</strong>。</p><p>给定一张无向图，求出一个点集，满足任意两点之间都有一条边相连，称之为这张图的一个<strong>团</strong>。包含点最多的那个称为<strong>最大团</strong>。</p><p>一个定理：对于无向图 <spanclass="math inline">\(G\)</span>，其最大团为其补图 <spanclass="math inline">\(G&#39;\)</span> 的最大独立集。</p><p><span class="math inline">\(G=(V,E)\)</span> 的补图 <spanclass="math inline">\(G&#39;=(V,E&#39;)\)</span>，其中 <spanclass="math inline">\(E&#39; = \{(x,y) \notin E \}\)</span>。也就是对于<span class="math inline">\(x,y \in V\)</span>，如果它们两个点 <spanclass="math inline">\(G\)</span> 中没有边，那么在 <spanclass="math inline">\(G&#39;\)</span>中就有边，反之没有边。也可以理解为，将 <spanclass="math inline">\(G\)</span>扩展成一个完全图，然后减掉原有的边。</p><p>很重要的<strong>补图转化思想</strong>，从问题的另一面打开突破口。</p><p>对于一般图，最大团与最大独立集是 NPC问题。（<del>好了不用学了</del>）</p><h3 id="二分图情况">二分图情况</h3><p>一个定理：</p><p>设 <span class="math inline">\(G\)</span> 为有 <spanclass="math inline">\(n\)</span> 个节点的二分图，<spanclass="math inline">\(G\)</span> 的最大独立集为 <spanclass="math inline">\(n\)</span>减去最大匹配的边数（最小覆盖的点数）。</p><blockquote><p>证明：</p><p>选出最多的点构成独立集。等于在图中去掉最少的点，使得剩下的点两两不相连。也就是用最少的点去覆盖所有的边（然后把它们删了）。</p></blockquote><h2 id="dag-的最小路径点覆盖">DAG 的最小路径点覆盖</h2><p>给定一个 DAG，要求用尽量少的不相交的简单路径，恰好覆盖 DAG的所有点，这个问题成为 DAG 的<strong>最小路径点覆盖</strong>问题。</p><p>设原来的 DAG 为 <span class="math inline">\(G = (V,E)\)</span>，共有<span class="math inline">\(n\)</span> 个节点。对于 <spanclass="math inline">\(x \in V\)</span>，把它拆成 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(x+n\)</span> 两个点。将 <spanclass="math inline">\([1,n]\)</span> 作为左部点，<spanclass="math inline">\([n+1,2n]\)</span>作为右部点建立二分图。对于原图中的边 <span class="math inline">\((x\rightarrow y)\)</span>，再二分图中连 <span class="math inline">\((x\rightarrow y+n)\)</span>。最终得到的二分图 <spanclass="math inline">\(G&#39;\)</span> 称为 <spanclass="math inline">\(G\)</span> 的拆点二分图。</p><blockquote><p>定理：</p><p><span class="math inline">\(G\)</span>的最小路径点覆盖包含的路径条数等于 <spanclass="math inline">\(n\)</span> 减去 <spanclass="math inline">\(G&#39;\)</span> 的最大匹配数。</p></blockquote><p>证明暂略，有时间补上。</p><p> </p><p>如果简单路径可相交，那么就是 DAG的<strong>最小路径可重复点覆盖</strong>问题。</p><p>最小路径可重复点覆盖中，如果有两条路径 <span class="math inline">\((x\rightarrow p \rightarrow y)\)</span>，<span class="math inline">\((u\rightarrow p \rightarrowv)\)</span>，那么这两条路径是相交的。但是如果添加一条边 <spanclass="math inline">\((x \rightarrowy)\)</span>，那么就能让他们不相交了。</p><p>进一步地，对于任意能够间接连通两个点，都添加一条边让它们直接连通，然后c拆点跑最大匹配，用<span class="math inline">\(n\)</span>减去就行了。但是一旦加边后，这就不再是一个 DAG了，所以如果要用网络流算法求最大匹配的话，对于间接连通的点对 <spanclass="math inline">\((x,y)\)</span>，只需要添加 <spanclass="math inline">\((x \rightarrowy+n)\)</span>。但如果是匈牙利算法的话就不用考虑，因为邻接矩阵的特殊结构。</p><p>上述判断间接连通可以用 Floyd 传递闭包实现。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1582E Pchelyonok and Segments 题解</title>
    <link href="/2022/cf1582e-solution/"/>
    <url>/2022/cf1582e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>倒着选区间。</p><p>设 <span class="math inline">\(f(i,k)\)</span> 表示从 <spanclass="math inline">\([i,n]\)</span> 中选择 <spanclass="math inline">\(k\)</span>个区间，其中最后一个区间（也就是最长的，最靠近 <spanclass="math inline">\(i\)</span> 的区间）的最大值。</p><p>当 <span class="math inline">\(k=1\)</span> 时 <spanclass="math display">\[f(i,k) = \max{\{ f(i+1,k),a_i \}}\]</span> 当 <span class="math inline">\(i+k-1 \le n\)</span> 且 <spanclass="math inline">\(S(i,i+k-1) &lt; f(i+k,k-1)\)</span> 时 <spanclass="math display">\[f(i,k) = \max{\{ f(i+1,k),S(i+k,k-1) \}}\]</span> 限制条件是由于</p><ol type="1"><li>选择包括 <span class="math inline">\(i\)</span> 在内的长度为 <spanclass="math inline">\(k\)</span> 的区间不能越界。</li><li><span class="math inline">\(f(i+k,k-1)\)</span>实际上就是上一个区间的最大值，要符合题意，<spanclass="math inline">\(S(i+k,k-1)\)</span> 这一段和必须严格小于它。</li></ol><p>最后倒序枚举 <span class="math inline">\(k\)</span>，首个非 0 的<span class="math inline">\(f(1,k)\)</span> 中的 <spanclass="math inline">\(k\)</span> 即为答案。</p><p><span class="math inline">\(\frac{k(k+1)}{2} \le n\)</span>，是 <spanclass="math inline">\(O(\sqrt n)\)</span> 级别的。</p><p>复杂度 <span class="math inline">\(O(n \sqrt n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, K=<span class="hljs-number">505</span>;<span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e16</span>;<span class="hljs-type">int</span> t, n, a[N], lim;ll s[N], f[N][K];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;lim=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i*(i+<span class="hljs-number">1</span>)&lt;=<span class="hljs-number">2</span>*n;++i) f[n+<span class="hljs-number">1</span>][i]=-inf;    <span class="hljs-comment">// 边界</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k*(k+<span class="hljs-number">1</span>)&lt;=<span class="hljs-number">2</span>*n;++k) &#123;<span class="hljs-keyword">if</span>((k+<span class="hljs-number">1</span>)*(k+<span class="hljs-number">2</span>)&gt;<span class="hljs-number">2</span>*n) lim=k;        <span class="hljs-comment">// 如果成立，表示这个k合法，下一个就不合法了</span>        <span class="hljs-comment">// lim记录最大的k，不然开平方会有误差。</span>f[i][k]=f[i+<span class="hljs-number">1</span>][k];ll S=s[i+k<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) f[i][k]=<span class="hljs-built_in">max</span>(f[i][k],<span class="hljs-number">1ll</span>*a[i]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&amp;&amp;i+k<span class="hljs-number">-1</span>&lt;=n&amp;&amp;S&lt;f[i+k][k<span class="hljs-number">-1</span>]) f[i][k]=<span class="hljs-built_in">max</span>(f[i][k],S);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=lim;k;--k) <span class="hljs-keyword">if</span>(f[<span class="hljs-number">1</span>][k]&gt;<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,k); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1197D Yet Another Subarray Problem 题解</title>
    <link href="/2022/cf1197d-solution/"/>
    <url>/2022/cf1197d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>还有比我菜的人吗？</p><h2 id="分析">分析</h2><p>最难处理的地方在于 <span class="math inline">\(\Delta =k \lceil\frac{r-l+1}{m} \rceil\)</span>。</p><p>设 <span class="math inline">\(g(x) = x \bmodm\)</span>，首先这是个在非负整数域上周期为 <spanclass="math inline">\(m\)</span> 的周期函数。循环节为 <spanclass="math inline">\([0,m-1]\)</span>。其次在每一个周期中 <spanclass="math inline">\(g(x) \in [1,m-1]\)</span> 的 <spanclass="math inline">\(x\)</span> 与下一个周期 <spanclass="math inline">\(g(x)=0\)</span> 的 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(\lceil\frac{x}{m} \rceil\)</span> 的值都是相等的。这启发我们从区间长度模 <spanclass="math inline">\(m\)</span> 的值下手。</p><p>设 <span class="math inline">\(f(r,k)\)</span> 为右端点是 <spanclass="math inline">\(r\)</span>，其左端点 <spanclass="math inline">\(l\)</span> 满足 <span class="math inline">\(r-l+1\bmod m = k\)</span>。</p><p>考虑最特殊的 <span class="math inline">\(m=1\)</span>的情况，设区间长度为 <spanclass="math inline">\(len\)</span>，上面那个式子永远是就是 $ klen$。当区间长度变为 <spanclass="math inline">\(len+1\)</span>，右端点到 <spanclass="math inline">\(r+1\)</span> 时，<spanclass="math inline">\(\Delta + k\)</span>，整个式子增加 <spanclass="math inline">\(a_{r+1} -k\)</span>。</p><p>当 <span class="math inline">\(m\)</span>是个一般数值时，就要用到取模了。设 <span class="math inline">\(len \bmodm = k\)</span>，其中 <span class="math inline">\(k \neq m-1\)</span> 且<span class="math inline">\(k \neq 0\)</span>，那么区间向右扩展到 <spanclass="math inline">\(r+1\)</span> 时，只会增加 <spanclass="math inline">\(a_{r+1}\)</span>，因为这是在 <spanclass="math inline">\(g(x)\)</span> 的同一个周期内，<spanclass="math inline">\(\Delta\)</span> 相同。 <spanclass="math display">\[f(r+1,k+1) = f(r,k)+a_{a_r+1} \quad k \in [1,m-2]\]</span> 如果 <span class="math inline">\(k=m-1\)</span>，那么 <spanclass="math inline">\(k+1 \midm\)</span>，进入下一个周期了。但是仍然相同，增加 <spanclass="math inline">\(a_{r+1}\)</span>。 <span class="math display">\[f(r+1,k+1) = f(r,m-1) + a_{r+1} \quad k=m-1\]</span> 还有一种情况，当 <span class="math inline">\(k=0\)</span>时，可以“重新开启一段新区间”的。新区间的权值为 <spanclass="math inline">\(a_{r+1}-k\)</span>。如果重启新区间，由上述讨论知道权值会增加<span class="math inline">\(a_{r+1}-k\)</span>。 <spanclass="math display">\[f(r+1,1) = \max{\{ f(r,0) + a_{r+1} ,a_{r+1}-k\}}\]</span> 有意思的是，当 <span class="math inline">\(m=1\)</span>的时候，<span class="math inline">\(k\)</span> 只能取0，享受同级待遇。😅</p><h2 id="code">CODE</h2><p>上文为了方便叙述，转移用的是刷表法，代码里用的是填表法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;ll n, m, k, ans, a[N], f[N][<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>||m==<span class="hljs-number">1</span>) f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+a[i]-k,a[i]-k);        <span class="hljs-comment">// 特殊状态</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!j) f[i][j]=f[i<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>]+a[i];        <span class="hljs-comment">// j-1 mod m = m-1</span><span class="hljs-keyword">else</span> f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i];        <span class="hljs-comment">// 一般状态</span>ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5687 网格图 题解</title>
    <link href="/2022/lg5687=solution/"/>
    <url>/2022/lg5687=solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>直接建图跑最小生成树只有 <spanclass="math inline">\(64pts\)</span>。</p><p>注意到对于一个节点 <span class="math inline">\((i,j)\)</span>，同在第<span class="math inline">\(i\)</span>行的节点向它们的右边节点连边的代价都是 <spanclass="math inline">\(a_i\)</span>，同在 <spanclass="math inline">\(j\)</span> 列的节点向它们的下方节点连边的代价都是<span class="math inline">\(b_j\)</span>。那么把 <spanclass="math inline">\(\{a\}\)</span> 与 <span class="math inline">\(\{b\}\)</span> 递增排序，此时就相当于把网格图交换了行与列。</p><p>这时候 <span class="math inline">\((1,1)\)</span> 既对应着最小的<span class="math inline">\(a_1\)</span>，又对应着最小的 <spanclass="math inline">\(b_1\)</span>，那么第一行与第一列都是要选择的，否则一定不是最小的。同时也可以推广到对于一个<span class="math inline">\(a_i\)</span> 或 <spanclass="math inline">\(b_j\)</span>，要么不连，要么能连的连起来，才能保证最优性。</p><p>最小生成树不能有环。画图不难发现，在第一行和第一列都被选择的情况下，如果在格子图中出现了环（格子图中的最简单环是个正方形），那么一定存在<spanclass="math inline">\((i,j)\)</span>，在某个时刻（不关心先后顺序）既选择了所有<span class="math inline">\(a_i\)</span>，又选择了所有 <spanclass="math inline">\(b_j\)</span>，其中 <spanclass="math inline">\(i,j\)</span> 均不为1。为了防止出现这种情况，已经考虑过的部分不能被后面的决策影响。</p><p>所以就很明确了，维护变量 <span class="math inline">\(row\)</span>记录当前行，<span class="math inline">\(col\)</span>记录当前列，维护指针 <span class="math inline">\(p1\)</span> 表示 <spanclass="math inline">\(a_{p1}\)</span>，<spanclass="math inline">\(p2\)</span> 表示 <spanclass="math inline">\(b_{p2}\)</span>。</p><p>当 <span class="math inline">\(a_{p1} \le b_{p2}\)</span>时，连起来这一行能连的边，前 <span class="math inline">\(col\)</span>列已经使用过了，贡献为 <span class="math inline">\(a_{p1} \cdot(m-col)\)</span>，这一行不能再考虑，<spanclass="math inline">\(a_{p1}\)</span> 不能再使用，<spanclass="math inline">\(row+1\)</span>，<spanclass="math inline">\(p1+1\)</span>。反之贡献为 <spanclass="math inline">\(b_{p2} \cdot (n-row)\)</span>，<spanclass="math inline">\(col+1\)</span>，<spanclass="math inline">\(p2+1\)</span>。</p><p>当 <span class="math inline">\(p1&gt;n\)</span> 或者 <spanclass="math inline">\(p2&gt; m\)</span>的时候，图已经连通，也就求出了最小生成树。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m;ll a[N], b[N], ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;b[i]);<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>), <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+m+<span class="hljs-number">1</span>);ans+=a[<span class="hljs-number">1</span>]*(m<span class="hljs-number">-1</span>)+b[<span class="hljs-number">1</span>]*(n<span class="hljs-number">-1</span>);<span class="hljs-type">int</span> row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span>, c1=<span class="hljs-number">2</span>, c2=<span class="hljs-number">2</span>;<span class="hljs-keyword">while</span>(c1&lt;=n&amp;&amp;c2&lt;=m) &#123;<span class="hljs-keyword">if</span>(a[c1]&lt;=b[c2]) ans+=a[c1++]*(m-col), ++row;<span class="hljs-keyword">else</span> ans+=b[c2++]*(n-row), ++col; &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#3 二分图匹配</title>
    <link href="/2022/notes-graph-3/"/>
    <url>/2022/notes-graph-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="二分图的定义与判定">二分图的定义与判定</h2><h3 id="定义">定义</h3><p>对于一张有 <span class="math inline">\(n\)</span>个节点的无向图（<span class="math inline">\(n \ge2\)</span>），可以分成两个集合 <span class="math inline">\(A\)</span> 与<span class="math inline">\(B\)</span> 两个非空集合，满足 <spanclass="math inline">\(A \cap B =\varnothing\)</span>，且任意一个集合内的点之间都没有边相连。那么称这张图为二分图。</p><h3 id="判定">判定</h3><p>不加证明地给出一个定理：</p><blockquote><p>一张无向图是二分图，当且仅当图中不存在奇环。</p></blockquote><p>根据这个定理，可以用染色的方法进行二分图判定。用黑白二色标记图中节点，当一个节点被交际后，将所有与它直接相连的点标记为与它相反的颜色。那么对于一个点<span class="math inline">\(x\)</span>，颜色为 <spanclass="math inline">\(col_x\)</span>，存在与它直接相连且已经被染色的点<span class="math inline">\(y\)</span>，满足 <spanclass="math inline">\(col_x = col_y\)</span>，那么说明图中存在奇环。</p><p>复杂度 <span class="math inline">\(O(n+m)\)</span>，其中 <spanclass="math inline">\(n\)</span> 为点数，<spanclass="math inline">\(m\)</span> 为边数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span> </span>&#123;v[x]=color;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-type">int</span> y=e[i].to;<span class="hljs-keyword">if</span>(v[y]==color) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!v[y]&amp;&amp;!<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-color)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="二分图最大匹配">二分图最大匹配</h2><p>如果一个边集满足「任意两条边都没有公共端点」，那么这个<strong>边集</strong>称为该图的一组<strong>匹配</strong>。在二分图中，包含边数最多的一组匹配称为<strong>二分图的最大匹配</strong>。</p><p>对于一组匹配 <span class="math inline">\(S\)</span>，属于 <spanclass="math inline">\(S\)</span>的边称为“匹配边”，不属于它的边称为“非匹配边”。匹配边的端点称为“匹配点”，其他节点称为“非匹配点”。</p><p>在二分图中，如果存在链接两个非匹配点的路径 <spanclass="math inline">\(p\)</span>，且非匹配边与匹配边在 <spanclass="math inline">\(p\)</span> 上交替出现，那么 <spanclass="math inline">\(p\)</span> 就是 <spanclass="math inline">\(S\)</span> 的<strong>增广路</strong>。</p><p>它必然有以下性质：</p><ul><li>长度 <span class="math inline">\(l\)</span>为奇数。否则连接某一个端点的增广路上的边是匹配边，与它是非匹配点相矛盾。</li><li>路径上第 <span class="math inline">\(1,3,5,\cdots l\)</span>条边是非匹配边，<span class="math inline">\(2,4,6,\cdots l-1\)</span>条边为匹配边。由定义不难得出。</li></ul><p>由于这两条性质，得出在增广路上，匹配边的数量必定是非匹配边的数量-1，那么如果将路径上所有的边的状态取反，那么就能减少一条增广路，得到一个新的匹配<span class="math inline">\(S&#39;\)</span>，其中匹配边的数量为 <spanclass="math inline">\(S\)</span> 中匹配边的数量 +1。进而得到推论：</p><blockquote><p>二分图的一组匹配 <span class="math inline">\(S\)</span>为最大匹配，当且仅当图中不存在 <span class="math inline">\(S\)</span>的增广路</p></blockquote><h3 id="匈牙利算法">匈牙利算法</h3><p>又称为增广路算法，用于计算二分图最大匹配，其过程为：</p><ol type="1"><li>设 <span class="math inline">\(S =\varnothing\)</span>，即图中所有边都是非匹配边。</li><li>寻找增广路 <spanclass="math inline">\(p\)</span>，并且所有状态取反，得到更大的匹配 <spanclass="math inline">\(S&#39;\)</span>。</li><li>重复第 2 步，直到图中不存在增广路，此时得到的 <spanclass="math inline">\(S&#39;&#39;\)</span> 即为改二分图的最大匹配。</li></ol><p>这个算法的核心为寻找增广路。</p><p>称 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 匹配当且仅当 <spanclass="math inline">\((x \rightarrow y)\)</span> 在匹配 <spanclass="math inline">\(S\)</span>之内。匈牙利算法依次尝试给每一个左部节点 <spanclass="math inline">\(x\)</span> 寻找一个匹配的右部节点 <spanclass="math inline">\(y\)</span>。<span class="math inline">\(x\)</span>与 <span class="math inline">\(y\)</span>能够匹配，需要满足以下条件之一。</p><ol type="1"><li><p><span class="math inline">\(y\)</span> 本身是非匹配点。那么 <spanclass="math inline">\((x \rightarrow y)\)</span>就是一条非匹配边，构成长度为 1 的增广路。</p></li><li><p><span class="math inline">\(y\)</span> 已经与左部节点 <spanclass="math inline">\(x&#39;\)</span> 匹配，但是从 <spanclass="math inline">\(x&#39;\)</span> 出发能够找到一个右部节点 <spanclass="math inline">\(y&#39;\)</span> 与它匹配。此时 <spanclass="math inline">\(x \rightarrow y \rightarrow x&#39; \rightarrowy&#39;\)</span> 是一条增广路。</p></li></ol><p>找到增广路之后直接回溯，将路径上的匹配状态取反， <spanclass="math inline">\(S\)</span> 中边的个数就 +1。</p><p>这个算法的正确性基于：当一个节点成为匹配点后，至多因为找到新的增广路而更换匹配对象，但不会变为非匹配边。</p><p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-type">int</span> y=e[i].to;<span class="hljs-keyword">if</span>(!v[y]) &#123;v[y]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) &#123; match[y]=x; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) ++ans;&#125;&#125;<span class="hljs-comment">// ans即为最大匹配</span></code></pre></div><h2 id="二分图多重匹配">二分图多重匹配</h2><p>二分图，<span class="math inline">\(N\)</span> 个左部点，<spanclass="math inline">\(M\)</span> 个右部点，从中选出尽可能多的边，使得第<span class="math inline">\(i\)</span> 个左部节点至多与 <spanclass="math inline">\(kl_i\)</span> 条选出的边相连，第 <spanclass="math inline">\(j\)</span> 个右部点最多与 <spanclass="math inline">\(kr_j\)</span>条选出的边相连。称之为二分图的多重匹配。</p><p>有 4 中解决方案。</p><ol type="1"><li>拆点。把第 <span class="math inline">\(i\)</span> 个左部点拆成 <spanclass="math inline">\(kl_i\)</span> 个点，把第 <spanclass="math inline">\(j\)</span> 个右部点拆成 <spanclass="math inline">\(kr_j\)</span> 个右部点。对于原图中的边 <spanclass="math inline">\((i,j)\)</span>，在 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span>拆成的节点之间分别连边。然后跑最大匹配。</li><li>如果所有的 <span class="math inline">\(kl\)</span> 都为 1 或者所有的<span class="math inline">\(kr\)</span> 都为1，那么只有一侧是多重的。假如左侧是多重的，方法是在匈牙利算法让每个<spanclass="math inline">\(i\)</span> 执行 <spanclass="math inline">\(kl_i\)</span> 次 DFS。</li><li>在上一种方案中，左右两侧是可以交换的。设右侧为多重，那么让每个右部节点<span class="math inline">\(i\)</span> 可以匹配 <spanclass="math inline">\(kr_i\)</span>次，超过匹配次数后，依次递归每个匹配的左部点。</li><li>网络流。</li></ol><h2 id="二分图带权匹配-km-算法">二分图带权匹配 &amp; KM 算法</h2><p>对一张带权的二分图求最大匹配，称为二分图带权最大匹配。注意前提是<strong>匹配数最大</strong>，再<strong>最大化边权和</strong>。</p><p>想了好久，找到了相对比较好理解的讲解方法。</p><p>先引入几个概念。</p><h3 id="完备匹配">完备匹配</h3><p>给定一张二分图，其左右节点数均为 <spanclass="math inline">\(n\)</span>。如果改二分图最大匹配含有 <spanclass="math inline">\(n\)</span>条边，那么该二分图具有完备匹配。也就是从每个节点出发寻找匹配都能成功。</p><h3 id="顶标">顶标</h3><p>在二分图中，给左部节点 <span class="math inline">\(i\)</span>一个权值 <span class="math inline">\(A_i\)</span>，右部节点 <spanclass="math inline">\(j\)</span> 一个权值 <spanclass="math inline">\(B_j\)</span>。满足 <span class="math inline">\(A_i+ B_j \ge w(i,j)\)</span>，其中 <spanclass="math inline">\(w(i,j)\)</span> 为两点之间的边权。这样的 <spanclass="math inline">\(A_i\)</span> 与 <spanclass="math inline">\(B_j\)</span> 成为顶标。</p><h3 id="相等子图">相等子图</h3><p>二分图中所有节点与满足 <span class="math inline">\(A_i + B_j =w(i,j)\)</span> 的边 <span class="math inline">\((i,j)\)</span>构成的子图叫做这张二分图的相等子图。</p><blockquote><p>若相等子图中存在完备匹配，则这个完备匹配就是二分图的带权最大匹配。</p><p>证明：</p><p>在相等子图中，完备匹配的边权和为 <spanclass="math inline">\(\sum_{i=1}^n (A_i +B_i)\)</span>，也就是顶标之和。</p><p>因为 <span class="math inline">\(A_i + B_j \gew(i,j)\)</span>，所以在二分图中，任何一组匹配的边权和都不大于顶标之和。</p></blockquote><h3 id="交错树匈牙利树">交错树（匈牙利树）</h3><p>在匈牙利算法的过程中，如果从某个左部结点出发寻找匹配失败，那么在 DFS的过程中，访问过的节点和边构成一棵树，满足根为一个左部节点，叶子均为左部节点，且奇数层的边均为非匹配边，偶数层的边均为匹配边。这样的树称为交错树。</p><p>一个没用的推论，交错树高度为奇数。</p><p>匈牙利算法中的<code>dfs(i)=1</code>就代表不存在以 <spanclass="math inline">\(i\)</span> 为根的交错树。</p><p>很多地方没有提到的一点就是，如果有交错树，那么必然没有完备匹配，否则与每个从节点出发都能找到匹配相矛盾。这也是下文一系列操作的基础——修改标顶使得尽可能多的边进入相等子图。</p><p>知道大概就行了，深入讲真的不太好理解，可能更加学术一点？总而言之，我们的相等子图中不能存在交错树，否则就没有完备匹配，就没有带权最大匹配了！</p><p> </p><h3 id="流程">流程</h3><p>对于 <span class="math inline">\(i\)</span>，可以把 <spanclass="math inline">\(B_i\)</span> 设置为 0，<spanclass="math inline">\(A_i\)</span> 设置为 <spanclass="math inline">\(\max_{(i \rightarrow j)}{\{ w(i,j)\}}\)</span>，这样一定满足条件。</p><p>调整顶标是为了让更多的边 <span class="math inline">\((i,j)\)</span>满足 <span class="math inline">\(A_i + B_j =w(i,j)\)</span>，也就是扩大相等子图。</p><p>设当前节点为 <span class="math inline">\(k\)</span>且满足<strong>在相等子图中</strong>存在以它为根的交错树。找到 <spanclass="math inline">\((i,j)\)</span>，满足 <spanclass="math inline">\(i\)</span> 在以 <spanclass="math inline">\(k\)</span> 为根的交错树中但是 <spanclass="math inline">\(j\)</span> 不在，那么如果把 <spanclass="math inline">\((i,j)\)</span>加入相等子图，就能够消去这棵交错树了。</p><p>如果把这棵交错树中所有左部节点的顶标都减去一个 <spanclass="math inline">\(\Delta\)</span>，右部节点都加上一个 <spanclass="math inline">\(\Delta\)</span>，那么对于相等子图中一左一右两个节点<span class="math inline">\((u,v)\)</span>，<spanclass="math inline">\(A_u + B_v\)</span> 和不变，仍然在相等子图中。而<span class="math inline">\(A_i + B_j\)</span> 变小了，因为 <spanclass="math inline">\(j\)</span> 不在交错树中。</p><p>怎么样保证 <span class="math inline">\((i,j)\)</span>一定进入相等子图呢？这要求 <span class="math inline">\(A_i + B_j =w(i,j)\)</span>。找到交错树中的任意节点 <spanclass="math inline">\(i\)</span>，令 <spanclass="math inline">\(\Delta=A_i+B_j-w(i,j)\)</span>，那么就相当于 <spanclass="math display">\[A_i - (A_i + B_j - w(i,j)) + B_j = w(i,j)\]</span></p><p>这个显然是成立的。至于 <span class="math inline">\(i\)</span>是啥我们不关心，只要这样做就能让 <spanclass="math inline">\((i,j)\)</span>加入相等子图。如果减去太多导致某两个点的顶标和小于边权和了怎么办呢？对于<span class="math inline">\(j \in [1,n]\)</span>，取 <spanclass="math inline">\(A_i + B_j - w(i,j)\)</span>的最小值。这个可以在匈牙利算法的过程中预处理出来，记为 <spanclass="math inline">\(slack(j)\)</span>。</p><p>最终只要把边权和加起来就是答案了。</p><p>这么一来最优情况下复杂度是 <spanclass="math inline">\(O(n^3)\)</span>，但是很容易就会被卡到 <spanclass="math inline">\(O(n^4)\)</span>。使用 BFS 优化匈牙利算法可以做到<span class="math inline">\(O(n^3)\)</span>，有时间再写。</p><p>KM算法代码较简单，且在稠密图上表现较好，但是只适用于“原图一定存在完备匹配”的情况。至于费用流的算法，以后再说咯~</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;va[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=n;++y) <span class="hljs-keyword">if</span>(!vb[y]) &#123;<span class="hljs-keyword">if</span>(la[x]+lb[y]==w[x][y]) &#123;            <span class="hljs-comment">// la[x]+lb[y]=w[x][y]，(x,y)在相等子图中</span>            <span class="hljs-comment">// vb[y]=1表示如果村子交错树，那么y必定在其中</span>vb[y]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) &#123;match[y]=x; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> slack[y]=<span class="hljs-built_in">min</span>(slack[y],la[x]+lb[y]-w[x][y]);        <span class="hljs-comment">// 不在相等子图中就更新slack</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;la[i]=-inf, lb[i]=<span class="hljs-number">0</span>;match[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) la[i]=<span class="hljs-built_in">max</span>(la[i],w[i][j]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) v[a]=v[b]=<span class="hljs-number">0</span>, slack[j]=inf;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 这样就没有交错树了</span>dlt=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!vb[j]) dlt=<span class="hljs-built_in">min</span>(dlt,slack[j]);        <span class="hljs-comment">// 取最小值修改标顶</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(va[j]) la[j]-=dlt;<span class="hljs-keyword">if</span>(vb[j]) lb[j]+=dlt;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=w[match[i]][i];    <span class="hljs-comment">// ans+=la[i]+lb[i]</span>    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7961 数列 题解</title>
    <link href="/2022/lg7961-solution/"/>
    <url>/2022/lg7961-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>于 2023 年 6 月 20 日重构此文。</p><h2 id="暴力">暴力</h2><p>首先明确 <span class="math inline">\(a_i \in [0,m]\)</span>。</p><p>设 <span class="math inline">\(f(x,S)\)</span> 为当前 <spanclass="math inline">\(\{a_i\}\)</span> 有 <spanclass="math inline">\(x\)</span> 项，其中 <span class="math inline">\(S= \sum_{i=1}^x 2^{a_i}\)</span>，能够产生的贡献。</p><p>状态总数为 <span class="math inline">\(O(2^{m}nm)\)</span>。</p><p>枚举 <span class="math inline">\(k\)</span>，转移 <spanclass="math inline">\(O(m)\)</span>。 <span class="math display">\[f(x,S) = \sum_{i=0}^m f(x+1,S+2^{m}) \cdot v_i\]</span> 边界用 <spanclass="math inline">\(\operatorname{popcount}\)</span> 判断。</p><p>复杂度 <span class="math inline">\(O(2^m m^2 n)\)</span>。</p><p>期望得分 <span class="math inline">\(50 \text{ pts}\)</span>。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">35</span>, M=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, k, v[M], f[N][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ctz</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> S)</span> </span>&#123;<span class="hljs-keyword">if</span>(~f[x][S]) <span class="hljs-keyword">return</span> f[x][S];<span class="hljs-keyword">if</span>(x==n) <span class="hljs-keyword">return</span> f[x][S]=<span class="hljs-built_in">ctz</span>(S)&lt;=k;<span class="hljs-type">int</span>&amp; res=f[x][S];res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;(res+=v[i]*<span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,S+(<span class="hljs-number">1</span>&lt;&lt;i)))%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) v[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="正解">正解</h2><p>暴力状态无论如何优化都无法承受了，考虑重新设计状态。</p><p>瓶颈在于状态数量太多。</p><p>在暴力的做法中，我们把 <span class="math inline">\(S\)</span>看作是一个真实的数，从而绕不开 <span class="math inline">\(S\)</span>的表示方法，计算贡献的方法也因此被限制。</p><p>尝试转化问题，我们实际上要确定一个长度为 <spanclass="math inline">\(n\)</span> 的序列，元素的值域是 <spanclass="math inline">\([0,m]\)</span>，元素 <spanclass="math inline">\(j\)</span> 出现 <spanclass="math inline">\(k\)</span> 次的贡献是 <spanclass="math inline">\(v_j^k\)</span>。限制是 <spanclass="math inline">\(\operatorname{popcount}(S) \le k\)</span>，把<span class="math inline">\(S\)</span> 看作 <spanclass="math inline">\(m\)</span>位二进制数的话，可以从进位的角度下手，按照数位从低到高处理，其实也就是确定了构造<span class="math inline">\(a\)</span> 序列的顺序。</p><p><span class="math inline">\(f(k,i,x,y)\)</span>，表示已经确定了 <spanclass="math inline">\(S\)</span> 二进制的 <spanclass="math inline">\(k\)</span> 位，其中 <spanclass="math inline">\(\{a\}\)</span> 数列确定了 <spanclass="math inline">\(i\)</span> 项，有 <spanclass="math inline">\(x\)</span> 个 <spanclass="math inline">\(1\)</span>，同时第 <spanclass="math inline">\(k-1\)</span> 位进了 <spanclass="math inline">\(y\)</span> 个 1 到 <spanclass="math inline">\(k\)</span> 位，还能够产生的贡献。</p><p>状态数量是 <span class="math inline">\(O(mn^3)\)</span> 的。</p><p>转移枚举第 <span class="math inline">\(k\)</span> 位上放多少个 <spanclass="math inline">\(1\)</span>，也就是 <spanclass="math inline">\(v_k\)</span> 用多少次。 <spanclass="math display">\[f(k,i,x,y) = \sum_{j=0}^{n-i} f \Big(k+1,i+j,x+op(y+j),\lfloor\frac{y+j}{2} \rfloor \Big) \times \binom{n-i}{j} \times v_k^j\]</span> <span class="math inline">\(op(x) = [x \text{ is }\mathrm{odd}]\)</span>。</p><p>当 <span class="math inline">\(i=n\)</span> 的时候，此时 <spanclass="math inline">\([1,k]\)</span> 位上有 <spanclass="math inline">\(x\)</span> 个 <spanclass="math inline">\(1\)</span>，前面进了 <spanclass="math inline">\(y\)</span> 个 <spanclass="math inline">\(1\)</span>。 <spanclass="math inline">\(y\)</span> 个 <spanclass="math inline">\(1\)</span> 最后产生的 <spanclass="math inline">\(1\)</span> 数量是它的二进制中 1 的个数。</p><p>复杂度 <span class="math inline">\(O(mn^4)\)</span>。</p><p>期望得分 <span class="math inline">\(100 \text{ pts}\)</span>。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">35</span>, M=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, m, k, v[M][N], c[N][N], f[M][N][N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">2</span>,n) v[i][j]=v[i][j<span class="hljs-number">-1</span>]*v[i][<span class="hljs-number">1</span>]%mod;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(~f[p][i][x][y]) <span class="hljs-keyword">return</span> f[p][i][x][y];<span class="hljs-type">int</span>&amp; res=f[p][i][x][y];res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i==n) <span class="hljs-keyword">return</span> res=(x+<span class="hljs-built_in">popcount</span>(y)&lt;=k);<span class="hljs-keyword">if</span>(p&gt;m) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n-i;++j) &#123;(res+=c[n-i][j]*v[p][j]%mod*<span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,i+j,x+(y+j)%<span class="hljs-number">2</span>,(y+j)/<span class="hljs-number">2</span>)%mod)%=mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,m) v[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, v[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>计数</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7960 报数 题解</title>
    <link href="/2022/lg7960-solution/"/>
    <url>/2022/lg7960-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先判断某个数十进制中是否含有 7 这个很简单。</p><p>然后用筛子把它的倍数筛掉就行了。</p><p>瓶颈在于，如何快速回答下一个要报出的数。枚举的话只有 70pts。</p><p>考虑一个数 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(p(x)=0\)</span> 且不存在 <spanclass="math inline">\(y\)</span>，满足 <spanclass="math inline">\(p(y)=1\)</span> 且 <span class="math inline">\(y\mid x\)</span>，它一定是某个数“下一个要报出的数”。</p><p>而每一个数“下一个要报出的数”一定是单调增的。</p><p>所以设 <span class="math inline">\(r_x\)</span> 为 <spanclass="math inline">\(x\)</span>下一个要报出的数，如果它本身不合法，那么就是 -1。</p><p>我们可以在筛数的过程中，维护 <spanclass="math inline">\(lst\)</span>。如果 <spanclass="math inline">\(x\)</span> 满足条件，直接令 <spanclass="math inline">\(r_{lst}=x\)</span>，<spanclass="math inline">\(lst = x\)</span>。因为 <spanclass="math inline">\((lst,x)\)</span>这个区间里的数都是不合法的，否则与 <spanclass="math inline">\(x\)</span> 为“下一个要报出的数”相矛盾。</p><p>注意当 <span class="math inline">\(x=10^7\)</span> 时，答案为 <spanclass="math inline">\(10^7+1\)</span>。</p><p>预处理之后就可以直接输出 <spanclass="math inline">\(r_x\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, r[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=a*<span class="hljs-number">10</span>+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">7</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(x) &#123;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;x/=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// pd(x)=1表示x十进制中有7或者是7的倍数</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(r,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(r));<span class="hljs-type">int</span> lst=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1e7</span>+<span class="hljs-number">1</span>;++i) &#123;<span class="hljs-keyword">if</span>(v[i]) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// v[i]=1就代表i不合法</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">pd</span>(i)) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=<span class="hljs-number">1e7</span>+<span class="hljs-number">1</span>;j+=i) v[j]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> r[lst]=i, lst=i;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// freopen(&quot;d:\\number\\number4.in&quot;,&quot;r&quot;,stdin);</span><span class="hljs-comment">// freopen(&quot;d:\\number\\out.out&quot;,&quot;w&quot;,stdout);</span>t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,r[x]);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7915 回文 题解</title>
    <link href="/2022/lg7915-solution/"/>
    <url>/2022/lg7915-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先明确，字典序最小是操作序列的字典序。</p><p>只剩下最后一个数的时候，操作 1 和 2是等价的。由于要求字典序最小，所以操作序列最后一个必定是<code>L</code>。</p><p>再考虑第一个操作。因为第一次只能操作序列 <spanclass="math inline">\(a\)</span>中的第一个数或最后一个数，且最后它必将留在序列 <spanclass="math inline">\(b\)</span> 的第一个位置。而回文序列 <spanclass="math inline">\(b\)</span>中最后一个数必然和第一个数相同。那么就能知道一定是枚举 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(a_{2n}\)</span> 两种操作选择，再通过满足 <spanclass="math inline">\(a_i = a_1\)</span> 或 <spanclass="math inline">\(a_i = a_{2n}\)</span> 的位置 <spanclass="math inline">\(i\)</span> 作为一个操作的临界点。</p><p>一旦确定了 <span class="math inline">\(i\)</span>，那么 <spanclass="math inline">\(i\)</span>必定是最后一个操作。我们可以将顺序的操作与倒序的操作的数相对应，满足最终得到回文串。于是考虑搜索。</p><p>建议玩一下样例。 <span class="math display">\[[4, 1, 2, 4, 5, 3, 1 ,2, 3, 5 ]\]</span></p><p><span class="math display">\[[ 4, 5, 3, 1, 2, 2, 1, 3, 5, 4 ]\]</span></p><p>不难发现每一次只能操作两个数，左边的位置单调增，右边的位置单调减。不妨设为<span class="math inline">\(L\)</span> 与 <spanclass="math inline">\(R\)</span>。一开始 <spanclass="math inline">\(L=1\)</span>，<spanclass="math inline">\(R=2n\)</span>。而倒序操作也只能操作两个数，左边的位置单调减，右边的位置单调增，且一开始始终是<span class="math inline">\(i-1\)</span> 与 <spanclass="math inline">\(i+1\)</span>。记为 <spanclass="math inline">\(l\)</span> 与 <spanclass="math inline">\(r\)</span>。</p><p>这里默认一开始操作的是 4。</p><p>第一步用 1 操作把 4 放到第一位，那么 <spanclass="math inline">\(L+1\)</span>，<spanclass="math inline">\(R\)</span> 不变，此时可以操作的数为靠左的 1与靠右的 5。这个时候要选择能与 <span class="math inline">\(a_l\)</span>与 <span class="math inline">\(a_r\)</span>对应的数，否则绝对不是回文序列。那么显然就是 <spanclass="math inline">\(a_r\)</span>，靠左的 5。所以要使用操作 2 加入5，<span class="math inline">\(R-1\)</span>，<spanclass="math inline">\(L\)</span> 不变。 由于 <spanclass="math inline">\(r\)</span> 在 <spanclass="math inline">\(i\)</span> 右边，最后一定是用 2 操作将 <spanclass="math inline">\(a_r\)</span> 归位的。此时 <spanclass="math inline">\(a_r\)</span> 已经不可使用，<spanclass="math inline">\(r+1\)</span>，<spanclass="math inline">\(l\)</span> 不变。当然，要记录每个操作。</p><p>接下来是将 <span class="math inline">\(a_r\)</span> 与 <spanclass="math inline">\(a_R\)</span> 配对，<spanclass="math inline">\(a_l\)</span> 与 <spanclass="math inline">\(a_R\)</span> 配对。</p><p>相信大家都看出来套路了。就是择优配对，先考虑可行性，然后贪心选择。<code>L</code>必须尽可能靠前，因此优先度递减排序为<span class="math inline">\(L\)</span> 与 <spanclass="math inline">\(l\)</span>、<span class="math inline">\(L\)</span>与 <span class="math inline">\(r\)</span>、<spanclass="math inline">\(R\)</span> 与 <spanclass="math inline">\(l\)</span>、<span class="math inline">\(R\)</span>与 <span class="math inline">\(r\)</span>。</p><p>当 <span class="math inline">\(l=L\)</span> 并且 <spanclass="math inline">\(r=R\)</span> 时操作结束。</p><p>但是还有一些小边界问题。这是由于边界的增减且不能越界造成的。</p><ol type="1"><li>当 <span class="math inline">\(L \le l\)</span> 时，必须满足 <spanclass="math inline">\(L &lt; l\)</span> 才能让 <spanclass="math inline">\(L\)</span> 与 <spanclass="math inline">\(l\)</span> 配对，满足 <spanclass="math inline">\(r \le R\)</span> 时就能让 <spanclass="math inline">\(L\)</span> 与 <spanclass="math inline">\(r\)</span> 配对。</li><li>当 <span class="math inline">\(r \le R\)</span> 时，满足 <spanclass="math inline">\(L \le l\)</span> 就能让 <spanclass="math inline">\(R\)</span> 与 <spanclass="math inline">\(l\)</span> 配对，必须满足 <spanclass="math inline">\(r &lt; R\)</span> 时才能让 <spanclass="math inline">\(R\)</span> 与 <spanclass="math inline">\(r\)</span> 配对。</li></ol><p>由于只有能够成为回文串才贪心操作，所以第一次到达 <spanclass="math inline">\(l = L\)</span> 且 <span class="math inline">\(r =R\)</span> 时一定是字典序最小的回文串。</p><p>复杂度 <span class="math inline">\(O(Tn)\)</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, flag, n, a[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span> </span>&#123;    <span class="hljs-comment">// l与r，L与R同上文</span>    <span class="hljs-comment">// p表示序列b中有多少个数</span><span class="hljs-keyword">if</span>(l&lt;L&amp;&amp;r&gt;R) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(p&gt;n) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;(a[l]==a[L]&amp;&amp;L&lt;l||a[r]==a[L]&amp;&amp;r&lt;=R)) &#123;s[p]=<span class="hljs-string">&#x27;L&#x27;</span>;<span class="hljs-keyword">if</span>(a[l]==a[L]&amp;&amp;L&lt;l) s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r,L+<span class="hljs-number">1</span>,R);<span class="hljs-keyword">else</span> s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l,r+<span class="hljs-number">1</span>,L+<span class="hljs-number">1</span>,R);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r&lt;=R&amp;&amp;(a[l]==a[R]&amp;&amp;L&lt;=l||a[r]==a[R]&amp;&amp;r&lt;R)) &#123;s[p]=<span class="hljs-string">&#x27;R&#x27;</span>;<span class="hljs-keyword">if</span>(a[l]==a[R]&amp;&amp;L&lt;=l) s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r,L,R<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l,r+<span class="hljs-number">1</span>,L,R<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;flag=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);s[<span class="hljs-number">2</span>*n]=<span class="hljs-string">&#x27;L&#x27;</span>; <span class="hljs-comment">// 一定的</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) <span class="hljs-keyword">if</span>(a[i]==a[<span class="hljs-number">1</span>]) &#123;s[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;L&#x27;</span>;        <span class="hljs-comment">// 一开始用1操作位置1，对应的最后一次操作位置是i</span>        <span class="hljs-comment">// 顺序操作区间[2,2n]</span><span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>,i<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>*n);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i) <span class="hljs-keyword">if</span>(a[i]==a[<span class="hljs-number">2</span>*n]) &#123;s[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;R&#x27;</span>;        <span class="hljs-comment">// 一开始用2操作位置1，对应的最后一次操作位置是i</span>        <span class="hljs-comment">// 顺序操作区间[1,2n-1]</span><span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>,i<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">sol</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7913 廊桥分配 题解</title>
    <link href="/2022/lg7913-solution/"/>
    <url>/2022/lg7913-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>不难发现国际区与国内区完全没有关系，分开处理就行了。</p><p>注意到当某个区只有一个廊桥的时候，就等价于保证在选择第一个区间的情况下，选择最多数量的不相交区间。</p><p>那么如果廊桥数量更多呢？</p><p>显然如果在廊桥数量为 1 时选择了最多数量的不相交区间，那么当廊桥数量为2 时仍然能够选取这么多，方法是钦定选出来的飞机只能用第 1个廊桥。多出来的这个廊桥又能够再对剩下的的飞机做一次选择最多数量的不相交区间。这样一定是最多的。</p><p>归纳一下就得到</p><ul><li>廊桥越多，所容纳的飞机数量单调不减，且具有最优子结构性质，可以直接贪心。</li><li>如果某个区有 <span class="math inline">\(n_0\)</span>个廊桥，那么最多容纳的飞机数量就是做 <spanclass="math inline">\(n_0\)</span> 次选择最多不相交区间。</li></ul><p>因为只有 <span class="math inline">\(n\)</span> 个廊桥，那么国内去分<span class="math inline">\(n_0\)</span> 个，国外区一定有 <spanclass="math inline">\(n - n_0\)</span> 个。这样只要预处理出每个区分配<span class="math inline">\(k \in[0,n]\)</span>个廊桥最多能容纳的飞机数量，那么就能 <spanclass="math inline">\(O(n)\)</span> 取最大值了。</p><p>维护每个区的飞机用<code>std::set</code>，它本身是有序的，自带<code>lower_bound</code>而且还支持删除操作。</p><p>廊桥分配情况是 <span class="math inline">\(O(n)\)</span>的，每个飞机最多进出<code>set</code>一次。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> n, c[<span class="hljs-number">2</span>], ans[<span class="hljs-number">2</span>][N];set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; s[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;c[<span class="hljs-number">0</span>],&amp;c[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=c[i];++j) &#123;<span class="hljs-type">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);s[i].<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(l,r));&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">1</span>;++k) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans[k][i]=ans[k][i<span class="hljs-number">-1</span>];        <span class="hljs-comment">// 先继承i-1个廊桥的数量</span><span class="hljs-type">int</span> lst=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!s[k].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> p=s[k].<span class="hljs-built_in">upper_bound</span>(<span class="hljs-built_in">make_pair</span>(lst,<span class="hljs-number">0</span>));<span class="hljs-keyword">if</span>(p==s[k].<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">break</span>;lst=p-&gt;second, ++ans[k][i];s[k].<span class="hljs-built_in">erase</span>(p);&#125;&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) res=<span class="hljs-built_in">max</span>(res,ans[<span class="hljs-number">0</span>][i]+ans[<span class="hljs-number">1</span>][n-i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中考2022 游记</title>
    <link href="/2022/zhongkao2022/"/>
    <url>/2022/zhongkao2022/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="day--1">DAY -1</h2><p>最后一个周末了。</p><p>难得几乎没有作业，周末返校不考试。（笑）</p><p>数学老师发了去年中考最后两个大题让我们练手，我又想起了压轴题某个点的运动轨迹是个抛物线，但我当成直线算的痛苦……</p><p>带回了一些没啥用的书，看了看错题。</p><p>然后依旧是好好放松~</p><p>话说我没报 B校的“小语种招生”，班主任还找我谈话了。不管因为什么原因，我都不想进入 B校的“A区”。一是我文化课实在没有那个水平（应该也考不上），而是我不想自讨苦吃，三是对我学OI 没有帮助。</p><p>所以全班就我一个人没报。</p><p>后来因为 B校作为高考中考考场，高一高二学生都“放假”了，就来了几个我们班主任之前的学生，给我们讲高中一些事情和怎么考“小语种招生”。某位爷说，当时数学选择题有很多是多项选择，但是他都按照单项选的。出场一对答案直接少了三十多分。语文出了各种奇葩题，有现代文猜作者（汪曾祺），千字议论文。他英语还扣了10+ 分，物理扣了 1 分。最后满分 360（语数英物），他考了 310+，以第 9名的身份进入 A 区。真是无语了，什么怪物。</p><h2 id="day-0">Day 0</h2><p>周日早晨返校。</p><p>先是核酸检测，然后复习了一上午语文。看不下去……</p><p>午餐终于改善了55555，还挺好吃。</p><p>下午复习物理化学，看了看错题。</p><p>4 点多要去看考场时变天了，但是没有下雨。</p><p>考场在 X 校。39 考场，5 楼。</p><p>X校作为我是著名的公私合营中学，那硬件设施自然是不差的。只不过这纯木桌凳舒适有点不太舒服，而且不如B 校的椅子舒服。</p><p>差不多就回去了，一路上一直看着车窗外的风景。</p><p>晚上依旧是物理化学。</p><p>由于不上第三节晚自习，所以 9 点就回宿舍了。我们宿舍只剩下 6个人，于是我和其他 3 个人去对面宿舍玩狼人杀。十点多睡了觉。</p><h2 id="day-1">Day 1</h2><p>不得不说早睡觉是真的舒服，6:10 自然醒。</p><p>到教室后发了农夫山泉和士力架，随便看看语文后就去考试了。</p><h3 id="语文">语文</h3><p>发下卷来一看，好家伙，又是孟子！去年前年考的都是课内的孟子，今年考了个课外的！这篇好像做过？课内竟然是大道之行也。</p><p>于是文言文就切掉一半了，但是最后一问</p><blockquote><p>结合某某某谈论对“货物其弃于地也，不必藏于己。力恶其不出于身，也不必为己”的理解。</p></blockquote><p>乱写，orz。</p><p>名著考的是昆虫记，没啥难的。</p><p>现代文阅读竟然是莫言在五四前夕的信？好家伙连文章都不必读了，最后一问又是结合实际，orz。</p><p>作文有 3 个主题。</p><ol type="1"><li>自律：自己约束自己。</li><li>《人世间》疫情版歌词，最后好像有一句“就像种子，永远向着太阳”。</li><li>貌似是责任担当？</li></ol><p>于是秒选2，仔细读了一下就发现，应该是对生活有希望，成长奋斗啥的。</p><p>所以我写了一个极其无语的题目“沐雨，向阳”。</p><p>沐还写错了，加了一个点啊啊啊啊。</p><p>但是通篇下来语言和逻辑都挺好的，最后一段议论成功点题。嗯，看来写博客还有点用。</p><p>然后回校。</p><h3 id="物理化学">物理＆化学</h3><p>中午 1 点多就去坐车，有点困。天气不太好，于是我带了雨伞。</p><p>刚好下车时开始下雨，考生们都一窝蜂地往校门里挤。到了排队进楼的时候，狂风大作，大雨裹挟而来，我的伞都被吹崩坏了一次qwq。SB 的 X校硬是堵着不让进，雨是斜着下的，伞上的积水又流到旁边的人的身上，然后基本每个人的衣服后背都湿透了。</p><p>试卷发下来后，发现物化是真的简单，完全没有难题。化学写完+检查用了30+min，物理写得比较谨慎，写完大概剩下35min。我自认为是做的不错的。</p><p>但是我还是把 <span class="math inline">\(NH_3\)</span>中氮元素的化合价写了 +3，物理有一个奇葩作图题少做了一个对称。</p><p>回校之后吃了某看起来价格不菲的面包，还行。</p><p> </p><p>晚自习一直在看数学。</p><p>依旧在宿舍里玩了狼人杀。</p><h2 id="day2">Day2</h2><p>吃了好几个巧克力，被同学说流鼻血。</p><p>昨天物理化学简单到离谱，于是我认为数学英语应该会比较难。</p><p>在车上看了很多职校的传单，说真的对于数学有点紧张。</p><h3 id="数学">数学</h3><p>无语了。</p><p>选择题完全没有难点，最后一个竟然是瓜豆原理板子题，问你在三角形两边上两个线性运动的点连成的线段的中点，运动轨迹是个啥。那必然是线段，它的中位线。</p><p>填空最后一个会做，但是平移的时候疏忽导致答案错了，orz。</p><p>倒数第二个大题，有人竟然用的四点共圆证明，然而我用常规方法大概 2min切掉了。</p><p>压轴题更是没有水平，只不过最后一问的四个答案中，有两个需要暴力因式分解推出的四次等式才能解出来，我也没有算对qwq。只有一半分。</p><p>这，看来英语会难些吧。</p><h3 id="英语">英语</h3><p>事实证明我错了，英语除了听力不太简单，别的都很常规。</p><p>所以 facet 为什么 means "face"。</p><p> </p><p>明天只考政治历史了，同学们貌似都轻松了不少，用教室的多功能黑板放歌听。我放了一首Daze，结果很快就被切掉了。</p><p>晚自习一直在看政治，但是发现我啥也背不过了，于是摸鱼。</p><p>还玩了狼人杀。</p><h2 id="day-3">Day 3</h2><p>要结束了吗？</p><p>天气很不错，踩着重叠的树荫到教室，随便看了看昨日不曾翻阅的时政。</p><p>起行，校长竟然向我们招手了。沿途的风景差不多已经厌倦了啊，迎着朝阳小憩片刻。</p><p>马上就到了。</p><h3 id="政治-历史">政治 ＆ 历史</h3><p>政治竟然考了我昨晚看的每一道题，运气不错啊。</p><p>历史就比较恶心，一堆总结材料的题目，比一二模要难一些，我竟然用了将近50min。当然我故意在中考放慢了做题速度，毕竟早做完也没什么用。</p><p>最终写完还有 20min。</p><p>出考场之前，X校竟然强制用广播向我们宣传他们的”昌乐二中并行班“，但估计没人会报名声不怎么好的X 校。</p><p>结束了，中考结束了。</p><h3 id="毕业">毕业</h3><p>全班就我一个人去餐厅吃饭了。家委会买了一堆吃的喝的，但是我没着急吃。一是不饿，二是我没有那么兴奋。另外好多人都带手机来了。</p><p>吃喝发言过后，就是毕业典礼，然后就是冗长的等待拍毕业照的时间。某些班拍个照都要十几分钟。</p><p>我没有心情去做那些事情，比如和同学拍照或打游戏。仅仅是，在烈日下回想起了去年夏天。</p><p>可是描绘出的是一幕幕不堪回首的往事，不管那时候我有多激动，我都想毁灭这些东西。我嘲笑那时候我的天真，我真想回去叫醒那时候的我。</p><p>「你能不能看清楚你到底什么样？」</p><p>「我不能原谅你……」</p><p>估计他也不会想到，一年后会变成这个样子。</p><p>我发誓，一定要让这个故事有个说得过去的结局。</p><p>然后我就会离开。</p><p>……</p><p>一转眼，已经要离校了。</p><p>回首，是生活了三年的校园。</p><p>我想起那些日子，想起一个个人，说实话，我很难忘记这一切。可我总是没有勇气传达出去，也没有必要让他们知道。</p><p>毕竟我就是那个怪胎啊！</p><p>脏乱的教室又被打扫干净，就像我不曾来过一样，大概是因为我总是想要逃避那些日子吧。我总是这样，那么讨厌为了纪念某些东西的集体活动，又那么怀念自己经历过的事情。</p><p>我紧紧抓着书包的背带，扔掉对这所学校的种种偏见，大声在心里说出：“再见啦！”。</p><p>再见了，称不上是朋友的同学们；再见了，配合的不是太好的老师们；再见了，每一个曾唤起我的回忆的角落；再见了，我的初中生活！</p><p> </p><p>今后，一定要快乐地生活下去啊！</p><p>各位保重！</p><h2 id="day-998244353">Day 998244353</h2><p>出成绩一个月了，我才回来补上。</p><p>语文：<span class="math inline">\(100/120\)</span></p><p>数学：<span class="math inline">\(114/120\)</span></p><p>英语：<span class="math inline">\(116/120\)</span></p><p>理综：<span class="math inline">\(116/120\)</span></p><p>文综：<span class="math inline">\(104/120\)</span></p><p>总分：<span class="math inline">\(550/600\)</span></p><p>全市名次（不含提前批）<spanclass="math inline">\([102,123]\)</span></p><p>够用了。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文化课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT2558 Many Moves 题解</title>
    <link href="/2022/at2558-solution/"/>
    <url>/2022/at2558-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="关于此题">关于此题</h2><p>去年夏天，我就从朋友那里知道了这道题。</p><p>素不相识、相隔千里的几人竟然能互相敞开心扉，这是我那是坚持下去的一个重要因素。他说这题很有意思，我便不顾自己的水平就放入了做题计划，这一放，就是将近一年。</p><p>“线段树优化 DP，好厉害啊！”</p><p>“什么时候我也能会写线段树呢？”</p><p>一年中发生了太多的事，他已经不再那么热衷于 OI了，我也从黄粱一梦中醒来。但是，仍然不变的，是一想到他就会燃起的小小斗志，是我不甘又无奈的形单影只。</p><p>也许我再也不是那个连背包问题都无法理解，只会对着题解研究代码的菜鸟了。但是……</p><h2 id="分析">分析</h2><p>读完题面第一反应，就是把操作“离线”了。（没啥用，和纯数据结构题的离线不同）。</p><p>考虑完成 <span class="math inline">\(i\)</span>个操作时，一定有一个棋子在 <span class="math inline">\(x_i\)</span>的位置。那么可以设 <span class="math inline">\(f(i,j)\)</span>为完成了前 <span class="math inline">\(i\)</span>个操作，其中另一个棋子的位置在 <spanclass="math inline">\(j\)</span>。</p><p>转移则有 2 种。</p><p>对于 <span class="math inline">\(f(i,j)\)</span>，可以将 <spanclass="math inline">\(f(i-1,j)\)</span> 中位置在 <spanclass="math inline">\(x_{i-1}\)</span> 的棋子放过来，代价是 <spanclass="math inline">\(\Delta x = |x_i - x_{i-1}|\)</span>。 <spanclass="math display">\[f(i,j) = f(i-1,j) + \Delta x\]</span>还可以将位置在另一个棋子放过来。由于状态无法直接表示，所以要枚举另一个棋子的位置<spanclass="math inline">\(k\)</span>。但是把「另一个棋子」放过来后，它位于<span class="math inline">\(x_i\)</span>，按照上文状态的设计，就转移到<span class="math inline">\(f(i,x_{i-1})\)</span> 了。</p><p>仔细想一想，<span class="math inline">\(f(i-1,k) \rightarrowf(i,x_{i-1})\)</span> 这种情况还挺少见的，有点意思。😅 <spanclass="math display">\[f(i,x_{i-1}) = \min_{k \in [1,n]}{\{ f(i-1,k) + |k-x_i| \}}\]</span> 直接这样做复杂度是 <span class="math inline">\(O(Qn)\)</span>的，考虑优化。</p><p>套路地把绝对值符号拆开，当 <span class="math inline">\(k &gt;x_i\)</span> 时，有 <span class="math display">\[f(i,x_{i-1}) = \min_{k \in [x_i+1,n]}{\{ f(i-1,k) + k \}} - x_i\]</span> 当 <span class="math inline">\(k \le x_i\)</span> 时，有 <spanclass="math display">\[f(i,x_{i-1}) = \min_{k \in [1,x_i]}{\{ f(i-1,k) - k \}} + x_i\]</span> 这样问题就变成了，在 <spanclass="math inline">\([1,x_i]\)</span> 中快速查找最小的 <spanclass="math inline">\(f(i-1,k)-k\)</span>，在 <spanclass="math inline">\([x_i+1,n]\)</span> 中快速查找最小的 <spanclass="math inline">\(f(i-1,k)+k\)</span>。</p><p>而第一种转移其实变相地告诉我们，<spanclass="math inline">\(i-1\)</span> 的状态是可以通过 <spanclass="math inline">\(\Delta x\)</span> 转移到 <spanclass="math inline">\(i\)</span> 的状态的。</p><blockquote><p>实际上不难发现，对于第一种转移，只有 <spanclass="math inline">\(j=x_i\)</span>的时候才是最划算的，所以可以直接单点查询得到。但是这样就会被第二种转移中的<span class="math inline">\(k=x_i\)</span>的情况覆盖了，所以可以完全无视第一种转移。</p></blockquote><p>所以可以建立一棵线段树，维护 <spanclass="math inline">\(f(j)\)</span> 这一层。</p><p>对于每个操作 <span class="math inline">\(i\)</span>，维护 <spanclass="math inline">\(f(i-1,k)+k\)</span> 与 <spanclass="math inline">\(f(i-1,k)-k\)</span> 的值。全局加上 <spanclass="math inline">\(\Delta x\)</span> 更新状态，最后单点修改 <spanclass="math inline">\(x_{i-1}\)</span> 的值。</p><p>初始值 <span class="math inline">\(f(1,A) = |B-x_1|\)</span>，<spanclass="math inline">\(f(1,B)=|A-x_1|\)</span></p><p>答案 <span class="math inline">\(\min_{k \in [1,n]}{\{ f(Q,k)\}}\)</span></p><p>由于只设计全局加，所以可以直接用打标记的方式实现。</p><p>复杂度 <span class="math inline">\(O(Q \log_2 n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200005</span>;<span class="hljs-type">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<span class="hljs-type">int</span> n, Q, a, b, x[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Segment_Tree</span> &#123;<span class="hljs-type">int</span> l, r;ll tag, v[<span class="hljs-number">3</span>];    <span class="hljs-comment">// tag是区间加标记</span>    <span class="hljs-comment">// v[0]是f(i,k)，v[1]是f(i,k)-k，v[2]是f(i,k)+k</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> l(u) t[u].l</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> r(u) t[u].r</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> tag(u) t[u].tag</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> v(u) t[u].v[0]</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> v1(u) t[u].v[1]</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> v2(u) t[u].v[2]</span>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> u,ll val)</span> </span>&#123; <span class="hljs-built_in">tag</span>(u)+=val, <span class="hljs-built_in">v</span>(u)+=val, <span class="hljs-built_in">v1</span>(u)+=val, <span class="hljs-built_in">v2</span>(u)+=val; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<span class="hljs-built_in">v</span>(u)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">v</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">v</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));<span class="hljs-built_in">v1</span>(u)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">v1</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">v1</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));<span class="hljs-built_in">v2</span>(u)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">v2</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">v2</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">tag</span>(u)) &#123;<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">tag</span>(u)=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-built_in">l</span>(u)=l, <span class="hljs-built_in">r</span>(u)=r;<span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">v</span>(u)=<span class="hljs-built_in">v1</span>(u)=<span class="hljs-built_in">v2</span>(u)=inf; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// 初始值</span><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(u);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u,ll p,ll val)</span> </span>&#123;    <span class="hljs-comment">// 单点修改</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">l</span>(u)==<span class="hljs-built_in">r</span>(u)) &#123;<span class="hljs-built_in">v</span>(u)=val, <span class="hljs-built_in">v1</span>(u)=val-p, <span class="hljs-built_in">v2</span>(u)=val+p;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">pushdown</span>(u);    <span class="hljs-type">int</span> mid=(<span class="hljs-built_in">l</span>(u)+<span class="hljs-built_in">r</span>(u))/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>,p,val);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,p,val);<span class="hljs-built_in">pushup</span>(u);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> id)</span> </span>&#123;    <span class="hljs-comment">// 区间查询</span><span class="hljs-keyword">if</span>(l&lt;=<span class="hljs-built_in">l</span>(u)&amp;&amp;<span class="hljs-built_in">r</span>(u)&lt;=r) &#123; <span class="hljs-keyword">return</span> t[u].v[id]; &#125;<span class="hljs-built_in">pushdown</span>(u);<span class="hljs-type">int</span> mid=(<span class="hljs-built_in">l</span>(u)+<span class="hljs-built_in">r</span>(u))/<span class="hljs-number">2</span>;ll ans=(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>);<span class="hljs-keyword">if</span>(l&lt;=mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,id));<span class="hljs-keyword">if</span>(r&gt;mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,id));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;Q,&amp;a,&amp;b);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x[i]);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a,<span class="hljs-built_in">abs</span>(b-x[<span class="hljs-number">1</span>]));<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,b,<span class="hljs-built_in">abs</span>(a-x[<span class="hljs-number">1</span>]));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=Q;++i) &#123;ll dlt=<span class="hljs-built_in">abs</span>(x[i]-x[i<span class="hljs-number">-1</span>]), r1=(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>), r2, r3;<span class="hljs-comment">//r1=query(1,x[i],x[i],0)+dlt;</span>r2=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,x[i],<span class="hljs-number">1</span>)+x[i];r3=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x[i]+<span class="hljs-number">1</span>,n,<span class="hljs-number">2</span>)-x[i];r1=<span class="hljs-built_in">min</span>(r1,<span class="hljs-built_in">min</span>(r2,r3));<span class="hljs-built_in">maketag</span>(<span class="hljs-number">1</span>,dlt); <span class="hljs-comment">// 全局加上dlt</span><span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,x[i<span class="hljs-number">-1</span>],r1); <span class="hljs-comment">// 修改f(i,x[i-1])</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">v</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 全局最小值</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4926 倍杀测量者 题解</title>
    <link href="/2022/lg4926-solution/"/>
    <url>/2022/lg4926-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先明确，对于 <span class="math inline">\(o=1\)</span> 的选手 <spanclass="math inline">\(A\)</span>，他不用女装的条件是 <spanclass="math inline">\(X_A \ge X_B \cdot(k-T)\)</span>。对于 <spanclass="math inline">\(o=2\)</span> 的选手 <spanclass="math inline">\(A\)</span>，他不用女装的条件是 <spanclass="math inline">\(X_A \cdot (k+T) &gt; X_B\)</span>。</p><p>这样是不能用差分约束系统来求解的，因为变量之间的关系是乘法，但是如果将它们换成同底数的对数，那么相对大小不变且乘法就转化成了加法。所以<span class="math display">\[X_A \ge X_B \cdot(k-T)\]</span></p><p><span class="math display">\[\log_2 (X_A) - \log_2 (X_B) \ge  \log2 (k-T)\]</span></p><p>从 <span class="math inline">\(B\)</span> 向 <spanclass="math inline">\(A\)</span> 连一条权值为 <spanclass="math inline">\(\log2 (k-T)\)</span> 的边。 <spanclass="math display">\[X_A \cdot (k+T) &gt; X_B\]</span></p><p><span class="math display">\[\log_2 (X_A) + \log_2 (k+T) &gt; \log_2 (X_B)\]</span></p><p><span class="math display">\[\log_2(X_A) - \log_2 (X_B) &gt; - \log_2(k+T)\]</span></p><p>从 <span class="math inline">\(B\)</span> 向 <spanclass="math inline">\(A\)</span> 连一条权值为 <spanclass="math inline">\(- \log_2 (k+T)\)</span> 的边。</p><p>虽然两个式子一个是大于等于一个是大于，但是允许 <spanclass="math inline">\(10^{-4}\)</span>的精度误差存在，所以这样连边是没问题的。</p><p>注意这样连边要用 SPFA跑最长路判断正环（其实和最短路判断负环完全一样）。</p><p>还要建立一个虚拟源点 <spanclass="math inline">\(n+1\)</span>，保证图连通。</p><p> </p><p>要找到最大的 <spanclass="math inline">\(T\)</span>，显然二分答案，值域是 <spanclass="math inline">\([0,\min{\{ k \}}]\)</span>，否则 <spanclass="math inline">\(k-T\)</span> 就会出现负数。</p><p>题目中还给出了一些人的分数，一种方法是直接向虚拟源点 <spanclass="math inline">\(n+1\)</span>连边。但是这么做的致命缺陷在于会导致一个节点有过多的子节点，会严重影响SPFA 算法的速度。<del>说不定还会卡掉 DFS-SPFA</del>。</p><p>所以再建一个虚拟节点 <span class="math inline">\(0\)</span>，对于每个<span class="math inline">\(C,x\)</span>，由 <spanclass="math inline">\(0\)</span> 向 <spanclass="math inline">\(C\)</span> 连一条权值为 <spanclass="math inline">\(\log_2(x)\)</span> 的边，由 <spanclass="math inline">\(C\)</span> 向 <spanclass="math inline">\(0\)</span> 连一条权值为 <spanclass="math inline">\(-\log_2(x)\)</span>的边。这是常见的维护差分约束系统中已知量与未知量相对大小的套路。</p><p>这样做比直接连 <span class="math inline">\(n+1\)</span> 要快大概200ms。</p><p>由于 <span class="math inline">\(T\)</span>是二分确定的，所以加边的时候加的是原来的权值，通过 <spanclass="math inline">\(o\)</span> 的不同分类讨论确定边权。</p><p>最后，如果有正环，说明不全成立，一定有人要女装。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5005</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-4</span>;<span class="hljs-type">int</span> n, s, t;<span class="hljs-type">int</span> tot, h[N], cnt[N];<span class="hljs-type">double</span> d[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> nxt, to, type; <span class="hljs-type">double</span> w; &#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-comment">// type1是o=1，type2是o=2，type3是特殊边</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">double</span> z,<span class="hljs-type">int</span> typ)</span> </span>&#123;e[++tot].to=y, e[tot].w=z, e[tot].nxt=h[x], e[tot].type=typ, h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">double</span> dlt)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) d[i]=-inf, cnt[i]=<span class="hljs-number">0</span>, v[i]=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;d[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(n+<span class="hljs-number">1</span>), v[n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();v[x]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-type">int</span> y=e[i].to; <span class="hljs-type">double</span> z=e[i].w;<span class="hljs-keyword">if</span>(e[i].type==<span class="hljs-number">1</span>) z=<span class="hljs-built_in">log2</span>(z-dlt);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[i].type==<span class="hljs-number">2</span>) z=-<span class="hljs-built_in">log2</span>(z+dlt);<span class="hljs-keyword">if</span>(d[y]&lt;d[x]+z) &#123;d[y]=d[x]+z, cnt[y]=cnt[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(cnt[y]&gt;n+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                <span class="hljs-comment">// 最长路中包含超过n+1条边，说明有正环</span>                <span class="hljs-comment">// 比判断入队次数更快</span><span class="hljs-keyword">if</span>(!v[y]) q.<span class="hljs-built_in">push</span>(y), v[y]=<span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">double</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">10</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;t);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s;++i) &#123;<span class="hljs-type">int</span> op, a, b; <span class="hljs-type">double</span> x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%lf&quot;</span>,&amp;op,&amp;a,&amp;b,&amp;x);<span class="hljs-built_in">add</span>(b,a,x,op);<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) r=<span class="hljs-built_in">fmin</span>(r,x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(n+<span class="hljs-number">1</span>,i,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i) &#123;<span class="hljs-type">int</span> c; <span class="hljs-type">double</span> x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf&quot;</span>,&amp;c,&amp;x);<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,c,<span class="hljs-built_in">log2</span>(x),<span class="hljs-number">3</span>), <span class="hljs-built_in">add</span>(c,<span class="hljs-number">0</span>,-<span class="hljs-built_in">log2</span>(x),<span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-comment">// 最小的T还不成立，无解</span><span class="hljs-keyword">while</span>(r-l&gt;eps) &#123;<span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分约束系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1712 区间 题解</title>
    <link href="/2022/lg1712-solution/"/>
    <url>/2022/lg1712-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>既然要最小化选出的最长区间长度减去最短区间长度，那么很容易想到一个典型的双指针算法：</p><p>将区间长度递增排序，维护指针 <span class="math inline">\(l\)</span>和 <span class="math inline">\(r\)</span>，表示选择 <spanclass="math inline">\([l,r]\)</span> 中所有的线段。</p><p>依次选择每条线段（也就是 <span class="math inline">\(r\)</span>在递增），在满足有一个点被覆盖 <span class="math inline">\(m\)</span>次的条件下，尽可能将 <span class="math inline">\(l\)</span>提前并删去对应的线段。答案就是 <span class="math inline">\(\min{\{len_r-len_l \} }\)</span>。</p><p>所以离散化，在离散化后的值域上建一棵线段树，维护区间内的点被覆盖的最多次数。</p><p>那么只要根节点的值大于等于 <spanclass="math inline">\(m\)</span>，就是合法的选取方案。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, cnt, c[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">L</span> &#123; <span class="hljs-type">int</span> l, r, len; &#125; a[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(L a,L b) &#123; <span class="hljs-keyword">return</span> a.len&lt;b.len; &#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Segment_Tree</span> &#123;<span class="hljs-type">int</span> l, r, w, tag;<span class="hljs-meta">#<span class="hljs-keyword">define</span> l(u) t[u].l</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> r(u) t[u].r</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> w(u) t[u].w</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> tag(u) t[u].tag</span>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> val)</span> </span>&#123; <span class="hljs-built_in">tag</span>(u)+=val, <span class="hljs-built_in">w</span>(u)+=val; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123; <span class="hljs-built_in">w</span>(u)=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">w</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">w</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">tag</span>(u)) &#123;<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">tag</span>(u)=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-built_in">l</span>(u)=l, <span class="hljs-built_in">r</span>(u)=r;<span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">w</span>(u)=<span class="hljs-built_in">tag</span>(u)=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(u);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&lt;=<span class="hljs-built_in">l</span>(u)&amp;&amp;<span class="hljs-built_in">r</span>(u)&lt;=r) <span class="hljs-built_in">maketag</span>(u,val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">r</span>(u)&lt;l||r&lt;<span class="hljs-built_in">l</span>(u))) &#123;<span class="hljs-built_in">pushdown</span>(u);        <span class="hljs-type">int</span> mid=(<span class="hljs-built_in">l</span>(u)+<span class="hljs-built_in">r</span>(u))/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,val);        <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,val);<span class="hljs-built_in">pushup</span>(u);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">w</span>(<span class="hljs-number">1</span>); &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);a[i].l=l, a[i].r=r, a[i].len=r-l;c[++cnt]=l, c[++cnt]=r;&#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>);cnt=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>)-c<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i].l=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>,a[i].l)-c;a[i].r=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>,a[i].r)-c;&#125;    <span class="hljs-comment">// 离散化</span><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, ans=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,cnt);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-comment">// r是递增的，直接用i代替</span><span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a[i].l,a[i].r,<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">query</span>()&gt;=m) &#123;ans=<span class="hljs-built_in">min</span>(ans,a[i].len-a[l].len);<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a[l].l,a[l].r,<span class="hljs-number">-1</span>);++l;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans!=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)? ans:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#9</title>
    <link href="/2022/yume-9/"/>
    <url>/2022/yume-9/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7524431ac86ac37f537dcb48b8beb4a72a8154bbb4a6f73f31c78e4b0480de3b">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f36de94952a546c031aecc5c3a88baae90daae290c7e18dc7fa99e21a95d32d7a98fa62aebe0c264424d1a686b5df4d075bd0436bf7782ab6194aefdd1f4852f1390c4d7072fbead0e1ece99befa8797fc607d91773f1ac758b84a64fdba8d13a39c606261e3307484ae59d2857e92f67e3d742f708b022f13834ef982ed83d05aa5168ce28d3cf3622a0ea203e72c5f2278f9b4ed082406f6f73e3e00162e29e589548a906447491db0af730d7b098a3a9525c8b7f1bef8ca4518dc29f0ffb124e1ff37b958d470b79d658a0d3cb830a6d601686e4e45628494fec2abe39f4b884a16b8193b518ce1a2ff7f89829eb54b294b8e0331406d9bb683696b941378e557bb84f88ef4eaaf94a7327d570e7a235375b37c02d40bb79d151ac1ec4774d63187b0f9d206a8974f1ddb1697563afe386eb841de4859a4867559bfe938ddcf42895a8a241cdb3df998b91f48fafe70e1a4fc830f4b8c4484ff8dab41e532f67f36e75f194c10ff665252c6c1c0a04518689152d79d60821ef101350c3d797c820034a24fb6a19b062588b1b677540c65e7d6ca7f2cc266a940f4bfe072fe2c45b266b92a6dad8178aa5ee3b3a0c41a6da490549444c30daad04d153f826b0d24950ce21ea4e059e05274954e7271d592e3eb7b8e77e379b6f121303dc358e212e01651c80ac662fce798999e328b067aeac5ad171bc28e252c67cc3e557e53e5aaedf060692fc7e317a7de4f57ed55b7583afbd63687302565f12944369a1e004d7f536144484d6fdb5df11b44b6915671a0e5df50983a978ff5411f654073c38a03243a580659f3c6bb0b000785a366e4fcb15d75980a9eb45740c481321fe7328c8b4ad8d37aaa95d9ad39b8ccb258dd7491d1943e9218084225321e2028f6a04c43d297e70102342db666f3a6e222252bb4864b8c242296949e18071c962e12d19feb2e89b91601c80284a20f14306b1b4ef8f6156a102adfa9a0c071c3097287420c9bf22ae9d3ad9e55a162989fe18c1f7745f51027e8cb03f7de8a8ea0d8fb52d65ac9a68d5561b5b8c5233ced915873106f038479d31c3d0993ff0fac7dc52b0508d8edfc9a1afca2d5b1252616977b2602aab63bf3491e58c4e4a28e7fca2a755615dbaf6693feb1ea73371549b6fc4a341d0610d0aac11450f644ec729072b24e800a1559905d2bf90be280978a35eadef5f7815bfe7f2891bd3fc9a320f91835bdff970108056dd7ec9215c217accaa8979801990c60ba5d2effd99dce55d991030ae1940340917254403daf811155d5802e50e36d0edf232883f74b15e0b8703dbc881c867b7e77a859ee8fcf2b023eed75696c396c22c151e001f1ac52cce1df15e8ee22af6e32cf97b49b8de66ad44df577dff1b9af8a5e71b9c9eae705af86e1e9589bd2fbaa65c2da10013a59d7775e37deb5dad54df21b250eccdcaf222d8e36f71a16ee1f07b3e0895073a5c6ae65c44ea819db90e802469512d02be042114f1149d5f36071c7f008fb3167c1042c584be9f38a2109680532515289f9dc3ff75520d001dc61dd2bc37d84634ba1845625dfe2aa3ba3eeb45e8320a13a4eb890a8a0d07335b440ed0d1b8aab53ebe6a1f9025228179ed252fdca867967071f697b571f8c3559282433af84c0850b9537c32963632f256a8275483463f5d11c75392a052169e0c00e4f3ea6d5516644b7ee907e46bbebc0d992ae7f385162c84624163b9910f7a75e58551072b9bac32cae9f9ac32a380df624ea22ccd03fbf4b83cfea4d2be119042025d917876580dc45ff216b1401eebdbc734fe05c9fce7dbbb636f57036c69822e0273841d8c3abe8da186249527ebd17628813cfeea4d0e3d52aa91673c93c6baf2a9b4e938f5053deac9392a085ab118fd27c3be9a20ab966b98ba56e196833463e094dd9f16b8cac3d123707a9fa39f632a2a8123f7bbd1eb38a1484e41558e6482961826e0c542697d685c463a8e60ce235827a3d5b82b3fedd00dbdb481e80c65f5b93bdac1dcecd0e642ac3576fc7f164f19d2bdb26f6a01101ce4af0c7798a09d95e6832e63df02d0b1b9b62285bd7f7aceb2579d680bd62d29a706e585ad2f81ed75c20d57ff8d7847cee287710e3845e57e5591f0d27209f9744cc92fb0c687861b4b7efddb1ed2ade9d7baa7f98d591de7583ebb65b899c3f9d210395da2adb88eab37c9afa853c4e1c1bce6bfcd4b606c7d9b80b2bcbd06d32faf97be04d53601da61e9c0569ebe74bc6128bb6bdd66713484d0972d640fd1f0bf99214c234489aa6383b285d0dea2b0f14d5e278b8ed4740bef7d2c3b9eba046bcd4a73ff4c675a49d1427e3443c4a2d56e3a334e012c122fdf64a07f4a07d59f57075830c2aeee473d66804ec0b4ced4f81f4d10496e3bc0c4467d3152ab56cce959ab92ef134ce67068ef83ddca3128cab8c0f973cecef9dff6d0136232b5c4b270545bc819d175f3ef24b1d1f30eea864d954acaa370c7676ac28c05be76d383f6c3ff9dacbae0dbb190a58c81be870cadbadfe58f13640f0c7f7c4d2a0a0dab4ef6676bb1d55f9e1a4efff68126efbb61ba49de7a4c1e59e88090539daf87a6d4f9fed0903cafcd8f5b01b6a36bec9084f2d3da3fcfc89bd9607e80df6e8a1b48b708ce03e4f18df556ad0bf37b6a48984380628abdfd36e48cb049b127ed12e4e3afaa688500617e2a3b439aa4a711dd6dc7f51604c5bcc0e0553ca02f262f6958534431e2550958be2133059c5f7a0e56fb03b47a8409dd61682531c55ac7f9903585817681d9e12590cd80d65e0cfbbbc2779c3f9464a75573be9aa0f463e1bfd2bfd68b08de181d469935c8b8b63fd6530bfe09317a4cb85feb32c5148b4e78d38625b097528ebb0d323b7973a82ee3440119662f9a1db03d909f1e12b7b1348ba7c223f9536cc4afba38defd7cd24533c61707ca9ad4d1f1b549cfcaf5a73f8f4d6b9f6cec08a769122fce811155de7a1dda0162e1518b3d8ded02504ce73b8b8183da379782e50c699af80e737a2436d6ce7382e5b161d101f9d3eafa0b8dadce6c87a1c472a5421ffe1fbc588eb43bbe76c458d9ec0d926e1357e3315849915ef988ec8493423014b7e26c521ba115dce7708e2461343846a684d701cf522f4af517d1b811dddbf8ace6f33082f2d66f8a2a5470f125ddbb2fbc3943e5c31952eaf0daa6b31b63853a46b1917ac872c98d44eafe08ae7e4fe99a917668f5d845f161a22e04e00021da080682beb045c1b3721b52096aff5326a5174f67238553cabda9b9ad8f8695ac57b8248e7b51c737cca6c8f19e2c490771245dfc110d6be1e984184c292bcd43a8d0933623686c37cfa950d04501b772067c41e3b88a5b1afa5a5d7bf23e4de8b3ad3430a22502a849f0bdc0c911b45c004a4796195b92cad321f486e6a9a21bc0bc548f4e06b5491359e4fc7126ed5493982a146418497e9e2028e5e78f42c2376be8b993ee6a1d524ec8d13c76c0d7ce2ec39be2e7f40a7075fe883969b8f4bf3085c07edd9f2237b126f71e9172279683834c6a0c483022d119e07d341dfc601e14119af46609617acc2f40859e64f6e111e20418667675a89c3c419289dcfb7a673270129ba8cbe05a924b501f530e1bc965f648189299138b2d3e885416ac74dd04bf19d6bfa49de05d04edb8c9fb84e14a73d0315126398df792c30ab60d327972c67a6f81670b36bd7d86ceff9def07429633a141249d2d1e567621d20e9d50b8ca30d86e12de743c986604f5cb1f3d96f2c2427e68a7003d8b0d756f447a2abc39b902a0146125551d9f95b02d973446bf4bbd45eb2cc712ea553c662a160bce53dacd4acde1897dcffc5f79cac0f99ea36ae5391e106b0797872fa7c47b01855b7f5daa5bf8a0f78d2c5b3d2c59f7c8c605c158aa1327c05adf1f333e1ec9bbbe05abd448a419cebb448b17d7e33acfb3c01f590c28a0fe0f923dbd5734e9a5733bd9b344b0f3639da53785fa7a5636e2209767a4f9b49e0c637e2b68bb8f3d2c1a24552c5526d51c8f26402af80e796673b411e232b235e984b7ad75e175a7e444e6e48164a722b85410a6d5ec8e77a0e09c04a964031ea572ee98a558b3f5abbb23eb58c66bfdd0ccd56c4f08e9636bba6263127467b5a5d9c01d7b22479302e89c276b6c4fe4847a539f8f549e67d75f801a39f227240e10d71b22cda6da3da9d61ae33e8b4326315de80a48f0c1269be71e55cc4cb5b6a887710260a5048c80a42aa47c5de98bdab1788285a9b1e63975e2ac1724df49de973d2bc2c952bc6b2377a9880abf08db6d40c3aae544a228b7dfe725e9829fbda6165e8d5eb519fffebcf760f2bf12c8133ce2d304fdac36bba1c44840dfb00b5b0516002b3a75531489981cb785cb0932e8e2fd3eea2e55d5e11a95b10f4f81701e169b9d12b235b6182f33a984c280fed03c9151abc1a918630e531dcaa1dc87ed521bd69365c4ca308712283a3ae6a4f890baa525f55242a7727fef6786541378551479817a7af9681f24887deb6d44d37bf3876efa5d874822c584a8bb2fe4299f8bfa026324ce38ed845ab239ba4fe05d57faa89e844089f5d7e2510296b61c1b550e6312b577fda885b4066d44b273ce8b4a9b0bbca1036c1184ad960b3211ce9f8638be6f0ec94a5997d452b522f0bc60e75ed4bab4f88b279e52715d54c9855943110eef120c89e87b18e37d73fb3af476dfd098f03d7945ba090457fc16d472d1ddabb755af60438e64e232806d9cb6a413c1221d047312b9eeb867d4add438311e779d00a091ced536c67fcae7f41ccce2390ec9bcf6630eb0aee102d518a0fe6171d7d2f646b7b0b9fe8c65de2a79a1bf5255e613d641300b49e08d6157c700295df9425075f0ea4eaacaebbf928c23c7d0dd26d2ddd81763d9ed5e8a1036e780a8bd31bfa310631a756d75702c2070df4c0d3162d3c6e13f14e54b3cd2908a88b557f29e7758170bacd95c474e70987f43b92ffbb1f647fade183d77a244d9815140c28fc37280f687651041d726455f1978cabc17458410777f79083d922abb4a59ab665a1d652d07b6f8b705edba8e334ea45f0f4c3845eb2a2688a957e2bc1ceed05a76050c05fcd484723c9039ee60734d8a1d693537dac5847aaa90c6bfba775f81e56adbfa71a03cbc651c4b7594564df39f1160d327ce5daab7ce9479374a870f3b1d45c80208470a3bca645d93f80a8d3bdc09941fc9a6df4b9cabe093e3950df54d0e136a387584344fd6b1082ff90e77ab2f4b334b2e152e0f52be1001faaf9448bc273811890ccb8363bd7b13df5369c45c7f776756057a00a8591593a3f693134998dd2f8b0cf9995de492d236061f0c433b952cb61dbef6745dc58e178b8214ad29eb841f4f7d9c3c311136c088b5170de3f2ecc58f2bb613982081795eabdd256ed258b21cee2808fd3c761775d9234f0f3cfc05974c222cb5074f65aa6f228870e0824f85364bbab1c19e8516530ad20485386925cceb9c96b74e1d3866b0cee833718cda64166ea782d40d5bf14b93a52a42686d6a8108b348aa84ec3fa197054e69427e9ee35564a3dc4adc39cdaed70545655ae30367503a70bea07c361e250a92316f1e53fb07d88593f2ad4f60537a8f51b943b6ba883bdeb101c161895ecf2314c9acad7bcee6ef157f9f44b6fe6ce526164857ef66a0a8ceb7f4003cd0c2b54ca10513c41edcfb65412ca086cfbd884e54eab0be787c066e5a9a57f6c89268f7a145aed6955246ab1aafdb8ade75401a1ff</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2679 子串 题解</title>
    <link href="/2022/lg2679-solution/"/>
    <url>/2022/lg2679-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>莫名其妙地想把这道题的题解写了。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为 A 的前 <spanclass="math inline">\(i\)</span> 个字符取出了 <spanclass="math inline">\(k\)</span> 段，恰好匹配到 B 中 <spanclass="math inline">\(j\)</span> 的位置的方案数。</p><p>如果 <span class="math inline">\(A_i \neqB_j\)</span>，那么不会产生任何贡献。</p><p>如果 <span class="math inline">\(A_i =B_j\)</span>，那么有两种情况</p><ol type="1"><li><span class="math inline">\(i\)</span> 接着上一段那么 <spanclass="math inline">\(f(i-1,j-1,k) \rightarrow f(i,j,k)\)</span></li><li><span class="math inline">\(i\)</span>是下一段的第一个。那么它的前继状态有 <spanclass="math inline">\(k-1\)</span> 段，匹配到了 <spanclass="math inline">\(B_{j-1}\)</span>，但是 <spanclass="math inline">\(i\)</span> 能取 <spanclass="math inline">\([1,i-1]\)</span> 中任何一个位置。所以维护 <spanclass="math inline">\(g(i,j,k) = \sum_{x=1}^if(x,j,k)\)</span>，转移就是 <span class="math inline">\(g(i-1,j-1,k-1)\rightarrow f(i,j,k)\)</span>。</li></ol><p>另一种理解，<span class="math inline">\(f(i,j,k)\)</span> 就相当于<span class="math inline">\(i\)</span> 这个位置必须选的方案数，<spanclass="math inline">\(g(i,j,k)\)</span>则是选不选都可以。后者显然是包含前者的，所以最终答案是后者。</p><p>这样会爆内存，可以滚动数组优化掉 <spanclass="math inline">\(i\)</span> 这一维。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1005</span>, M=<span class="hljs-number">205</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, K, f[N][M][<span class="hljs-number">2</span>];<span class="hljs-comment">// f[i][j][0]是上文的g，f[i][j][1]是上文f</span><span class="hljs-type">char</span> a[N], b[M];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%s%s&quot;</span>,&amp;n,&amp;m,&amp;K,a+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>);    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 简单设初值就够了</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j;--j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=K;++k) &#123;        <span class="hljs-keyword">if</span>(a[i]!=b[j]) &#123; f[j][k][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-comment">// 因为有滚动数组，所以要置为0</span>        f[j][k][<span class="hljs-number">1</span>]=(f[j<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>]+f[j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>])%mod;        f[j][k][<span class="hljs-number">0</span>]=(f[j][k][<span class="hljs-number">0</span>]+f[j][k][<span class="hljs-number">1</span>])%mod;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[m][K][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3216 数学作业 题解</title>
    <link href="/2022/lg3216-solution/"/>
    <url>/2022/lg3216-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(f(i)\)</span> 为 <spanclass="math inline">\(Concatenate(i) \bmod m\)</span> 的值。</p><p>那么显然有 <span class="math inline">\(f(i) = \Big( f(i-1) \cdot 10^k+ i \Big) \bmod m\)</span>，其中 <span class="math inline">\(k = \lfloor\lg i \rfloor +1\)</span>。</p><p>这个直接递推绝对是 T 飞的，<span class="math inline">\(n \in[1,10^{18}]\)</span>。</p><p>但是这明显是个线性递推式，可以用矩阵优化。</p><p>定义一个向量为 <span class="math inline">\(\begin{bmatrix} f(i-1) \\i-1 \\ 1 \end{bmatrix}\)</span>，我们的目标是把它变换成 <spanclass="math inline">\(\begin{bmatrix} f(i) \\ i \\ 1\end{bmatrix}\)</span>，这个 1 是来辅助把 <spanclass="math inline">\(i-1\)</span> 变换成 <spanclass="math inline">\(i\)</span> 的。</p><p>手算不难得到这个矩阵就是 <span class="math inline">\(\begin{bmatrix}10^k &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1\end{bmatrix}\)</span>，设它为 <spanclass="math inline">\(A\)</span>。</p><p>那么就有 <span class="math display">\[\begin{bmatrix} f(i) \\ i \\ 1 \end{bmatrix} =  A \begin{bmatrix} f(i-1)\\ i-1 \\ 1 \end{bmatrix}\]</span> 进一步得到 <span class="math display">\[\begin{bmatrix} f(n) \\ i \\ 1 \end{bmatrix} = A^{n-1} \begin{bmatrix} 0\\ 0 \\ 1 \end{bmatrix}  \]</span> 由于 $i +1 $ 在 <spanclass="math inline">\([1,9]\)</span>，<spanclass="math inline">\([10,99]\)</span>，<spanclass="math inline">\([100,999]\)</span>这一类区间里面都相同，所以可以按照每一段分别处理，具体见代码。</p><p>注意上面的矩阵变换！必须保证先处理矩阵的幂，再统计答案。统计答案只需要累乘每一次的结果就行了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5</span>;ll n, mod;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Matrix</span> &#123;ll m[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j) m[i][j]=<span class="hljs-number">0</span>; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; ans, f;Matrix <span class="hljs-keyword">operator</span>*(Matrix a,Matrix b) &#123;Matrix c; c.<span class="hljs-built_in">reset</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;++k)c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;<span class="hljs-keyword">return</span> c;&#125;Matrix <span class="hljs-keyword">operator</span>^(Matrix x,ll y) &#123;Matrix z; z.<span class="hljs-built_in">reset</span>(), z.<span class="hljs-built_in">id</span>(); <span class="hljs-comment">// 矩阵快速幂要把m[i][i]置为1</span><span class="hljs-keyword">for</span>(;y;x=x*x,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll p,ll b)</span> </span>&#123;f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=p%mod;ans=(f^b)*ans;    <span class="hljs-comment">// 一定是这样的计算顺序，不然WA</span>&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;mod);ans.m[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f.m[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=f.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=f.m[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=f.m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// f就是上文的A</span>ll r=<span class="hljs-number">10</span>;<span class="hljs-keyword">while</span>(r&lt;=n) <span class="hljs-built_in">solve</span>(r,r-(r/<span class="hljs-number">10</span>)), r*=<span class="hljs-number">10</span>;<span class="hljs-built_in">solve</span>(r,n-r/<span class="hljs-number">10</span>+<span class="hljs-number">1</span>); <span class="hljs-comment">// 特殊情况，不是一个完整的形似[10^n,10^(n+1) -1]这样的区间</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3620 数据备份 题解</title>
    <link href="/2022/lg3620-solution/"/>
    <url>/2022/lg3620-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>很容易发现选择不相邻的两个办公楼是不划算的。</p><p>所以记 <span class="math inline">\(d_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 与第 <spanclass="math inline">\(i+1\)</span> 个办公楼之间的距离。</p><p>由于任一个办公楼都属于唯一的配对组，所以一旦选择了 <spanclass="math inline">\(d_i\)</span>，<spanclass="math inline">\(d_{i-1}\)</span> 与 <spanclass="math inline">\(d_{i+1}\)</span> 也就不能再选择。</p><p>考虑特殊情况，当 <span class="math inline">\(k=1\)</span>的时候，答案是就 <span class="math inline">\(\min{\{ d_i\}}\)</span>。</p><p>当 <span class="math inline">\(k=2\)</span> 的时候，设最小的是 <spanclass="math inline">\(d_a\)</span>，那么答案一定是</p><ol type="1"><li><span class="math inline">\(d_a\)</span> 加上除了 <spanclass="math inline">\(d_a\)</span>，<spanclass="math inline">\(d_{a-1}\)</span>，<spanclass="math inline">\(d_{a+1}\)</span> 之外的最小值，</li><li><span class="math inline">\(d_{a-1}\)</span> 与 <spanclass="math inline">\(d_{a+1}\)</span>。</li></ol><p>两种决策其中一个。</p><p>为什么会出现这种情况呢？因为选择 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(a-1\)</span> 与 <spanclass="math inline">\(a+1\)</span> 便不能再选。可是如果 <spanclass="math inline">\(d_a\)</span> 加上除了上述三者之外的最小值后还不如<span class="math inline">\(d_{a-1}\)</span> 加上 <spanclass="math inline">\(d_{a+1}\)</span> 小，那么就是另一种答案了。</p><p>那么就有一个结论，<span class="math inline">\(a-1\)</span> 与 <spanclass="math inline">\(a+1\)</span>，在 <spanclass="math inline">\(a\)</span> 不被选择时同时不选，在 <spanclass="math inline">\(a\)</span> 不选时一定同时被选择。</p><p>感性理解一下，对于任何 <span class="math inline">\(k \ge2\)</span>，这个都是成立的。</p><p>单纯地贪心不能保证当前最优就是全局最优，可是能够修改某一个决策的方式维护全局最优，这其实是一个反悔贪心。</p><p>所以维护 <span class="math inline">\(d_i\)</span> 的集合 <spanclass="math inline">\(S\)</span>，贪心地将最小值 <spanclass="math inline">\(d_a\)</span> 加入答案，同时删去 <spanclass="math inline">\(d_a\)</span>，<spanclass="math inline">\(d_{a-1}\)</span>，<spanclass="math inline">\(d_{a+1}\)</span>。加入一个新的元素 <spanclass="math inline">\(a&#39;\)</span>，其中 <spanclass="math inline">\(d_{a&#39;}=d_{a-1}+d_{a+1}-d_a\)</span>。</p><p>这样当取出的最小值为 <span class="math inline">\(d_{a&#39;}\)</span>时，实际上表明第 2 种决策优于第 1 种决策，加入 <spanclass="math inline">\(d_{a&#39;}\)</span> 后也相当于一步反悔，把加入的<span class="math inline">\(d_a\)</span> 消去了。</p><p>既然要快速查找相邻元素，可以用链表维护，用优先队列实现贪心。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>, inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<span class="hljs-type">int</span> n, k, pre[N], nxt[N], a[N], d[N], v[N];<span class="hljs-comment">// v[x]代表x是否被删去了</span><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> x, val; &#125;;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.val&gt;b.val; &#125; priority_queue&lt;node&gt; q;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(node t)</span> </span>&#123;<span class="hljs-type">int</span> l=pre[t.x], r=nxt[t.x];v[l]=v[r]=<span class="hljs-number">1</span>;pre[t.x]=pre[l], nxt[pre[l]]=t.x;    nxt[t.x]=nxt[r], pre[nxt[r]]=t.x;    t.val=d[t.x]=(l&amp;&amp;r)? <span class="hljs-built_in">min</span>(d[l]+d[r]-d[t.x],inf):inf;    q.<span class="hljs-built_in">push</span>(&#123;t.x,t.val&#125;);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) d[i]=a[i+<span class="hljs-number">1</span>]-a[i], pre[i]=i<span class="hljs-number">-1</span>, nxt[i]=i+<span class="hljs-number">1</span>;    nxt[n<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) q.<span class="hljs-built_in">push</span>(&#123;i,d[i]&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;    <span class="hljs-keyword">while</span>(v[q.<span class="hljs-built_in">top</span>().x]) q.<span class="hljs-built_in">pop</span>();         <span class="hljs-comment">// 优先队列不方便删除元素，可以额外标记已经被删除的</span>node t=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();             ans+=t.val;        <span class="hljs-built_in">updata</span>(t); <span class="hljs-comment">// 更新链表</span>    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1332E Height All the Same 题解</title>
    <link href="/2022/cf1332e-solution/"/>
    <url>/2022/cf1332e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先转化一下题意。</p><p>对于一个 <span class="math inline">\(n \times m\)</span>的格子图，每个格子都有一个初始权值 <spanclass="math inline">\(a_{i,j}\)</span>，有两种操作：</p><ol type="1"><li>将两个相邻格子的权值都 +1</li><li>将一个格子的权值 +2</li></ol><p>求能将所有格子的权值变为相同且满足每个权值都在 <spanclass="math inline">\([L,R]\)</span> 范围内的初始局面的个数。</p><p>这种题目可以从奇偶性下手。</p><p>对于操作 1，实质是同时改变两个相邻格子的奇偶性。</p><p>对于操作 2，实质是在不改变该格子的奇偶性的前提下增大或减小权值。</p><p>那么只要我们让所有格子权值的奇偶性相同就行了。</p><p>设奇数个数为 <span class="math inline">\(A\)</span>，偶数个数为 <spanclass="math inline">\(B\)</span>。那么有 <span class="math inline">\(n\times m = A + B\)</span>。</p><p>考虑操作 1，如果那两个格子都是奇数，那么 <spanclass="math inline">\(A+2\)</span>，如果一奇一偶，那么 <spanclass="math inline">\(A\)</span> 不变，如果都为偶数，那么 <spanclass="math inline">\(A-2\)</span>。也就是说，无论怎样改变使用操作1，都不会改变 <span class="math inline">\(A\)</span> 的奇偶性，同时<span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 此消彼长，<spanclass="math inline">\(B\)</span> 的奇偶性也不会变化。</p><p>由于最终一定会让 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 的其中一个变成 0，所以 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 中至少有一个是偶数，否则无解。</p><p><del>但是似乎题目保证有解。</del></p><p>先说一下，向下图这样，将两个格子所在的路径上所有的格子都进行操作1，最终就会单独改变这两个格子的奇偶性。</p><p><img src="https://s2.loli.net/2022/05/15/XAtmTSQCOpI9Na5.png" srcset="/img/loading.gif" lazyload /></p><p>因此只要 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 其中一个是偶数，就有解。</p><p>如何计数呢？再分成两种情况讨论。</p><ol type="1"><li><span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 一奇一偶</li></ol><p>由于 <span class="math inline">\(n \times m = A + B\)</span>，那么<span class="math inline">\(n \times m\)</span> 是奇数，从而 <spanclass="math inline">\(n\)</span> 与 <spanclass="math inline">\(m\)</span> 都是奇数。</p><p>在这种情况下，要么 <span class="math inline">\(A\)</span>是奇数，要么 <span class="math inline">\(B\)</span>是奇数。所以无论图中初始权值是多少，都一定能满足上述条件，随便选就行。</p><p>由于每个格子的取值都在 <span class="math inline">\([L,R]\)</span>中，所以答案为 <span class="math inline">\((R-L+1)^{n \timesm}\)</span></p><ol start="2" type="1"><li><span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 都是偶数</li></ol><p>不难得到 <span class="math inline">\(n \times m\)</span> 是偶数。</p><p>由于要保证 <span class="math inline">\(A\)</span> 是偶数，所以答案是<span class="math display">\[\sum_{2 \mid A}^{nm} C_{nm} ^A \cdot k^A \cdot l^B\]</span> 其中 <span class="math inline">\(k\)</span> 是 <spanclass="math inline">\([L,R]\)</span> 中的奇数个数，<spanclass="math inline">\(l\)</span> 为 <spanclass="math inline">\([L,R]\)</span> 中的偶数个数。</p><p>然而这个式子是没法求的，根本找不到 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span>。</p><p>考虑二项式定理 <span class="math display">\[(k+l)^{nm} = \sum_{a=0}^{nm} C_{nm}^a \cdot k^a \cdot l^{nm-a}\]</span></p><p><span class="math display">\[(k-l)^{nm} = \sum_{a=0}^{nm} (-1)^{a} C_{nm}^a \cdot k^a \cdot l^{nm-a}\]</span></p><p>由于 <span class="math inline">\(B = n \times m -A\)</span>，所以将两式相加，<span class="math inline">\(a\)</span>是奇数时相抵消，<span class="math inline">\(a\)</span>是偶数时算了两遍，最终答案是 <span class="math display">\[\frac{(k+l)^{nm} + (k-l)^{nm}}{2}\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> ll p=<span class="hljs-number">998244353</span>;ll n, m, L, R;<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;ll z=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;y;x=x*x%p,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%p;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;L,&amp;R);ll w=R-L+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>)&amp;&amp;(m&amp;<span class="hljs-number">1</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">fp</span>(w,n*m));<span class="hljs-keyword">else</span> &#123;ll k=R/<span class="hljs-number">2</span>-(L<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;ll l=w-k;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(<span class="hljs-built_in">fp</span>((k+l)%p,n*m)+<span class="hljs-built_in">fp</span>(k-l+p,n*m))*<span class="hljs-number">499122177</span>%p);        <span class="hljs-comment">// 499122177是2在模998244353意义下的逆元</span>&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4155 国旗计划 题解</title>
    <link href="/2022/lg4155-solution/"/>
    <url>/2022/lg4155-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>把区间按照端点递增排序（左右都一样，因为没有包含关系）。断环为链求出每个区间<span class="math inline">\(i\)</span>往右经过一个区间能到达的最远区间。注意只有 <spanclass="math inline">\(l&lt;r\)</span> 的区间才需要复制。</p><p>对于满足 <span class="math inline">\(l \le M\)</span>的区间，倍增求解覆盖 <span class="math inline">\([l,l+M]\)</span>即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, cnt, f[<span class="hljs-number">2</span>*N][<span class="hljs-number">20</span>], ans[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> l, r, id; &#125; a[<span class="hljs-number">2</span>*N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.l!=b.l? a.l&lt;b.l:a.r&lt;b.r; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> r=a[x].l+m, t=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">18</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(f[x][i]&amp;&amp;a[f[x][i]].r&lt;r) x=f[x][i], t|=<span class="hljs-number">1</span>&lt;&lt;i;&#125;<span class="hljs-keyword">return</span> t+<span class="hljs-number">2</span>;    <span class="hljs-comment">// 算上x与最后的那个区间</span>&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();cnt=n;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].l=<span class="hljs-built_in">read</span>(), a[i].r=<span class="hljs-built_in">read</span>();a[i].id=i;<span class="hljs-keyword">if</span>(a[i].l&gt;a[i].r) a[i].r+=m;<span class="hljs-keyword">else</span> a[++cnt]=&#123;a[i].l+m,a[i].r+m,a[i].id&#125;;&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+cnt+<span class="hljs-number">1</span>);a[cnt+<span class="hljs-number">1</span>].r=<span class="hljs-number">1e15</span>;    <span class="hljs-comment">// 特判情况从[1,m]跳到[m,2m]</span><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;<span class="hljs-keyword">while</span>(p&lt;=cnt&amp;&amp;a[p+<span class="hljs-number">1</span>].l&lt;=a[i].r) ++p;        <span class="hljs-comment">// 找到最后一个满足a[p].l&lt;=a[i].r的区间p</span>        <span class="hljs-comment">// 求区间而不是点，相当于离散化</span>f[i][<span class="hljs-number">0</span>]=p;&#125;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">18</span>) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-keyword">if</span>(a[i].l&lt;=m) ans[a[i].id]=<span class="hljs-built_in">calc</span>(i);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);&#125;</code></pre></div><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#8 从今往后</title>
    <link href="/2022/yume-8/"/>
    <url>/2022/yume-8/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ce4908d22229203e8ced8cae6c00d70829ba6050f80cf1b626350f7c300c580f">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f3ef4906db41e418021c1021c98cb253ac90920075cd2c9ea22aee4411cb6ce22316263a6c79322e8797b414b0826926e89ec2ffb6983e832e3596434a8c374dbcc60d3a7fbe9c06a6fe2f9b73724a1a1dd70d2ef62820f4411328cedaee99e853d8b532803c6b4ea15f9ad4598c56193feb89b312609624b21532e5f0f64f79fd2f617aad9a4889fa22524f3f53c412838f94ef85294302364002f10549c77cf0fe522b5762e7614e7e0fa405f3dd76e2a95532918f41b4ecabdc9e4cd322cc004a3c9363aaea38f135021100002c7827ae3a3ad489fb4e38798c91d8f2741bddcfa2576e5acf6b6e2f7403fd4032f7e87c032a2c879fc3bd70ba04d1d70d523609ed8184a9c960f6b1937e177cbd13a9d5c3a538f897e29b0912b32050863e070e149929b8897a41430aed1bd08fc56e1bf879cb717dc2cef1ad6db5db49a965242006e9bcdcb303bb38096a91365e39da28132da62781b07e3860c772c893951ad8381e5fefe6b4bd6012da067019f706a76eec54676d2f4538e1f98f6beca25887645ae45ec604a28991514a8217c8dbfbefb2e0bfcccd6142cbacc2df8d747743338149251d0a9265c19b817ca5162131887e2d52ef64919cb049b88d2072dc4c2ddc4e020457b905650a7ad22a61cfe76c6b9e560c2427f469e1996a14c5eff64ab149088d0bb465952ef1a8c9e83c0bd5e6758d4c39b079a7a8d8fb76af93b8d69f49656091edde11b8f6b57bd63574114b2975a61da379e9918712efacb1173e903dec4657ef6a8731e9e35fd663c5d93a60611bee077afb3dfe9439cc2f5b745cc6a430bd30a71b734ca07f4bca6711ee791910bf51b13a7c520b786b45d40f2ed415188af74c7ec6e0907eb3ec0ba627ef6225e21da02c685fdc5b6f275d27a814eb48ebc7f00ca9d192c21b5a90bb41ef8c97e4658997071450531c0942f21bc4e316da03b43eb4929deff43bb5d7bdc81a79f80dccb948a04b643b25749da2a67604ff9d9c275002a3b63365b344c70971f3c3b5efba9b8dfa10548a98df259b3fc6a04d94ca1de4a33ed934a4ba051112c963d48a12fe1e6b286d4ce53643046d55e9ec6e7630531684c309259de07c6af1399076c99c85760fb5142c576d658a0556c02c66741c7b6a3dc0c8b7e15256750108b01ff32887249d8ca4e87b256e68cf96d82b6076179ea11c948e4e86b152b7ba55752c181ac61cc489618446d87d862e9eddd40a0f19e7fa0030b295146582a816ad1804ceba9a18525ecf63818b7263e84173f0f4c04f03919c1474f7b71c95a753ee2bd57631a66309c37a61d2a4540f03993e8025c205a13eb932a85eeb842a422b99bde05b405e5dc1707947e4d28f463d268e141256fe7c51456049b3a9d45e84d563477a0fde368481ab4b21e51f1f71eec25e46078249a88aecf0a288afd8b74df568983c83ee02a4255137f93ef10174599bb7c89da4d2637e2e42c7f2e90fb6586761cf3a7e3e811d7066a143fe84a0c7a85a8215ee89c576178c8e27e89a25b8d21f51166bc29fd800387f13f835e3f7efda5e08d5519f01161a7ab971b908a57912e8d8ab148a597af2f10584b401db0afa5884cb45b74bbbcc123e29b403568cc07de31db1f5d05601e2778c9005472b3057fb76c89644907a5bf94e45fee847fdda024a8c248d8a0df5453cd2a2258f8c8b67a261affb5d508d228c48b06648f20db2947a6dbab865f389e08cc332ee5ddf5e306b74362c05d5a453d72024536fec67990828e65c2239af68754d7705690176f80a21a724a8c47ec6dbcff1b88c46eba65e14a2520b8f2369b9ee49f917d9e57695af80955768cfdbc35509ae6ff0d1c4d0d713bb1eddd672bfc346f0fa6b46b8845325d2df6c42c2e409db78865ac97bf2f86d3a36ca0669ae41324e8a5abac3687e3d2da2c47b31837c38dc179c56b0ef085b7fcdefe3d6504325781605e6c85ad0ae2ccfbae9495eb1da3a14ca7eeaeaebba647fb178790e8127005bb979d035c4e84b0a16b298a8ed1b471fc63a197169b5192742a9b47e099ac6f0e232855d6af74f00576d228100e32014daa2838d73b38be91f9de9d91c49e41766449b08eecfe0bc6db3266011c5f5a60993ea1b96b6a8af22c14ee8c9fbfa6f6b7dace7eb61586e33cffbab1d75399b6ed00aa3badd762e775f6420b208f0fed034c20c59f1485ff38e3571fd68e06da0774378665287662639f3e8a8059ca6009e87d5344fc642acfa16a5bdf05b67c540ed543041627bb28e3e322660287515360f74ed43089c7c52563413524a08c64ce0dba776d92f72cbf69782539e18a5695ec116436fbcd9f6f00bef78f34af9467d38e2b33fd62fecbbae731cf86b8d38f85f3043f913a840b83b427ec1914e890da640ae20870a5b4761fe7a2abe66c1646b99616edacc7e992844711a5881a654fa4feaaf500dd000a0287dcb57311cda6d89a7dbc1e9aaf3b9f8501357eefde417ef0ddeeaae1ba4452f111c04c70b928b3589fb7ef528c358371105ed9fc62326bd9ea43bb5d26382c3222572c946623bd996ed19108eed8b56878ba363a72f5e186ea92f15b9b34c3a6e4389d479a6a7fb585cc8c17744863a24e2fd9578a57992fbb44e76a03c494a8d29689292a0e97ddd42c0e8e49877e8a503c84096e4cd845dd15f2e7db65f146dd74b33bfa387f31d13e68140cad79897685f3696665ff5cd9cc159d24429f5fbdb51f42b055f98fca7698ad9c9a95c65bb1efa1181f79db4367d35fafe4e926da4496e43a8785d89aa0caa8bde36096bdff75f3a9289cac6908b2ed245bea5992ba1e73a8d659281002d3f961bb997ea7c2f46494a18bcca3b620f80408099e44b71792fe9217c44c90a55f7e52d01ef8492d0af1ed6b13f303adb300865a1449dfe1a6f2126049ed6ea1d459384b6735f28e36444e2bd39b4bb469e5f99ca21e3b82022c286a7cefcb59faec3e120a6708ab1a429f7816d082c134804dcda198748c8625b93fc9335aa3da19f958feda991b9d3953b8e8a028f2a487e2e7bef980c760a048afb62d362cf9b838cf8120210d6b95be5046ccef03cb5dc1402851f98807ce1f782d401edf30b422eb05f187b155f1e15fbd9aed4a4d64df33c222150c8232bf33392873d6f50d8117c3ae162a2cadb818ade9035491b96233ac3498ca0a167c79ccaf0a8e29ffe08c5f19f136e6a46a0d33eb15b4b9b683a68b0bb9a081f49e41ebcd352dfe058bc48b2102287237de1fddf54ae0b6fde241e3ab6eaaa69179617205290fec6ca1d80e1792ff83a57afac176d8e7a89a84abec236c05663fe632242d108198fc86dda12fb1e8f986ccc3e5f171087d5b1fe2a8bbae33f0346cb97053d1b4b61da4245aea4458256d28a840fb436be3349444b231f816e94980f672862aa9dca2422f50187e794ae23bee6d562f619c9bd05db7a985d55626097842cc79b88c2c2bb8a1d47fd8fec2de55cbddf8447870316a74b4a057f6237a2ce80bd30d83c25a1bf0a002324827caf0432d264ebb5be03525a4ef4c78dbb2d3575ec89e12f524430c1577f9eae0bcaf8e984d641bbc6c1f9dabb1930cfcc909cde92d7fdc8aa96730c965001ed8eb115a9347bb3d671efb2f062e4045bd5e87a5d9cf57b0a10ed67d49e0c596efb0cdefc8611cd1510cea0f58f21f21b13207c14617e3959f631246bd7a0f88c2a2a56fd51ee737731cd7ae72fde7aee2e1ba4172f65230397f761fda051b38a3eed4737256e9bda290db04898134383f56b773c63787c4c31303ff9be41dcad776b9554676799c6e7e867d63546f3502d409aa4cfc7e6d346ff02dcf27b1d7d38deba306524d0f3c25f55635f07468ae37edf324358c799d95e7460e464b2449e47f9e0e255b1de7a1d94bd90df366e2a0d87343adf87e9199f220c2616fd1989d2a500120139e1ab415308caa503d64c3654bee6925882c1922be8edec808b873c696e0f0e4e5203d4604185ac1f6752795ce406bd3eaeea911d9c5e8441d677965d3689f95c955c7b6fa45c508f175e4267991b3faf646ca4f3883141f224b0433c221a34e3300c43e8d464e8df1ab5bd6ab0cd169f7fbab7d6e0dff6508faf5f0fb99721c7a9cc460b0468a5bd74df644ae1bf6e07d264d67ad0ab1247c1a432f2a50b636340bd56480a72d82dddd2bfe81422e0728420fefd94b20d13b5a6ce8177886a376379e83bff1d5ee64859600a48ad180cbec9d939cc6be58c684555ee3f852046a3c98f32801dbdab0ca235ec9cafca3dac3c61d9dbee0401acdec93bb295e952a4d421f9267b23677f3c9ed03c560ea1ef76cb51b59e6fb2e9c4c3413da7a47c443b3a87c5a9e02857340f8991e3cd27156d3f495468a76209e445586369d25392a801bd882ea5e76facf1cf9777990e394afcdd3da841a4d4b1b366136e40e95f204c5b168825987fd48256c02171698a91879f078005519db6fce5cdc5aa0879aea1c2848cc0041a268f25383e2be2a3fa97137cf05dd37255cbe951b2c537e0a5f02d0e558217d77196b8735dc48297a027629a6e4443f7d874e260603da5b2f4ae094e093326e5484a4a95cab7a40ae7d8b7d2e3850b6f314bc2a87a9ef7129a882a2c289c841e5ec3c769139c7cf1e71f085ed8ddb141ae70783fe3ca55ae0a2df407ffd722fc646ce9d003973fa6089dfb22d71e4eb942f964522af43241dc3292003466157a12871f210f22140eca7358b32b4256fdb50bda4652a8df0706288e1dccf6fcbb884c77786b29e0ba7d46b52c60478ced83a8ad9cd441801e20b60431178fb829b504cbd5cdff9ecb41b841fa8a22e11a32b2a8306eb9e8d2741c71c4353cf9f462cc735bbc9772065a5c7641d70425a89410d08d096dece4094dfadae3471359a71150f91c1ee072429767c69311288343ca3ba8909a09d68e2ede21d9c943978571b5e671ce5c02f8677e0404be30a0adeae30fb6622541bbe50d4da025e5aed21c75a54b541f31abde99d5995d84e71e32679f9ad92a8722dde7c773f5a86457f357f7f537c4955572776064e4bad841624dcf0ec20caee25b41d29210bb49d8814b143a013ec0807853e2b49fb06f05f99341ec12e77afed70c72c7d88464c1340b78e7fbc62899f2c1f9f44c54fdd8e7d0bba2753aaf038458ae9dce06135e71acbdaf6c9d99cc6282dfae94d5f602bca91e000afdf6c3e62083f7cc4cc432daf0c1462c67ceccc7855030aa4dbfb6b33e2559a0bdb13dd772f9c05389bda462744eec5455effa2a238e4abcda81fc02ef63ed07e00877320d3e560989ac38a806ec39195d299a7a2c6cae8b32e82c040a72b8fd4d3c704e8af828e72e4ecf346ac1213b046e1fdb765c622499fb70e43845f946f1e65bbb81706298762c86a51652844ac3bc4802efc241a35c5772d6c96f162ab4f5e44f3558fd8e8a24b15ac376b3aa8ea16b2614d51d2084887610bca6de9c76e7097786ccc853b048d900fbd6deb1bebdf39b6bf67df87095000c22f7fdb2fe9ef9cd4366df028a1223ea3664805d2a6a6b42b8d938741307f6f5e3761807bceffedc5200893f531220e56250f27bc521d443d0550378897a53eae8d604f7a27d4611db926ebff5bea85d725690fa30985259101b94c212fe2f9b9ae19764e137d4494382d365055412c5702344b156e76120638ea70fdd569e48acb8003b793b7c05c81a8937572795070e7cc66bbdea04beaf94b8bc6d09784005a7ec1120d7a305ca7e454275a2639291ebbacaab3db20f27dbe119eff21fc36df5f03d3f4806804e148a16841a68a0fa6a4a21c3fde2de569bffa281b37aa4a482660363ffba0eb5f1512d89cd57738013866b084e254e429be31c4bb8804015af4e205b80b0d263b095adfdd352e9927338162eca301cb0ce69e1d77a07bd4d6e66718c6a638e5d4857e66e07a03bed2f34acee15f23aab1b2d31fdabe95331617fe2831a155d6ca237b5f1116f7cd11c543a69250097b46dad209325c94e2e7888cbd4891a6467c1f3286906bd49f195ac22780e6c979365d263794f308dbdf40762e1c647952a743773b7f21bb6ea1d7e403331c7472c96bbb233495f1f1d265a84e4ca18324749c11077dd7bc742ec1b1e96a50b9b1aa895e8dc84d846ccbadcac4cc726a67ad45b13e729d9576fc61a04a3e50d7b5ce4ba67a1a11aa3b8066bfa40e32858e157b762635e6be2116556968753b8e1915b0350e923f6b9b983355f8a515528f803ad04fa150a4af47375a854581723f615903175277d7d3337e01ee7350fd1a127305567a304c694b0a39bd634624ea6e7f0c1017c2247e00dee571d61f8f50a994e79f80432bdfd6d1b3b5e9700a1378a4f0c671b29b95e84b46689d6391d9e383740c064666e1921136c3e68d1e06dbe4bf20ec30a52c06f4e82bdccc7da56faccab4d58900a6428f31843c94ff0d9a7491695b6e2ce99ddc98bf1787ac614f3209a0bf9dea2554d67ef1279d25fd7696db2a73c18ca4238471267cc2bf2b0a3b58f33b8aa85cac7ca217244b7f0bc4d24a5f2329f065e353e336fee957727e0814b752b7c3a545aadba4403febd1ebe161ad9359298ac9398738b06bb0ca22e2af4cda486bd6898060393bd668d6853f39dafdfde7a5b202e3d030717d9d6ec2864a28b86511ef70c32f33ee001fddc078d07860c6b40e69c2c0f370cdbd409fda562ddc20f39727ae335dbfc3b284382de6773bd85b9ab3c43d11eae2fcd9bf8b46a7bc3ffb0d943fbf7fb4c3898b875bcb787f16cce7c9ac0e16598eff54d63839db33127bb3cb039a1c0cccc7a913632f2298ca6fc8e507f19fe0c0e9f5078dea6a432dcbc4be5a7c7999eb93fa335f1915000770002b3b80336f5cc94566ffb9b76682f0c91398d2b340ff8366ae7f13f6d2f7748425d8f131b4a8e716921197615feabacdd0e148839a2dd68c4e2580b4ea1b918a7f0a0889342f35f269b5395102d9b8a1a43787537c56aa3895269e1da5d5e46df16c5c7693f30bc39c8a59fbf5996b21617732d59085bffced8c6e9cd0927aa752c5d70ca502f9903bf92ba29e444920863de1a8dd0b978a3455bc45d4f883a05d68390aa2268046bf340240cac15d638ff4e568db4e36fe72120ccfa18ae496c2f0d50e3e26eb8f2fb6188a331e75c5a7d88902c43f179a94e3a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6186 冒泡排序 题解</title>
    <link href="/2022/lg6186-solution/"/>
    <url>/2022/lg6186-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>手算一下不难发现，一轮冒泡排序会让所有逆序对个数大于 1 的位置减少 1个逆序对，逆序对为 0 的则不受影响。</p><p>设 <span class="math inline">\(f_i\)</span> 表示位置 <spanclass="math inline">\(i\)</span> 的逆序对数，那么经过 <spanclass="math inline">\(k\)</span> 轮冒泡排序后，逆序对的个数为 <spanclass="math display">\[\sum_{ i=1  \text{ and } f_i &gt; k}^n f_i - k \cdot \sum_{i \in [1,n]}[f_i &gt; k]\]</span> 树状数组维护之，具体见代码。交换的操作分类讨论就行了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, a[N];ll sum, f[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BIT</span> &#123;ll c[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c)); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 放置下标为0</span><span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=y;&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll x)</span> </span>&#123;ll y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;&#125; t1, t2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t1.<span class="hljs-built_in">modify</span>(a[i],<span class="hljs-number">1</span>);f[i]=t1.<span class="hljs-built_in">query</span>(n)-t1.<span class="hljs-built_in">query</span>(a[i]);<span class="hljs-comment">//printf(&quot;%lld\n&quot;,f[i]);</span>t2.<span class="hljs-built_in">modify</span>(f[i],f[i]);&#125;    <span class="hljs-comment">// 先利用t1求出原本的逆序对，再维护f[i]的权值数列</span>    <span class="hljs-comment">// t2维护t1对应的和</span>t1.<span class="hljs-built_in">reset</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) t1.<span class="hljs-built_in">modify</span>(f[i],<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-built_in">pre</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> op, x; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123;t1.<span class="hljs-built_in">modify</span>(f[x],<span class="hljs-number">-1</span>), t1.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],<span class="hljs-number">-1</span>);t2.<span class="hljs-built_in">modify</span>(f[x],-f[x]), t2.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],-f[x+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 把交换的这两个数先从树状数组中删了</span><span class="hljs-keyword">if</span>(a[x]&gt;a[x+<span class="hljs-number">1</span>]) --f[x+<span class="hljs-number">1</span>]; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[x]&lt;a[x+<span class="hljs-number">1</span>]) ++f[x];            <span class="hljs-comment">// a[x]&gt;a[x+1]，交换后x+1这个位置的逆序会减少1</span>            <span class="hljs-comment">// 反之，x这个位置逆序对会增加1。</span><span class="hljs-built_in">swap</span>(f[x],f[x+<span class="hljs-number">1</span>]), <span class="hljs-built_in">swap</span>(a[x],a[x+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 交换他们的值</span>t1.<span class="hljs-built_in">modify</span>(f[x],<span class="hljs-number">1</span>), t1.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);t2.<span class="hljs-built_in">modify</span>(f[x],f[x]), t2.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],f[x+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 重新插入回去</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(x&gt;=n) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-type">int</span> cnt=t1.<span class="hljs-built_in">query</span>(n)-t1.<span class="hljs-built_in">query</span>(x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t2.<span class="hljs-built_in">query</span>(n)-t2.<span class="hljs-built_in">query</span>(x)<span class="hljs-number">-1ll</span>*cnt*x);            <span class="hljs-comment">// 注意1ll*cnt</span>&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6185 序列 题解</title>
    <link href="/2022/lg6185-solution/"/>
    <url>/2022/lg6185-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>把每个点的点权都搞成 <span class="math inline">\(a_i -b_i\)</span>，问题转化为把所有节点权值都搞成 <spanclass="math inline">\(0\)</span>。</p><p>有两种思路。</p><ol type="1"><li><p>用并查集维护 <span class="math inline">\(1\)</span>操作，因为一个连通块内可以同加减。</p></li><li><p>用并查集维护 <span class="math inline">\(2\)</span>操作，因为一个连通块内可以多次使用，从而让任意节点加<spanclass="math inline">\(1\)</span>，任意节点减 <spanclass="math inline">\(1\)</span>。</p></li></ol><p>虽然前者也具有传递性，但是对问题却没有帮助。</p><p>而后者隐藏着总和不变的信息——只有当总和为 <spanclass="math inline">\(0\)</span> 时才有解。</p><p>同时连通块之间的 <span class="math inline">\(1\)</span>操作，就相当于在二者差不变的情况下任意加减。</p><p>如果图是二分图，不存在奇环，那么就只能在上述情况下修改，因此要求这张二分图左部右部权值和相等。</p><p>否则连续使用 <span class="math inline">\(1\)</span>操作，就能在节点权值奇偶性不变的情况下任意修改点权，别的点权也能往环上传递。因此对图黑白染色后，两种颜色的权值和要求同奇偶。这个黑白染色可以直接用上一步判断二分图剩下的。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> T, n, m, a[N], b[N];<span class="hljs-type">int</span> fa[N], w[N], col[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y, w[y]+=w[x];&#125;vector&lt;<span class="hljs-type">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-type">int</span> sum[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span> </span>&#123;col[x]=color;sum[color]+=w[x];<span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(col[y]==color) res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!col[y]) res&amp;=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-color);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), col[i]=<span class="hljs-number">0</span>, p[i].<span class="hljs-built_in">clear</span>(), fa[i]=i;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) b[i]=<span class="hljs-built_in">read</span>(), w[i]=a[i]-b[i];vector&lt;PII &gt; opt;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> op=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) <span class="hljs-built_in">merge</span>(x,y);<span class="hljs-keyword">else</span> opt.<span class="hljs-built_in">pb</span>(&#123;x,y&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:opt) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">get</span>(t.fi), y=<span class="hljs-built_in">get</span>(t.se);<span class="hljs-built_in">add</span>(x,y);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i==fa[i]&amp;&amp;!col[i]) &#123;sum[<span class="hljs-number">1</span>]=sum[<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<span class="hljs-type">bool</span> isbin=<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(isbin&amp;&amp;sum[<span class="hljs-number">1</span>]!=sum[<span class="hljs-number">2</span>]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(!isbin&amp;&amp;(sum[<span class="hljs-number">1</span>]+sum[<span class="hljs-number">2</span>])&amp;<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5588 小猪佩奇爬树 题解</title>
    <link href="/2022/lg5588-solution/"/>
    <url>/2022/lg5588-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>分类讨论一下。</p><p>对于颜色 <span class="math inline">\(w_i\)</span></p><p>若 <span class="math inline">\(w_i=0\)</span>，随便选两个点都可以，<span class="math inline">\(\frac{n(n-1)}{2}\)</span>。</p><p>若 <span class="math inline">\(w_i = 1\)</span>，设这个点为 <spanclass="math inline">\(x\)</span>，那么只要两个点之间的路径经过 <spanclass="math inline">\(x\)</span>，就是合法的。为了不重不漏，要按照一定的顺序去计算。对于一条边<span class="math inline">\((x \rightarrow y)\)</span>，我们先令答案累加<span class="math inline">\(sz_x \cdot sz_y\)</span>，再将 <spanclass="math inline">\(sz_x\)</span> 加上 <spanclass="math inline">\(sz_y\)</span>。最后累加 <spanclass="math inline">\(sz_x \cdot(n-sz_x)\)</span>。手算一下就知道是对的，可以直接处理任何一个节点的颜色数量为1 的情况，直接查询即可。</p><p>可是对于其他情况就不是那么好处理了。不难想到对于 <spanclass="math inline">\(w_i&gt;1\)</span>，由于两点间有且仅有一条简单路径，所以想要经过所有这个颜色的点，就必须保证这些点全部都在同一条链上，也就是端点数量为2。</p><p>图中的蓝色就无法找到合法的点对，贡献为 0。</p><figure><img src="https://s2.loli.net/2022/04/30/UcuIbZlRiQXEoMT.png" srcset="/img/loading.gif" lazyloadalt="没有贡献" /><figcaption aria-hidden="true">没有贡献</figcaption></figure><p>图中红色的分布就在一条链上，不难发现贡献是左端点的子树大小乘右端点子树大小。</p><figure><img src="https://s2.loli.net/2022/04/30/QAXMYjbgv6ma3ky.png" srcset="/img/loading.gif" lazyloadalt="能够产生贡献" /><figcaption aria-hidden="true">能够产生贡献</figcaption></figure><p> </p><p>如何快速统计同一种颜色的分布情况呢？对于每种颜色单独处理是不行的。</p><p>在 dfs 的过程中，设当前节点为 <spanclass="math inline">\(x\)</span>，颜色为 <spanclass="math inline">\(c_x\)</span>，设 <spanclass="math inline">\(pre_{c_x}\)</span> 为 颜色 <spanclass="math inline">\(c_x\)</span> 的链上，到 <spanclass="math inline">\(x\)</span>的位置时经过的点数。用一个变量<code>fg</code>维护信息。（因为非链就不会产生贡献，不影响答案）</p><p>如果 <span class="math inline">\(x\)</span> 是端点且此时 <spanclass="math inline">\(pre_{c_x}=0\)</span>，那么搜索完与 <spanclass="math inline">\(x\)</span> 直接相连的边后最多让颜色 <spanclass="math inline">\(c_x\)</span> 的点的个数+1。相邻节点有颜色相同的，让<code>fg+=1</code>。</p><p>如果 <span class="math inline">\(pre_{c_x} \neq 0\)</span> 或者不是<span class="math inline">\(c_x\)</span>的最后一个节点，那么就让<code>fg+=1</code>，这两种情况都会让 <spanclass="math inline">\(x\)</span>可能为端点。（硬说的话前者是有机会成为后搜索到的端点，后者是有机会成为先搜索到的端点）</p><p>可以对着下面的图理解。</p><p>这样如果 <spanclass="math inline">\(fg=1\)</span>，那么就一定是一个端点了。</p><p>然后记录左右端点，设它们为 <spanclass="math inline">\((x,y)\)</span>。</p><p>对于下图情况，直接让 <span class="math inline">\(sz_x \cdotsz_y\)</span></p><p><img src="https://s2.loli.net/2022/04/30/KeP5mGdpYcBb69A.png" srcset="/img/loading.gif" lazyload /></p><p>对于下图情况，设 <spanclass="math inline">\(dep_x&gt;dep_y\)</span>，<spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 的链上第一个经过点是 <spanclass="math inline">\(z\)</span>，那么答案是 <spanclass="math inline">\(sz_y \cdot (n-sz_z)\)</span></p><p><img src="https://s2.loli.net/2022/04/30/zniNcKvrRAsLkjW.png" srcset="/img/loading.gif" lazyload /></p><p>实现的时候要用好多映射，就不一一写了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, col[N], cnt[N], pre[N], sz[N];<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans1[N], ans2[N];<span class="hljs-type">int</span> cc, h[N], p[N], v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> nxt, to; &#125; e[N&lt;&lt;<span class="hljs-number">1</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;e[++cc]=&#123;h[x],y&#125;, h[x]=cc;&#125;<span class="hljs-comment">// cnt[i]，颜色i的总数</span><span class="hljs-comment">// col[i]，i的颜色</span><span class="hljs-comment">// pre[i]，颜色为i的链上已经经过的点数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-type">int</span> c=col[x], t=pre[c], fg=<span class="hljs-number">0</span>, z=<span class="hljs-number">0</span>;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-type">int</span> y=e[i].to;<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-type">int</span> lst=pre[c];        <span class="hljs-comment">// 这里没有算上x</span><span class="hljs-built_in">dfs</span>(y,x);ans1[x]+=<span class="hljs-number">1ll</span>*sz[x]*sz[y];sz[x]+=sz[y];<span class="hljs-keyword">if</span>(lst!=pre[c]) ++fg, z=y;        <span class="hljs-comment">// 搜到了相同的颜色，记录z</span>&#125;ans1[x]+=<span class="hljs-number">1ll</span>*sz[x]*(n-sz[x]);<span class="hljs-keyword">if</span>(t||pre[c]+<span class="hljs-number">1</span>!=cnt[c]) ++fg;++pre[c]; <span class="hljs-comment">// x也在pre[c]的链上</span><span class="hljs-keyword">if</span>(fg==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(!v[c]) p[c]=x;<span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> s=z? n-sz[z]:sz[x];            <span class="hljs-comment">// n-sz[z]的情况实际是搜索到的第一个这个颜色的节点就是端点</span>ans2[c]=<span class="hljs-number">1ll</span>*sz[p[c]]*s;&#125;++v[c]; <span class="hljs-comment">// 端点数量</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;col[i]);++cnt[col[i]], p[col[i]]=i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!cnt[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">1ll</span>*n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt[i]==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans1[p[i]]);        <span class="hljs-comment">// 注意i是颜色，要用p[i]映射过去</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[i]==<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans2[i]);        <span class="hljs-comment">// 有两个端点</span><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#7</title>
    <link href="/2022/yume-7/"/>
    <url>/2022/yume-7/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="04a974432c4ee00299fb7380e656166b67aa80962520ce6e02ef642a26f5d362">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f3bf32f310d3dc588f93757b4ee391d008465705e56e96148691214059e3d4487c8f3be47c4261b25b769ff885439459755d34cef4976e0c82776f11a4c4cb96cb7814852688dca741cb03a35b2930fde248602cb61be765a9d44238941bd4df726a97e8438bf5203fd7139515a7af18d60dbb265c1ed9fa4ecc0772d7185a0a86765697e7bd9ed48aec96c3995e67444b43913e9ec90a2c02d08cd5d3dcf95a01485e094e1eafaf08c1b9ebadbf4a4f5c773a0d1abe721c36769e0e20394aeeff3bcbd3c5ba58982b973e9fedb6d2cc95c17bcc01f11da6ae0a9e2e6bfb936aa0a4575b13b8b67ec9be643705f18e9c4fe38e65d8e864ac83b9840c9ea6dad3797a8d2dc39452a26d359b927780c60adc52a8e3d945205648500ef339704c00fc4b0222f445508f7e6ade4ce9316fdb2571dbbd1ff3ccefdbd7757fdd389abd60ea9e5e795212a9629d0d9dae8f2e8995e4a547b72a38d2ab8d665e3bb41758dc90b51f5b420b0bb6bff98aab09d08b923a0cce03784982c794468eb27d03215d5f9c457bf0a4cddc7cef569e666035cf7b2b7e84f924eac20884b1ab6a9df950fc1e8e2d45863739b6d6651eb20c24a0966c55104172082f1568f453e5743c9dcd69751fc5c334f6d35fdc0c0ecb4a7bb97c739563cd73f315f109e90a4043af102509e9bb52729761379b9ec1775fdd7407f6b7aed671ae1ed83d8ecdb5dbb1a6544b4ea4dd5409c2c7ff359fd1a25450c244a7c1119b6dfb62b8e8e189e3007fe2de0d7f7b1d3ed1b8c6937ed6547cf70108b248c2a94f5c8239c49f56090b6c91cc07ff3e2eb3aad064e15ec6b5259d442f25f16b0db8614e0626449b90218662b7167a383eb771437fd8794132b4fb7f7eb0d8cf1dd4a65377c2e2a0a4198e6b3a9099f31a6de845bf5576499a5622897ea919a5e81ff067e96d3fb923de20bd72e9cee5d8ba1cfe7b3fe3cc62be955e275e882d79cb9661be721c59b43e93b157a9fa85ba845efb3b95b6676cfc13bd8772a999e8a68cdcdd386f9c6833b04936c93ba7cfe244fe47ee8fd8d4314dce882996f120afabcfae451f80c5a10bc12b1dca2c8bcbbf3009708d2c06792e7c84e100ae46654ead797e1e58ed1bff751a6cc39633cd9d017affcc3fc868ca62b5ffac0cf80d56d910afcec2b31e33e0992d62589a57c52669290a53348b88d2e8912e74f553be06996dfbd157dd11c47cda43d26d462e3fba7efeb87917e1ce7dea514693d628a4b9ab7dcfdc709d7251ec7f020b87829a991dbf8d07cd43627ce2de81666c37435fb2283459c94adc3a93ba706329a08eb27131522f59338e57b7859abb9119aaa9ba3fb689da056f46b1d31052c543cc6063d41d25915d63cb8a35085deea6469173b3f9f2bf16f1333d609206e0c67384ff3815b56e1309ff4a62e7ba008265185568e581c0bc2c0b457f476949b58e43ec2b9ad27119ae0af4258c6f2a4ba403f5627d8271afb1980a50eb69f98f61ee228d379690903c0d2692ba2ef84e7031791cea3cc3199627d0212f510567c84ee34ee809d17fe393809397c7445900fa5a19a1c07234712252a333ca0ea8c124fc73d8e28716bf14542319e907814bb391ed798e00cb2a7de3342328f4cc36d50f3785a9637594a5eea9d60c856b98b96537c98725470a42a63949ad92bd13b39d4c3f7a9917fb2440c3c023f4e60f13f9619f9ae7cab627ef50dd7cffebad763f7ada9c671a68a00d7b082ef95e478fd91074ad892d01a7457b53beb450c8a2106f64817645d3a4f5c32a98ec99b846a52abc222d6e0710f9b4ed83433711c37a79218949e845d9af811f4f693bcc99656d9264fb7e64c92be457523326df8624dd0794df20e51bfe91854277d055f01e1a2117f87b159a4f2a13c09e6a2d7a0788ddbe53484e65ff1d9031d4e23ee9e70d2a1123111e2386666364aeb10dfdf4bd2bbbd9bcbfaab69b9c70c870dd8171dc7b3ad33ccef7cd2a31bfd3baac0ab2803bbfdb1c83b40c7f5f462c99198562dd1aee533552c858a47156090d89473bcbec8d8a20e3c1c351f68aa42fddb03eeef2523d7799ce34c3742b225019e707e3ddad1d65bfc19ebb5a2c93c39766dbd8c0a31cf235a4c99cd4032aa8aac038b2f6d34fa43c3501a5ab29cedc3cd2b7c6a6bff8f7ea7d164a3ab1a520c455eb247aa3669e31e71c411dfa9ec5863c7fd39f706d9a0b31489335d2c41b7b70190c3d3a68ce105569b6988fef46ca860528b6dc3ad912eb32a097948cbebfb830cf56b080452221f9780356841b980a1687c5b882c7ffbee5e973add0292c4073f85b5a718a8fc02114afcbd97c1fe7d9bc31e857f20475f7b334205e2bbd26761a95f0a79f52a542a9da775972478c430722bfcd3c0ad3aa69661db355fa444368e7a35c8038ef661f32cdee44390e4f1b50a714e138cc97520e12a26ee3305a4e895e4356a0b1b3e613b6d84280dbe84d2c6a4d337b97aaa6b114c51a779c1f83cfc75e23f14f37fc9aa2a789db80d9f0712588ac6564f7b3df893c6b31702a045a5059d47f21339414a23de466d83f551c2075eb986be0c78edba912c83139c0866993d8a1ca35aa440ea6616ed648e18ac3e2584f51668a229787195361419472832df2a92b5755684e5474c32058bbe980c476404327de8c0091820a0c783bf778b8097dc54d1653690339c29cff3ce4d1959317c7e6ce3761ad0397e58e84bc0507f940d72f94f4a79082ff1e3f5cfb7e0e9ed8b0ead0ca30303387d7aec09cff6ca57f9f94e32bf046dc13f1dee0fd86480fd8962e93ea015cd4688af5a3a048fc55154cd8b4c2c46be0bdeef9cff40a864de0cb9550deca242e87c260d03dbff39d2fb508b216f2d28f79b1b4707f1f1f74159b32c1ba06895dc0b26b41f6b3501f92b3124d66b1e7e855d05398890edb2924ebb7f63e3733ad6ea6016e433148da1ef1939cd2990bd3a97da0daea476117dbcdad9ed12403f3ba53c2747896837184ca160667f5f28e5e5e9971d3b2763ac28571cd11567a2644ed2c30dd3fc795e3f9baec508a709712a1056eaff8e12512b83f1fb14e590f9dcb77d31a41034cc0763f30b341d98cd2d7c44c84165689e9b99d875632119cf50f63f4eddf9cd1d00fa7b04b8445af1bee17e5a1b2caba4167d1db24d134644b9bad4245223cc69d69868be0309b4f3f0a0fd019ff1cd217f7d205833be654613494cc3c678ebb58fa5f7527cf890621530326c51442659056f3e8d35d7de1ed5bd61cf30bdc55799ce6c2027d6a6d4683b42020d4f6eae74470d83ec2e521cfd966ae828a8ca997c209253e4b3a13b37058c5bc86f9df03d6bd12547cd48346d1e3cd7c201f57d8089b1a77905a2c9d7f51630de029445f79404daf6c4adec22cc1b74bceeea1e81bdcddc0350e520e974a5b237bbe90fe7eaf35b17f1dbdb8b4bc75f8d75f8a474b9df9f44774f3ce4743bb37e6c7b8a9486b20d616ee57cd8257933c94a1dd05fe439250c28d1a1cf250837582dd50f8727a0239f770d6f4028e6393b599ec9691ff7f15d285bb6eb31c0aff11b310c02098441f0e7de3ac10ceb4ff026987187f6a9936a01497763e0c0054ced8d75ae464cadaf6c9d0302985787a8e95c2643b7bc80335abde16e8e229e9085bc7e149ceb929030eb1ccb847e569fca6ee680be9b46ddd115655f63e32bff9eed26f0d0fc07dbe87761380f5335e5fb504044383a9a43d5e97a230a200d55c238ea94239bc9e8b7ec5fa4cac64f2c787e01f972b8205ecb33b5cd4bf90858fe4aa6d7fa6eca7774b037a6e6e549cfe4a80fb331b2fd55dd7bc112b9ae633c052714566a7279b9c313547495f1d886c729eafd7696701a7abee45feeaf7966b6f9ca698448895f308ecd0fbe63096da3c4536fe5b5e90f5ba49eeb275b1c22111639f58674478dafe00399c4cb9ddb384d50d23df85158c063689eb64c619ef40e06a9b3b37c7269e5b9220796fd9a3c06853ea95bd8fdd124a450c0ab42dfe228caa6c307558e698b3c6c2e808478dcc4f1509a2ed90a1b3490013bbdba3472b4b9ecdbdde959fd46db24fa6da00f194440ddec712d69741b73fd98429a317494e7a05da8fc5eb7eefaaf38107cc8913310338860fc930cf1a80a822f0a3aec8e8c28947eac22490b90df564f605b58b6db1aedb2651a013de683c74cbcf9c9c261fc9f5564f80ac2a53cf98cd16743bd4a5b4c65227b3cc3771ad8c70db620b5a1282ddf4af78008e652fea050050e07fb1c0c2be6a64b7f766ecef54400b0859a8063fe3ba1300489ab98c5075df43d0cc29dfc69a2b80b560bd8635decf097d39b4d9ba9f1cbdb07cfa0ac3986db4cc714c89f664281cb2fc03ede700921b7ad13cef6abd9347bb7f20c965f56149ea04cc7b80524a457929f959cfd31dd1f92c0673925fb381ecfa70c8cec56c42eb4bfb32d09daedeb1e78976ec636a521d6c5fec6e22d8de4dfcce8ededc4568e7e3ab17d70069979fa784cd49e90cf918ef83639fb98c814083021d9001da904044b0691414e68df2e547a56ccc5703af120a0b838ac3c7f440f8ee7d563a07e6aa45221644879e57fbc78168c13c47f79f638daa3e7e37c4dc2d6c521369761b9f5841e316af40a05e4cbc908087ffe3b938389e88ab1a714bfca4396be6b9b9925d3c8cac483842241379b63a6780c0f0900650ee27590d29ef9163dec7bf46aab5df1561552674e6451c45cd55ca7391d3d6740787c8bc90cd3f168d7c2061f89f74ec29cdd28ab3f9c02142a93eea19d9f5acc21fe0a82ccb209cd2dce7f6752c673296f3ed415dffe16f8b78a12c9e84b8ccb9738dddaf1f0d652dcee7e9c9f742c7a9216222b4d37451fd9f9888a9e00847de76d1486b5c9ab945cee7ee8335cb2cf8b2061538681acc3f96e9d47c18db3a6fd81f263a38b3a1e39fe71e76e6d1d4547528cff79a91c519496185a1f9457611011b33e235c3e345b7a283fd34c7abe6ff782f2c3e6c2b75273aa128cab724859f2f7eb642ac46dd5485c436c77b5869b6925a9d387587f16af9a76c70a6496f14e3d51300b2b66ad2d43a30186e1e4bb8f420b327b1b64beb9830f6a353c2fd9779a0adf8dd80fd0c3e919a2cfd2cd2a5bb8ba253615f30ada6f95f7e8997daf279a669e69be4a6ec770eacd25f3f9609297770178805cd2b56939a59bbef2068df2e378e3744c1422a40ce82abbeabb0f69c6794147a1426372961cfd107bdc481af5be9933e21ea87ede84cd2b3aaa9d8c2cebee61b3106294023e33dfa8a756cba09df21c4ad8b7477ce1fd2e40c3a27efd846a7f21f896132343e52e144ce7b981310bd18e747890cae43ba2581ca517e1fa0d542b7ce54caac8231da7cdaf45819bdeb29ab1f0935705b9645e359dddd38f637fbfa441b806ca96671d0e411e6dc5cc79eabd3d7f09be7241e4e233e5c1f49ce778178aac12829a8c7f394eeef968c53ce2617c94d1aab7ef0f592f000ab002891307a897fcd1528cd2bf9f7bb9231683ec2b101831036bd5ac655a96bc84168b1821287de72c78ec88c8d1e74cc0dfbf3b1e6193f8fde640840b583c8d29e5d3b78fd4aeaef6074b38cbaa41ee1453a5844fe63608cda5988114e25b20bbf854eaf6161c53e65564d0b1ea69dfd6840b5fa33a7062cbc17d5577741ff3c539e5c7dc7384154b4e910b5f5a6a88bd499cbb406001e560b6a46ee77ae0e38d3bcf78a753cc097e98d23e1b385f4e2f49d36292e2684bd183918ba0aad614d29a6fc2561a1bb68476b9e5bc5f8f2f263f1705815b1dce6eebe09ef085359fd0d8480357fb0d5e61f0ca439d10a2ddbb5cd0d1ecd99c6e9accbe9610a77164757d57c5a598f899b9dad8be3729610a832001ed96fc473f7717da3fbcc9fb53c81202df6a7b834c382bde0bdf1b464aaed32437a2f03f41f3e75923ba6d71f098eca330e51c8fe1a6010348993a2b437659223f376e3288a06e4419ce1542b957caed2f501792174b361d00eb06279c7314ebb1ceadd842ec2b8f9d2544dfa7218529245baab6d760c5de4b70fbabddac61c8d6385adf7f1cfb7082211d5708113744e013455c6b8d2c2e47cd930b394d2c993b15fe08a0b91a635cb461c1dfa28b8b7ffc3d1fc7f5c31308fff82aa1a2ec5f98077e8c722874eb4fe50d089dea7972dba0d03960e19405ced2e8291afdbbd2dd667494e8d4dd64128030e5d3b7f40e9b12e7d981dd53fede35e0987bb15ece99a4151e74ea870d2fcac1aa42f4dbc3fb5e92a9fedf5b1eca18398b0463cc7e68aefb208f847857e9550d5b9804f24039b1558bfeb77da8f675bd8111f94d15d93b71755e1e60874892f20f3a12b402c186d8415830d90b1e92d4784fea8de39ec61e3a8b4e0ba81b72f8f6e2669ab918bafd13faf40e72cc3da0fbe6d31210fd1611e1b1057517c4876b88c47f88863e8d84d120c7505c26ce28d94e654ce754bab0c0ae914f2bfa6b97f48b0e52c39805315</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2519 problem a 题解</title>
    <link href="/2022/lg2519-solution/"/>
    <url>/2022/lg2519-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>说假话的人最少，可以转化成求说真话的人最多。</p><p>考虑按照成绩递增排序的情况，如果第 <spanclass="math inline">\(i\)</span> 个人有 <spanclass="math inline">\(a_i\)</span> 个人分数比他高，<spanclass="math inline">\(b_i\)</span> 个人分数比他低，那么 <spanclass="math inline">\([b_i+1,n-a_i]\)</span>这个区间表示的就是分数和他相等的人。</p><p>令 <span class="math inline">\(l_i = b_i+1\)</span>，<spanclass="math inline">\(r_i=n-a_i\)</span>。如果 <spanclass="math inline">\(l_i &gt; r_i\)</span>那么这个人一定说假话。同一分数相等的人不能超过 <spanclass="math inline">\(r_i - l_i +1\)</span> 个。</p><p>所以我们把每个 <span class="math inline">\(l_i\)</span> 与 <spanclass="math inline">\(r_i\)</span>看作线段的端点，端点相同（分数相同）的人数看作这天线段的权值，那么问题就转化成了带权区间调度问题。</p><p>以上的特判可以用<code>std::map</code>来快速实现。</p><p>设 <span class="math inline">\(f_i\)</span> 为前 <spanclass="math inline">\(i\)</span> 条线段能得到的最大值，那么有 <spanclass="math display">\[f_i = \max_{1 \le j &lt; i}{\{ f_i,f_j + cnt_j \}} \quad r_j &lt; l_i\]</span> <span class="math inline">\(f\)</span>显然是单调增的，二分即可。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mk make_pair</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, len, d[N], f[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> l, r, k; &#125; a[N];<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(edge a,edge b) &#123; <span class="hljs-keyword">return</span> a.r&lt;b.r; &#125;map&lt;pii,<span class="hljs-type">int</span>&gt; mp;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x,y,l,r;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);l=y+<span class="hljs-number">1</span>, r=n-x;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 第一种不合法</span>pii e=<span class="hljs-built_in">mk</span>(l,r);<span class="hljs-keyword">if</span>(mp[e]==r-l+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 第二种不合法</span><span class="hljs-keyword">if</span>(!mp[e]) a[++len].l=l, a[len].r=r;++mp[e];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) &#123;<span class="hljs-type">int</span> k=mp[<span class="hljs-built_in">mk</span>(a[i].l,a[i].r)];a[i]=(edge)&#123;a[i].l,a[i].r,k&#125;;&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+len+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) d[i]=a[i].r;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">lower_bound</span>(d+<span class="hljs-number">1</span>,d+i,a[i].l)-d<span class="hljs-number">-1</span>; <span class="hljs-comment">//注意-1</span>f[i]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>],f[k]+a[i].k);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-f[len]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4588 数学计算 题解</title>
    <link href="/2022/lg4588-solution/"/>
    <url>/2022/lg4588-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>比较巧妙的题目。</p><p>乘上一个数再除以它，相当于在 <span class="math inline">\(x\)</span>中去掉了这个因子。我们的目的是快速找到那个因子并且快速维护 <spanclass="math inline">\(x\)</span> 的值。</p><p>在 <span class="math inline">\([1,q]\)</span>上建一颗线段树，起初每个节点值为 1，根节点表示这 <spanclass="math inline">\(q\)</span>个数的积。因为每个节点最多操作两次（一次乘一个数，一次去掉），所以对于第<span class="math inline">\(i\)</span> 个操作<code>1 m</code>，就把第<span class="math inline">\(i\)</span> 个节点改为 <spanclass="math inline">\(m\)</span>，更新根节点；对于操作<code>2 pos</code>，把<span class="math inline">\(pos\)</span> 位置的节点改为1，更新根节点，相当于除以这个数。</p><p>你甚至只需要写建树和单点查询……</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> T, q, mod;ll t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;    t[o]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(o&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> pos,ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l==r) &#123; t[o]=x; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(pos&lt;=mid) <span class="hljs-built_in">update</span>(o&lt;&lt;<span class="hljs-number">1</span>,l,mid,pos,x);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(o&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,pos,x);    t[o]=(t[o&lt;&lt;<span class="hljs-number">1</span>]*t[o&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>])%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> op, m, pos;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;q,&amp;mod);    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,q);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);        <span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,q,i,m);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t[<span class="hljs-number">1</span>]);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;pos);            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,q,pos,<span class="hljs-number">1</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t[<span class="hljs-number">1</span>]);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1385E Directing Edges 题解</title>
    <link href="/2022/cf1385e-solution/"/>
    <url>/2022/cf1385e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>可以把给无向边一个方向的过程看作加有向边的过程。</p><p>如果在原来有向边组成的图中有环，那么无论如何加边都不可能变成一张DAG，无解。</p><p>考虑到在 DAG 中，对于一条有向边 <span class="math inline">\((x\rightarrow y)\)</span>，<span class="math inline">\(x\)</span>的拓扑序一定小于 <spanclass="math inline">\(y\)</span>。所以根据这个来构造，在原图上求出拓扑序。对于一条无向边<span class="math inline">\((x \rightarrow y)\)</span>，如果 <spanclass="math inline">\(y\)</span> 的拓扑序大于 <spanclass="math inline">\(x\)</span> 的，那么就从 <spanclass="math inline">\(x\)</span> 向 <spanclass="math inline">\(y\)</span> 连一条边，否则就反过来。</p><p>题目中说图不一定连通，但是不影响判环和求拓扑序。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> t, n, m, tot, in[N], topo[N];<span class="hljs-type">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();topo[x]=++num;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">return</span> num==n;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;tot=cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) h[i]=in[i]=topo[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> op, x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);a[++tot]=<span class="hljs-built_in">make_pair</span>(x,y);<span class="hljs-keyword">if</span>(op) &#123;<span class="hljs-built_in">add</span>(x,y), ++in[y];&#125;&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">toposort</span>()) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=a[i].first, y=a[i].second;        <span class="hljs-comment">// 这里是直接存了所有边</span>        <span class="hljs-comment">// 因为如果a[i]是有向边，那么topo[x]一定小于topo[y]，不影响</span><span class="hljs-keyword">if</span>(topo[x]&gt;topo[y]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,y,x);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,x,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">sol</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7914 括号序列 题解</title>
    <link href="/2022/lg7914-solution/"/>
    <url>/2022/lg7914-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>为了防止与下标混淆，这里用 <span class="math inline">\(m\)</span>表示题目中的 <span class="math inline">\(k\)</span>。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为考虑区间 <spanclass="math inline">\([i,j]\)</span> 内的字符，确定合法串的方案数，<spanclass="math inline">\(q(i,j)\)</span> 为 <spanclass="math inline">\([i,j]\)</span> 能否变成不超过 <spanclass="math inline">\(k\)</span> 个<code>*</code>组成的串。</p><p>显然合法串的左右端点必须分别是左括号与右括号，所以以下转移都是在满足<span class="math inline">\(i\)</span> 能够成为左括号，<spanclass="math inline">\(j\)</span> 能够成为右括号的前提下。</p><p>除了两个串合并，其他几种情况都是比较平凡的。</p><ol type="1"><li><p><code>()</code> <span class="math display">\[f(i,j) = 1\]</span></p></li><li><p><code>(S)</code> <span class="math display">\[q(i+1,j-1) \rightarrow f(i,j)\]</span></p></li><li><p><code>(A)</code> <span class="math display">\[f(i+1,j-1) \rightarrow f(i,j)\]</span></p></li><li><p><code>(SA)</code></p><p>枚举<code>S</code>最后一个字符的位置 <spanclass="math inline">\(k\)</span>。 <span class="math display">\[q(i+1,k) \times f(k+1,j-1) \rightarrow f(i,j)\]</span></p></li><li><p><code>(AS)</code></p><p>与上一种情况类似，枚举<code>A</code>最后一个字符的位置 <spanclass="math inline">\(k\)</span>，可以与上一步一起转移。 <spanclass="math display">\[f(i+1,k) \times q(k+1,j-1) \rightarrow f(i,j)\]</span></p></li><li><p><code>AB</code></p><p>为了避免重复，我们只考虑加入最后一个不是通过合并得到的合法串，所以记录<span class="math inline">\(g(i,j)\)</span>为只用上面那些方式确定合法串的方案数。套路性地枚举断点即可。 <spanclass="math display">\[\sum_{k=i+1}^{j-2} f(i,k) \times g(k+1,j) \rightarrow f(i,j)\]</span></p></li><li><p><code>ASB</code></p><p>直接做的话就是枚举<code>S</code>的左右端点，然后<code>B</code>还是要用<span class="math inline">\(g\)</span>来转移。但是这样的复杂度过高，考虑优化。</p><p>能发现当<code>A</code>确定时，<code>S</code>是有一个明显的取值区间的，并且右端点单调不降，所以可以枚举<code>A</code>的末尾字符位置<span class="math inline">\(k\)</span>，找到一个 <spanclass="math inline">\(pos\)</span>，满足 <spanclass="math inline">\([k+1,pos-1]\)</span>可以作为<code>S</code>并且极长，此时<code>B</code>的方案数就是一个后缀和，预处理即可。<span class="math display">\[\Bigg( \sum_{k=i}^{j-2} f(i,k) \times  \Big( \sum_{l=k+2}^{pos}  g(l,j)\Big) \Bigg) \rightarrow f(i,j)\]</span></p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, m, f[N][N], g[N][N], valid[N][N];<span class="hljs-type">int</span> suf[N];<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-keyword">return</span> (s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;?&#x27;</span>)&amp;&amp;(s[j]==<span class="hljs-string">&#x27;)&#x27;</span>||s[j]==<span class="hljs-string">&#x27;?&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(r,l,n) &#123;<span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;m) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(s[r]!=<span class="hljs-string">&#x27;*&#x27;</span>&amp;&amp;s[r]!=<span class="hljs-string">&#x27;?&#x27;</span>) <span class="hljs-keyword">break</span>;valid[l][r]=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">rep</span>(l,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=n;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i,j)) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==j) &#123;f[i][j]=g[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">continue</span>;&#125;f[i][j]=(f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+valid[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])%mod;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i+<span class="hljs-number">1</span>;k&lt;=j<span class="hljs-number">-2</span>;++k) &#123;(f[i][j]+=(valid[i+<span class="hljs-number">1</span>][k]*f[k+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+f[i+<span class="hljs-number">1</span>][k]*valid[k+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])%mod)%=mod;&#125;g[i][j]=f[i][j];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j<span class="hljs-number">-1</span>;++k) (f[i][j]+=f[i][k]*g[k+<span class="hljs-number">1</span>][j]%mod)%=mod;suf[j+<span class="hljs-number">1</span>]=suf[j+<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j;k&gt;=i;--k) suf[k]=(suf[k+<span class="hljs-number">1</span>]+g[k][j])%mod;<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j<span class="hljs-number">-2</span>;++k) &#123;pos=<span class="hljs-built_in">max</span>(pos,k+<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(pos&lt;=j&amp;&amp;valid[k+<span class="hljs-number">1</span>][pos]) ++pos;(f[i][j]+=f[i][k]*(suf[k+<span class="hljs-number">2</span>]-suf[pos+<span class="hljs-number">1</span>]+mod)%mod)%=mod;&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5658 括号树 题解</title>
    <link href="/2022/lg5658-solution/"/>
    <url>/2022/lg5658-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>水一篇题解，明天写 CSP-S2021 T2 括号序列。</p><p>考虑序列上的情况，设 <span class="math inline">\(f_i\)</span>为序列中以 <span class="math inline">\(i\)</span>结尾的合法序列的数量（注意是以 <span class="math inline">\(i\)</span>结尾，不是 <span class="math inline">\([1,i]\)</span>中的合法序列数量）。那么如果 <span class="math inline">\(s_i\)</span>是左括号，那么将它入栈，<span class="math inline">\(f_i=0\)</span>。如果 <span class="math inline">\(s_i\)</span>为右括号，则有 <span class="math display">\[f_i = f_{l_i-1} + 1\]</span> 其中 <span class="math inline">\(l_i\)</span> 是与 <spanclass="math inline">\(i\)</span> 配对的左括号位置。</p><p>最终答案为 <span class="math inline">\(\sum_{i=1}^nf_i\)</span>。</p><p>现在考虑树上的情况。由于是一棵树，两点之间有且仅有一条简单路径，所以我们每次都是处理一条链的情况。在链上，<spanclass="math inline">\(l_i-1\)</span> 就变成了 <spanclass="math inline">\(l_i\)</span> 的父亲节点，其他都是一样的。</p><p>还是一样，遇到左括号就将它入栈。否则就如果栈顶元素是左括号，维护信息；如果是右括号，那就把它入栈。处理完一个节点要回溯时，撤销当前节点的操作，不影响下一条链的信息。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">int</span> n, tp, f[N], fr[N], sk[N];<span class="hljs-type">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];ll ans;<span class="hljs-type">char</span> s[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++c]=y, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,ll res)</span> </span>&#123;    R <span class="hljs-type">int</span> i, y=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;(&#x27;</span>) sk[++tp]=x;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span>(!tp||s[sk[tp]]==<span class="hljs-string">&#x27;)&#x27;</span>) sk[++tp]=x;        <span class="hljs-keyword">else</span> y=sk[tp], f[x]=f[fr[sk[tp--]]]+<span class="hljs-number">1</span>;    &#125;    res+=f[x], ans^=<span class="hljs-number">1ll</span>*x*res;    <span class="hljs-comment">// 统计答案</span>    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-built_in">dfs</span>(ver[i],res);    <span class="hljs-keyword">if</span>(y) sk[++tp]=y; <span class="hljs-keyword">else</span> --tp;    <span class="hljs-comment">// 撤销本次操作</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(R <span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;fr[i]), <span class="hljs-built_in">add</span>(fr[i],i);    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1359E Modular Stability 题解</title>
    <link href="/2022/cf1359e-solution/"/>
    <url>/2022/cf1359e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>由于 <span class="math inline">\(a_1\)</span>时最小的，所以对于长度为 <span class="math inline">\(k\)</span> 的序列<span class="math inline">\(\{a_i\}\)</span>，取模每一项最后的结果是<span class="math inline">\(x \bmod a_1\)</span>。</p><p>而对于下标的任意排列，显然 <span class="math inline">\(\forall p_i&lt; p_1\)</span>，都必须满足 <span class="math inline">\(x \bmod a_1 =x \bmod a_i\)</span>，即 <span class="math inline">\(a_1 \mida_i\)</span>，不然最后的结果就会改变。当 <spanclass="math inline">\(a_1\)</span> 为首项时，就得到了 <spanclass="math inline">\(\forall i \in [1,k]\quad a_1 \mida_i\)</span>。</p><p>所以，我们只要枚举首项 <span class="math inline">\(a_1\)</span>，在<span class="math inline">\([1,n]\)</span> 范围 <spanclass="math inline">\(a_1\)</span> 的倍数个数为 <spanclass="math inline">\(\lfloor \frac{n}{a_1}\rfloor\)</span>，我们要从中选取 <spanclass="math inline">\(k-1\)</span> 个数作为其他项，所以答案就是 <spanclass="math display">\[\sum_{i=1} ^n C_{\lfloor \frac{n}{i} \rfloor -1} ^ {k-1}\]</span> 统计就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(i=(j);i&lt;=(k);++i)</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">const</span> ll p=<span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> n, k;ll fac[N], inv[N], ans;<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n,ll m)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> fac[n]*inv[m]%p*inv[n-m]%p;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-type">int</span> i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    fac[<span class="hljs-number">0</span>]=<span class="hljs-number">1ll</span>, inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1ll</span>;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">5e5</span>) &#123;        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%p;        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) inv[i]=(p-p/i)*inv[p%i]%p;    &#125;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">5e5</span>) inv[i]=inv[i]*inv[i<span class="hljs-number">-1</span>]%p;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;        <span class="hljs-keyword">if</span>(n/i&lt;k) <span class="hljs-keyword">break</span>;        (ans+=<span class="hljs-built_in">C</span>(n/i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>))%=p;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT5759 ThREE 题解</title>
    <link href="/2022/at5759-solution/"/>
    <url>/2022/at5759-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题构造一下链和菊花的情况会理解地更透彻一些。</p><p>“三步走”战略啊不，距离为 3的点，它们所在的深度肯定是不同的。也就是说，我们能把整棵树按照节点深度奇偶性黑白染色，分成两个集合，距离为3 的点一定在不同的集合里。</p><p>对于 <span class="math inline">\((i,j)\)</span>，要求 <spanclass="math inline">\(p_i \cdot p_j \equiv 0 \; (\bmod 3)\)</span> 或者<span class="math inline">\(p_i + p_j \equiv 0 \; (\bmod3)\)</span>，又可以按照节点编号模 3 的结果来分成 3 个集合。其中模三为 0的那个集合是最特殊的，因为其中的任意一个点和其他所有点组成的点对都是合法的。</p><p>为了方便，称 n 类点 表示模 3 为 n 的点。</p><p>很容易知道 0 类点的个数为 <span class="math inline">\(\lfloor\frac{n}{3}\rfloor\)</span>，接下来就是大胆构造，<del>绝不证明</del>。</p><p>如果黑白某个集合节点个数小于等于 <span class="math inline">\(\lfloor\frac{n}{3}\rfloor\)</span>，那么如果把所有的 0类点放到这个集合里，另一个集合无论怎么选，都是一组合法解，因为乘积均为 3的倍数。</p><p>但是如果每个集合都大于 <span class="math inline">\(\lfloor\frac{n}{3}\rfloor\)</span> 呢？</p><p>注意到 1 类点和 2 类点，它们的和模 3 为 0，即 3的倍数。所以一个集合全放 1 类点，一个集合全放 2 类点，0类点随便放——因为它们和任何点组成的点对都是合法的。</p><p>实现还是 STL 好用。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-type">int</span> n, col[N], p[N];vector&lt;<span class="hljs-type">int</span>&gt; g[N], c[<span class="hljs-number">2</span>], v[<span class="hljs-number">3</span>];<span class="hljs-comment">// c存节点黑白染色，v存模3</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;    col[x]=col[fr]^<span class="hljs-number">1</span>, c[col[x]].<span class="hljs-built_in">pb</span>(x);    <span class="hljs-comment">// 按照深度奇偶黑白染色</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:g[x]) <span class="hljs-keyword">if</span>(y!=fr) <span class="hljs-built_in">dfs</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) v[i%<span class="hljs-number">3</span>].<span class="hljs-built_in">pb</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-type">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        g[x].<span class="hljs-built_in">pb</span>(y), g[y].<span class="hljs-built_in">pb</span>(x);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()&lt;c[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(c[<span class="hljs-number">0</span>],c[<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 取较小的集合</span>    <span class="hljs-keyword">if</span>(c[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()&lt;=n/<span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">1</span>]) p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 全放0类点</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">0</span>])        <span class="hljs-keyword">if</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">1</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">1</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">2</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-keyword">else</span> p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 随便放</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">1</span>])            <span class="hljs-keyword">if</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">1</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">1</span>].<span class="hljs-built_in">pop_back</span>();            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 分别放1类点和0类点，不足用0类点补齐</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">0</span>])        <span class="hljs-keyword">if</span>(v[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">2</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();    &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p[i]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5664 Emiya 家今天的饭 题解</title>
    <link href="/2022/lg5664-solution/"/>
    <url>/2022/lg5664-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题很有启发意义：不要为了 DP 而去DP。对于一个计数问题，应当灵活地去划分。</p><p>题目中的三个条件，如果直接去计数做的话，信息冗余太多，很难理清思路。但是注意到我们能极其容易地求出满足前两个条件的方案数，而且三个条件都满足的方案一定在满足前两个条件的方案数中。所以如果我们能够单独求出不满足第三个条件的数量，就能够求出满足三个条件的方案数。这是一种常见的套路。</p><p>显然对于一种烹饪方法 <span class="math inline">\(i\)</span>，能够做出<span class="math inline">\(A_i = \sum_{j=1}^m a_{i,j}\)</span>道不同的菜。</p><p>由于每一种烹饪方法都可以不选，但是又不能每一种都不选，所以满足前两个条件的方案数为<span class="math display">\[\prod_{i=1}^n (A_i+1) -1\]</span> 接下来单独考虑第三个条件。</p><p>这个可以 DP，但不是直接用 DP统计目标方案数。因为太过苛刻的转移条件会大大增加复杂度，而加入可承受范围内的冗余信息有时是能够简化问题的。</p><p>所以，设 <span class="math inline">\(f_{i,j,k}\)</span> 为前 <spanclass="math inline">\(i\)</span> 种方法，选择了 <spanclass="math inline">\(j+k\)</span> 种方法，其中 <spanclass="math inline">\(j\)</span> 次用到了当前食材 <spanclass="math inline">\(x\)</span>。</p><p>转移比较简单 <span class="math display">\[f_{i,j,k} = f_{i-1,j,k}+a_{i,x} \cdot f_{i-1,j-1,k} + (A_i-a_{i,x} )\cdot f_{i-1,j,k-1}\]</span> 最终答案 <span class="math inline">\(\sum f_{n,j,k} \quad j&gt; k\)</span>。</p><p>这样状态数为 <span class="math inline">\(n^3\)</span>，转移为 <spanclass="math inline">\(O(1)\)</span>，但是还要对于 <spanclass="math inline">\(m\)</span> 种食材分别计算，所以复杂度为 <spanclass="math inline">\(O(n^3m)\)</span>。这个不够优秀。</p><p>转移和枚举是优化不了的，只能从状态下手。可以看到，对于食材 <spanclass="math inline">\(x\)</span>，我们只关心使用它的方案数是否占到一半以上，不关心具体选择方案。这也有一种常见的优化技巧。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为前 <spanclass="math inline">\(i\)</span> 种方法，其中选择食材 <spanclass="math inline">\(x\)</span> 的方法数量减去其他方法数量结果是 <spanclass="math inline">\(j\)</span>，若 <span class="math inline">\(j &gt;0\)</span>，那么就说明占到了一半以上。但是这个下标可能为负数，所以要加上一个偏移量。</p><p>这样状态数降到了 <span class="math inline">\(n^2\)</span>，转移呢？<span class="math display">\[f_{i,j} = f_{i-1,j}+a_{i,x} \cdot f_{i-1,j-1} + (A_i-a_{i,x}) \cdotf_{i-1,j+1}\]</span> 依旧是 <span class="math inline">\(O(1)\)</span>。</p><p>所以这个 DP 的复杂度为 <spanclass="math inline">\(O(n^2m)\)</span>。</p><p>答案为 <span class="math inline">\(\prod_{i=1}^n (A_i+1) -1 -\sumf_{n,j} \quad j&gt;0\)</span></p><p>具体细节见代码。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">2005</span>, mod=<span class="hljs-number">998244353</span>, dlt=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, m, S=<span class="hljs-number">1</span>, ans, a[N][M], s[N], f[N][<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (s[x]-a[x][y]+mod)%mod; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;        a[i][j]=<span class="hljs-built_in">read</span>();        s[i]=(s[i]+a[i][j])%mod;    &#125;    (S*=s[i]+<span class="hljs-number">1</span>)%=mod;    &#125;    (S-=<span class="hljs-number">1</span>)%=mod;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);        f[<span class="hljs-number">0</span>][n]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=n-j;k&lt;=n+j;++k)            f[j][k]=(f[j<span class="hljs-number">-1</span>][k]+f[j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>]*a[j][i]%mod+f[j<span class="hljs-number">-1</span>][k+<span class="hljs-number">1</span>]*<span class="hljs-built_in">calc</span>(j,i)%mod)%mod;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) (ans+=f[n][n+j])%=mod;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,(S-ans+mod)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5052 GO 题解</title>
    <link href="/2022/lg5052-solution/"/>
    <url>/2022/lg5052-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题评紫确实过了。很容易看出来是套路的区间 DP。</p><p>设 <span class="math inline">\(f(i,j,t,0/1)\)</span> 表示抓到了区间<span class="math inline">\([i,j]\)</span> 的宝可梦，花费的时间为 <spanclass="math inline">\(t\)</span>，在 <spanclass="math inline">\(i\)</span> 或 <spanclass="math inline">\(j\)</span> 的位置，所获得的最大收益。</p><p>转移情况比较多，用刷表法比较方便，而且要注意时间限制，否则下面的<span class="math inline">\(B\)</span> 是不能加的。 <spanclass="math display">\[f(i-1,j,t +\Delta t,0) =\max \begin{cases}f(i,j,t,0) + B_{i-1}\\f(i,j,t,1) + B_{i-1}\end{cases}\]</span></p><p><span class="math display">\[f(i,j+1,t +\Delta t,1) =\max \begin{cases}f(i,j,t,0) + B_{j+1}\\f(i,j,t,1) + B_{j+1}\end{cases}\]</span></p><p>计算 <span class="math inline">\(\Delta t\)</span>只需要将对应的编号相减就行了。</p><p>注意状态中的 <span class="math inline">\([i,j]\)</span>指的是按照编号排序后排名为 <span class="math inline">\([i,j]\)</span>的宝可梦，而不是房子编号，不然复杂度不对。这一步就相当于离散化。</p><p>边界为</p><p><span class="math display">\[f(i,j,t,0/1) =\begin{cases}0 &amp; i=j=k\\-\infty &amp; \text{otherwise}\end{cases}\]</span></p><p>复杂度 <span class="math inline">\(O(m^2 \max T)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, maxt=<span class="hljs-number">2005</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, k, ans, T, f[N][N][maxt][<span class="hljs-number">2</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">qwq</span> &#123; <span class="hljs-type">int</span> num, v, t; &#125; a[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(qwq a,qwq b) &#123; <span class="hljs-keyword">return</span> a.num&lt;b.num; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i].num,&amp;a[i].v,&amp;a[i].t);T=<span class="hljs-built_in">max</span>(T,a[i].t);&#125;a[++m]=(qwq)&#123;k,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 原点</span><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(a[i].num==k) &#123; p=i; <span class="hljs-keyword">break</span>; &#125;f[p][p][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=f[p][p][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;t&lt;=T;++t) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;len&lt;=m;++len) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=m;++i) &#123;<span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(f[i][j][t][<span class="hljs-number">0</span>]!=-inf) &#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> tt=t+a[i].num-a[i<span class="hljs-number">-1</span>].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[i<span class="hljs-number">-1</span>].t) dlt=a[i<span class="hljs-number">-1</span>].v;f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>],f[i][j][t][<span class="hljs-number">0</span>]+dlt);&#125;&#125;<span class="hljs-keyword">if</span>(j!=m) &#123;<span class="hljs-type">int</span> tt=t+a[j+<span class="hljs-number">1</span>].num-a[i].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[j+<span class="hljs-number">1</span>].t) dlt=a[j+<span class="hljs-number">1</span>].v;f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>],f[i][j][t][<span class="hljs-number">0</span>]+dlt);&#125;&#125;&#125;<span class="hljs-keyword">if</span>(f[i][j][t][<span class="hljs-number">1</span>]!=-inf) &#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> tt=t+a[j].num-a[i<span class="hljs-number">-1</span>].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[i<span class="hljs-number">-1</span>].t) dlt=a[i<span class="hljs-number">-1</span>].v;f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>],f[i][j][t][<span class="hljs-number">1</span>]+dlt);&#125;&#125;<span class="hljs-keyword">if</span>(j!=m) &#123;<span class="hljs-type">int</span> tt=t+a[j+<span class="hljs-number">1</span>].num-a[j].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-type">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[j+<span class="hljs-number">1</span>].t) dlt=a[j+<span class="hljs-number">1</span>].v;f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>],f[i][j][t][<span class="hljs-number">1</span>]+dlt);&#125;&#125;&#125;ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">max</span>(f[i][j][t][<span class="hljs-number">0</span>],f[i][j][t][<span class="hljs-number">1</span>]));&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1120D Power Tree 题解</title>
    <link href="/2022/cf1120d-solution/"/>
    <url>/2022/cf1120d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="part-1">part 1</h3><p>对子树操作，自然想到DFS。但是题目里的操作仅仅是针对叶子节点的，所以用的不是纯粹的 DFS序。通过这种办法，就能把子树操作转化为序列操作，而每个子树内所有的叶子要对应一个叶子编号的区间。</p><p>具体实现时我们只需要维护节点 <span class="math inline">\(x\)</span>子树内叶子节点编号的左端点 <span class="math inline">\(l_x\)</span>和右端点 <span class="math inline">\(r_x\)</span>。说明如果控制了 <spanclass="math inline">\(x\)</span>，能够让我们对 <spanclass="math inline">\([l_x,r_x]\)</span> 区间内的叶子修改一个值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;l[x]=n+<span class="hljs-number">1</span>, r[x]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 初值</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);l[x]=<span class="hljs-built_in">min</span>(l[x],l[y]), r[x]=<span class="hljs-built_in">max</span>(r[x],r[y]);        <span class="hljs-comment">// 维护最左和最右编号</span>&#125;<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">1</span>&amp;&amp;deg[x]==<span class="hljs-number">1</span>) l[x]=r[x]=++num; <span class="hljs-comment">// 叶子，赋值编号</span>e[++m]=(edge)&#123;l[x],r[x]+<span class="hljs-number">1</span>,w[x],x&#125;; <span class="hljs-comment">// 下面会提到这一步</span>&#125;</code></pre></div><p>做完了这一步，似乎离解决还很远。</p><p>不要忘了本题最开始的目标，无论权值是多少，都能把所有叶子节点的权值变为0。</p><p>这个该怎么入手？我们能做的只有区间加减法，怎么才能做到把权值都变为0？</p><p>如果我们从「终态」去想，就能发现本题的巧妙之处。</p><p>一个全 0 序列，它的差分序列也全为 0！</p><p>而差分操作是在左端点 <span class="math inline">\(l\)</span>修改上一个值，在右端点后一个位置 <spanclass="math inline">\(r+1\)</span> 修改一个值。感性理解，就像是把 <spanclass="math inline">\(l\)</span> 的值传递给了 <spanclass="math inline">\(r+1\)</span>，如果传递的这个值就是 <spanclass="math inline">\(l\)</span> 的权，那么 <spanclass="math inline">\(l\)</span> 处将变为0。这不就是一种无视具体权值，构造出 0 的办法吗？</p><p>更进一步的，从 <span class="math inline">\(r+1\)</span>再往后传，一直传达到 <span class="math inline">\(n+1\)</span>的时候，序列就变成了全 0！</p><p>差分序列全 0，原序列有两种情况。</p><ol type="1"><li>全 0。显然是正确的。</li><li>全相等。但是如果我们在区间修改的时候在把这个值去掉，那么最终也还是全0。</li></ol><p>呼之欲出了！</p><p>我们之前处理了每个点能控制的区间。能从 <spanclass="math inline">\(l_x\)</span> 修改一个值到 <spanclass="math inline">\(r_x+1\)</span>，不妨看作从 <spanclass="math inline">\(l_x\)</span> 向 <spanclass="math inline">\(r_x+1\)</span> 连了一条边，再建一个虚拟节点 <spanclass="math inline">\(n+1\)</span>。</p><p>这样，当且仅当这张图连通时，能够把序列变为全0。而当且仅当选择的边组成其最小生成树时，代价最小！</p><h3 id="part-2">part 2</h3><p>事情到这还没完。如果仔细看题面的话，就会发现他让输出的是最优解种可能的最小权值，可能的节点数以及可能的点。</p><p>转化一下，就是最优解的并集。</p><p>有不同最优解，当且仅当最小生成树不唯一，也就是有相同边权。</p><p>解决这个问题，我们只要再 Kruskal算法里，分别处理权值相同的边，相当于缩成一个“点”。具体看注释。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num+<span class="hljs-number">1</span>;++i) f[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> j=i;<span class="hljs-keyword">while</span>(j&lt;m&amp;&amp;e[i].z==e[j+<span class="hljs-number">1</span>].z) ++j;        <span class="hljs-comment">// 如果有权相等的边，那么这些边都可能在最小生成树里。为什么是可能？如果不连通的话就不在了</span>        <span class="hljs-comment">// 所以下面根据连通与否来分别统计，跑两遍是因为如果一边合并一边统计就会导致错误</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;++k) &#123;<span class="hljs-type">int</span> x=e[k].x, y=e[k].y;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123; ++t, v[e[k].id]=<span class="hljs-number">1</span>; &#125;&#125;        <span class="hljs-comment">// 统计可能在最优解中的点，这里的点指的原来的图中的点</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;++k) &#123;<span class="hljs-type">int</span> x=e[k].x, y=e[k].y;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123; f[x]=y, ans+=e[k].z; &#125;&#125;        <span class="hljs-comment">// 合并[i,j]这些点，正常统计边权</span>i=j;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %d\n&quot;</span>,ans,t);&#125;</code></pre></div><p>最后按照<code>v</code>数组输出就行了。</p><p>剩下的代码</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, num, m, t, w[N], l[N], r[N], deg[N], f[N];<span class="hljs-type">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>]; <span class="hljs-type">bool</span> v[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> x, y, z, id; &#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(edge a,edge b) &#123;<span class="hljs-keyword">return</span> a.z&lt;b.z;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> f[x]==x? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x), ++deg[x], ++deg[y];&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">kruskal</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(v[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>贪心</tag>
      
      <tag>生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#6</title>
    <link href="/2022/yume-6/"/>
    <url>/2022/yume-6/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d0b28fefe57b478579d1d492fd44c7864c847b549c143c085abae711999311db">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f39798b5bfeb56d81ac72d503a2be9dba93e6dfdd4f196ddea2997de9b8ac85a11bd1584e134ebb25aba04932d4cb74a668afd271733618ee48b4f481f988a26bf879403bc40413d224ca6a7ded3ae2d0eea564e719e49bdf1c2a52a12cc3d62e43b3e64105e0fae6e75a98c4f2503cfa20cb1027d0be9de1db4891ad6f40f342eeff06f4a0491983b0ae6b6abd39a2c58a2b1f41d75f6fe155279e1cd2db9031a8c8f8fabd60f853d93fa1531a8178c7f57724ed9522400426647d631508ff2ef72ed1eaeca901548f21854d0c6bc00f7995d7c8083e22d55d861e9452230cef18c946f4b4e207be4498a9ef4bb49f1cb5939a1e0c14abba28fd5003eef0fc579c88b6515f2b34849c805f935c2ced06c784ea5d8b0778c0b3dcab37b579a840f532b9600c62b6c68a7410e4cb83a2d681fa61d37870589f110e9c03ec9d38b9659739760758804b45b1e9c429c31040fe5616cc29a7c9004b76ac6d95527cef6592b16436f5659b190ff653a9751e5355f9aa6893481701c640beec2936276e49f41522b1e4cd810f886711eb5134eb47750db93df4716d8c5b5188395c8799c19616a47ba6867572e5ffa275afcf13e8a9276762d638ed5df22447485f890119cd13af93f2d0c74781b9c1dcbf8ea9abf7d17650183f260bc0e9ed4dcfdc1c5d5a22fab3dc212888f62980760b4fc43db428e44943092e6dd3c7784bb9eb2f89a4311c6f50b32d6071972cc1b3fc549069b9768e45efbe00419bc6086c6e4c1f4df734c4839b912f30085801f21ed93dc24cf519350a009ae9cc49b59c5cb91e35de8b630759ebc7fb233bc3f8ab0f9d6cfd261bd59830f2c83770d7ec866d20161128e80bc326a73e6fceb96f3e7566962b8d0d5e596965d8d87dbaaf47a025c4f5a37ff0622987193f3eeda7d3ce6f0a3dc103ebcd6abbe176e7b532e1e3eb74414157aee9485e69089f72792d8d2df9ccb98e7a09721f05dd9e405ae3d8703fce3a575054c993638544f1cb864ee13f686a811ae8e90fe150a7de88434210a9753e2ad6793792a615f72bfe7849664cdf35c9b3291c40a8596ed46be16889c118e9e6ef6f0f726121975e19e8816c656a0abd5d776b22bd04cedae09e024f92d43189a960856304d73fbb158471e08bed1b05e0ad2e43bef55b5918853508c0fede5ce1f179673d296a9e362f1db1a08ebb363f596fd52345adb774d5f9a1c4adbe75e7b35d8b8dfd0813436affe72f8731abd6ca86b02bb22c572244e5e6e88416fc45ff7399c285a159009f18bac1a67b59d4a3e2378909872261b113b9b952a7c531fdf20bfd45079769a8cbaf94bf0cfe5d8bac99e1eaa0a169b2054f5e68026290d4bc6ab0e084626c134a2cb9e1d26b4655bac3d6aa522620f8f72e092fa23d0e8ef1ef71d301b9f602ca765ae6d9ff481f0f2baa8df0de24f8650b10cc477f7e7b6a9de020c80a7b8409714c80230e97736f172da9094ee015b8263b4fb8169d745a2c0274bfeb61fb37d3b38fdea7c9dcb562b0cf03033d4739a860db29ce245a586e66c8b44eeafbe370f421f11855b9f0cacb7ad6f7631b5ef4e38d300779fa85cd0365cec44a85415a18b566e6e1b6b602fdb724925d72e98dfe3321c04a0b2385e41ab1da53ba45e5bc08c5ede4301f63222b010d7f0e61fe6069ef5c26d510cc59d74886cfa610b2c7c1ddddc75ec8bae5c0c52fb1762a6e91e5ff40690dbb35b960a4086a4d54d5ca70268b7d5aa877e3867f65cedbfa501ae838623eb8ea021e5f7bc08bc0c0eb65ea3a779098f9fb59cddef400ecba631bcf52037a5edb89df002b56085b04325d1682076a23a41a0a9f93855f7f0a2de01e9aa50cda656a828e088d7316a45288f0b73fb362a893a88f805b384630a3006029b4cccaab3c1c2d2234f703adef1aac75316032d51f962337ecce95034725488cc1e6dd29637cc58fffbbdbd25dc835206fbcba8b0d037d20518697cdbf1dba0e0ca8b72606019d7e8805bdd8ab7491348da86092cab422a6ecda0f5ea67a5c99d1e2e375760b82bf5bd0d5da39643330811c27379165646ea4b9598032499b5711fc18dce622040dd759b1f9613db6c6a6a061d1a8e85152fdf84c4fea508435b6bfd803ef2b3e21fcd157d042e2f455a8f185e86b5050786583f9b44479c94d696c0d5fc4953676a5be8cdcb104aa0a2c4b87d14258bb6850226f38e9fe0c4b2132377a45d47e17fd70699d7b64feb9edf36c353e688e3639fbe83622d4066ddb92c0c8fb104f99e205d1d32cfd3552ac1106a9237a593e87e4dab9a437661d0de4a25719b6a7ad90b4fd2799f5acf7b195eeb80ccdba77a1b65e3b4347eb5b667c612c405ea9ba4dc5c7e8e2ad86c0ba21ae9cd2df40a6565b697fc4eca4925023b6b9f2e3da7463f8c5a5eb82d25cd8f37c5fd87022aba1bcd345f0490bdaf7dd4582d0cf4ebe636db661ef19b815d020d83eb15f2d1f17be1043b5e7bb338ebbb7ba3031d48593d9f580e0bef08cc7c2d6aae78b8d9c53f630312aa63d178d50a0886703a65f60499574750e8028449150505f14bbea14f82c10afab37466987647835e8c5c1db86a05fa370461bf78f562723d4106e9f1af74415d8a644c3e38ee7747debad68242a1aca23d290e0be2bd55cfe5fcb58b7c0685783468a68bfbc4db7de2b241fcc18099992fabaacdd128a8d6831ffb514800e893d06ff9a7196235e8c4c8df9c1df97852aa26f5e458dda3cbd2770c4e0f8233dff6301607ec696b863b9b0e640a49be35211b7a54232b79ceec1bb2a702dbbaeb73099f92ba5a538cdcbe0c990277183ed351b5db36cd5bbeca46e73e59fbd15358f800873d3a462dfdc7b2a0c8a418cbed9fc0c5079fe1b3d2bd828c6264af38accf68013ab581f96738ca37950503904554ded4a3a697b39450f8fc1277b2620c3852579dcc0547521f4c92161486cfbba6ec331b7a6acafc02f4b11e72f8820ebde281238bbac80c422cf1b6c8297adb9bcb3062afa11bf83c1c4d8ee4a6795c12685bea9e567c65aa0aa26b4e65c8d78e16c7093caff824cf36d095cfb6a4bb62b63497145f6a51449656911ca3f3b56d55aab224e97d3d25c3c5cc17984d1b1173fc5dcf090194aaa22ec17312c4d72007fef8e0d191a83790b2aa3883ca480eaf6b9855c2fa3006aa0be3b0122721e7c13916c94fe2e05ae0df590472fd9697d6f36b23792a80f82c09d0a3e2de73c40113fdae424c65214e8c9b16e36189fb038eb1556062fff758bcca2a9a3ca50a4540b5ee852379b25b32b86f47932271928f6787d18a8c2251932387f3b246057008363b43892efdb3ee7c3ee904eddc294f9cff8065ca3078252930cf28b2f2936234ec3087bbbd2697d0ccdbd80e8be726c19c646a664b62492ac5854d116f7e18162deb968f137134ce27617a14f7835f8b35d38618879f330b49faef33e2f240e86349bfd7891743a7e5cfd0e179aab697ba1749349509862b6a9070c97ccca7a40bd304a8ebfdec47dd77fff72626a2dd9aa281130f004dd554315b8735dc72d667cc55986432d50fbfccee3101c30ccc53cf0138c38a94ba5c567e27f4341c1daf3108ea7de35ba49703b8ed1ce19bd62960c6634fcbf89cef63cbc1cea464d16f4c90415bc6a8e09c5e1ef7f220d03b49f1136e794c672498882a618cd289ef52b55cdb0a616da9bb5a3fb784bb3e673fe859680c68dfc1af74d272acd6ae67550912b238fbb796560e18fa116d1f3c33e0ffaca66ccdf9bd259e7abbe3178399d298e8a977a786a55e2aeedff87ee389e4afe4876e15cea1eddcb28907bb2a843bb0b7710bc6316a89c7816084acfb0963b7163cd65b00d87e44d84b5e9982b83517de21f4f6daa2f7a45147b2d1668d15e296d4cfe1bf555c7207c7fa20faf4658f6befd4fa766843171aa842f2c68b91e377d192843b2848f1fea965e230ab341aed10c17a22b7253aee893505bfe6fad8c5117d6ed930475c47e4d42bc17edde0300a4141f8d80bbd5cd2118fcaaf4a723216710e3d9277865c45b5f1f9a15adc9b24659e9ad6f9f37053fb837409d9a65bb5a3bdf162982e5b66ef9c9aea931cbf892060d748e0232fac6661e55c9264d72003125cd674a0e0614f7f821ca923cd5d5ff18db276faabb2bb4b0bdb9434bdc69f4402c643de92617093ac41108a69fa18ab84e86e34ab4d7fe1a1c125ac1e7bf1499c177ab591a80635d99d47784eb8d89363b1b15fd9633081603b5da29393cd0016c0a0a34463699193bcf019b60e68443bd7266b6a2b61324d9d6f7dddd697b560612a71c5a474d2e34129e8129edc6bf511de45100e6683f48393892cd632cf1c540f61ce25e550030ec58c38c9208500910f51abd9129f2de02cf5ee01c8f59dae7fd1a9a7d4321085c64f3aa84258e23a5b95ad0a3a937f157c95d28fac7a26849b2fae614e86010af1a278a6500d8d2396db1831499f8f73208eea19d52b417cf00d87f60d8dd396ea3f0c91cfee49e30e70e186e2b9032cd5d28a76deb98288aac2f04c9967deb8cc1796e44f7b26e5dcd2c90d5ed4eed3b4b10e912128d33b099088303981ad9a108d401527af008c2c29ab6656ae9e472b44e9f15192e9c18c2159250652bc66eb74901a2a891130f4645cd4d0926b4bc6f922fb5f851c0b0fd1c6c73c61c02883455c3c5e701c75c9ba3162ece5b501567fcdd74d068c7e63ec31fe0f86765b21a14e0f0cb5b206a106d3077a849deae223e0ee2d12bce9b1b1944aa8ac4718849aa7dfeb34c1c4a649a59be27a8ddb26786abfc53d8914d8980008534b13d7635686ddc39cf41971ff8974819832f9ee593987692c245b42716b7b65acea14f66ec0cd4f73140f26dc974dde5b7449bb9e8e4bf51928ad39116209a7a4eaf570d02798962823b317715b5fd5120c25ae040567af41ab896b9262db3d39fe16a7b24fbadf944c7e0d87237ccc2511cff7c6f7585888fac795a537102849eee5edeabc53cfcbd7c9fa647f3456ce5dbe4a0c0c8c43a99651f86230c7e5ef2bca5f2f515482961578e62a5b96620c0a74e3699fda69641b93ed5ffa52e3969a83a7bdeac8da98979cc78123ded1900b1c9d2e9b4500f118cf6d1c661726b10da0e77b25ad55d218e5ecf73b63f0714a74b682745a6cdb19f7d7c17f685c5e305f2f7e4ac0292a917c2ca594a139183879851edc5d3627a92dc68484d65a44d6d3597f84bca0a1f2d10b161be667ca8f25b7d99bcdb8141ac42b754477148c15e3c5fdbe00bc25ca34b5a634f8604d59fbd7b1a9f8515143263d55a72cb741ab2d4e7eff8eed16015638dc58725c2c4173d7798fca8129b3ef9afe7c669871db61157cc4ecb9501329036c78dee13334c85d3f7db9d8d1f96fc07f342d30c4927b3dc0f6cac37c8789c61fe28c4d331dcdbc8e2b0e7faffc3514befaa47e666b94aa35edf4aad86d38ed9d3b65c8a2b03cbff480c5e4c8fcfd15f797112b5fb8beb05dbb5a66429e5483e4c823c383d04cec95c3cf898f4ffe03c7a9430b50673f67ea6152950b8740fdea0eb3899d8ca7b63c3c418aac215872bad92b3776666e2a52e87fc33f355954a26cfdc5922f3c5f0a2b7acdedc16761568063e44cf5df81fe5e00745f0bbabf4c0f960117df5edcd7dcea70dbb4eb9b81a1428ca48d8b976b2591456eaf5848b6327d9cab54c8d39045c23c6a9dd4bf59d94eb08d49d41736f01434546525ceae02ce2c18ec649d1e8f977f7616289e2e63998bd7e67eea031a4465d1d76074a43dc80a1560f9b0bc7106ad419df3a72ff8ad700f5016f18cac1c1ac49bfec49a235c10f7379c5600b2e5e121f710c8d2af7a6a3a2c5162fa6f24f8902c2aa4834a1e50dd98cc4a8b2b3737e61e32e7121b48c7235750af9121ec99c263c9d0bc83861a34e670600b15d9db83b776ae0eb88b72224d4c4432eaf20d7c63afd5f39fc161e790bddf4c786fb96e5f3c61f15d5f72d8f8f46918e9379e99141df63dbf1ea914a1fad3c585754c7b3f2ca7f823372ead374ef51eed2ab1cd3985e9b54a5cef411f8e28838b471588cf3382e8b0a0a6c61eda8db7d7ac0f9644534139eb69917ddd492079463ceeadfff4c1cca9b229619015dee8f7a157549b733039b5a62e2d29a3c618a8f2a899ef6b603010d0e6071130656ab04b8da2a70070de47a282e5b9decbe5112622eba5c5e45930a66b210d8699c98aecedcf1315d2cd414342aaf14ecc9ec11052e32e03add86eda31876980097a8c4c91ce9f96f92ed11e71e66e1d58fd44dcb045ddd8e6ab33134c6198146bd2538046d783f419b55a5640a812628851a30115003404bac7232b97480b0ae668cb338a15852052fc3a2e3b40f30a8210e4481427384eebcb4344d05e25132971d5478ec0ab67c358d1f00c1c48cc37469e245d87df6f8d81a77413978f89b8baa28aa702f30d33ef15939602f1db245f02d1948a9558ca2bd9bcfcca5c14fe42ada4f4d1b1a6d794b1825d005e963961a3059fcbdd830b28814058225a144108252ae81a710b26d90f3e6124ed469caa9332220d83a4bfa15dbbbeefbc9d68bde8c123f08503b717eba03224c44f72a33e25f7872e001630d574e2b4b905efafe3c21087caade95ac691d1192e0719bc171fa516c2368cee51b5a9690f2fd9d506c730f92a5e23307fb38525b04f43fe72b521db260d1aa44fa238c41e105a35b6148bf203299897252c395d99f13c0c5a99f9cb68b64ee58d1b99bbf1f70edeafaed2153d21e5531f56b50a6d34bf4d4edd1d7562869f0e3470c79b7d94d15a9b290acce145048fd912d81c2fed4fdea378af41c6938fb894ed4db91c689fa5afa0c9daa04e06b84fde419de69d40d031fa8b3f5cb41ea9a122896b57e281625024155b531468d136e2d58bb4e8cb41dfe3c2d861a9f30f4ec13a3f9d0a85dbb6bf52e7113354fd0ba921752a228d3dc59dc13b9528e14bb58ecc1183f11e478f1ebb41f8eb5d80562a0d17e57a2ec1fe9685fc44272ce6fcecfda7651a06ad83089269c0de58d686c0fad866fe7a59573c6b22b4ef4a76da427cb558349aa48c5f46e79082f883a73fa7d6153f9a297ae571efedf60bbcd021b082343f354fad86fc5be9105ba04216f2ddba1e5495df01746cad2cc2d2e0ac32ac256603a166e8ac16cf0e185729f9f0ed446f93d953152d0c03c4af1e303b7cc6a0134486ebfb27e56e4ceb52df47b7ab96530372b6f19291e209611ed76e648d01a23814fd6a1d85b1f34cfeb381f81f642df43164790df53c748c608ecf5935f9dd67a1dad535fa5b14f6a1adf2508e5c371d6600cbcb8a5cd13b74858e5368c968f3b2e2f4eefc17f8ac5dfcd18d1e4ff4078bf4a5dc6084e2eff9d3e8c266bebc7bc62f895c310c319d52857ccfbe8eaf1627bddb43b2f8663236e0d27228b78f465c6af8364d7a6214614ff179bd6ba256934446bfdf7068c40b84ec26dc6218eb53a80e710081e168c4cc46baeef891ff38574e6b098a4ea812dacf713c0fd05731be964a14b3597b5944c634d3c5d794d670b784eb9baf2fde8a7a7e5a24315eff79e7df01ab095894cbeb507c0c77cb62df58404431b0011694ca51182e2ffdde60c6dbfd87f25d70d8309a6c17b37d12731a243566f518fb84d83a496dd20c1f0ac60c54ad3cd2721ab71000daf86d0b506539a51788b4dbd7bcf8d021ee77fdef1f5a2ed05d2f13ff59ab6b7f2eef56d1cdef70d2f7e56b82d63e19f444e5b40ae04632e5a8a78888743382c5a0acd2eab0f2f75dfe3354e44fdda9935a94401af793e73fe53139d505968a4524de7f2651f2eaabbf537f9149d91edd80fea2d6ec66938b001eae4e858eeddc635152d68fdb1eade3bf81769b4c186275a2b19ef874c8fbf0f4c9a82a36b81e99f8ef8bc019f1f4f18482ff775bf364417a476c55729eecf90c6158ae1a06f88148700be0af6dfee406eb57b443d138dbe514737bce972d1344c877da8fd89630ee54ad9c292a389b864ab8c126eeae4980f1562103a4de4ce6d2bf5d47a0692a288e852e412f43a8f1bcefabefd08cc9ae686743d7f9b920e214cd629ec7b936490cb28272d99a0c3bd51ac07d72a83db8463c776575dcf04805bff181785d6de6b4950a4ad8435f62e4002751c11383ca0d94062336ad96be454f2f9addfd2c7c9aea66b7eb636aef5abcaf49e65b11943e6cb9baaacd47491202fda3ba515eeeee827f1b7e383a0ccf6dba646066c5389e120f157faa16eb7da6518d81710e850e780a7723030cb73fe409ed2c9c0379c2e56737421f62e1f798b2f8da0fe9c3efe21f0fcd1d0a9e1c060109caef6bb7630c106c304aeb795d72dd0105bd29358a692a52a8364022dbb6f3c331c11f01cf58dd9e3a3b4065822e8839978b64bda5fb86512eb9f51b0fa99b81e147bb70f5bc4632ce59119fdee8b5a6c233e155370e8ee1a31a81f9d15c61a12f50eead95d62a81d4ce78bcfbdeb7f0f82652e2140a5fbc259837448a9f175b18c5a193691f76487f7540cf46cb4ebfcc1c4c897bea108b942fcc12f7a162254dd788ed0e255f6b49b2ba75b0ae1a503a11ed117e619e43c4b7b5a2c163a2e7100acf4f7f65bcb4a626f7efc1e8115fa5cf3091bd5bd40bc84c2ba6d604328af89418793641f86769614e631897585ec6e99b71c53ec65c0e0092dd7e6db8f61f6c828f703da6d3258db44f146bf2e50a792b7600b58bf571cf6b84e9e419d82a0c8e3e71a48981d38614897f3904f76babf6c32fcec96f457d02a80c205aac371a7a91dddd24d3627b0abac30aa67e3c1b217ba847e8d47ca85bf322f4feee0aec04c0ec0c64b69254216ad9d7514d7f20edd7ee1c28a5c2b8e63c7a4a41790213193abba9a1f039cf0de1e3a2c6eadf569bc39b1340ee4afddc0b238ed6d8fbc0b905959ad63366b7548ad8adfacbf1462dda62d979efcc7aee489c230bd8324afbf31a4dcf7205dc815cc41f549451dd4381057798638f61be9f6ffdbc113263d2df5a33092b7d52f186128a35e0fc0ee4e9d468e9cf16abaada7eaf567968c15a4c18ceaf8009e45bf39359865f4c43691a1479e2abeeaac110128f55ec6439bca5e046377b7db3e366894505fe69ac5bfb6b3ff54975fd0fb242af15ed576a36fd794a9c9aca24e02f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1854 花店橱窗布置 题解</title>
    <link href="/2022/lg1854-solution/"/>
    <url>/2022/lg1854-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>朴素的状态为 设 <span class="math inline">\(f_{i,j}\)</span> 为前<span class="math inline">\(i\)</span> 束花，放在前 <spanclass="math inline">\(j\)</span> 个花瓶的最大收益。</p><p>由题意得，如果把花的编号看作数值，它所在的花瓶编号为下标，那么是不允许逆序对的存在的。编号为<span class="math inline">\(i\)</span> 的花必须放在 <spanclass="math inline">\(i+1\)</span> 的左边。</p><p>也就是说，对于一个 <span class="math inline">\((i,j)\)</span>，前<span class="math inline">\(i-1\)</span> 束花只能在 <spanclass="math inline">\([1,j-1]\)</span>这个区间内放置，与后面怎么放无关，「无后效性」。于是我们只需要考虑第<span class="math inline">\(i\)</span> 束花要不要放在第 <spanclass="math inline">\(j\)</span> 个花瓶中。</p><p>所以转移的时候把放与不放两种决策比较一下就好了。 <spanclass="math display">\[f_{i,j} = \max{\{ f_{i-1,j-1}+c_{i,j},f_{i,j-1} \}}\]</span></p><p>具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> </span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> n, m, c[N][N], f[N][N], pre[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!x||!y) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(pre[x][y]) <span class="hljs-built_in">print</span>(x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,y);<span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(x,y<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0xcf</span>,<span class="hljs-built_in">sizeof</span>(f));    <span class="hljs-comment">// 初始化为-inf</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i][j]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 初值</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=m;++j) &#123;        <span class="hljs-comment">// j从i到m，减少一些无用状态</span><span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i][j]&gt;f[i][j<span class="hljs-number">-1</span>]) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i][j], pre[i][j]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 放置在j</span><span class="hljs-keyword">else</span> f[i][j]=f[i][j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 不放</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<span class="hljs-built_in">print</span>(n,m); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#5</title>
    <link href="/2022/yume-5/"/>
    <url>/2022/yume-5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7783f4e208c6d7300afb18979f1e0f86f50fd0130b0b7351450577909f53cc47">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f3d46f61253602057621acc2855161f5a7e9b6090bb51864b5cef61472fbd9d8b789914ca8edadedc2ad48101bb5db43729f7f7c8a2c578e40c04425fac0d574094f63c65c510a32c68d0d238351ec352be62d33ca3fb97b604df6b63c6fa63fceb867587730dc664feb85679c32727181d6f3176bb7a117672549ba079894c6af894e761b4a4df6c8d774254f118b9e8524cc7042c920ff9925c4587fdfc36429121fb8589a7a79c0c5e298fcbb71117642bfbce15ad42bff01ce6141fc738159ae36018181c6dc6a081763ad4d412d15672ff9e24aca72ed8c5778703ee999dbec734483a69f158234a12691f0ec4ec485df9c896eff1fd0515f01647874f7b6587d338fcf6276ea3342a2a51942b56bd051512ba1a5692d1f24a456a86c3ae29ba1e5bb23b16083628680327f0e755bd1e07f0d08043456147c34641e3bec7bcdbd8f5c644650c74deb5e4e274b4ebcc80aeb06c5464160efe41b3eb469af3df01c2e455bd49b6f4ea6f8325e0f723a985fbad9147c74587b4962f9fdc7a45fd7e94a3f462f0466e9a3e908f4fd497d167b305e9c90e4ba0025863f8035360f0b874ed63712f6ae33f450c1db147ee6efc974735ed0b887e07066b625df792919f2a5be0cd9b24f23d6acb71e1ebe94ccfa2ede879970bba12bd1b75929275aae90da61c35f1edbe3189b7dbe74d615ce10ce0a9c813f84fa7caf6a0d5a5db46a9cc2e440efc913d08d4eb62f866397dbd7713c1f661a195cb1a577652df42a1023562adfdfdbb29bb507304ba2c298b22a762ef2106a215d05a6e6b411b7f05268795996417e094316dd0791ba6e7c5eb0531b1917e01140c7e649a808b5ffc66cb59de66fb5aab4add17d13e84cc3911e3b3b2c3d569720c34b6cc3459d9e7eae6e9c9705893ae3cea94d29e595975b403c412419c03cb011d5dd10e6987e58956ed533bfa8968a2335e221cb886ab08641356e5262a38d04ce9c688fe9d74da1701063a98eb3bb467ce80d2a9b9c2ea343430d7394f531446f39a4c287f349edc54e0f8eb4dedd2bd48471e8575b30f906dedf1d7669be2390d4aa13c490ce0acb49ca0651718f73daa1af454a995def3ca18c05e2e2d8ac3a3ce7a86ae553cb4a3d7c077a75f79c0a50715e5087f9cca6205d9e9f38853093a122daadfee0063e9d4d03e24adfa26a860f7174a46735e55922595d8394fdba19ea40d05b119b558edcb86fb07275e0d8759daa080e6b485bddbd8c4ca77a160870960926e2e23034848daeed3c7c523042cc16c9ed7056be303219c9f2d449afbfcc85d77b3bad81dc136068fab1dfd47b4de56c73b018bffffc3e0d4d065dc9ad68c8c7d7efb7955cb325c86f4923643759901bd29bd9af6a0f403027199b6aa395371646824349474304d150d511f3bea5580e21bc95f9cae90b1174543bb0bea018d1a8cba59dff07033e799f1e64335ce4a9007e11108933ac312d19e3c4b0ea5daa856dd175055a629a8d76ea8894e6b81cd338d78da9f8d831cf525e231e63c572299072a59f39dde247a9559ba13eceff18037491fe32c9398ad0e8b17c32c5e05e7b39d1c98353da5854ac6d73cace8ae5d16b8a4dab8d0d4fad046e373014cbe837f154237b271355dd90983a7e54752b9c9d8f53275658e7b451cbbf1a1d381066badc2101589e6199463bf74820058063ab5518b19849c1586dae9726e95d53e572dfc78fb48d44b451eb794419e5a1901fa528120df931f9279ac7cd93391641c9fedcfd172203059f381f9ad5d8691633571f5fdc8df9e78421fbe53d58637b487d3890b6ccd27f8e8d8884d9943a73c44b75e1821f4cb80b8a9d690e1f781b594eb4c9f360dbb101548d0e8497bd23a481ab8bcdf30ab76d65550a4c6d358ae9a74a99f7bf93c465e47a2a813ff897c7d83a5612474012427e925cffa7c5a907f6a50bbf824781a1c9e43f96e52d9fe13ebe9474babfd327c7ea3a0be62d0fa1dabe83a75bd60b88552e1e090fb037b3321665c5f8c7229f2db820e7d392c805bdbeae989dd0803d1baa50e16a4fc3ede8e4f76d0a58b3ea11869a94f578cb6d91885e026e1be3480f2edc68ba882579210ecc63ceb81e2d53ed2cc9c5006c29a6de2983f9c7c80fca27827a95ed36343d25359af344c3783d91b346c6e28065254be61b1d41b0b0db3aa53b5b3f5120835fef987599a03ab463b3db77c904d4b746fb420d2088af03497329b53fd7212390c72173c93e9c89a53638f7da78d0d551f0ad44150b94df806e8bd7255c3e518360de701ba3e680f1bcb80de292a9a381a32c9061737c3a8e7135a10c330beeafdcd9d7566b6b102230b877c45f62ac986842710d67378811b1832848dfac5e0580ee1b2eae8dbe33cfd22ddd96ec51984872b99e241f52e4dccadcf18135ea44fa1a73fd280dc7a200535f318e63dfc751b97c2d12f99fd77884d949d5e9e2db91c9252120fb7d00140447f979fb1f6c074f9b3daeb41b5a946a9a863ec392cdafee89fc907edba090eafc2b873d2829ec04be006f749f2a212058cb9debf3bff66876a45afa3cef8cbcf55ea3872ec222fe6f82508b89760d7e0517deb93dd8f3be070dd1be8f80ef455801acb576f08b528c30e36b78dc37ff8180d874886cfde3a0d8c37d09bc00d897fd9d8de7d96adcd5b4361b4b8fde07965d58bbc20dda01d472f56023a1b0bfaddaea05f15dc492b02f7e0a24d394dc62d4176aad5ee9e3c609958a0b673633b5c8746916e5097ef243ab6d98a643c45cbadbd34a148827cbd368e6672fe5b38407d182c291b02c06a80027e4fcb24bc18644042fd7b2fd61e2bf6d1d51c612fef8a2d74d41ab2367d9ba14cc73e5626a105b8bab1ef9e55f86c2d4915db5fbb0dd9ecb95adbcf38adfe78c2cd58bbaf4ac933d5dce8e28400f6caaacb08b778196cd7689e7b2f7c4c0c554da441536ed24af98871d9ebf02d3e0ae6e7c0129dc82029a82120fefc68f237e3bd02eba23fbe2df0b6b6aa1031c9b96fa0f218a4029ff008b1752f1690971e108864d33855c753ccb94c333b4cbba71f7434b27ceebfa96374cc511c8f86ba1223ca314d0939d5a2718aa54e3c3100398b5bf05953e6eacb81178be18326a56139b20adafe174f7c25332441cf29588aedd8d65b3e662a7d69db8633b5602b66d59fdb46a60a9e071d4c0e76f5697a5e5a1f402f42821ec9d8f705eb853ad2ddaf7bf18d475c04c1b05f20c9b9fcb5cad6029d0f7ca87951d4325530a90aa24ea557ae57b0047e5c317e4f6283bc6f42575ea73f099257a1d64c2b6300914b3b24624caadd44fe3b4ba80fd78e04cd2bdc2c521ca6ff112d8cab76033788cffe7e50b3522dd0baf0fd6333bc6d4eea6b2800c57f50f593b3d976817ba14f932f18e3ba7f383f4f97264bd773e833305f91fcfd3c7ab66fac8c2e9fe457b09972e53106fc0f4ac3890677453e3f5725ed8c0710ea023b00b9119f920e4332661214f8bdc4bb70163051e0edf05081ec80193d224e2771060ffa8957b0da9d9a4629c12cbc4cedd5007a3bca7757f6c6984f8b3ea517288eebac6d0d970494b16a236004635dc1e8ba17189cc5fbce6ce24d6488600d23f1c1507e128375f46c5d8f2eba7b26eaac9f07134bc9d187751d6ccbe41e3553e10721a215a1cc3c4eba60d12735080ce7d9b98ba6b51f0e90c8d7d3bbe5216f98d01581d1bfa6bc42c0b42152103d4250bd4d11913320dfdd87e28f06109ef66797e933d0c392d8a73bf07a087d65f2bca62785b687cec262d0fbd3b3b5d6a0027af3f63582701d68fb875500bb71b3bf2346a69e664e202e77b0501a3e6bb465a7fad0b4c0b813dfe15e266bf910d93aad2e064bfb38c4e61424234fcda067cff9e62de2412bcb8c7091fd2dc3241d8259b9451fcbf0d1d8285326313fd3e12bfebf7d3cd5fd3b7b01a56869a65df79562b53cffe17852e04276e3914b269a88e2cb9e794185ac6fdf0561471d22580fbcfccede8ad1eebbac42436cbe84a079dbfa0281293d7794ceda096d421dd44060463af76569dc3df5891d9e3c268ac6094000b9ac07b54abe74be0d1a704908cc548c8d42cf4b9f5fe6e428647eb90eb67c06127b09f83fab08e089a803438984fcdd8c49811c20c09a9a5cca579e0fc38ffc12e6616c8a19e2cdecbb4b180661b0027361a0e9f7e57186d150787d402d10015eb6db5ba0dea3e1d633a03573e87e693a001fff036b9c2cb731d480c16ae4d6260c45f375b80085147f789cc635564e45d53947504074a25f924968a68acc461ab7501cab436804d6a08a35ca39808746237d621355fd51601b983d6e873249ae76b11443395f3c310d6e4b02005d1088141b1d6c10436bfba6a0552ee63dcf238e8f563d8177dfee05b51c325d21b30f24f133021586bad65c04f6d79804f78fb4c82c75c10fd2737d7135cd317736bcd17b9f448db392afd9d2eacb9969dd8a2ba96a346484acdbb6d0ca7cf4390370a0709ddf61d3d5c9b281e3a4136d6f269b15b84d85ea67555ddae1d0844e3ddf8a6fa4d46d1ee1e4611562acd537403bea1a470f53f7573334cf11ddf37cb74ad119a1c2dd5d699d023984e6683be02bda651145de2c5d220a4ffaedf19efadc9d8e8b050a69c4f70ebfca6992111da141bb54a0bf863311b40c66fea25e9a39799812012db815a5cb09ee518db7368cb6cf500b9c1b05689fbdca5e0803c7db9d801ad1b792b25816824fe2d407f5a57505c399a3485bdd7085b264698b45c6549599b6f13dace78ea850ad632a43d97c8b6005b280229cf1ac3d3badfe6b84fda23304e8c19ecdd880df4902667d22821f0af92c8d00133575a71750d27b4677cddb4b9a297c2d45c29f500d45653558b2a76f11143e5fcf9589a573ddf1fe57a5d87d0f197e666c2b379154d636702f017d5f93c5d4c129d0b5d9e1de391671e9e547881e3c1a7033c89ce49f27cc2c2d10dd0d13d9b440d8565180f5407d4b0dfe1c5c0a727005a76ea8e1cb05be7b1016365cb2a088effe892008e63261ecadd9528dacf7f40e7277689b99f480bc48ee185d1d0f55db743b1e5a9759935ba625014c2156e37ffa2f9cb791b1b15efec1a35764b044bb7cc3c4996af3b464de58d68023141b1b2d2234084adbd0ac69d5a9def4d211c0860d655744d7a2a29b9165206a9450d5d41ced1c1c8ba76a4182f670d8a0ad9e5cfed8ace0d13e1f8b4f789660377a66145050b492eac74536730919c50a23a3ec231d31d3cea452d9d5aeca6e1e12f666ab0a6ca903636ed3a3fa5b1c213b35b34f06aa57362ec09661f1c3b98631639aa478122cb70efcb57ce646c80a25aec42925662d23b3b1cf5bc0febe504514e53894d6f5fa07d5de05dc9c72911496f8497efcf3462c2d5c470ed0c5e4e0b7a6a608b21d0380e778d8e6b632fdda1ca2ad1bb1e176f8275745938b92edffb4ffb85ba042fc462803bc1a74903f605fb320bf39a4d0c04289e917a87f189cf8fb2941697e8d308047aca4564b0bdf1437f4d8bab6eaf182997e68105e07786f78cf24a14d4838864a69698b1d0384ace28033129e9943e11fe3db2760bda9554696c8315755bbb64c996c0041273b344ccb5e964f91b6bd4e05f3e955e95b3629a0a639057d08571861772517940ee2f14057cf87b593a64dba42a64530f098bc6c2626df83f478aa021e34ed0c4491a3b9595b5f3cbfc251e19e87ce90eedb46a7f7a3bf81a715c1710f975fda2be092e72c38f8ccea8626ea6b7e4cd445ffce403b866bc685da447fca652dae99300bfd2c4107d7f50fe43bbd2c96d8a44fcf76399bc31e71f738235cb5fde60c1edef0b6d9e7b732a6229158c346357ddeb436e57c24b73cb53bc78921de3630eac62fd6d21532aedcdd946bcf503e5ad1ad0d45dde8980a5c5c1d5eb8a8bf7a757ee486d062e3681811f7fef3dd4764fed48fb3a653760e17b87510a89c377f40c1a84484d5931a0e9446db4044624a4060ef6dcddd073322ddd542f4a920bf51fb41c5c0b69f175f073f59ed228b587a8de183af4aec8abe6c0a6f30b5d722c46aa0233ef0dc54964d889dd4b889e70a76ef3d9913af56c39f1bb734c3211f463bd70f86ca5d19327a066175eee465fab8f3788f29508989d9e72f32252463ed40f74d7324454933809d9b2d1226fd9c90e3b1a911e764b9e6dc880fbe1dcb8bdb33db6ac9b0ce37d32e616bfbfbc753e6856abc10292265a5e46948f3d2f5a7e3652c19dae200eacaf262a034871da3546fe997f3b6005c7af620c3b32c00958573df6de0196da7d799f2890db8abb30d732bacc98afe2cb96019ceb258f640c1288d34aab029e0507e6cae3360647aeefe820e3b980fd0882f70cbea3cbe25ae5f941d3c5da3303056243dd7fd3fb781c2e489be7cf4e599c6f13b0d87050a4ea11d3f1b09029cb54a3dda6e81494932ba690993ea339765177a2e3d5391d8c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF449B Jzzhu and Cities 题解</title>
    <link href="/2022/cf449b-solution/"/>
    <url>/2022/cf449b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(d(x)\)</span> 为 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 的最短路径长度，<spanclass="math inline">\(cnt(x)\)</span> 为最短路条数。</p><p>不难发现，对于一条特殊边 <span class="math inline">\((1 \rightarrowx)\)</span>，边权为 <spanclass="math inline">\(w\)</span>，它能被删除，当且仅当满足以下条件之一。</p><ul><li><span class="math inline">\(w &gt; d(x)\)</span></li><li><span class="math inline">\(w= d(x)\)</span> 并且 <spanclass="math inline">\(cnt(x) &gt; 1\)</span></li></ul><p>所以直接在图上跑 Dijkstra，求出最短路及其数量，最后判断就好了。</p><p>没啥难度，但是好像会卡掉常规 SPFA。</p><p>顺带一提样例 2 里面，2 个点 5 条边，稠密图警告。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;ll,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, k, ans, u[N], v[N], cnt[N];ll d[N];<span class="hljs-type">int</span> c, h[N], ver[M*<span class="hljs-number">4</span>], nxt[M*<span class="hljs-number">4</span>], w[M*<span class="hljs-number">4</span>];<span class="hljs-type">bool</span> vis[N];priority_queue&lt;PII &gt; q;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123;ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(vis[x]) <span class="hljs-keyword">continue</span>;vis[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, cnt[y]=<span class="hljs-number">1</span>;                <span class="hljs-comment">// 此时长度为d[x]+z的到达y的最短路只有1条</span>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[y]==d[x]+z) ++cnt[y]; <span class="hljs-comment">// 长度相等，另一条最短路。</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u[i],&amp;v[i]);<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,u[i],v[i]), <span class="hljs-built_in">add</span>(u[i],<span class="hljs-number">1</span>,v[i]);&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-keyword">if</span>(d[u[i]]&lt;v[i]) ++ans; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u[i]]==v[i]&amp;&amp;cnt[u[i]]&gt;<span class="hljs-number">1</span>) ++ans, --cnt[u[i]];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#4</title>
    <link href="/2022/yume-4/"/>
    <url>/2022/yume-4/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4e83e126f4cfed860b2326d54bc9b52ccc4a7151ec23024cb9dfd5cb0cbdabdb">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f3d46f61253602057621acc2855161f5a7e9b6090bb51864b5cef61472fbd9d8b7038a868c7b10328842899ce01fc7f75112ce19352a333b270650083800ec3b1de5cf23c4a9b383335fc61cd759d3923c63604a2f68ee5a90ba444b14df57a5e1b4b44218ca14d96d71965ef091c599cc1908399f0872e2c0955196716318bac93d012e7e7870a48962b255bbe275ed1fc4380c59e24959ce755a38e2e2095bd490276e048d62eacd86c1461e654235ad408eb50a48c04cba9f37155d77199a8a274caa9fdabe5c58c8adeda29d81bee678b7e0fd6cbb590118c1271cba44c0efad89c5d52a6f4a7004a6a08f0c1d117b0f2b3814650e8a8c38697af43753104412bd46f1547de2a43b3620cb7f515accf5fc7f818d51551034b4699c482b2ad8932120495ff1064d716d6c83c38b35f5dc693e3994e9415e70014685a09b91b5fa9edc5696ae8c3cdebff6104880a678cbe29b19e74749afb20d55a2ce26612eb3124f53c839e87113e5397008dc53068eb0d07b3cdd7fa78ba4da85fae1ca4f4e2bf88ff34747dda51cf7b7bf930cc0cf117f088f0b4d74e235bb1695432ab4ce2be34ba5473c9fc785c89568f9eddc49592a32efefc6bf19e8f89bbec7c8f60a0ce655ed45b8d8d624a8736d2ed522ea312e8d17d54b4f75670ed420904787779c88fd24dee3152e1cf9e27021fdfd21152e93eed5c73f6a2627111f850da661bb50f7e9ef9c363e0a218466123f8688d3f24975c4070288e3dd5d2b74b95875628ace70299cf1e3b903182dd2c98f2ce5e4b3f61bdc15c9a92f6fdf9a839fac581fa0a451c8af37f04f56d1c4de3eee999cccd23b7d9bf70869a07ad82aa6361cf5199322175a32cd16c72f41f42d3233c0c1f4effa28fa57d26e21f17af3c9edcc07d44ad7960e8d8dd46fafc6ee59b352b4cc2dbd5672daa120b332310e94cc2a5aaffad87a1e8d2ec8812c5ff398e360264245bc054441923749a8703753bd86a8d55ee1067eadcfb48fccc6ce0f17878234188a1d4c598b05c43c92d42b9823a9e5850e00796c951483d99d520e5f27408ec166175bfe9e5f88e66080f453cd611c7d2b8461be129155fd6fdb0920d3820470ffd5fb9d1ebb3670cc92b2852d74db48b1b06a08fea0d20a90d55f9f496e39fa3b68e8962b79edd480357c8d4afceae04ec699cecf87ba635f2c30a3feefc861ec43396232f65875c7be30c79c540dabbea5a957c3c2478e22d32c5cc317671b7d810f9d7ab5ef9fc5342a2bc0ed3563c91719ce4274795921e82800531de7f6f21f97104833f0d246b4962909033b821a3df1c8e380f261115df0eb1ed3f81f392535f81cd608cb8d6496f3d82c9cacb26d7ee1e3c7c3dc9f5fc017d3cfc18bc019a4e32688ec8e45e20a6552c0f3647ec7e6d312b8caac2cb73398d3110fe3148e81eb82675ca44627266d5b8af43cc7fa1628c12ef664fb0d05a2caa2bc9df7df4e95b30da539e9ac0693a82749bfbf2a0180289de9497eeb8650bc8b745fa3f0d16dfed81469d68d48c1f074862be82c5b205da2a226f5e8c8188e73622234958103a517d3e9a1f44f19afea7e9dceb340c84b675038f64b7ca92c68e10c76bff99ff53a7f1bbea29dec1897f06875e3573dd5e3f5177ff7b7d4de11feb2e53185cd712c6437fa10ab6f6c322ca6bee92f3fbe6f3d10aed19edf5a5850157d21cf14052c7a0df23483f52a68fa8ef403e09bd794290504f609bd9811ff5312282973a47df82feae32b8f2ea1daa734487b5a6beb37f6337eb17db55574d5cb4d91450ff79e4539022b4ef5136b6e65cd200439642eb03a211fdf6a19a3103f01c9a50a8d449ef7d5643a212ec249899ce68fc2dafab9b5b4ae73cbce5bde69532f2ed80246b1b39d6b360ec47184837c9fb8c459adcbc96340666ecc9c2a260af849e5f4ebd256cdebbfcf77b3754b60d7e1aaed2b50be82fdc9ec17f188a0b31c1523784386412ad79426256be656cb83c44902ba545d105a76ea54bb7d13e2165212f1e321392f54d9040a80d97fae3141cf535e39323484297968ed81410a519176f0c5996e7d7174121a6d744e72f48c73c74ab02bc14e913888a1e74a5f12784a5ed0836b9ce6f3aadfd087f42d5c68e988ecedc38720a8ad3abdf386048c845d916de7206a1ed4cfd4e425daec3bf19f699d2239a059d7efa3a1a5d2df1c366fa39db3b6e28db38f17e24391131d7c80ccc8be131573010e7f6fabc57ffbecfa0df7aa6b385c57ace7c5aa9173828d968d77791e0075b6d14570882d339f125acda0adbe633c7346bad40e43f8163a6e9d1ebe2c750d33ec367e8d3abf283e58632887e15dabf99f5f1e586f1eec8b9210fa12fe64dc727eae91038cd3fd34a0f38f7f5987400c52fad2c3acb7170ee0f85b1a715e135a70e8134eda5fe835940cbcccf859d8947ae42ca196be34968c7857dc930735cc2ae4697c75757cd195d49e359e09996575b8dee3e45c705d897d754aa8b85362b40940e8b27e871f33c2f79a1569184d8d37e0d2c190ee57e7f672fc654c90ddde9d91faccad3897665d97c07794b7eaed2c159ab60ff3cd3e2e42194488c58e95b01790e0eb2ba48a297ece4bd281ddc4b662c876180d226be570f56ce3a9a21ca925ce49773e218693ab9fdf833653249bec05b7bb5ebf7e288dff8b8342ccad7de84d5406b04b3e3a7951381df75a2f9bce5d8e072eb91bba2b39ca93a0f72e241526c4b652522e943e94eb5745366e4be70896493f5714552c5290394b030ad2d422ce5683c13eabecdc724e0d92d168654d5af88693017e47351bd4cfb3ccdf63edb529a6486fbadd63c4afd18eb8261406ab764635d19f6f66c0fd294fc1655bb89fe66c95ae8522cebca57012b46f7f1ff1c0a05131c388bf14e8c1ae52bd80cad55382a4101359ef82c7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3648 序列分割 题解</title>
    <link href="/2022/lg3648-solution/"/>
    <url>/2022/lg3648-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>根据小学学的乘法分配律，并且手算一下，能够发现，如果要把整个序列分成若干段，那么不同的分割顺序不会对最终得分产生影响。</p><p>比如样例的方法是<code>1 3 5</code>，如果我们按照<code>5 3 1</code>来分，答案也是一样的。</p><p>然后划分方法就没有后效性了，我们可以定义一个固定的划分顺序。按照习惯都是从左往右去分。</p><p>设 <span class="math inline">\(f_{i,k+1}\)</span> 为前 <spanclass="math inline">\(i\)</span> 个数字，划分成 <spanclass="math inline">\(k+1\)</span>段的最大得分。状态看起来是没有错的，但是怎么去转移呢？如果像样例一样做的话，不还要记录某一块区间的长度吗？看数据范围，如果加一维的话肯定是不行的。</p><p>不知道是因为我太弱还是太长时间不做 OI题了，我竟然连这么简单的问题都考虑很久……</p><p>后来想到，大可不必像样例一样分。</p><p>对于一个 <span class="math inline">\(f_{i,k+1}\)</span>，找到一个<span class="math inline">\(j\)</span>，满足 <spanclass="math inline">\(j &lt; i\)</span>，把从 <spanclass="math inline">\(j\)</span>分割开看作第一次划分，这样就能准确地计算对答案的贡献，也不用关心区间。再者，规定之后只能在<span class="math inline">\([1,j]\)</span>这个区间里划分。而这一部分就是 <spanclass="math inline">\(f_{j,k}\)</span>。这样就不需要记录划分的那个区间的长度了。</p><p>所以转移为 <span class="math display">\[f_{i,k+1} = \min _ {j \in [1,i)}{\{ f_{j,k} + s_j \cdot (s_i-s_j) \}}\]</span>其中右边那一项就是把这一次划分看作第一次划分产生的贡献，剩下的就由之前的状态转移过来。相当于把划分顺序颠倒了，而事实上根据开头的讨论，这是正确的。</p><p>复杂度 <span class="math inline">\(O(n^2k)\)</span>，显然不够。</p><p>然后就是斜率优化的套路了。</p><p>对于一个决策 <span class="math inline">\(j&#39;\)</span> 优于 <spanclass="math inline">\(j\)</span>，则有 <span class="math display">\[f_{j&#39;,k} + s_{j&#39;} \cdot (s_i-s_{j&#39;}) &lt; f_{j,k} + s_j\cdot (s_i-s_j)\]</span></p><p><span class="math display">\[f_{j&#39;,k} + s_is_{j&#39;} -s^2_{j&#39;} &lt; f_{j,k} + s_is_j - s_j^2\]</span></p><p><span class="math display">\[f_{j&#39;,k} - f_{j,k} + s_j^2 -s^2_{j&#39;} &lt; s_is_j - s_is_{j&#39;}\]</span></p><p><span class="math display">\[\frac{f_{j&#39;,k} - f_{j,k} + s_j^2 -s^2_{j&#39;}}{s_j - s_{j&#39;}}&lt; s_i\]</span></p><p>套路地去维护下凸包就好了。</p><p>内存不太足，滚动数组优化。开 long long。</p><p>复杂度 <span class="math inline">\(O(nk)\)</span>。</p><h2 id="code">code</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, K=<span class="hljs-number">205</span>;<span class="hljs-type">int</span> n, k_, p, l, r, a[N], q[N], ans[K][N];ll s[N], f[<span class="hljs-number">2</span>][N];<span class="hljs-function">ll <span class="hljs-title">squ</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x; &#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">return</span> s[j]!=s[k]? <span class="hljs-number">1.0</span>*(f[p^<span class="hljs-number">1</span>][k]-f[p^<span class="hljs-number">1</span>][j]-<span class="hljs-built_in">squ</span>(s[k])+<span class="hljs-built_in">squ</span>(s[j]))/(s[j]-s[k]):<span class="hljs-number">-1e18</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">solve</span>(ans[k<span class="hljs-number">-1</span>][x],k<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k_);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=k_;++k,p^=<span class="hljs-number">1</span>) &#123;q[l=r=<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[l],q[l+<span class="hljs-number">1</span>])&lt;s[i]) ++l;f[p][i]=f[p^<span class="hljs-number">1</span>][q[l]]+s[q[l]]*(s[i]-s[q[l]]);ans[k][i]=q[l];<span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[r],i)&lt;<span class="hljs-built_in">calc</span>(q[r<span class="hljs-number">-1</span>],q[r])) --r;q[++r]=i;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[p^<span class="hljs-number">1</span>][n]);<span class="hljs-built_in">solve</span>(ans[k_][n],k_);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>斜率优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#3</title>
    <link href="/2022/yume-3/"/>
    <url>/2022/yume-3/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="73bbf6e4e9a6dde095ddf1a7f9940110309b7d7b7c0f986b1e94b39e8da1f652">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f38f40df0655c87dd6934a44f0162b0892e7c49ba13b0a8075a8fb1c649442207cfc8e825650084262afe406bff139e60bdb798ab014a4cdd766893a9a8fffb5b5e9e39d82e5dbd274ee5ea76c2a82f6a5f18ca1e47a0ed70ec346099dbe6df0d6003224db6f37e7dadce99551bb6142d2a6bbae7cedd415ef8cff8ac99b7dbfaa90629aa5ae4cca3a503c82c7813fa3120161b209a488d2c61c567c14be0b9a049bfb355c0625f267c2bbd83b2f1bdbfabb1cd7c1bb376e9bc9679e4cf6500fff4842a2455bd7d11b78100a416ef7b9c5985989d8f59a7d4135ad72b6fbb546447d7e7db608e268f3be57a4ff3704a856e0741bc4fe7b1b6553be232b1ff7049de0794d5050ad53b342c4acc53f47ea0ea0f97bd1f1d67a737954ecb2ccee5d037a1bc112a3d1b02051f961e2f26a5a8a9271603b8353ea5cd0f12608b0397bee1e48c03caf54e13ca2f2bcd4b1c0df457f9717f71e73fb3c56d435d46d77702e5348c13b96c3d7f21209d49b8cb4082af9da3eccb438bcae9e2a6d7a20a2cbc39ad1ca5fd99cf0bb8c4cade5bbe49db7a0a44b522e3ba82437d087a6f48789b7786c7ce07addcfc95398cfdd6940be4901ee368338dad2b488cfb745802cca28f3dca8b88dcb120afb2d59d3d1e4b75baeba0df3840a984960bd8bcf358a20ae9511a8f2028839339704e116222a5ea1bea9e7fd09c509c837adad73b31c61ae0071259e0a3b19f5fc6e377e8af788bbf5d642438df344f670a9988ab042e9fd57e7755e43f655b24993907814f46dca2000255d51eb19841d98e17d0b99d43afa85dcd1397c48ac31cb51287277a0932b364f8761c3899e6fe83e34e09aea67ae539043c44e72aad1a0e83b99a02e7f1e1f2c97b6d40a9de716bbb3f26637a01486a888957b4971b4d44425944db0bba4e21c77292dc70af8d418f702d885776dcc5552caf0f624c41b8628adf0c11c833008bc752a448b193b23c9cd81949d081be08f2f7ce2cf23d26e13ef30d14ac49fa1c3cbf95c2092ae93d7bfa72943364b573fc16398636fe5cb6457b8a6b06f686e64aa4e9744a34d03b45673caa5193ea328d9b03841cffb29363da19a5e94f5fe0d79ac8fd509f7da880323cd987a1dc53eff02827478e4cacdf61e917dc6597b54895c1c563ef6cf6821fa76e08eb8d068363db259dcb60265f20336784e9b57af0c07bf147b42b101d0da4b6fed05c35462b821a0fc2235181ecf5b113bde91b42c0e864c0d131a01c18e445b3481372a2a1b87c7233e4fa14b17e24140c953dddff4b494fb61b99bf47231f8ee68e7b76c604732b87278ad949d0c8fb4dba7239b3c3761d7defe15588a43215a06fa2154783337f3726aae5ed6b484d7893da0c77ba5c4f5ce0b1f937d1fb207a98b2a612ce21cc4865edabdad62a4a86ddc5ca01d7fa4005cf649482a0ccb0b245a159c10323684b5219b106b0d1ac72c0f6827433d506dcf50ff4752086c3c4e2e4427f790b833dd1a9f316df75efef2b870fadbe7879c402d3eebef047b0298f6670fa091595a33530adc005359410b3da55e7a3f1ba0725c7131e49e7cdac1bcf67aaaba14aeaad776ebdf97a61145dc0f5c8360d1f6de8f9aa9e40e75057e18f7abcec1f9b4014b61b1533df0ed0a93db9dcfe60e3c0a2c0ec6169f5a2889e6b96135d0367d03d358c0b83d747e2549a4e64eafb97a8928cb96b684b5415a80ef350862980e82af6353e8fc972751420bbc7bf487be197499f228f43feb5c9799c81fe0c2cab93856483d570f6fb0402955d30011966000fe7a065bc17cd7abaaf8ca93977bad1a79d28e6ee11379cc63b157463b7802e58507d9e520e1816c9b4224fd31d640ed5119d66f6d5a13993c55fc22737ae0981e7080972306cf023a568cf20c97eb903f9bfb79096fb437225fb2d5318b34077fef31811882b969caab7ad3522e579131f57514c95b55fb7c0ee37f0941be5e8281560b503530069a01b6dbb9a6761e7ec28ea657305a611aee9c137587362c2a3d1722b4b138e6a89079e2575d3379e06434abb09209668f103f39b49a4cbc31089d6b4c7f301a1892f74a80336f9566db128c649a2bfbb1bf803ed4532c6f1f64f62283da28df2fd1e7b912479dbb8971f7e651b95103b06e0578ca29b127a5e2dd83007340ffe7d5d0dffdc5cd1de2d796768e703b70739e35417b0886ee335ea1e3ea136274f5c0a27cc0071ea4136dfc77cd5761985b324c68d77e04a83508cbc76529319d5fe1b3152c38f1882733b6832bc146e8d9ccfc2145f81494d17accaddbe27fd4cf3e9051c07e6312dba7e21149d1aab4dc09d5f500c0faf95bc5925c0b46f9d27edb3fecbb98172e948afee782eb41bdbd12fd931d544c542f5c5984da58ed1edb780748a28424d06324393181851311e823d8ed02fa555b56d9d6c59c42f303bff1f1320435d54fd8d81cbf37b995f1df08951b91e9df7908f1631ba7f977fad44edf3da70ef3585fc1dd5d755accef27ef86e831e1f1267fac7847ac2175fb64d46c1897892cac8efa599fec82043d7dda067d708dcb6c7d01d72c684544052a3986477260e2521b8b507507d386e3c25ff7445ec66977dd77f396efe4113ac94fcae56979637fa147d0e7a9d24f3f733a01784dbd0319688b103ab3bc7003304e72b0c13373960394704128e199aea158909fa389d52f83ef2124bb5b78ebdeaea5e0ea564aeb4d8736f3c5d52cb9533043bc7a7cfe25e73dc2e26a4a38686bb015813570664329cb297fea6cea4d4cefcef5a468ab04aa84d1f7859de5e93222adf11bf7690a99d20c1e7ea2b12ea9fcdcc679682f184b08a36a01dcfcc51a2b1d1cf342531ef642417e5089f402d5802de0a7f60cff0324fb6deea05ec654c3655cf793723bb3921979834781f51bd8fd43a02dc4ab590cdb616b43c1ba70cf4be82bd6b43794f9c6510d480ca2be31268321ede9ce5dc1a3eb206e6c169f3c9af5e1778b7888f55b4f7b5c3d5c5ca044171e032b8a4aa6b98c421b804c12300629802797958a780a2e0a21fb620ba4a0560d2a92bca9e8b9c32841f3dc8cf0c50f35f7af71ce468b5013294f098ff217ad5e0c03d307729cfdf63a8c488a6ceaeaf70e3f630d9a15aeeb21bdbbaf38a440a5043251f0186db4b6c883113ca5f31b0a9d68fbb976718e826640a0702723230121e3cb72e05bcec6045d5a8425411546a7b0937bdd6517d9a9f28f32557dea7dc6b3298191a83610c0416884e6a7a7aa1eb1df06681f66941f882d46e95a51ea5265f54ef49c1e1b1fdc94ad1a9c5b6294988c790ca323b3fa388647711fd62cdae76b65fba7886991c7456088f950c133fa0cd0f1dc694e9c21de0300dffc1f8bc7bfd10c42e7c7bc67ca7888f0620dbcf31453d66d22a8ff8dccaa6854ab56dea750eaa50ccbd81f2e5d1becc8ac5a38cc05ef858f5db7a0179b5666824ff7914ad92a156a347a5afece19bbccbc7d292c1408081b188fa9e110b2bf80e73dac5cddc563d43da1c4e53abe6669e6d97ccb70bdc7839d0bf3c15610e1cb2452247fae8e6a0c0018fbc07409533bfaa09038218fb641c16b562164ef59876b50bc3a90184dc15aff6d8e07a48940ac6bb54f579ec2644633d692103336e1251d4218cde8762496ed65d9cc6412a4bc697137a4ab732cdfeddbda0162d0d34d76b2a0b1142616bc2c0f46630bfd302d53a989da6515473809a4cbc3bbb9e6638c22a060cd1458216dc4499a91b4f5b0fc7e2f10ce81abd6c1f5a65a10effc24fe0385dca177eeaa50c9a78fc7938750602e2e0227f340f516b91be66861ee922cd3aeb4e8f6b9b0f8d9f6c62db5ff8aa85043aeaa3f2edebe3a551e173d9dd7e2a8e49575b535487b61db77dfe4b0973d9f298504211737a78d48f537aef64e82d7e76c7e176a6a1b2456c815fa00db4d9145259dc93fa1bbc3e36fd6793f15bf6a1cd1a4268a2e57b12438451aec98802e23f6f3eda594921ba3ae82ae5f32882ba3a9c5ea021c6ecd62e769b2e050fda1edd29e90768e113860c150f269902171ba91e866ff8ef8adb351730e11e855677f33359cad0da0982605b9a3d240f81e5e713d96ea93a946211a6b6c3b31e9dc86672682b3e3251e5f917823e51bd07766ac5764168b6bfdca6362d9faccf15fba927878cf9e9854e97200a009885ed1e6b533e31a2bfedda58acbe995b9701db61f7289aa5f5653497644f3d88250fc4576aaaeedb7f3fa9d6186a558232f530341d840e7bf917eccfdb226be41297727863e23fe94c43e42916e6afb9547149792837a8b97cd9dae73aa98595f8f1429a2e07eb26da7161e268e668ff45ebdcae56984bb296c7c8c5db043b518c2919626fb41be50c265b141dd3caf3523398f1549bc5a524b20a976ef46d0722a436803daf1bda16ab3878357f9ce440848574fdde7258fef8fe7a454b2b1090eb63bafda460412c0de8db971954f65453dbd66f281d0a2f338f9f2c06c828c5aa32aee0a569e610b8ce15d2b19bcc7cdb4a24d013a63dc3cc0001ca5a1b8729d06d5f3351c184f6c58865eb20dee7d2b862b539162f66bfa5c0e42936713a3fd45a83ef11cc5b0e074aa93533edeaf2ad2066397447400e830a616a92999fbbde8d9a4c232e3a1e2b42c72be0e2bda0e4e2c5653370efdd3d4259a2158aaba31ba795a21fcee3d5eaead54dadfddb4db19885ec4615b946f8c1ab7b4aec0dff671d2de1d9502aa591a1d7ee1b0ee7253233b55829d0e0b2abec8524f74461453407e6950ca955decb21ee993b1878975789a4e7c23d5ee9e4ac5933553a0c0d6b1a7671de48d6b4f793aaa9c8d86dd599b9990a180147daa50e0467e2a24df0a03c98583d88f15050c6b3647d8dcd19dc6f0da601d3cce1b05f61fb158ba2b2530b716ec14ccb76f1dd01ac655c14fcdec7f561955a1673da7524fd7f91d7958e289f577f277a8ddaa13f6310c3534a96a1afaa6060c2672a46a368854260a848e5f7bb5675e1737226e9022d5f0068ca301ea7d5978baff6e3c6007051bee60ec5716a5ebce01fda973cd4e72814a1769a9bdd848a3fffa4ace4490edd898f1696a156690971f25102f4e6a984a597075d21eae7df44340cbc774e60f0581e031d027cb0a48531f9da5b6246a5494abd7abeba1ba7a5535c8a18f22a294a434fb67c3eef70d08b85ff407456e1c5b486f72bbfa52a58c549d9fc1ef8e16272ae9c89b28a77b5ea2ebc7b05c51b44c43c63c19631bbdc8ffe956241797195aaeb1778818d706f53ba77dd3490a0e01531909b1a5b46ba77fa98a57d0f22bd80be729a907e0fecbdfdd0fae7b578ccd17c4619affa0072f7667834c1f23c42f8a5ee0ca52ca278da5cd115777616049089907af4660fc0820bb7968adb18afcb6d2cfcb57c97910edd43639eb4d3ae2f8940414728e228625e4bbb25eb80560edd7cab59698660287e2773452a50670b88dc6600c5968c6f299e59b55ebdde9d104028bd3300bcb335741c76c80c8d430ac12d2b3d611d7d778245362d03d367804a195b3c36bd3cf02a0432edff8ce0ac242d0a63d3345453cf71a6830f9a03c89dadc6eaf0bb12279814e4a22da6c6d9907e0f294bcb9c1ca271aac3b70f1c93f0a99cc6a2860728661b31eb7446d14f035325ddabdad361ec90ec1c7facb4a245cd3ee9a0185e5b74f431efdbc183fd264556c8cab5ccace466b90876b569130ea279a85a712f80b2a632ab96f701a017c00a478cd57721e8397f5fcc8c3819977c9b73792dd4036775249b3054844261b4767f1a2d410bd632e52988566d10b2e571c685ab9859fc0903883b4afa60579315a962a84592648680a5ced68a1f679940daca2c9c473178cf07e5064fafb5bbc1a99d40c56d6cb71f8da0739cf1acdbbabb7c44d555b6380a62c0fa942e9aab03e1b4adaf9849df251c4a1885d0b127e030fca9fb9887f731c80a4f01bf87b3617f6e0bf167f285a6a1c5f73a932b75f24270710c87d8b6063aee3661ce743e974b47df7e2ca02d9d3cf3f7796e238f4aadf0307b5650b5e7000e54202021b38645f4a6381cfbce220c50a8fb67d8094e0228e4d55dd436de45d15b236ea8116acf33cdaf01932b0d6a746d196f1323e4d9265f94823836a79f83e943378ca52db983bb7d21a93d5f839dcf10af0c00899d50e47538281fc21f925618c71f178d00244d592722189393aef34670d61626ec09d76806fdbd585d0365340010076ad3d41ba65600840321f7360ef7992d227dfe3d0c3deb0cfba3b618386747adfcdf4c05ecd66c0bb97669ddbf888794b26cbac8f727ac4b9efd4ea565df7d5ee1d7df92ad297dd689944de549af8d5c89a653498ea2d0d87380feeba48dc4db159ae545ee8e0a54c5aad6398d097cc68d8311a69ef216da41a5f38364e03530c6c2c965703b75c96072517ff7f70b93f13e36c59a31cb52a301f09811d70ae00b1b6e7b88fbd3c6370ce58abf178bb8752081d225edce57215ba6e158a04f4d39d22829c7c5d652251b989a32b70341058e3ac9fb9fc0bbd929ab684048a48124317bd23eb58b40732e47779cad3f667ad644a1ea3d5a57ace083e07c08b1a267de77fdacb3d23d21acf1540c6709fdbb7bdc52be516c2ae9cfc8bb4947b30ab02c157f315d2c41b0e599905709e3879e07cdb30ee1b41ea9ba0ecd593e99b84fc7745efbf1a47244512ba26eb8e646c3e101a272e45675af1310ebdfe5b7d984f8bdca435c1044a3591b528b508c59817edebdbc3949ff3b3f8ba2afed30df8d0755d4ed49466fff382894d3d6324019e33aaf7df169d42e3530cec0a3b19bc5f3fab54835107acb78c9fc4192245260faec34deedb28652100815a27d90d8803154fafc94baf97a2ee3f67a92790e95396189edd68dbc2aa4dc783844bddeb6043af685d1ce7545360b3303aa10593031d6b1aff27087f8401ab9ea454947f6dbde297c41d644cb0a5ec8723473b2c077e316e3844e300b3a1c43694777dab5bb1f1903579a7b3075df322946bc0fc6f0a8414473817efb567ba5bf4dac513c485c60d8fb4ed1ebe6ac03efade76fe0e2dd8884921a3fd674a74825b53a6fd0f25cbf94f2d16f18c5e663b0dbb9dc3bc555bc9f3a26e576e5fbbac9fc04d6b5ed80a05af1192899e27aee00f9ba1a01d5fb8af64bd11ecebd7497d8d07abd2e4ea2f081da26971f27384af09aee4c4cb62da0e466449417f77497e8b66801c41468705b8cdfa91c15d2085d550abd3c33e2cd7729d00f92b010d1667c180c7c4ebff86840336a5b7dda18af107c72c255ec0aeb46c7a0d2490fc9c6859ba742281f9ce0bb73475bd90bcf3205f23ed1b63da02370ff8aa2ab7a852c24ea0d74f57098e5a9fe7e72b013e626eecdd43e13d4b6d2a3194f7ad4f88d92a0c85b216e4bd47c9c91a84a70e93602944127efdaddd61811e4b14c8fa4a20c7d11c27fdbf78028a79eae9f303400ebee0c601b56dabc0b35bffa7c57232f0b40c237fae039c473b08368370d30f088385cc4e4f9b6d3ef16defb3a4fbb51fa47ae802212627f350afa7e39f97103fa65b090bfcd10843f6aeb01ffa1c0697477b0a18289d7fd7dd7ff6e3a766793619b0a1a58a3fb3b99abcc1183dcf560026d52a80e781b0b5fb97da84ff1199df45408f0029ab6aa042f38d3f8a762998cfc5eb8cd226cb6f3cfc995c22bf3674e0fc8af08b9c95ced4b9cbec2d1e258b8c374bd62b377705df17f4b198b2db208a85fd22982cf5d03a1ac6f64e0b999fb1303d473fb9ac2eab3a1dfc2547975b862cb8f5a956ddf17b01d0ffce2b7395f49faf521c32b7a208e9145400a0ccecfb318009262e5fdde7f318a112d1f9119528408b643f64db064d00be019cb7f87ea6a1f4aa164d9684f8b6f4b37f00f4c0f580393d783428652a3ad598312cd42be8f9b571f455cad74a90dc6f5eff909a6d1ff908c34f8f6dce01619ef40441608dfdc1d3d144fbad41da3b3a1d2be081e64131fd019a6db24a3bea5225a9a1ad3d159d9b7a6e80c79a3d45a3df5069a0c1d9211957b7f69e50ea17c9c5059341e81ffc350a105b8ecfe4fc8d1a1bde9499ff541661d33344875275c62263aff696b3f24a74c76dc2a3599b3f9d2bb547118ee1b4f393c43818525843a1f609f6c126806ac95e3ad294a1282d570a4ba9850c5d8fb8570913638d2256eea05e14d7e11292764902103704dbacf6bcb38914a9707055b39b77</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#2</title>
    <link href="/2022/yume-2/"/>
    <url>/2022/yume-2/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="35c84e5dc296936adb2e4908159c55c30ce62bbdc169dceacdae35a6c12b168b">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f3d53aed6fff44f35396c032ac3d71c03865dc7dd67b007f4c7ffc3e1a8cebb7a67d3d7f4bbb8bf74e190a47c69ecd149c4b1ab0055b290732426a6c934ab005d60f21100dcbc447cfb65388198a333d0b2f3bdd666505b6ed1904d90d7bd69f531e24d06192891a9dec778fedcb03d4b6f752c5422da9738481255265930ddb630a2eeabb51e8fc8fb88e58d1f105ae08477e62aa6cd34126ec1bc29ee8f413ecddfeebbee3cbd0d0837bc03522fbabe06ad4bf90c446bd90dd2c537f8d34e993959942f539118cf5353101333292ef7582554bfed72403eab44cb477a193922045769b3f032d1bce3cc3ad5ac5700eb730bf25451804aa6a101c1a3a435f09701cbae355c5d31a5fc4299155039946245b493ef8366d0b3822460c32a40441966bd13fa07718c901b5482a7d29aa77baec700193cbb4f7336bac5480c3b9ffcd32910f267374f781deb28863a021a50250e0972e66ace2f9b6a4666770713ad66c6d5594afd9aec80e42a0ad17eb9cfe5bcc95136476ecd3dea874a88faf7971d689e1efbe64afeb44f3ba39c3f936bbfdb8564c1a4cbd03774cea7af66a7f3bf98ce03e15d86b7f8bdd86719983fedd99759cc32779aa429d81f91b0d62369099b4fcc0823ef188e2b72cd263626a1652c3a58ee49d6d6b63be931affed9b47afa310a2a7abcd93b64f640f9dfefd27cf4ea46bf24e44f098c643eb31ae8ce5cc77dc537bb0ba4ea1cfc6e4e1b5cd8974cbad0ef4dfa69b6e4e1dc916e012a3bbc7bf4e3ce3ab81505d3c5b7a6afbccdc05f889910d3aba2de26219ce9ba784449d70aeba1fd56be250c1f4b177d37931ca9b478104bda54ff3064a2509bc9c92cdc8990465491b7271b51007bf6a29be5cb430e8e5dd679213568b10a0776e6d3ab9ecb17c3bfa66f751203f42c6ff52b2a970c052d83f5f08aa399c8c9130fa4c43e71de493313a34506bc50346356843e1905c077038ca3b01d46b36de50a73eaa941afe75122670987ec56a0c11fb0062a3c0cc0302908e30d0b0d8ca31da320e258dd7efabb4c76e62d14ec56c4501baf926dea1d6339b05d127955a6876154119cc083100d8b80a0ec9ec91295fab42dbf0cfc65965e4ba630b322db4525622d76ae2515db1bb3a2c6db9fa8aa7f218d3d057e974d22e5f3d1f274d7ed17e23b865cae53d03deed4ba2eba9186fde269e62b359e54c15605eea197933a809f1e895f14e7ebab9683851afae5216c35476e8aae10c47faf5aa586f7966c573fe1a520530ef0c53f7bbb5ab57b7582d03875c66325b12363506ba8b8741a5394324e6ef7750c4a3826f643155db43d987aec15e141ee4bf51d9f65676fe2123623a8efea5c44123e45de839ead8fd0f5251e199638ee3442a23b21d557d1140d3a3770d68dbde34683f701257a899ffab3b35210006f9317285e8a57d4629dd0550c4377dc6ed8b3cd2b255a9136df5010220224ed79812dd636b39cf206392914d41a610fa6714e18885401685a843f1fad5e25a4b8390e3da4e7df9386b6e3fce4ea5e8fb5ab52c70db9cf20225680dce62986cd613df54b9e267d4f66369b4ff342e7c0717831cc29fff57a5baaac8b07a9644de7083c2d034c8dc44d479955ac4031312843b0365a8f3aed939fd83d772c69a7780cf23416b9562eb971a60fd28d635deac981de395cab0f3c17bbe9e4704c952415f7004b23fdaaa8b2ac061a571112ab957a3ce21952c2108a790e9b3668a5bb28d2eb9d3b652eb688c7f65a760d447f111eccfffe741ddf90f7913153c91891ada519230ca871078cf44d43ac41fc2933ebe34e6983da70f1445cdd71139c4301015f0da8e5c33b8ecb971d198b3e7e2fa680b0a66369fb874f3c89dcf01e409322a012a9ad58d398c638f6cf0e92abd9517e6923f6caae8c94a28d92c56b802208da79c22c7f25abe08129b2f755008c28d055b25cf32171a95d809e4463458d8e5187852025c407aae70d0e92dc5476120fa7169060b1d1fb6db8a393329194ddf0dbbd578dcd2995303a764d8854fad524bbbc332c04d3f3a2fa66d38e62d38a9fe680fbf8ee4e1bec6aafe7e6a64527f5d829209ff8593effad919708ef46d341add2a4c1347790c59659ce39f1c912a20cd9363fee4ba42e591f60e31de2b320425ceaa07e98bc87c33f0fed7f698e7b177490149cfe58d9e244a0df222fcc9c5b3654be8feeef2b2ce1a1c5316982099d803b02d5b9d7c979da5f4312250f6a5404ae8e7a77e8150a961caffdc720a5bcc83107b9d08b3b543a05f6280c4c11a34c5a3e027414b36bc8f6127fb39174c5b801bacf855e07af0e7644fc399b0db65d59421587acf8603848c720cdf3db4250a9dea9353b6f1c13d7bf25e5d124ec85b67f7a74e97a1464c6537c450d6893a43517f46f5fc5880b2ca63077357d95ffb9ddcb1ce62b0e4d7ce01572e51045af28c14f6eac235fb9cef874c25a3aee2cb31fc55edc2f2ecf88813ebf6672fee2b65137e0c78ad023d8a443f11555b1869be510430c44d9f51b05ef0a9b7ee9293c7eba661081bbf4b9afd420166c09be6341c841577cfda0340cbded77659153fc0b14c963fffeca9db9ab8933d922806d32b49b9330d3b7dce4db2c0599ddd189bb2edcfe0a7d01907b286bdfb5cfd57451329cb4fcd6b157327dfa32b3f8d7e66449af176b42ffbf43fd17f8b1b06c61990036ce0dc3c390ddd233b7c988f9214f7347991287fac6d5abaebc94608b3318822b59901614f5d123d6fcd92a818caa04a2ec81b75d741cdb70638ba51f29ef1944bfecd37e8f5e40ae4662c8143788f43cee8d14780704f0dc5354a2ad62b376028c25132412603640f7fcfda3d25ce613bc66e18c42ae7234b65213f9e203ee91353ff15c6c500b33ef0977f94d6a06705482b99f33ce7ada76dc42c238a3738475229f273902175efe601ce02906f11b7ee89536cd7ae045e093da6cac0ee47adf7a77365a16cf63bc3c6671d722a4d7733df97c5715eb5e669800b9b9ffaa3d395128f9134544eb69eaf592f80782c3bac9bb1518d7976cf42b9800c61bbd066e59fce02946bd414cc7517bc1116cbb7a4a78827e8aa5ffbb18f55b6ed336d8485fe5ad91ac5d1a721464783e8dd36cbb7f54634567eac69eeac8b4849e3899ef33c34562fa4922d04c0b4da65d324459ccf7f876fe5060a9dce45fd382968d42fc0f54fe79d49c47448b51b7925a6fcad944b6061625fedd2a80de63dec9a938ba37098786b7dd64bc61f0e842de707baa64a0df295d95753f4a6e267170f5a609e70893267a606e2f9937d7b2fbdc5ab4a6de570db7e4607cd0c893e4006f9959c5e40dc2d858f87e858c721c51b7854d5055e669098681000423a50309e6c1048ab87b2a65055236221f62b141511b1cc62e5d6c7b2b33d98682d607101dfd89b1035a79a871cd39f6b5fb7bdd7f4ef25b4a780f3a29f8bf4f4be84f67f5402574461f2dd798a11b9df73ab9bbc8c8e854ceef25016fedd7393159c9dce01e3917c2bcb210b7c953004dce091c1da79cde82385643a39f04b00c68fb33d36740800ac57734bb25cde22b8efb44a82d1213270df3c5a8e21968c5ca4f13d1194c967da76339756aa3adf8325865d316dbfbeabe0ef3a6fe13a8645f0b987a9dfaedd9123bc3079dd3db32d6f7a9bd120e81c6e51d1fbe68539a2030e2bf35fca72a21c9523acf9823afad64e1a3474e75ac0af8146345449041d19c00d04df3687c5c8e70cefcc68520c15adf72bcf4dc7c2e554adc28b8681a571fbf83ae6a2f49f4b5439a496f066d7c93e46852b34b4697ae49c3de456cfc394437363377253c9731f96e45d7688505e65f7f4e989e1964f9484c789d6f29f5dead46de10cf4132d39341e0ea7d569f14b52fa54a1352d8d1fc2a88c1e05a1acd97cfe7156685aa6e946170970187fe02b892668ab71ab4806b01c794d6807957fabd530d4f652f7f35d19c56e80d34975173362ca75d02eab38a32d7df8fb51ee90c69eabbf88524ea105e2e0cb2ff34e8ad114953c6757622b299a348567b12cfb03e16317198d2b0632e410184d8166e636e99af8ff51fb946344560132b80d3059b1d78fda9613c212df1b4fc822d6fed8d6778dd72aed21b12fc005d2b1f17cee7f261e6af4da22f51d9eede120acc6bed82e34bdd53e722b2ac747524fe42620e0d701afb0b5c4a0047d3aaaa8e18208711f36eb21c5b017ca79c4a6602e83c9e773e6bc1a532a0f1bf151a1a9714ddf5d3e8d1d88b424990b91758ec6a026b74222dfea97221d3d554b97b5c6cc3e6a926da7954627cfc8e7e50107f122dd84b8c668cb22658ef52ac8153387c00de611e52b9fa4fe11c3e850d99650153aebd2c7311c406e1f8c11215b75fe971e92fff81e354bfeea8e547e6afc5fd689b2a55d5fd74cb8d6d27f83c4e115ec71768c5a6c53ae98c7397c1fb43b5fb5032b3f0593484c6591fa95359f53c1c3eb716e6fc1d0aeebbc6d35a4d926c666a9755bac4d0f59192f73b1d2f5bdd082f4f729e6309e96d01ec932add6015f813fb018dd08be941834fb72b6c8e04a09159ba2a1a1fd54030485e9b1a51f91f0fb704ae64a8989293f590d59c9b4348ccc4794ef8447820b1d3b1b1759a1f7df11c33a715aa81cebb5b5569abb9cb5e6f5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#1</title>
    <link href="/2022/yume-1/"/>
    <url>/2022/yume-1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2ada4ffbd98b9c06b5e302754ab0a86874dfd7d1448ccb59a33442ad04d852b7">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f36d00f8ab114e327eef921e387ac99e74b061a78c8cd79f52935761e3dadfa6ab8ee61974ca12f76afdcb150404e4fe14716e788130035de586074e94507ac6f13ddf784aff39556a7c6f8543ca4fd2f8009ba5d75ea97e34467a3e600883fea464c0e82b202ab36dee091c0971f5b36e1c4def85c43873bb2cbde3ac69671e275a422e5661ef708cdc1df4137343d9d27fa0474c3b52996c4b6350ddda1d6637092e43ebbd23dd50c6e8fb309b6410a015830ba915dc69011be6ea9c4b723bba450c25e80d42533f65ca390940a123c0f256a6db8c37ae5ad4a4ea0ca6fec4c1ecbdd3142108797c93cc435a76469fd71920d08e51381953778e58e65ced87c45cc34b18a7158def0064a53ca2d641911482a9d0b705d848a8cce893a77daa93775ea13b5768d59cd751238c7969ab7a4c48c32fd35e0431f9e6bc386fc6be17aa531c252a8e1a802712fa6ef75414e81bed5b12122794c9b7f1e821c72190ef0ad161424986eca103408547d2316f2bf71ccc1ba5482b4b6258a41853ffbd3ab294b5a884a72fc448b495e68d032bde1f8432865b806d5d656533d34a71f03e78aaa952220106f3e2c979c482de8d59fc44325c5e23913133cb5f1e4e700051df74f5bf16f00d29ae6421f58b891b21167ee144c289ba5780523d8a610326afe81f6eab65728fc0d3fb68b10aa119ee8818024345b5a7f17f5ba24c0fabfd6d4358dd4b0ed69c46f5a86e2d05eedb7f9a4312f2b043722e0cfe56e3e2278d3a428ffc2343fa27e93156b8320ed41e189776984d31474aabc321bacc4ce94a491c0725a46e985ee16168044feced4d655affd32cf65d559e28a0d5f1d5bad08dc2ed48ab60ea780c3de6e96d5320772dc0264eb1a94facc11cd56530b92844265562decd4b37cb6e6870cde0d9c64842e04c16be91f7515d18e0fc3b6a7ff857c0596ba951912516cac8667778ca30b16f8222cd2f092838c3068c66a28d8f926f2d98c8f8c23b5162006a3bd1ad1675e4140bfd60f20475e0d0aadc21dc52379f047975ba2ea626cee229386f528a96f7ed6e19d61eab2bd3658485a13394291af19657a12ae8bd419be6922a9debe25b09c77dce36cf3cb0eb5c49ccd72349979e47bc7ff5a2e28ddeb39b3201be6d2c361a723bd3332c32a329a627cf72683b9ba439f295b1d6995ff6e6a62f27ff39ca881d5092987cb11a60fffe41b3ead07e7ef4f8948f9e24755711e26b948d82c84a377bce106c5687a5b82c0c71d7e24fe23659900f8371b8a4bc9474f684d484504cf4a6f816ac6c79ff0af94d45fd12f1f117dee52b7cd5d6fea495a7616d7aadbb0f3e5f3358730389271fbebc9eb4fcf619bb2ab2469fffca180d1fa64ce60518b02e4ebdef04fc4dfe0874aad612409bdccb72fdf9bc348edf4bd11415ffde3695655ed2505136e3d134dead05f391c40c256fa5e3cde14b5cc91f22dedd8fd4ff6579a61304fc6db3340421f23ca1e5ee8a2a55f8bbaec46ec40ed1ddaf4952034a53e9eefa911d732dead84c8baa319af97e401e2463bc9fc6cb4e3def6a159e2636940b82d2a1547d5e0a8d351d27d3c8a180d7ac0508a2fd9e120ef8703c6fe4d09d3f0332ac20b4555dff16b311b65a68a1b20f39cb65b47e813ee6a29766c726bf8be8380ab8d1b7f08aa1242c013e6e602a705405b08a67ecdd5e5e22f266cc79565f2ba689eb0bbca0828023e9f59f9880530a418615beeaf41c928bc9fb9ecb15cca7ba940ad8673aebbc92e4f71ca827e5be8a1907a7bf830059e80b28d64324c930851ee36fdcb044e6cc70b691ee618cb9edf6b4aab2146988a5d9f59646f58745ec605939f2cffa27c2bb5edf357bc1a1c81ab092c4cb58677eabf5f9857498374c9bf70104120c5814bd9de47fd7e3f5a889c79f51856ed5df5d0fc65d5c95d5667508cb967b5772595c59aacab2cc7f01a8918d04dd574bce7dc7194b0e62d76f2cb697dafb2f11aa20b30d15246248226379720dbecbf520801dcece00a0831ab0ef62a48d7d8e3f52f5c277c3e357c5ce19496ef28914bf6550a1865ae864e0b56c6206941645cd7c9d82ef663ae9e5e5a32c84d40ad240cd5b4164199657becd2d996d34354f062fef878c55f29eea5cd907fa718c3487ff6be82be77fb94914185cced31af4028c2dd397316ef83c1fe53d0afde9d04a1c0c0b87493e9723ae8787b7e2d4fcf781b1b7be5dd05f97b0422bd2160aac4e685856e4af627a857df58931feea2fd2b2a9311e8b0a9fb8abd287e78f14277a6e23ff05a097c3d843e22db10f913ff4963a540878394cf31dac32104c34f1ec036295e2123c2a725cee7105ba19120d45cce12dbf74e280488a58d0d06dcfe367488ed27bf0c640383deb255673c5a48adefb853c8df5c7c73e592d8d7cdfae8063d7cdcc645396d777c6072682dde08072335eecfa7a0913a45a017e34c1e5cc93e4d7391b6aaf9667090192619c3b249a85d0c7823da1ba6b81907167b482b050ac5b6c6decd42232695b353f208279f03ea36dc6599502558c6e3a8ed0fc7778450311cbf852bf66a84d5d47514f31420cdfcdb4b1781a9b905de37f46ea461fde8ccaec24ad6e5d2e4bc314ec358cc89dfcf71da0736821f50a5dac20dec665bb2edab315e0ecb36b74911dafb796a9b999736c973f153f211b870fceabaf4a037c910e77609707659bb0adefdc1c3ede6041bd6273bc06be3d4bf998ffd5161d610955f34db10913cc2d1353c4f9694f55ab1ec44a793f6552b4965420917805ede15e3be61e78c51c42434aec71fb890efda2329599d6e7d3b062c0d7039654513d361d4c5376c4784db933c85a82124dd74699dfa21096937ecafaff565beee489b6c33a7e5a8432b9b17a91c892d06c3181909e939adaea4fbd60c8634355c04b659a748f488f99fdb3aa6ef211c9b17114c960916b656845296cde607fa499ad1f03bbce61e159b6daa9d2538e65aa8e3f20a4665648fc8a62730323d711cb14d377cff16415acf8b1b82cfb984c69ddb2336e947293f8edaa389c795ba4b8448369162f128c1db078deb782538cafaec39c618b04c2e2dc0aa5ed662ee77f8dd3a5a9e84514974470962b95cc6686cec6c600fa908537223a68dd3d3d1c5aec615a7e6d0792cf70bda5ab91584fda82b47926655408199f20f89806cbf8e5680a708f7ceb67bc4f49e9101a17bbba16a770fe16d4e95183e4d60956a7f2e186cf0fa86178ea645fc1487fcb26add82f5303ea8353c3790d7928f1280de5f8076e56ddc3159e24fbebbc765e32a5d3ce4fab3d606341c5a57d9c164600b84e491ae9f7a1f64f29210a4f37e6608ff705b573adb38e14052a3a189533cc7c8de0e259d901581311915d697f60d44646a0c3cd679f22aa1154bb3d4a644a2c648d84d9f91a3fcd04732118da6c391b3587d7fcfb64a16902ad99d0a5d4735e7347a192246af70216fabf1a7fd718be51dfffb8bc30abef44b5dc69b1e0b1b3494e32da48f1fbd5dfa63e7e32428edbb6a9219b9b188b11e7791aec8b9d880feeff09e85848504c1b1e9de6ea0a1682599f20716dc25297ab9f8e65bd0bb4b404f9814eb546cb164fb568d5aeac3cbcfb04403d62ed995c3fbe22fb35826bae041d4287b16edde6cdc5fdaedacac72102a65b1509117845242e1044aa28aa94cad9fed40a838712e55873257607e5ee16607a33984ff2c58b5a2f0837e7f9c70480cebc167a395fc1a8a4f1af1e866b8e070fed1b51f295e312b8f98bd08705ec42d30dd38209b2b0fd0ab7ea92a62359d7c2a3a0040dc3ce6fa9ec4f08f4a30c0fcefded28ad3ec94059a3177df6ef440eba38ec3eac3acc168c606148747810ff0284abddd0bce3ed0bf1395d617b5e752994df1013118614d3aadda5c481a23a77a9e47a5351b18f66063726ea2ca1c4515238513c7fa5c1a456bf5695183cc7df91cb9db47c062316dcc234d160e572aa46fae8156192c38be9e608c839a5d72d0ea0bf7e1aaa9dd89504e256bcee6238283cc84e35a14029ef029db695634fe840d14c50411a9a20cac8e7beecdf67b805fcb7f1501b9f2b1f603d8bb923fa3d8c0a7dc1d7b12e55f827e4c0fcac7e5a52411f011de8e1495d3de8ca0aea162bfd19d46a86a86f533c6def02ef69d094d56f5811cb30a0f9b08763ac73c62f057802fc4fd9003140ed981a43f90ccbe82054f9fd6b176fa8d7c49b3e8aafec92a8f5dfa04f7a5627252584861680e7190537097bccf48758c211bf1c449676745f2ada2dbc464b79e4068415c609e7692f2baec61c8b46c64c9833d793b7753f161d4c9db2d7f724d620e02e1cf78eb66f96f4b3d6a8d86e41c79e7015f1999443c5e6645fbc798863bf1e2418edad6eab0b8093de1463c031e88d70f123d61c6273b180fc33fb957b630a496a64b92a65f9294ef8fdf4318eb4e1666365e6756ed27fbf7d64a8bb7a35916d1168c28d10e1cda63de2f235e4b4ab184d0f63f0f5f23ab7b1d769ce9d642f9a0926cfc30d77ba713bcf474fedb13322aee162bdc0c841c303d13f48d1ed422cd5d58d811eac56636bb510b451c79e0b9d9b4cb4b4ffbd0f319fd9c0f44fd09b2cc0ae175b28e7ae2fa594639c543b56425125ebe83ad8e6b6a3ead6a1d7b32b1c725686b652312cfb6e45ed6b2bab201c8b64c3f7322507789da567654c9a9bd06191d6d617cb42ffc9bfb395ca9050e5cb6e7b711872c0053f4ceabe952817b9cfee63fb271c989f8b6f90695a7d8db67fc8e12f270df3821770ccec36a3d24173bb7a919d31bd1f8659e8d13aaf61b3dbba3cce569fb55c1e432eba8749decebd8b1cc1ddc96545d9da7a380fd2456959604a528a44541531afc6e83121e08f329204a75d1b1b24a80dcaa39b0317a505ac4e6ec3764ed8bd7f75c7fb4ba9e69000dac1e1e767677d7031e5e8583ecc058937e36ce70473d510e007d97162ef34a1ac7bff74768ea9543485f35986e6b84b1131ae92bb5038f9abad190b83262d44f15806cd2e8c87d260cade610d353e327e93326ca1421bf4c7b890c9dd813466f5ccaa42f75cbfd844f8333177eba5489a7ba5b45ee9bfd333feb2c92b2c19c75e4897051fcebaf0dafb5f9b23fa510c7563280bcc6dd6857201feb1629a76dd3ce349388422f8cd105d4453972926c32b4af70487c74d4b320ff62b492b102570e3d43077428bebfc093fe00229ef7fbf6884967f25a3665e3264abdbf9ab495a6b3fe75031bcb0f0fc6d7fea8b57f51000ac063d0bdcb82c0858282a46d24d9e783c48ca870a2fe79934979b071cfb7c39b4f5738fd33c083e9553c522fd23fc60289527ac4c3433f7ba51bcaf07715e105a57d67b176122c0d8018e8cad8bdcf14269333cab8cc793b3a16a6960a6587c25654df078a96fe9080de8be44e82b4fb06ed825fc96fffb70106669391fc0d0f3bb789d986f24967cda222d1184ecd9475d318d4df25d2ef85069c856de84450da48fe13edd0f09d0bf89af48159da94951e7577d61a750ee79d2606adb64548410cc2ea2733e9b0967ecdd19d3d64508dad2c9112b29e5b497c915dfa40968f94d90b51b8b44bbc02c51da229a7a31640030250943e81e9bbd7c167e98244d4bc6bc4ec47bb35b81ce397a8d10d866d4e2ab225b333d300fadf15e93b0b86bba71d860b77cfee3d57d79ced4b0b07e8dfcb8c3b10813863cc0cf1dbc87e160000ca5710c34bad6630019f215f822621ba068c0abae0ea5ace223dd0c95a3ff92b68630b3eda83c4b4a83521fba8b256d52a6f72f83bb7c87ef4279ebbd427f6daeacf9e85dc602c741db6f59df6825282a10f9eb624b8f30d5ab985fd67c2ca02043f73afd625748dd053422d47c98e01a5ab7c4a8c180243567fca33cfd2d67837b3c7e737ac61a61403d0f4931d31efb94b46873fd31a7aa373971013cbf0b55359a6afb0faee15d9b9c4447b23b8307a4d50936a28a240f11df3da1a1386ee25071a17e3dc2e9ddb094e85109b5bc29b616aef954c960cf927265256fff37b32a6787e36cc1506632b4256f268106e0ceb6bf1010f6696c4a42974fc5ff1c702d8b623372c038f93a240262feced4852d9d7145447af65e295fb9410f047682195f82758dc6f3a2a0d7c706ff168388d03cc3afe0fd1e92abc279f69719199e0e6239d1a590171c278479910a1dcaed1e40c76c3ffc5f1cb06bb715d952b2c80393f65ba4731bf62cd79899667dd7dc4d1133ddaded7453bf2b70b4c7b7bed0b351255ff7e0657260e2057211901189e4767066a2720a91179e7f04f8e28a4d0e4ad5ae40847238e201e25204f4bd52d2c39e1f75a9f403cee15c250fa66c584e69fb2315564a2555023d70a72d6bde13d6bad306c682edc6a8ec65716cabbae15caa7af79a83a059e13be75e8e9d8f9333aca7efd51ee48061460632906f7c7e78a7e72cbd8077ef13b255c060a276362315a27c192176c0952fe4b4219f5456fb3159c178f32ca61ddd742169ea9a476ffb6101cdfb9bc4e13e2011c5ef1b5a26276e139e6b26a0180c9f817f2d789c860f7bad7acf2d505cb9c226df91c9b5138f663cd075d8ad2532595d40f92b1f1fb01ad63d0c1fc16f53bdc22f9c96f76896100bcbf8a92a4fbafdf60bb07306ca4ddec0078d19cc4b338f86a83d413884bf338de986789ab24f28f702c321e00737f327db87b8b8b993b257566e64abfc7971791912ec92ecedfce57dbdea68567e40fd6d65b361e61302968ae9a9d972aeb22dd7a23020256c6c897a11a8a0d5be8dd805f72734e5f1167a69b34a9b6665070358a2cf494813b7a50dfb3c6a99621173b31319dbec0868b296c0fb80d5fbb215b103a881af4a7497f091a5ee19e0392a3f84cffb1737b275de2d006e86f04b41609af6508b71442a3762d6528747115ef6007775de90af501d3b1ac5d3de040d7f70ead635756a7007637bf46cad6671941ffa9e2390c0ce03dc98f20724f9990c252bdf863e54942a44e4248039604c03c3c28fa2a6886fbbee15fd715d7740eebd2c4aad60ac6ad716cd7fb8af1311c29552d6c323060e46ba68e76dbcabfd4e4590cbf15546adadc8c82d48ddd11f1d1a25208c8a026cb414036310ee787c76308eeef31f1df14bfcd78ae18e83c2c1635f4aaa1566c92f57e0ec4fb4469b5e27b6439a29b16047e2698d84139054dabbe72120f3ffb1f500da90604dae1500215b0982a6b107e760aea1c659b882a82d1923865b2fae59cdb0ee6260307637f65a319154b241449a890f55406d15431887d4369e968441e15006923bd84c548fbc27036d39c3fb9fb7adb251306faa4bfca924afc317cdad74478f8139ac8fa171f8e5a4238045d7162e863d4c116b719114267e8c7f577c32a4b5854276b27869c98dc47bb00f599c920b075f4b9814cd6f8df73fd2acbbe4f4b85e4796b638afc7081d82ac2ec88f3a41cbe4a1c8af2d6faa9685b9dda86b68d57e1bb25ae73bc71782534f7cd7a79ab16bac2affc41d7c394f30c855bdaff15639a42a8c70ca0f0b9557090d82a51d6418c4661e310577a3065bfa87a7cc7fb03faf3761ee5f6f9554edbf6ef03234a09d8281dfd924c1817a48adcc0e5fd9d76e3a63c5ece627a35abd73e10be89092e1dd52aa0917c196a3f8b273a75da52ab02ce3a8b7aa823e5f3d157f0444c968aa234f3109aba4525e5212a8b143a5ebbd1217bb0fe85690260d18ffc7763537caa3be101a97f683f25a626320fef941707936d9dd0f93290331b11d06a04ccbfd0f8349329792e2300d8bcae8ada9cf071726fd951c0a80a1ed5d3e0790bd4a91289a80548484e02b2b3666dfe7d8ac2a5b5979ad2631a20a35c47f0b84d9a6ad402536b70aca1f2a1e7f8e20747d68178c7d875ee9e1ad802c287beffa85b1ea19b914c2bbf84f1ac89c60a89253e5da2094e9f769614db0eff3b208204283ddf387abe9a154777b0ecbde76ddcad1bb4ee7d1a960f57886cf489aff4dcc59d63004a66c362c8a05d1fe77c0b54a3b35b95649ee3e0af427a33b8ac19caa6b0e5f17327118da6b30ae5859a4e989ebfd23997778d27b31fc548a22ce561621e4b56a0e88fab5608053f895f4d87582ad6b1d681d509a466198010c50d49ade00cb43331522bd642d3801979c18eceec369db11a532f9a0b7e78ae594305f71a5f7db4d45a015889b58958abd24ed30e899df7fbedf9569ea372f56c4f548127a6733206f52a24715f3d180a458eb571915f255b9955ea5d8a612a03cbc790ec34f22ce0baf675a449508804eb459d2a1cc6ca7a777cba4bc2b8a4f57ab35b65a19742cd425b1c9ed2b489f1021df972aac3ecdca9b0a4f9514f89d9d294047bc66a84cbd726e3f6e39438bc1a41bb3ec76acf4711473b8648ed97958c5d89f62da918bd6db96b19065a53fff001d526085d81234c0ab3bf796fdb2624decd0a26333f0f29358be0a082c57cd4922e7fee070f5c6dafd341a063eaf2a5846351f068aa43e7e55c9d598f07be5f68dc9d80cce2fa015e016843684deb5ca80d866e9bdd06ccbe110758707e872474bf1a0eb288ce85543e4d6e4d817d8c455e2c7b64e5f648f4f8f5e469ba021cdd975b4332dd4e529030249f03144b5737868bf6a73253b5127387d948ff31a89bde1603f3f9a217d522fefa887648f0acd232915adc4ef88deb8b8993ddeac2ee3078f20b9deaf34173d1917c963c33571381e2b80c1726abaa342b88931cf9fd42e498f2ca7360a89950dbb4e9d20c0899e788b2f22638de1d33de6c25264f0a5f030b4425b1941a2afe8c934a215eb57e4e5d44f5aaa20155b8020f49437cac6daa192192b288e7be8fe202b4d4d5ea258bf859e9407134627a68e503cfe2d574235bf7af994ad003de45a634118cdc4d6c2505bc406dd9823d8df74eb75e1337755a0083230d297681005759375f5790d80bea86b86387ef132615397806f31663f61455bf674519184603679c13c8be87224299834e363f99f24ddf8ca231ff879fe4356bc30c884b389d54629271494c880dc098ba39e6abf356f5801a56578a995558b0beae867f06474d281bf1eee817f6576607a43570943d87526f98875f31b0ddd4d2eebdf662c554ec568533ff38d8c40e12d0e4209b4e63bec3c0e33e171bcd79dc57bd7d4b5b163c511b1d70e44b0b19c0a323499b1c10772582cca9296961f7d3c224d4c5993bf0d3d3090375989d5037fac54c23d986778b3ce0580b57e0720916d8f8723c7ef0b07a566a0b6a3ffa12edcfb18c2db2ac7452165cf84d8f40b56029e502b6366f8fe7bbcbf832fa6d4388ce2980fd0ce3fe592d8d603643af1afed8b05fa6929749d14bb6e181e9372a0c39740d4455c28f87907520992311643edde3ff7c2bb1ab8967625d5e9e990dbd6b5c82aeaaab48ce08fa3f077a5604299a54bcd49e9478310e18fcd17c073f1233fc84b5cee97958f5f20aba37b99ebbdcc2951e5cf89f3299439548b63a7902455d1d59b3dc02501b2c0626f667e1273de7d3940af74aadf7854696cc8d13d58b05c38bea615772097cf624a8b6ded158aa1701ff12b565f9322ab3bb7fcfde760233b9e30a0c3ed734337193a812f15174e18158159b1fe8209d23b6e139d6ead027230e64f566f5fd120457591e6b7a1d8e8ee9cfd0002ddcde7629f710d529d7f3191bccc0fc2bc43f28722cdf8e9a17edcc0c01d23df7587777acfb9d1077517edbba7ea965945496eb6c4f94118189b1f1e1d0a4b932b27afbd480f1234580ef82c3e6f240b412ac988c35f39026d296ecc8940fe0e10df872714c9e6ddf2a0a54a2c884b589a0ba1832f050f9c6b119d817aa62f0bda406d6481e4519e12065266e725458db191d8ab3f83381fc18926bd1bcbb2f08742ffa19873b0bc0561f0b28fac95d9b95983c352ee47dce0f8b330c2ac3364572ef3ed33fcfd5225d1207fed8bca84d9a5d52b71254e1030b8cacfeed7c528eb630ecac84d3fb34829d744bb951cec69e66cf50f2a5608aa6cf45b3436e31c72c0cc2c8f65dfaae562df3e8e9757ee17c7f09206e65109a582c8716a2891d805351d0fc152fee9d342c1972f0e0f4b604c627176568f8d4a37e4bb816e8d8ecbbabe89cb0add7877ba4f848cfa5c94f539d180107e9ee78e758c789420de97616b1b136ce46b0d1cbfc47f7a26e1895779d3ee29dd81194b5044cc5469433ebe302ab7522b9d64304168487fb755b541fc650a086487a80043d6254e330789b86552c3575e2cd19f0d688d984c103b2ac851f0e99430b4aa277b2ca09290bda2ca9081f35b32a097d197f514f84a2ddd618ff019a5c45a1664d6d3c29bac559b156c4123a80a0efa692cc1f46982c4caec13d42243ade16bbb1f37b29f77ea44ca956abc4eb497e013c8402b00957d66a35bb372239f9e8ba2e4ce811c44c023d4f6ab1bc7767e764318aae3aa00bb11e9ab57824feab2de4d607d55d162483527</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1291 百事世界杯之旅 题解</title>
    <link href="/2022/lg1291-solution/"/>
    <url>/2022/lg1291-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>有一个显然的结论：设当前已经获得的名字个数为 <spanclass="math inline">\(k\)</span>，那么再获得其他名字的概率为 <spanclass="math inline">\(\frac{n-k}{n}\)</span>。也就是说，平均买 <spanclass="math inline">\(n\)</span> 次有 <spanclass="math inline">\(n-k\)</span>个其他的名字，那么再获得一个平均次数为 <spanclass="math inline">\(\frac{n}{n-k}\)</span>。</p><p><del>感性理解一下</del>。</p><p>事实上有这个定理，对于事件 <span class="math inline">\(A\)</span>，有<span class="math inline">\(P(A)=p\)</span>，那么发生 <spanclass="math inline">\(A\)</span> 的期望次数 <spanclass="math inline">\(E(A)= \frac{1}{p}\)</span>。</p><p>回到题目，就是要求 <span class="math inline">\(\sum_{i=1}^n\frac{n}{i}\)</span>。要输出为分数形式，那么分别计算分子与分母，最后判断输出就行了。细节见代码。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">int</span> n;ll p, q, r;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);p=<span class="hljs-number">0</span>, q=<span class="hljs-number">1</span>;    <span class="hljs-comment">// p是分子，q是分母</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;p=p*i+q*n, q*=i;        <span class="hljs-comment">// 模拟分数加法，可以自己验证一下</span>ll d=<span class="hljs-built_in">gcd</span>(p,q);        <span class="hljs-comment">// 及时化简分子分母</span>p/=d, q/=d;&#125;r=p/q, p%=q;    <span class="hljs-comment">// r是整数部分，p要去掉r*q这部分</span><span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,r);    <span class="hljs-comment">// 分子是0，表示r是整数</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> d=<span class="hljs-built_in">log10</span>(r)+<span class="hljs-number">1</span>;        <span class="hljs-comment">// 整数x的位数=log10(x)+1</span><span class="hljs-keyword">while</span>(d--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,p);d=<span class="hljs-built_in">log10</span>(q)+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(r) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,r);        <span class="hljs-comment">// 如果有带分数整数部分，就输出</span><span class="hljs-keyword">while</span>(d--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);d=<span class="hljs-built_in">log10</span>(r)+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(d--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,q);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#2 2-SAT 问题 (1)</title>
    <link href="/2022/notes-graph-2-1/"/>
    <url>/2022/notes-graph-2-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="sat">2-SAT</h2><p>2-SAT 属于 k-SAT 问题的一种。不幸的是，对于 <spanclass="math inline">\(k &gt; 2\)</span>，都是 NPC 问题。</p><p>给定 <span class="math inline">\(n\)</span> 个变量，每个变量 <spanclass="math inline">\(A_i \in \{0,1\}\)</span>。接着给定 <spanclass="math inline">\(m\)</span> 个条件，每个条件形如 <spanclass="math display">\[A_i=0/1 \text{ or } A_j=0/1\]</span> 求 <span class="math inline">\(n\)</span>个变量的合法赋值，满足全部 <span class="math inline">\(m\)</span>个条件。</p><h2 id="求解">求解</h2><p>将条件转化为：若 <span class="math inline">\(A_i=p\)</span>，则 <spanclass="math inline">\(A_j=q\)</span>，其中 <spanclass="math inline">\(p,q \in \{0,1\}\)</span>。</p><p>举个例子，条件是 <span class="math inline">\(A_1 = 1\)</span> 或者<span class="math inline">\(A_3 = 0\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(A_1 = 0\)</span>，则 <spanclass="math inline">\(A_3\)</span> 必定为 0。</li><li>如果 <span class="math inline">\(A_3 = 1\)</span>，那么 <spanclass="math inline">\(A_1\)</span> 一定为 1。</li></ol><p>所以把 <span class="math inline">\(n\)</span> 个节点拆成 <spanclass="math inline">\(2n\)</span> 个节点，使 <spanclass="math inline">\(A_i\)</span> 对应节点为 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+n\)</span>，分别对应以上两种限制条件。</p><p>具体做法是，从 <span class="math inline">\(i+p \cdot n\)</span> 向<span class="math inline">\(j + q \cdot n\)</span> 连一条有向边，从<span class="math inline">\(j + (1-p) \cdot n\)</span> 向 <spanclass="math inline">\(i+(1-q) \cdot n\)</span> 连一条有向边。注意 <spanclass="math inline">\(p,q\)</span>都是把<strong>条件中的值取反</strong>。</p><p>前者是原命题，后者是它的逆否命题。</p><h3 id="dfs">DFS</h3><p>这个 DFS 的算法，代码短的同时还容易构造字典序最小解，但是复杂度为<span class="math inline">\(O(n \cdot (n+m))\)</span>，过高。</p><p><del>所以为什么在洛谷模板题，DFS比Tarjan还快</del></p><p>具体流程</p><ol type="1"><li>对于每个当前不确定的变量 <spanclass="math inline">\(A_i\)</span>，令 <spanclass="math inline">\(A_i=0\)</span>，然后 DFS 访问相连的点。</li><li>检查如果会导致一个 <span class="math inline">\(j\)</span> 与 <spanclass="math inline">\(j&#39;\)</span> 都被选，那么撤销操作，执行过程3。否则令 <span class="math inline">\(A_i=0\)</span>。</li><li>令 <span class="math inline">\(A_i=1\)</span>，重复过程2，如果还不行，就无解。</li><li>继续考虑下一个不确定的变量</li></ol><p>代码略。</p><h3 id="tarjan">Tarjan</h3><p>用 Tarjan 算法求出图中所有 SCC。如果存在 <spanclass="math inline">\(i \in [1,n]\)</span>，满足 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+n\)</span> 在同一个 SCC 里面，那么表明 <spanclass="math inline">\(A_i\)</span> 必须赋值为 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(1-p\)</span>，这显然是矛盾的，无解。</p><p>还可以构造出解。对于一个 <spanclass="math inline">\(i\)</span>，选择拓扑序较大的状态更优。</p><p>由于 SCC 编号的顺序就是逆拓扑序，所以我们判断 SCC 编号 <spanclass="math inline">\(c_i\)</span> 与 <spanclass="math inline">\(c_{i+n}\)</span> 的大小。令 <spanclass="math inline">\(f(i) = c_i &gt; c_{i+n}\)</span>。如果 <spanclass="math inline">\(f(i)=1\)</span>，那么说明 <spanclass="math inline">\(i+n\)</span>的状态更优，对应到上面讨论的连边方法，就是令 <spanclass="math inline">\(A_i\)</span> 为条件中的值。否则说明 <spanclass="math inline">\(i\)</span> 状态更优，就是令 <spanclass="math inline">\(\ \neg A_i\)</span>，与条件状态取反。</p><p>然后 <span class="math inline">\(f(i)\)</span> 就是解中 <spanclass="math inline">\(A_i\)</span> 的取值了。</p><p>复杂度 <span class="math inline">\(O(n+m)\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, scc, top, num, c[N], dfn[N], low[N], stk[N];<span class="hljs-type">int</span> cnt, h[N], ver[N], nxt[N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> xv,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> yv)</span> </span>&#123;    <span class="hljs-comment">// xv,yv是条件中x,y的值</span><span class="hljs-built_in">add</span>(x+!xv*n,y+yv*n), <span class="hljs-built_in">add</span>(y+!yv*n,x+xv*n);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;++scc;<span class="hljs-type">int</span> y;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]==c[i+n]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i]&gt;c[i+n]);&#125;</code></pre></div><h2 id="题目">题目</h2><p><a href="https://www.luogu.com.cn/problem/P4171">满汉全席</a></p><p>板子。</p><p>汉式看作取值为 1，满式看作取值为 0。判断 2-SAT 是否有解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">2005</span>;<span class="hljs-type">int</span> T, n, m, num, top, scc, stk[N], dfn[N], low[N], c[N];<span class="hljs-type">int</span> cnt, h[N], ver[M], nxt[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> xv,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> yv)</span> </span>&#123;<span class="hljs-built_in">add</span>(x+!xv*n,y+yv*n), <span class="hljs-built_in">add</span>(y+!yv*n,x+xv*n); &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> y;++scc;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;cnt=top=scc=num=<span class="hljs-number">0</span>;<span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(dfn,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(low,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a,<span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;h&#x27;</span>&amp;&amp;c!=<span class="hljs-string">&#x27;m&#x27;</span>) c=<span class="hljs-built_in">getchar</span>();b=(c==<span class="hljs-string">&#x27;h&#x27;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]==c[i+n]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x, xv, y, yv;<span class="hljs-built_in">get</span>(x,xv), <span class="hljs-built_in">get</span>(y,yv);<span class="hljs-built_in">addedge</span>(x,xv,y,yv);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-built_in">puts</span>(<span class="hljs-built_in">check</span>()? <span class="hljs-string">&quot;GOOD&quot;</span>:<span class="hljs-string">&quot;BAD&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">solve</span>()); &#125;</code></pre></div><p> </p><p><a href="https://www.luogu.com.cn/problem/UVA11294">Wedding</a></p><p>翻译（复制的）</p><blockquote><p>有N-1对夫妻参加一个婚宴，所有人都坐在一个长长的餐桌左侧或者右侧，新郎和新娘面做面坐在桌子的两侧。</p><p>由于新娘的头饰很复杂，她无法看到和她坐在同一侧餐桌的人，只能看到对面餐桌的人。</p><p>任意一对夫妻不能坐在桌子的同侧，另外有m对人有通奸关系，而新娘不希望看到两个有通奸关系人坐在他的对面，问如何安排这些座位</p></blockquote><p>假设所有妻子和新娘坐在一侧，所有丈夫和新郎坐在一侧，如果没有通奸关系的限制，显然是合法的。</p><p>如果两人 <span class="math inline">\((A,B)\)</span>有通奸关系，那么令 w 为 1，表示和新娘同侧，h 为 2，表示和新郎同侧。<spanclass="math inline">\(i \in [1,n]\)</span> 为妻子，<spanclass="math inline">\(i&#39; \in [n+1,2n]\)</span> 为丈夫。</p><p>如果 <span class="math inline">\(A\)</span> 在新娘一侧，那么 <spanclass="math inline">\(B\)</span> 一定在新郎一侧，从而 <spanclass="math inline">\(B\)</span>的配偶一定在新娘一侧，反之亦然。这样通奸关系就转化成了条件，可以直接根据这个连边，表示一定在同侧的人。然后跑2-SAT。</p><p>一开始本人也想不太明白，最好举几个例子。</p><p>最后要注意编号从 0 开始。新娘要和新郎连边。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">8e5</span>+<span class="hljs-number">5</span>; <span class="hljs-type">int</span> n, m, top, scc, num, c[N], dfn[N], low[N], stk[N];<span class="hljs-type">int</span> cnt, h[N], ver[N], nxt[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> xv,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> yv)</span> </span>&#123;<span class="hljs-built_in">add</span>(x+!xv*n,y+yv*n), <span class="hljs-built_in">add</span>(y+!yv*n,x+xv*n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]); &#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> y;++scc;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a,<span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<span class="hljs-type">char</span> c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,&amp;a,&amp;c), ++a;b=(c==<span class="hljs-string">&#x27;w&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;cnt=scc=num=top=<span class="hljs-number">0</span>;<span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(dfn,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(low,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x, y, xv, yv;<span class="hljs-built_in">get</span>(x,xv), <span class="hljs-built_in">get</span>(y,yv);<span class="hljs-built_in">addedge</span>(x,xv,y,yv);&#125;<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>+n);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]==c[i+n]) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;bad luck&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]&gt;c[i+n]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dw &quot;</span>,i<span class="hljs-number">-1</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dh &quot;</span>,i<span class="hljs-number">-1</span>);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) <span class="hljs-built_in">sol</span>(); &#125;</code></pre></div><h2 id="to-be-continued">To Be Continued</h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>2-SAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#1 最小树型图</title>
    <link href="/2022/notes-graph-1/"/>
    <url>/2022/notes-graph-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="最小树型图">最小树型图</h2><p>最小树形图，也可以理解为有向图的最小生成树。</p><p>更学术地说，在一张有向带权图 <span class="math inline">\(G\)</span>中，找出一棵以 <span class="math inline">\(root\)</span>为根，权值和最小的有向生成树，满足：</p><ul><li><span class="math inline">\(root\)</span> 入度为 0，其余节入度为1</li><li>任意两点 <span class="math inline">\((u,v)\)</span> 间，有且仅有 1条简单路径</li></ul><h2 id="朱刘算法">朱刘算法</h2><h3 id="理论">理论</h3><p>朱刘算法是一个能在 <span class="math inline">\(O(nm)\)</span>的时间内验证有向带权图是否有最小树型图，并且能求出此图。</p><p>首先保证图没有自环且连通。</p><p>接着就是算法的过程：</p><ol type="1"><li>对于每一个点，分别找到它们的最小入边，构成一张新图。</li><li>如果新图没有环且连通，那么此时就是所求的最小树形图。</li><li>否则将一个环缩成一个点，建立新图，重新计算边权，重复以上过程。</li></ol><p>严格证明？不会。</p><p>但也是类似于 Kruskal 的贪心，只是多了缩点。</p><p><del>感性理解一下，显然是对的</del>。</p><h3 id="实现">实现</h3><p>如何去实现呢？前两步显然不难，最大的问题在于缩点后的边权怎么计算。</p><p>对于一个环，最终一定是将它断成一条链，那么就必须舍弃一条边。贪心删除最大的边？显然不可以，如果向下图一样删边，那么如果A 只有一条权值巨大的入边呢？这个贪心就 fAKe 了。</p><figure><img src="https://s2.loli.net/2022/02/11/GyauMAeoQZYNLCI.png" srcset="/img/loading.gif" lazyloadalt="断环为链" /><figcaption aria-hidden="true">断环为链</figcaption></figure><p>所以我们不能直接破坏这个环。</p><p>将环缩成一个点 <span class="math inline">\(u\)</span> 之后，<spanclass="math inline">\(u\)</span>继承了<strong>所有环内节点的所有环外入边</strong>。而建立新图后只会选择一条最小入边。且选择对于一个环内节点<span class="math inline">\(v\)</span>，选择 <spanclass="math inline">\(v\)</span> 的环外入边只会被动地删掉 <spanclass="math inline">\(v\)</span> 的环内入边。</p><p>所以如果我们先把环内所有边的权值统计入答案，再把每条环外入边的权值减去相对应的环内入边的权值，则无论选择那条环外入边，最终都不影响答案。</p><p>如下图，<span class="math inline">\((Y \rightarrow B)\)</span>早在第一个阶段就被 pass 掉。<span class="math inline">\((X \rightarrowB)\)</span> 是 <span class="math inline">\(B\)</span>的一条环外入边，那么如果把 <span class="math inline">\(X\)</span> 的权值<span class="math inline">\(x\)</span> 减去 <spanclass="math inline">\(B\)</span> 的环内入边的权值 <spanclass="math inline">\(3\)</span>，即直接累加 <spanclass="math inline">\(x-3\)</span> 的话，就相当于删去了 <spanclass="math inline">\((A \rightarrow B)\)</span>这条边。且对于其他的环外入边，这种方案都是可行的。</p><p><img src="https://s2.loli.net/2022/02/11/OQeAHkhruwdRNc6.png" srcset="/img/loading.gif" lazyload /></p><p>于是这个问题就解决了，具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, root, in[N], pre[N], v[N], id[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> u, v, w; &#125; e[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">zhuliu</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">// 环的数量</span><span class="hljs-built_in">memset</span>(in,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(in));        <span class="hljs-comment">// in[x]=x的最小入边边权, pre[x]=in[x]对应的点</span><span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));        <span class="hljs-comment">// v[x]=在新图中，能从哪一个点访问到x</span><span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(id));        <span class="hljs-comment">// 标记所属的环（或者点）</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])in[e[i].v]=e[i].w, pre[e[i].v]=e[i].u;        <span class="hljs-comment">// 寻找最小边权</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==inf&amp;&amp;i!=r) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 不连通，不存在最小树型图</span>in[root]=<span class="hljs-number">0</span>;        <span class="hljs-comment">// 根没有入边</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans+=in[i];            <span class="hljs-comment">// 直接累计边权</span><span class="hljs-type">int</span> x=i;<span class="hljs-keyword">while</span>(v[x]!=i&amp;&amp;!id[x]&amp;&amp;x!=root) v[x]=i, x=pre[x];            <span class="hljs-comment">// 标记能够访问到的点，如果访问回来了，那么就找到环了</span><span class="hljs-keyword">if</span>(x!=root&amp;&amp;!id[x]) &#123;id[x]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=pre[x];y!=x;y=pre[y]) id[y]=cnt;                <span class="hljs-comment">// 所有换上节点标记为第几个环</span>&#125;&#125;<span class="hljs-keyword">if</span>(!cnt) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 没有环，直接结束</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!id[i]) id[i]=++cnt;        <span class="hljs-comment">// 不在环中的点，自成一个“环”，便于统计</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> u=e[i].u, v=e[i].v;e[i].u=id[e[i].u], e[i].v=id[e[i].v];            <span class="hljs-comment">// 缩点，将每条边的两个端点改为它们所属的环编号</span><span class="hljs-keyword">if</span>(u!=v) e[i].w-=in[v];            <span class="hljs-comment">// 不是自环，进行减权操作</span>&#125;n=cnt, root=id[root];        <span class="hljs-comment">// 修改信息</span>&#125;<span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回答案</span>&#125;</code></pre></div><h2 id="题目">题目</h2><p><a href="https://www.luogu.com.cn/problem/UVA11865">UVA11865 StreamMy Contest</a></p><p>二分答案。</p><p>二分最小带宽 <spanclass="math inline">\(mid\)</span>，判断是否能用带宽不小于 <spanclass="math inline">\(mid\)</span> 的边构成一棵花费不超过 <spanclass="math inline">\(cost\)</span> 的最小树型图。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long </span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>, M=<span class="hljs-number">10005</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> T, n, m, len, tot, cost, root, in[N], pre[N], v[N], id[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> u, v, w, b; &#125; t[M], e[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">zhuliu</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) in[i]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])in[e[i].v]=e[i].w, pre[e[i].v]=e[i].u;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==inf&amp;&amp;i!=root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));<span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(id));in[root]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans+=in[i];<span class="hljs-keyword">if</span>(ans&gt;cost) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> x=i;<span class="hljs-keyword">while</span>(v[x]!=i&amp;&amp;!id[x]&amp;&amp;x!=root) v[x]=i, x=pre[x];<span class="hljs-keyword">if</span>(x!=root&amp;&amp;!id[x]) &#123;id[x]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=pre[x];y!=x;y=pre[y]) id[y]=cnt;&#125;&#125;<span class="hljs-keyword">if</span>(!cnt) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!id[i]) id[i]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> u=e[i].u, v=e[i].v;e[i].u=id[e[i].u], e[i].v=id[e[i].v];<span class="hljs-keyword">if</span>(u!=v) e[i].w-=in[v];&#125;n=cnt, root=id[root];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;tot=n, len=<span class="hljs-number">0</span>, root=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(t[i].b&gt;=x) e[++len]=t[i];ll ans=<span class="hljs-built_in">zhuliu</span>(tot,len);<span class="hljs-keyword">return</span> ans&lt;=cost&amp;&amp;ans!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> l=inf, r=<span class="hljs-number">0</span>, mid;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;cost);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;t[i].u,&amp;t[i].v,&amp;t[i].b,&amp;t[i].w);++t[i].u, ++t[i].v;l=<span class="hljs-built_in">min</span>(l,t[i].b), r=<span class="hljs-built_in">max</span>(r,t[i].b);&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(l)) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;streaming not possible.\n&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">while</span>(l&lt;r) &#123;mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d kbps\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div><p> </p><p><a href="https://www.luogu.com.cn/problem/P2792">小店购物</a></p><p>如果把所有要买的物品都买一次，那么剩下的物品就都能用最小价格买了。所以目标就是计算所有物品都买一次的花费。</p><p>如果买 <span class="math inline">\(u\)</span> 能把 <spanclass="math inline">\(v\)</span> 优惠到花费 <spanclass="math inline">\(w\)</span> 元，那么连一条 <spanclass="math inline">\((u \rightarrow v)\)</span>，权值为 <spanclass="math inline">\(w\)</span> 的边。同时将虚拟节点 <spanclass="math inline">\(n+1\)</span> 与每个物品连一条权值为原价 <spanclass="math inline">\(c_i\)</span> 的边。</p><p>虚拟节点目的是让图连通并符合题意，注意这里不能是0，因为在朱刘算法中，多个数组的 0 是未计算的状态。</p><p>这里的 <span class="math inline">\(n\)</span>是要买的商品总数，连完边后就多了一个虚拟节点，<spanclass="math inline">\(n\)</span> 要 变成 <spanclass="math inline">\(n+1\)</span>。边数 <spanclass="math inline">\(m\)</span> 就是要买的商品数与优惠的数量之和。</p><p>建完图后跑最小树型图，最后在加上剩下的物品就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">60</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, root, mp[N], c[N], pre[N], id[N], v[N];<span class="hljs-type">double</span> ans, a[N], in[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> u, v; <span class="hljs-type">double</span> w; &#125; e[N*N];<span class="hljs-function"><span class="hljs-keyword">inline</span> edge <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">double</span> w)</span> </span>&#123;edge e;e.u=u, e.v=v, e.w=w;<span class="hljs-keyword">return</span> e;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">zhuliu</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) in[i]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])in[e[i].v]=e[i].w, pre[e[i].v]=e[i].u;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==inf&amp;&amp;i!=root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));<span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(id));in[root]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;ans+=in[i];<span class="hljs-type">int</span> x=i;<span class="hljs-keyword">while</span>(v[x]!=i&amp;&amp;!id[x]&amp;&amp;x!=root) v[x]=i, x=pre[x];<span class="hljs-keyword">if</span>(x!=root&amp;&amp;!id[x]) &#123;id[x]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=pre[x];y!=x;y=pre[y]) id[y]=cnt;&#125;&#125;<span class="hljs-keyword">if</span>(!cnt) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!id[i]) id[i]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> u=e[i].u, v=e[i].v;e[i].u=id[e[i].u], e[i].v=id[e[i].v];<span class="hljs-keyword">if</span>(u!=v) e[i].w-=in[v];&#125;n=cnt, root=id[root];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> t1, t2;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t1);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t1;++i) &#123;<span class="hljs-type">double</span> x; <span class="hljs-type">int</span> y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-keyword">if</span>(y) mp[i]=++n, a[n]=x, c[n]=y;&#125;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t2);m=n+t2;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) e[t2+i]=<span class="hljs-built_in">trans</span>(n+<span class="hljs-number">1</span>,i,a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t2;++i) &#123;<span class="hljs-type">int</span> u, v; <span class="hljs-type">double</span> w;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lf&quot;</span>,&amp;u,&amp;v,&amp;w);u=mp[u], v=mp[v];<span class="hljs-keyword">if</span>(!u||!v) <span class="hljs-keyword">continue</span>;a[v]=<span class="hljs-built_in">min</span>(a[v],w);e[i]=<span class="hljs-built_in">trans</span>(u,v,w);&#125;++n, root=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=a[i]*(c[i]? c[i]<span class="hljs-number">-1</span>:<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,<span class="hljs-built_in">zhuliu</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最小树型图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3489 WIE-Hexer 题解</title>
    <link href="/2022/lg3489-solution/"/>
    <url>/2022/lg3489-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>预处理出每个铁匠能够打造的剑能够打败的怪物集合 <spanclass="math inline">\(s(x)\)</span> 与每条道路上的怪物集合 <spanclass="math inline">\(u(x)\)</span>。还是正常连边。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 为从起点到节点 <spanclass="math inline">\(i\)</span>，能够打败的怪物集合为 <spanclass="math inline">\(S\)</span> 时，花费的最小时间。状态是一张图，用Dijkstra 算法转移。</p><p>边界自然是 <span class="math inline">\(f(1,s(1)=0)\)</span>。考虑<span class="math inline">\(x\)</span> 的子节点 <spanclass="math inline">\(y\)</span>，<span class="math inline">\(i\)</span>为 <span class="math inline">\(x \rightarrow y\)</span> 的边。如果 <spanclass="math inline">\(u(i)\)</span> 中包含 <spanclass="math inline">\(S_x \cup s(x)\)</span> 中不包含的元素，那么在<span class="math inline">\(x\)</span>打造的剑和之前的剑就不能打败路上的怪物，不能转移。更数学一点，若 <spanclass="math inline">\(S_0 =S_x \cup s(x)\)</span>，<spanclass="math inline">\(S_0 \cup u(i) \neqS_0\)</span>，那么不能转移。然后就是板子了。</p><p>答案：第一次到达 <span class="math inline">\(n\)</span>时的最小时间。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">6005</span>, O=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">13</span>)+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, p, k, ans=inf, d[N][O], s[N];<span class="hljs-type">int</span> cnt, h[N], ver[M], nxt[M], w[M], u[M];<span class="hljs-type">bool</span> v[N][O];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123; <span class="hljs-type">int</span> x, y, z; &#125;;<span class="hljs-comment">// 节点编号，集合，最小时间</span><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.z&gt;b.z; &#125;priority_queue&lt;node&gt; q;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z,<span class="hljs-type">int</span> s0)</span> </span>&#123;    ver[++cnt]=y, w[cnt]=z, u[cnt]=s0, nxt[cnt]=h[x], h[x]=cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));    d[<span class="hljs-number">1</span>][s[<span class="hljs-number">1</span>]]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>((node)&#123;<span class="hljs-number">1</span>,s[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>&#125;);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().x, s0=q.<span class="hljs-built_in">top</span>().y;        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(x==n) &#123; ans=d[x][s0]; <span class="hljs-keyword">break</span>; &#125;        <span class="hljs-comment">// 答案</span>        <span class="hljs-keyword">if</span>(v[x][s0]) <span class="hljs-keyword">continue</span>;        v[x][s0]=<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> S=s0|s[x];        <span class="hljs-comment">// 造完剑后的集合</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-type">int</span> y=ver[i], z=w[i];            <span class="hljs-keyword">if</span>(v[y][S]||(S|u[i])!=S) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 已经到达或不合法</span>            <span class="hljs-keyword">if</span>(d[y][S]&gt;d[x][s0]+z) &#123;                d[y][S]=d[x][s0]+z;                q.<span class="hljs-built_in">push</span>((node)&#123;y,S,d[y][S]&#125;);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;p,&amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;        <span class="hljs-type">int</span> u, v, w;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);        <span class="hljs-keyword">while</span>(v--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w), s[u]|=<span class="hljs-number">1</span>&lt;&lt;(w<span class="hljs-number">-1</span>);        <span class="hljs-comment">// 预处理一定要-1</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-type">int</span> x, y, z, u, v, w=<span class="hljs-number">0</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;u);        <span class="hljs-keyword">while</span>(u--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v), w|=<span class="hljs-number">1</span>&lt;&lt;(v<span class="hljs-number">-1</span>);        <span class="hljs-built_in">add</span>(x,y,z,w), <span class="hljs-built_in">add</span>(y,x,z,w);    &#125;    <span class="hljs-built_in">dijkstra</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans!=inf? ans:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>最短路</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2403 所驼门王的宝藏 题解</title>
    <link href="/2022/lg2403-solution/"/>
    <url>/2022/lg2403-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>把能够到达的宫室连边。</p><p>具体地，对于一个横天门，将它与同一行中的普通点连单向边，横天门连双向边。对于一个纵寰门，将它与同一列中的普通点连单向边，纵寰门连双向边。对于一个任意门，向周围的8 个点连单向边（前提是不越界）。</p><p>由于只要到达一个强连通分量里，周围的点都能到达，所以求出所有强连通分量，缩点。点权为改强连通分量中点的个数。然后DP 最长路就行了。</p><p>这题主要是实现麻烦。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;, dy[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-type">int</span> k, n, m, num, top, scc, ans, x[N], y[N], op[N], dfn[N], low[N], stk[N], c[N], ccnt[N];<span class="hljs-type">int</span> cnt, h[N], ver[M], nxt[M];<span class="hljs-type">bool</span> v[N];map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp[N];vector&lt;<span class="hljs-type">int</span>&gt; a[M], b[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=a[i].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(op[a[i][j]]==<span class="hljs-number">1</span>) &#123; x=a[i][j]; <span class="hljs-keyword">break</span>; &#125;        <span class="hljs-comment">// 找到了一个横天门</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(x!=a[i][j]) &#123; <span class="hljs-built_in">add</span>(x,a[i][j]); <span class="hljs-keyword">if</span>(op[a[i][j]]==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(a[i][j],x); &#125;        <span class="hljs-comment">// 连边</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, len=b[i].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(op[b[i][j]]==<span class="hljs-number">2</span>) &#123; x=b[i][j]; <span class="hljs-keyword">break</span>; &#125;        <span class="hljs-comment">// 找到了一个纵寰门</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(x!=b[i][j]) &#123; <span class="hljs-built_in">add</span>(x,b[i][j]); <span class="hljs-keyword">if</span>(op[b[i][j]]==<span class="hljs-number">2</span>) <span class="hljs-built_in">add</span>(b[i][j],x); &#125;&#125;        <span class="hljs-comment">// 同上</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;++j) &#123;<span class="hljs-keyword">if</span>(mp[x[i]+dx[j]].<span class="hljs-built_in">find</span>(y[i]+dy[j])!=mp[x[i]+dx[j]].<span class="hljs-built_in">end</span>())<span class="hljs-built_in">add</span>(i,mp[x[i]+dx[j]][y[i]+dy[j]]);    <span class="hljs-comment">// 如果是任意门，那么找有没有对应的位置，有的话连边</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;++scc; <span class="hljs-type">int</span> y;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc, ++ccnt[scc]; <span class="hljs-keyword">while</span>(x!=y);        <span class="hljs-comment">// c[x]: x属于哪个强连通分量</span>        <span class="hljs-comment">// ccnt[x]: x这个强连通分量有多少个节点</span> &#125;&#125;<span class="hljs-type">int</span> tc, hc[N], vc[M], nc[M];<span class="hljs-type">int</span> f[N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">suodian</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=k;++x) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(c[x]!=c[y]) <span class="hljs-built_in">addc</span>(c[x],c[y]);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=scc;x;--x) &#123;f[x]+=ccnt[x];ans=<span class="hljs-built_in">max</span>(f[x],ans);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hc[x];i;i=nc[i]) &#123;    <span class="hljs-type">int</span> y=vc[i];f[y]=<span class="hljs-built_in">max</span>(f[x],f[y]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x[i],&amp;y[i],&amp;op[i]);a[x[i]].<span class="hljs-built_in">push_back</span>(i), b[y[i]].<span class="hljs-built_in">push_back</span>(i);        <span class="hljs-comment">// a为同一行，b为同一列。</span>mp[x[i]][y[i]]=i;        <span class="hljs-comment">// map记录(x,y)的节点编号</span>&#125;<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-built_in">suodian</span>();    <span class="hljs-built_in">dp</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>强连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4766 Outer space invaders 题解</title>
    <link href="/2022/lg4766-solution/"/>
    <url>/2022/lg4766-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><div class="note note-info">            <p>本文重写于 2023.8.27</p>          </div><p>把每个外星人的存活时间看成是区间，那么本题又可以转化成那种经典模型。</p><p>区间的贡献在交点上。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为消灭被 <spanclass="math inline">\([i,j]\)</span> 完全包含的所有区间的最小代价。</p><p>我们肯定是找到 <span class="math inline">\(d\)</span>最大的那个区间一发干掉。</p><p>枚举干掉它的时间，以这个为轴，划分子问题 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">605</span>;<span class="hljs-type">int</span> T, n, m, t[N], f[N][N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> l, r, d;&#125; a[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lsh</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-t<span class="hljs-number">-1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].l=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,a[i].l)-t;a[i].r=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,a[i].r)-t;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;m=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;a[i].l=<span class="hljs-built_in">read</span>(), a[i].r=<span class="hljs-built_in">read</span>(), a[i].d=<span class="hljs-built_in">read</span>();t[++m]=a[i].l, t[++m]=a[i].r;&#125;<span class="hljs-built_in">lsh</span>();<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=m;++l) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=m;++i) &#123;<span class="hljs-type">int</span> j=i+l<span class="hljs-number">-1</span>;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) <span class="hljs-keyword">if</span>(i&lt;=a[k].l&amp;&amp;a[k].r&lt;=j) &#123;<span class="hljs-keyword">if</span>(a[k].d&gt;a[x].d) x=k;&#125;<span class="hljs-keyword">if</span>(!x) &#123; f[i][j]=<span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=a[x].l;k&lt;=a[x].r;++k) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i][k<span class="hljs-number">-1</span>]+a[x].d+f[k+<span class="hljs-number">1</span>][j]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][m]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA12170 Easy Climb 题解</title>
    <link href="/2022/uva12170-solution/"/>
    <url>/2022/uva12170-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>老样子，先判断无解情况。</p><p>我们假设 <span class="math inline">\(h_n\)</span> 无限高于或者低于<span class="math inline">\(h_1\)</span>，那么中间的那些都必须尽力去逼近<spanclass="math inline">\(h_n\)</span>，一定是递增或递减的。但由于相邻的两堆石头高度差不能超过<span class="math inline">\(d\)</span>，所以递增或递减的最大长度为 <spanclass="math inline">\((n-1) \cdot d\)</span>。如果 <spanclass="math inline">\(|h_n-h_1| &gt; (n-1) \cdotd\)</span>，那么肯定是无解。反过来想，如果不大于，那么一定存在合法的构造方法，即一定有解。</p><p>手算以下不难发现，对于每一个 <spanclass="math inline">\(i\)</span>，都有 <span class="math display">\[h_i&#39; \in [\max{(h_{i-1},h_{i+1})-d,\min{(h_{i-1},h_{i+1})+d}}]\]</span> 那么如果 <span class="math inline">\(h_i\)</span>不在区间内，将其变为距离它最近的区间边界是最优的，因为差值最小。</p><p>如果 <span class="math inline">\(h_i\)</span>在区间内，那么可以让它不变，这样贡献为 0。</p><p>如果这样去做了，那么对于每个 <span class="math inline">\(h_i&#39;\)</span>，都能写成 <span class="math inline">\(h_x+kd \quad (x \in[1,n],k \in [-n,n])\)</span> 的形式。</p><p>感性证明一下，如果改变 <span class="math inline">\(h_i\)</span>的值，那么一定是在某个现有的 <span class="math inline">\(h_i\)</span> 或<span class="math inline">\(h_i&#39;\)</span> 的基础加上过减去 <spanclass="math inline">\(d\)</span>；如果不改变，令 <spanclass="math inline">\(k=0\)</span>即成立。严格证明可以用归纳法，这里不再赘述。</p><p>所以所有可能的值的个数为 <spanclass="math inline">\(2n^2\)</span>，记为 <spanclass="math inline">\(a\)</span>。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 堆石头，第 <spanclass="math inline">\(i\)</span> 堆的高度为 <spanclass="math inline">\(j\)</span> 时，所需要的最小代价。</p><p>边界</p><p><span class="math display">\[f(i,j) = \begin{cases}0 &amp; i=0,j=h_1\\\inf &amp; \text{otherwise}\end{cases}\]</span></p><p>转移</p><p><span class="math display">\[f(i,j) = \min \limits_{j-d \le k \le j+d} { \{ f(i-1,k)+ |a_i-j| \} }\]</span></p><p><span class="math display">\[f(i,j) = \min_{j-d \le k \le j+d} { \{ f(i-1,k) \} } + |a_i - j|\]</span></p><p>滚动数组+单调队列优化即可。</p><p>最终答案 <span class="math display">\[ans= \max{\{ f(n-1,i) \}} \quad |h_n-i| \le d\]</span></p><p>由于 <span class="math inline">\(j\)</span>这一维值域过大，具体实现时可以离散化，这一维存下标。</p><p>状态数 <span class="math inline">\(n^2\)</span> 个，决策 <spanclass="math inline">\(n\)</span> 个，转移 <spanclass="math inline">\(O(1)\)</span>，总复杂度 <spanclass="math inline">\(O(n^3)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=N*N*<span class="hljs-number">2</span>;<span class="hljs-type">int</span> t, n, m, d, h[N], q[M];ll ans, a[M], f[<span class="hljs-number">2</span>][M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-n;j&lt;=n;++j) <span class="hljs-keyword">if</span>(h[i]+j*d&gt;=<span class="hljs-number">0</span>) <span class="hljs-comment">// 高度不会小于0</span>            a[++m]=h[i]+j*d;    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>);    m=<span class="hljs-built_in">unique</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>)-a<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-built_in">lower_bound</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>,h[i])-a;    <span class="hljs-comment">// 离散化去重，现在和h[i]存的是原来h[i]在a中的位置。</span>&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-number">0</span>, ans=<span class="hljs-number">1e15</span>;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<span class="hljs-built_in">i</span>&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;h[i]);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(h[<span class="hljs-number">1</span>]-h[n])&gt;(n<span class="hljs-number">-1</span>)*d) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// 无解</span>    <span class="hljs-built_in">init</span>();    <span class="hljs-type">int</span> p=<span class="hljs-number">1</span>;    f[<span class="hljs-number">0</span>][h[<span class="hljs-number">1</span>]]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i) &#123;        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>, l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;a[q[l]]&lt;a[j]-d) ++l;            <span class="hljs-comment">// 排除不合法（越界）的决策。</span>            <span class="hljs-keyword">while</span>(k&lt;=m&amp;&amp;a[k+<span class="hljs-number">1</span>]&lt;=a[j]+d) &#123;                ++k;                <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[p^<span class="hljs-number">1</span>][q[r]]&gt;=f[p^<span class="hljs-number">1</span>][k]) --r;                <span class="hljs-comment">// 维护决策单调增</span>                q[++r]=k;            &#125;            <span class="hljs-keyword">if</span>(l&lt;=r) f[p][j]=f[p^<span class="hljs-number">1</span>][q[l]]+<span class="hljs-built_in">abs</span>(a[h[i]]-a[j]);            <span class="hljs-comment">// 队头即使最优决策。</span>        &#125;        p^=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[h[n]]-a[i])&lt;=d)        ans=<span class="hljs-built_in">min</span>(ans,f[p^<span class="hljs-number">1</span>][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);t--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1336 修缮长城 题解</title>
    <link href="/2022/uva1336-solution/"/>
    <url>/2022/uva1336-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="分析">分析</h2><p>将多游修理点按照位置递增排序。由于经过一个点便会立即修复它，所以每次被修复的点一定是一个连续的区间。由于修完一个区间后处于左右端点有后效性，要加进状态里。这样状态就出来了。</p><p>不难发现，最终答案能转化为每个点立即修复的花费+增长的花费。我们只计算后者就好了。</p><p>设 <span class="math inline">\(f(i,j,p)\)</span> 为修完区间 <spanclass="math inline">\([i,j]\)</span>，处于 <spanclass="math inline">\(p\)</span> 时增长的最小花费。<spanclass="math inline">\(p=0\)</span> 时在 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(p=1\)</span> 时在 <spanclass="math inline">\(j\)</span>。</p><p>对于要修理的区间 <span class="math inline">\([i,j]\)</span>，<spanclass="math inline">\([1,i-1] \cup [j+1,n]\)</span> 都会增长 <spanclass="math inline">\(\frac{|x_j-x_j|}{v}\)</span> 个 <spanclass="math inline">\(\Delta\)</span>。所以我们将 <spanclass="math inline">\(\Delta\)</span> 求出前缀和数组 <spanclass="math inline">\(g\)</span>，这样就可以快速计算这个区间外增长的量。即<span class="math display">\[F(x_i,x_j,i,j) = \frac{|x_i-x_j|}{v} \cdot g(n) - [g(j)-g(i-1)]\ \quad i\le j\]</span> 特别地，当 <span class="math inline">\(i=j=0\)</span> 时 <spanclass="math display">\[F(x_i,x_j,0,0) = \frac{|x_i-x_j|}{v} \cdot g(n)\]</span> 转移显然有两种，对于区间 <spanclass="math inline">\([i,j]\)</span>，一是转移到 <spanclass="math inline">\([i-1,j]\)</span>，二是转移到 <spanclass="math inline">\([i,j+1]\)</span>。再加上分别增长的量就好了。下面定义当<span class="math inline">\(p=0\)</span> 时，<spanclass="math inline">\(P=x_i\)</span>，反之 <spanclass="math inline">\(P=x_j\)</span>。 <span class="math display">\[f(i,j,p) = \min \begin{cases} f(i-1,j,0)+F(P,x_{i-1},i,j)\\f(i,j+1,1)+F(P,x_{j+1},i,j)\end{cases}\]</span> 开始先找到 <span class="math inline">\(X\)</span>左右的两个点，分别转移到这两个点上，取最小值就是答案了。</p><p>转移的时候注意判断边界。</p><p>最后看代码吧。</p><p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1006</span>, inf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>);<span class="hljs-type">int</span> t, n;<span class="hljs-type">double</span> v, x, sum, ans, f[N][N][<span class="hljs-number">2</span>], g[N];<span class="hljs-type">bool</span> vis[N][N][<span class="hljs-number">2</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">O</span> &#123; <span class="hljs-type">double</span> x, c, d; &#125; s[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(O a,O b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">double</span> x1,<span class="hljs-type">double</span> x2,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">double</span> dlt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;j&gt;<span class="hljs-number">0</span>) dlt+=g[j]-g[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">return</span> (g[n]-dlt)*<span class="hljs-built_in">fabs</span>(x2-x1)/v;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>&amp;&amp;j==n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">double</span>&amp; w=f[i][j][p];    <span class="hljs-keyword">if</span>(vis[i][j][p]) <span class="hljs-keyword">return</span> w;    vis[i][j][p]=<span class="hljs-number">1</span>, w=inf;    <span class="hljs-type">double</span> x=(p? s[j].x:s[i].x);    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>) w=<span class="hljs-built_in">min</span>(w,<span class="hljs-built_in">dp</span>(i<span class="hljs-number">-1</span>,j,<span class="hljs-number">0</span>)+<span class="hljs-built_in">F</span>(x,s[i<span class="hljs-number">-1</span>].x,i,j));    <span class="hljs-keyword">if</span>(j&lt;n) w=<span class="hljs-built_in">min</span>(w,<span class="hljs-built_in">dp</span>(i,j+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)+<span class="hljs-built_in">F</span>(x,s[j+<span class="hljs-number">1</span>].x,i,j));    <span class="hljs-keyword">return</span> w;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    sum=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf&quot;</span>,&amp;s[i].x,&amp;s[i].c,&amp;s[i].d);        sum+=s[i].c;    &#125;    <span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) g[i]=g[i<span class="hljs-number">-1</span>]+s[i].d;    s[<span class="hljs-number">0</span>].x=-inf, s[n+<span class="hljs-number">1</span>].x=ans=inf;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(x&gt;s[i<span class="hljs-number">-1</span>].x&amp;&amp;x&lt;s[i].x) &#123;        ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">dp</span>(i<span class="hljs-number">-1</span>,i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+<span class="hljs-built_in">F</span>(x,s[i<span class="hljs-number">-1</span>].x,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));        ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">dp</span>(i,i,<span class="hljs-number">0</span>)+<span class="hljs-built_in">F</span>(x,s[i].x,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(<span class="hljs-type">int</span>)(ans+sum));&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf%lf&quot;</span>,&amp;n,&amp;v,&amp;x)&amp;&amp;n;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa1443 Garlands 题解</title>
    <link href="/2022/uva1443-solution/"/>
    <url>/2022/uva1443-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>先判断无解的情况。</p><p>由于每一段都要非 0 的偶数朵花，那么当 <spanclass="math inline">\(n\)</span> 为奇数时显然无解。</p><p>用 <span class="math inline">\(m\)</span> 个点固定，就是分成了 <spanclass="math inline">\(m-1\)</span> 段。每个半段不能超过 <spanclass="math inline">\(d\)</span> 朵，那么总数最多为 <spanclass="math inline">\(2 d \cdot (m-1)\)</span>，最少为 <spanclass="math inline">\(2 \cdot m\)</span>。所以当 <spanclass="math inline">\(n\)</span> 大于最大值，小于最小值时，无解。</p><p> </p><p>题目要求最小的半段重量的最大值，可以二分答案。我们定义 <spanclass="math inline">\(check(x)\)</span> 为半段重量最大为 <spanclass="math inline">\(x\)</span> 时，能否划分成 <spanclass="math inline">\(m-1\)</span> 段。</p><p>可以用 DP 来判断。设 <span class="math inline">\(f_i\)</span> 为前<span class="math inline">\(i\)</span>朵花在满足限制的情况下最少分成多少段？不行。不难发现，奇数段只能从偶数段转移而来，偶数段只能从奇数段转移而来。不记录奇偶性的话会产生后效性。</p><p>所以设 <span class="math inline">\(f_{i,j}\)</span> 为前 <spanclass="math inline">\(i\)</span>朵花在满足限制的情况下最少分成多少段，且段数奇数或偶数。当 <spanclass="math inline">\(j=0\)</span> 时为偶数，<spanclass="math inline">\(j=1\)</span> 时为奇数。</p><p>边界 <span class="math display">\[f_{i,j} = \begin{cases}0 &amp; i = j = 0 \\\inf &amp; otherwise\end{cases}\]</span> 转移。这个就比较显然了。 <span class="math display">\[\begin{cases}f_{i,0} = \min{ \{ f_{j,1} + 1 \} }\\f_{i,1} = \min{ \{ f_{j,0} + 1 \} }\end{cases}\]</span> 其中 <span class="math inline">\([j+1,i]\)</span>这一段有偶数朵花且不超过 <span class="math inline">\(2d\)</span>。</p><p>如果 <span class="math inline">\(m\)</span>是奇数，最终一定有偶数段，如果 <span class="math inline">\(m\)</span>是偶数，最终一定有奇数段。所以答案为 <spanclass="math inline">\(f_{n,(m-1) \% 2}\)</span>。</p><p>具体实现中要考虑半段的变化，最好结合 pdf 里的图看看。</p><p>复杂度 <span class="math inline">\(O(n^2 \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e4</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> t, n, m, d, s[N], f[N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(f));    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(j&lt;=d)&amp;&amp;(j&lt;=i/<span class="hljs-number">2</span>);++j) &#123;    <span class="hljs-comment">// 保证i是偶数。 j是半段长度，保证它不超过d与i/2</span>        <span class="hljs-keyword">if</span>(s[i]-s[i-j]&gt;x) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 靠后的半段超重了，随着j的增加它的重量单调增</span>        <span class="hljs-comment">// 所有的j都不能满足条件了，所以直接跳过这个i</span>        <span class="hljs-keyword">if</span>(s[i-j]-s[i<span class="hljs-number">-2</span>*j]&gt;x) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 长度为j的半段超重了，但随着j的增加它会整体向后移动</span>        <span class="hljs-comment">// 可能还有满足条件的半段，直接往后找</span>        f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(f[i][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-2</span>*j][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);        f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-2</span>*j][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> f[n][(m<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]&lt;=m<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    s[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;d);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,w;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w);        s[i]=s[i<span class="hljs-number">-1</span>]+w;    &#125;    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>||n&gt;<span class="hljs-number">2</span>*d*(m<span class="hljs-number">-1</span>)||n&lt;<span class="hljs-number">2</span>*(m<span class="hljs-number">-1</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;BAD&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=s[n], mid;    <span class="hljs-keyword">while</span>(l&lt;r) &#123;        mid=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);t--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3959 宝藏 题解</title>
    <link href="/2022/lg3959-solution/"/>
    <url>/2022/lg3959-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="这题我只想称之为神">这题我只想称之为神</h3><p>最优解中，开凿的道路一定联通，且一定是一棵树。这是因为如果最终不连通，那么显然不符合题意；如果最后不是一棵树，那么删去若干一条边后，不仅仍然可能连通，而且会减少代价。</p><p>暴搜显然不合适，那就考虑状压 DP。</p><p>DP 需要一定的顺序。和树形 DP一样设子树信息为状态？不行，一开始并不是一棵树，直接 pass掉。节点编号？也不行，根本转移不动。考虑到最后求出的实际上是一棵生成树，那么可以用生成树高度作为顺序，将免费打通的节点看作根。</p><p>于是就有了状态。设 <span class="math inline">\(f(i,S)\)</span>为联通的节点集合为 <spanclass="math inline">\(S\)</span>，当前生成树高度为 <spanclass="math inline">\(i\)</span>时，需要的最小代价。由于可以免费打通一个点，不难想到边界为 <spanclass="math display">\[f(i,S) = \begin{cases}0 &amp; i=1, |S|=1 \\\infty &amp; \text{otherwise}\end{cases}\]</span> 设全集为 <span class="math inline">\(U\)</span>，答案为 <spanclass="math inline">\(\min \limits_{i \in [1,n]}{ \{ f(i,U) \}}\)</span></p><p> </p><p>接下来就是转移了。显然，设 <span class="math inline">\(S_0 \subseteqS\)</span>，一定能从 <span class="math inline">\(f(i-1,S_0)\)</span>转移到 <span class="math inline">\(f(i,S)\)</span>。</p><p>因为不管高度为 <span class="math inline">\(S_0\)</span>的这一棵树是怎么打通的，只要打通 <spanclass="math inline">\(S-S_0\)</span> 中的所有点，就一定能够达到 <spanclass="math inline">\(S\)</span> 这个状态。我们可以枚举每一个子集 <spanclass="math inline">\(S_0\)</span>，然后将这个状态加上转移所需要的最小代价，满足最优子结构性，这样一定是正确的。</p><p>代价怎么计算呢？道路长度可以贪心地选择最小的。由于是按照树高由低到高的顺序计算，所以经过的节点数就是<code>i-1</code>。那么所有新打通的边的<span class="math inline">\(K\)</span> 都是相同的（就是题目中的 <spanclass="math inline">\(K\)</span>）。所以设 <spanclass="math inline">\(d(i,j)\)</span> 为状态 <spanclass="math inline">\(i\)</span> 转移到状态 <spanclass="math inline">\(j\)</span> 的最小边权和。</p><p>转移为 <span class="math display">\[f(i,j) = \min \limits_{k \subseteq j} { \{ f(i-1,k)+ (i-1) \cdot d(k,j)\} }\]</span> <span class="math inline">\(d(i,j)\)</span>可以直接预处理，参考下面代码。</p><h3 id="复杂度分析">复杂度分析</h3><p>预处理要枚举子集，枚举能够打通的点，复杂度为 <spanclass="math inline">\(O(n^23^n)\)</span>。</p><p>DP 时要枚举树高，枚举子集，复杂度为 <spanclass="math inline">\(O(n3^n)\)</span>。</p><p>总复杂度为 <span class="math inline">\(O(n^23^n)\)</span>。</p><p>当然你也可以用 预处理完一个 <spanclass="math inline">\(d(i,j)\)</span> 后马上转移 来降低常数。</p><p>不过这也完全足够了，而且看着思路很清晰。</p><p>关于如下枚举子集的两个循环复杂度为何是 <spanclass="math inline">\(3^n\)</span>，这里不做赘述。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j;j=(j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>)</code></pre></div><h3 id="code">code</h3><p>这题实现并不显然，注意代码，具体看注释。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">13</span>, M=<span class="hljs-number">1</span>&lt;&lt;N, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> n, m, U, ans=inf, a[N][N], f[N][M], d[M][M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;    <span class="hljs-built_in">SET</span>(a,<span class="hljs-number">0x3f</span>), <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        a[x][y]=a[y][x]=<span class="hljs-built_in">min</span>(a[x][y],z);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=U;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j;j=(j<span class="hljs-number">-1</span>)&amp;i) &#123;        <span class="hljs-type">int</span> fg=<span class="hljs-number">1</span>, u=i^j;        <span class="hljs-comment">// j这个循环意思是枚举i的所有子集</span>        <span class="hljs-comment">// u是j关于i的补集，就是j-&gt;i要打通的节点集</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k) <span class="hljs-keyword">if</span>((u&gt;&gt;k)&amp;<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 枚举u的每一位，如果是1的话就找到达这个节点的最短边</span>            <span class="hljs-comment">// 这个点记为a</span>            <span class="hljs-type">int</span> t=inf;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o=<span class="hljs-number">0</span>;o&lt;n;++o) <span class="hljs-keyword">if</span>((j&gt;&gt;o)&amp;<span class="hljs-number">1</span>)            <span class="hljs-comment">// 枚举j的每一位，如果是1的话，就记录这个点到达p的边权</span>            <span class="hljs-comment">// 记为b，取b-&gt;a的最小值</span>                t=<span class="hljs-built_in">min</span>(t,a[o+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 注意这里o和k都是要+1的，因为上面枚举的是二进制位。</span>            <span class="hljs-keyword">if</span>(t==inf) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;            <span class="hljs-comment">// t=inf 不存在b-&gt;a的边</span>            d[j][i]+=t;            <span class="hljs-comment">//直接累加</span>        &#125;        <span class="hljs-keyword">if</span>(!fg) d[j][i]=inf;        <span class="hljs-comment">// 不存在的话，自然是inf了</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">init</span>(), <span class="hljs-built_in">pre</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>&lt;&lt;i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 预处理</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=U;++j)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j;k;k=(k<span class="hljs-number">-1</span>)&amp;j)        <span class="hljs-comment">// 枚举树高，状态以及它的子集</span>            <span class="hljs-keyword">if</span>(d[k][j]!=inf) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][k]+(i<span class="hljs-number">-1</span>)*d[k][j]);    <span class="hljs-comment">// d[k][j]!=inf 可以转移</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,f[i][U]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans); <span class="hljs-comment">// 很友好，不会爆int</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3092 No Change 题解</title>
    <link href="/2022/lg3092-solution/"/>
    <url>/2022/lg3092-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>直接设状态为花费的钱数是不行的，硬币的使用顺序与购买顺序都会影响答案，复杂度爆炸。</p><p>设 <span class="math inline">\(f(S)\)</span> 为使用的硬币为 <spanclass="math inline">\(S\)</span> 时，最多能买的物品个数。</p><p>对于 <span class="math inline">\(S_0 \subseteqS\)</span>，显然能够转移，但方程并不是一个简单的多项式。</p><p>不难发现，枚举 <span class="math inline">\(S\)</span>的子集是不行的，不能直接转移，且复杂度过高。那就考虑枚举硬币。</p><p>对于一个集合 <spanclass="math inline">\(S\)</span>，枚举枚举其中每一个硬币用或不用。设<span class="math inline">\(S_0\)</span> 与 <spanclass="math inline">\(S\)</span> 中只相差 <spanclass="math inline">\(j\)</span> 这个硬币，那么 <spanclass="math inline">\(S_0 = S \text{ xor } 2^{j-1}\)</span>，余出来的<span class="math inline">\(c_j\)</span> 的钱就可以继续往后买。设 <spanclass="math inline">\(t(i,j)\)</span> 为用 <spanclass="math inline">\(j\)</span> 的钱，从 <spanclass="math inline">\(i\)</span>开始往后买，最多能买到第几个物品。所以转移为 <spanclass="math display">\[f(S) = \max{ \{ f(S),t(f(S_0),c_j) \} }\]</span> 用前缀和搞一下物品数组，显然 <spanclass="math inline">\(t(i,j)\)</span> 是可以二分的。</p><p>这一部分复杂度为 <span class="math inline">\(O(2^k \cdot k \log_2n)\)</span></p><p>还是可以的（</p><p> </p><p>考虑如何计算答案。</p><p>设 <span class="math inline">\(g(S)\)</span> 为使用的硬币为 <spanclass="math inline">\(S\)</span>时的最小花费。显然可以采用与上面差不多的转移方式。</p><p>注意到 <span class="math inline">\(lowbit(x)\)</span> 可以提取出<span class="math inline">\(x\)</span> 的二进制表示中最后一个 1以及后面的 0。</p><p>举个例子</p><blockquote><p><span class="math inline">\((x)_2 = 011010\)</span></p><p><span class="math inline">\(lowbit(x) = (10)_2 = 2\)</span></p></blockquote><p>这正好对应了「去掉最后一个硬币」。由于不找零，所以能够直接暴力累加钱数。且因为我们设计了这样的状态，一个状态最多买多少物品是一定的，只需要计算出这些目标状态需要的钱数（也就是<span class="math inline">\(f\)</span> 的限制）。故可以从 <spanclass="math inline">\(g(S-lowbit(S))\)</span> 转移到 <spanclass="math inline">\(g(S)\)</span>。</p><p>由于 <span class="math inline">\(lowbits\)</span> 运算只能得到 2的整数次幂，那么我们可以将每个硬币与一个二进制位建立映射关系。</p><p>不难想到转移为 <span class="math display">\[g(S)=g(S-lowbit(S))+c_{lowbit(S)}\]</span> 最终答案为 <span class="math display">\[ans = \max{\{ sum_c - g(i) \}} \quad f(i) = m\]</span></p><p>注意实现。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">17</span>;<span class="hljs-type">int</span> n, m, orz, U, ans=<span class="hljs-number">-1</span>, c[N], sum[<span class="hljs-number">100010</span>], f[<span class="hljs-number">1</span>&lt;&lt;N], g[<span class="hljs-number">1</span>&lt;&lt;N], p[<span class="hljs-number">1</span>&lt;&lt;N];<span class="hljs-comment">// ans要初始化为-1</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lb</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;(-x); &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">erfen</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> v)</span> </span>&#123;    <span class="hljs-type">int</span> l=s, r=m, mid, pos=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(l&lt;=r) &#123;        mid=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(sum[mid]-sum[s]&lt;=v) pos=mid, l=mid+<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> pos;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i]), orz+=c[i], p[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)]=i;    <span class="hljs-comment">// p建立的映射为: c[1]-&gt;二进制最低位，c[2]-&gt;二进制倒数第二位，以此类推</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x), sum[i]=sum[i<span class="hljs-number">-1</span>]+x;    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=U;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)&amp;i) &#123;        <span class="hljs-type">int</span> t=<span class="hljs-built_in">erfen</span>(f[i^(<span class="hljs-number">1</span>&lt;&lt;j)],c[j+<span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span>(t!=<span class="hljs-number">-1</span>) f[i]=<span class="hljs-built_in">max</span>(f[i],t);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=U;++i) &#123;        g[i]=g[i^<span class="hljs-built_in">lb</span>(i)]+c[p[<span class="hljs-built_in">lb</span>(i)]];        <span class="hljs-keyword">if</span>(f[i]==m) ans=<span class="hljs-built_in">max</span>(ans,orz-g[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa1099 Sharing Chocolate 题解</title>
    <link href="/2022/uva1099-solution/"/>
    <url>/2022/uva1099-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>设 <span class="math inline">\(f(x,y,S) = 0/1\)</span>为当前巧克力长为 <span class="math inline">\(x\)</span>，宽为 <spanclass="math inline">\(y\)</span>，选出的 <spanclass="math inline">\(a_i\)</span> 集合为 <spanclass="math inline">\(S\)</span> 时，能否成功分割。</p><p>这样状态数有 <span class="math inline">\(xy \cdot 2^n\)</span>个，过多。</p><p>设集合 <span class="math inline">\(S\)</span> 中元素的面积和为 <spanclass="math inline">\(sum_S\)</span>。仔细观察不难发现：能够分割成功，当且仅当<span class="math inline">\(sum_S = xy\)</span>。</p><p>所以我们就可以只计算满足以上条件的状态。并且在满足以上条件的状态中，知道<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 其中一个就能直接计算出另一个。</p><p>所以设 <span class="math inline">\(f(x,S) = 0/1\)</span>为当前巧克力较短（较长也可以）边长为 <spanclass="math inline">\(x\)</span>，选出的 <spanclass="math inline">\(a_i\)</span> 集合为 <spanclass="math inline">\(S\)</span> 时，能否成功分割。</p><p> </p><p>先考虑特殊情况。</p><p>设全集为 <span class="math inline">\(U\)</span>，集合 <spanclass="math inline">\(S\)</span> 中面积的和为 <spanclass="math inline">\(sum_S\)</span>。若 <spanclass="math inline">\(sum_U \neq xy\)</span>，那么无解。</p><p>如果在有解的情况下，集合 <span class="math inline">\(S\)</span>中只有一个元素，那么一定有解。</p><p>  再考虑转移。</p><p>设 <span class="math inline">\(S_0 \subseteq S\)</span>。</p><p>考虑到如果 <span class="math inline">\(S\)</span> 有解，那么 <spanclass="math inline">\(S_0\)</span> 一定有解，并且 <spanclass="math inline">\(S - S_0\)</span> 也一定优解。</p><p>那么转移的方法就呼之欲出了。</p><p>枚举 <span class="math inline">\(S\)</span> 的所有子集，设 <spanclass="math inline">\(x_0= \min{ \{ x,sum_{S_0}/x\} }\)</span>，<spanclass="math inline">\(x_1 = \min{ \{ x,sum_{S_1}/x\} }\)</span>。</p><p>这里进行一下数学分析……</p><blockquote><p>已知 <span class="math inline">\(sum_S =sum_{S_0}+sum_{S_1}\)</span>，<span class="math inline">\(sum_s =xy\)</span>，显然 <span class="math inline">\(x \midsum_S\)</span>。</p><p>但 <span class="math inline">\(x\)</span> 不一定都整除 <spanclass="math inline">\(sum_{s_0}\)</span> 和 <spanclass="math inline">\(sum_{s_1}\)</span>。举个例子：</p><p><span class="math inline">\(x=2, y=5\)</span></p><p><span class="math inline">\(xy = 5+5=10\)</span></p><p><span class="math inline">\(x \nmid 5\)</span></p><p>这样就会转移到错误状态。</p><p>可以通过「切一刀后有一条边长不变」来理解。</p></blockquote><p>所以为了达到正确的状态，求出 <span class="math inline">\(y= sum_S /x\)</span>，<span class="math inline">\(y_0,y_1\)</span> 同上。</p><p><span class="math display">\[f(x,S) = \begin{cases}1 &amp; f(x_0/y_0,S_0) = f(x_1/y_1,S_1)=1 \\0 &amp; \text{otherwise}\end{cases}\]</span></p><p>这里的斜杠是“或”的意思。</p><p>最终答案即为 <span class="math inline">\(f(\min{\{x,y\}},U)\)</span>，直接记忆化搜索就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">16</span>, M=<span class="hljs-number">105</span>;<span class="hljs-type">int</span> _, n, x, y, U, a[N], sum[<span class="hljs-number">1</span>&lt;&lt;N], f[M][<span class="hljs-number">1</span>&lt;&lt;N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x) a+=(x&amp;<span class="hljs-number">1</span>), x&gt;&gt;=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> s)</span> </span>&#123;    <span class="hljs-keyword">if</span>(f[x][s]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][s];    <span class="hljs-comment">// f[x][s]=-1 表示未计算</span>    <span class="hljs-type">int</span>&amp; dlt=f[x][s];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cnt</span>(s)==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 特判只有一个元素的集合</span>    <span class="hljs-type">int</span> y=sum[s]/x;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s0=(s<span class="hljs-number">-1</span>)&amp;s;s0;s0=(s0<span class="hljs-number">-1</span>)&amp;s) &#123;        <span class="hljs-type">int</span> s1=s^s0;        <span class="hljs-keyword">if</span>(!(sum[s0]%x)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(x,sum[s0]/x),s0)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(x,sum[s1]/x),s1)) <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!(sum[s0]%y)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(y,sum[s0]/y),s0)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(y,sum[s1]/y),s1)) <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 被x或y整除才去计算这个状态</span>    &#125;    <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f)), <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sum));    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;s&lt;=U;++s) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(s&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) sum[s]+=a[i+<span class="hljs-number">1</span>];    <span class="hljs-comment">// 预处理所有集合的sum</span>    <span class="hljs-type">bool</span> fg;    <span class="hljs-keyword">if</span>(sum[U]!=x*y) fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> fg=<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(x,y),U);    <span class="hljs-comment">// 特判</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %s\n&quot;</span>,++_,fg? <span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5858 Golden Sword 题解</title>
    <link href="/2022/lg5858-solution/"/>
    <url>/2022/lg5858-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>设 <span class="math inline">\(f_{i,j}\)</span> 为放入第 <spanclass="math inline">\(i\)</span> 个原料，炼金锅中共有 <spanclass="math inline">\(j\)</span> 个原料时的耐久度之和。</p><p>边界 <span class="math display">\[f_{i,j}= \begin{cases}0 &amp;  i=0,j=0 \\-\inf &amp; \text{otherwise}\end{cases}\]</span> 考虑 <span class="math inline">\(j\)</span>的取值范围。因为最少一个也不拿走，最多拿走 <spanclass="math inline">\(s\)</span> 个，锅中最多有 <spanclass="math inline">\(w\)</span> 个原料，所以对于状态 <spanclass="math inline">\(f_{i,j}\)</span> 的一个决策 <spanclass="math inline">\(k\)</span> <span class="math display">\[j-1 \le k \le \min{\{w,j-1+s\}}\]</span> 转移为 <span class="math display">\[f_{i,j}=\max{\{ f_{i-1,k} + a_i \times j\}}\]</span> 答案为 <span class="math inline">\(\max{\{ f_{n,i} \}} \quad i\in [1,w]\)</span></p><p>交上去，光荣地 TLE 了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e3</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> n, w, s;ll ans=<span class="hljs-number">-1e15</span>, a[N], f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;w,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=w;++j) f[i][j]=<span class="hljs-number">-1e15</span>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=w;++j) &#123;        <span class="hljs-type">int</span> t=<span class="hljs-built_in">min</span>(w,j<span class="hljs-number">-1</span>+s);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j<span class="hljs-number">-1</span>;k&lt;=t;++k) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][k]+a[i]*j);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=w;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><p>考虑优化。</p><p>注意原转移方程中，<span class="math inline">\(a_i\times j\)</span>是个定值，将其提出后，我们要做的就是快速查找 <spanclass="math inline">\(\max{\{ f_{i-1,k} \}}\)</span></p><p>使用单调队列维护 <span class="math inline">\(f_{i-1,k}\)</span>单调减，队首即为最优决策。用 <span class="math inline">\(q_l\)</span>表示队首，则转移方程为 <span class="math display">\[f_{i,j}=\max_{j \in [1,\min(i,w)]}{\{ f_{i-1,j-1},f_{i-1,q_l} \}}\]</span> 前者为「不拿走」，后者为「拿就拿波大的」</p><p>注意，为了保证队列中的决策都是 <spanclass="math inline">\(f_{i-1,j}\)</span> 时状态， <spanclass="math inline">\(j\)</span> 这一维必须倒序循环。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e3</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> n, w, s, l, r, q[N];ll ans=<span class="hljs-number">-1e15</span>, a[N], f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;w,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=w;++j) f[i][j]=<span class="hljs-number">-1e15</span>;    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-built_in">min</span>(i,w);j;--j) &#123;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;j<span class="hljs-number">-1</span>+s&lt;q[l]) ++l;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[i<span class="hljs-number">-1</span>][q[r]]&lt;f[i<span class="hljs-number">-1</span>][j]) --r;            q[++r]=j;            f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][q[l]])+a[i]*j;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=w;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022.1.1</title>
    <link href="/2022/mz/"/>
    <url>/2022/mz/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ab2e4f328bd9203913839c1d91b9a83fd3ba0ba1624d52d09b7ba6947292cccb">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bc5b7cd4f87baec3fd3e832a2262ad5bb4e54a69e5f79e2740b28436eb16a625322cf7c44f48a3dfef555fa1fa5c0374a4807959f4e79b8434393459190babd54289591efdc243d37e5fd015e9f5d41ea293f4e0ce207aa1662340e999e17e7862bf9dccdee6661d1152dea597bcefc21f864249576fac1fca28774fb86b481ffed27de5ab17032179518e27bb4cb35c032dbbbccbae0d9b20bffc505b36d9f80ae7e885222bb362bc3f3333c36c1dcff03789b373ff740af6ab6c6c951c2f4a8f6bf69724f6adf7e3eacf9cb8eb1f7a6768abe28e9c47851d00014da77ddc01e85b781a6873522e148751d4ec8475c892e40c74204e0e742ba0012b72bf7705529ebf87cefa4bcecac68a7490a03e0903075b9b560a8cc86be8a8007b78832115043870f5109715eb0229920e451e5a6af683aab3cb70396e18cdf1f5f8a46ea1569be89e5b5d30711cadf3850576cc6050fcc77a55e9f62c25fd069da7e6cc10e055b765e65d97214559eb45430848298d647aea4498d5313f12b8f08b48701f466bd96fd17eab29b739c91d14c96001a4da8c989e567f65f32582ca07e76a315110783ffb5fded0083db72a0429528b36ceeaf8d2f0cc22985be4fc7f653b3bdf00dea9333d55483c94881aa4e8c805ced41bd8a86a2688c9609184cd714e856b37abe3431698cdee49c976568bcff8ea6700b9601b6aeec86dabe56894ec138ae5ca10e8a4b7450ac2fd40320f9ccac9981bd395c731c5a1dbdd868bcf3e93eb56e0f765d7e15b5e1abc994477d6c17705eda43624d9476f36597db8e613128afcd9e5d8fcdf60bb5da559cbdc4e7bbfee87852891d511200214ad9614c613e7cb961ef8b24141aaa35dd97b09aca0a712541ce2f84ef6f1f84432817c41510e0997be77567600a83a6ea6fb6b81319a2eace6151bf6cc66e918d26558720426b7530e23cf356bbbc4dd40dbefa17df3a3ab68c18fa33920b01ba4e0e7a924af21031e2845f2fb6e551386df67012fd68492b0528ee291951f948b1c11937791708fa2fd78dff556ead793374a608e9384b803830a5365a7d848952a3d4890bba1f8dbf69e6985201bf3c4759b50d1a5f77c948ecc06ac55ae0f1d4eeb9669ea0ee2c0d077486803886c64ef28d54e50d0ca01ae4db11d931de552c94dd9a7a233217700cc5d9606500e30ad47d803cf72b50922b6cd722777db79529eefda766c2d7b16a9572a37bf440c412acf21738dd40a6996d38075637321828eac88c7ddbb813f78d2167d686c078e1897d50a6211a079b7df79cc0fa177359b888841a146481ef6f4147ed588d4d3b38f1d116e28ecefeb945abb6c518886b584b660e166de49b1aa8b51a2eb36f996ef0b6f14e2282bb36d08c97247d11e41b96503fc15ca12cff0ade90af8bf8f151ecb5e0214d857f286b57acb0817e7b9755f6914be15b04a0a74b6ac913ebc6ad74c1b4da75035e25d077ae9145dfd5455ea919f64642f312a52a196ab47e2281e49e1485493c0e89987315756666181a4c0800a146ec8f9f2bb8522c9d545817720248a2ea25b1584fdf613c5dc007c7320a330109b291c667c675bb5a09f9ddb7fa950622480041bbec2e70cda8cfc2f33eecdf9de262924c121236c49ce605951c556503e566c475e3a137e05e1b751778002f2cd4fe81b991ba183310c587cbc174f6c1a3f261411a092a9760e563a1f69e82d28495a3c474d9653bebab5635a4c67ba4ae89d580791b72f371eb1cb68e51ed22e18e16c6d3a4e3c5dc20442dad7fb0308e436cfef954b33a3c9a74278b8f1b4fb125ed9ff2abf202cd79f62a8a4269c7023b97377a914ecd19078d1c5c08a4d565ebb055c3cd60340136ff75a07e333fb8d16dec6c5950f9ad79d16b1a6d6e3bc00380f71b095d127797c5db7ac62d208c107acab1fdcb9503490b775ebf1a0df14e8a40eedd858dc34b885c9bee794131405b2a934062192acc3237ca5abab222ff7144bcbd330152cfd34776c8424307806aa51356f32cfa73d8dd801a4a375d304c9a51bdd3392ccebd4935e384c0f4cd8132ef3330c3564c913122ccb5dec310abf01cacec2c7f83d9f3c764ce0d59aa22c6479be1f31e383c235def69a7ac35b40f465fc3caa5a1a9aa139c6a0525eafb204788f93977915b56b48a72dd9515eae256308d05a7af7ca7f837235ebe884df5f4c9652514b1d9c9c7d51442195509dda2ac557db19680aa32ff3566350ad528a03c0c51b889ce346627a2544d3eb55bc0f997df4c7cd9b419a120988db0a773ce91b83098115326aee216006cae71adaba26913cad1f4a017dc90e8fbc4e6466d29ee7db71cc0ac6c48461b92e8c3d44997033b515195a59042a4f55a6e25d854e0356cd677644c2e5da9f345dae7379d3b5e325c7bf8736d9f04e851489a1fa9318637448b182ce18530c6262c53f7dc1b61fc84556201b4e9f1413def228b1d368e7fb57084037a774d69a18dbd5fe80b4de3a84eb7d2268f16acba47777be0affd1866c67f7c501ddf46df2a4426af40f4fd8b9eddfc85097ab9175b1b730ae812fe5d0056c5d8703a6148c8670a45d64b380c4bc0a2662c860537fa90f44ef1221c5a516ffd860495a889f0d98fba0e5bb4dca60dd3cac7f0ea092fc59e6cf25ba94c55b1bd2880bb075cfed91b9168922c3a9ab2b24e00a806125ad54ccf5e3d38e7f626e892fa7c4fc9f91b08f488df171107799e0309a748b285bc230d88bc600b3f5a536779650a3805bafbceca256db247a6e1acf596f4e84eeefdaf31c28f91c91b369d8466ba685e338bc47f0c06e6ad5f1d510e4957ca641c4b6eff53477cdfbdf74b0d0a95b88703bb6340b5e8f3f01cc3591333e41b0f1aebc05ec2a800b86225e4350bb5a69002a5ae64bf30651ebce58e0ec13cd96a40d304bfd6e5707def597b3d8200e6c5c90cfd7db126237a6f20ba77b0dcb3c1c55158f4b807e2054b09c45871dee1a3ea59ac7a0e785888257e2c500f3028598ee1efcecc01fa7bb950edd7ed5db88bdd80abff4f3c08388a2838d413c36cd35b56b86e3bb5f54c5c1d23b8c8719dfb0b679e41a35ddb1b00ea22cfd71eb99b5b4d03929d66eecb4e7837555366685f98d1f021a0a5a29dc28c30a2228b81ceca2eb5b948824b67fc17d67dbc92003a6066881244c3d595854a934efb91783e73ea7266320b0697f5fd038a0b62fe92d1cb3ee5ce48d3552b0bf11256a42d7ca128d42cb211006c23388cd786a4dc5051058edbc052dc0de6265bbd12dbabd98b84b9a052d7b16dda908b9672bbfa9fc14af80142f1f8215c6801e8322f8b8b047c86db756b4e0f306d2224c0ae9dc18026978c1b0ef4622d12a97220f868bfe8ae896123cda9a853f870b1e3bc4b500a458497687446f9fd4a84f041a46bc7b36963e5220d31fb6cf3348a1757129f67d15af739a29501a35132e90c2c8f1bd80ed2270ba9d5808462c6093d0d50cbee9c8593aa3cf5b89831a2b7a56337902c4af708fdaccc7feeefdf7373715b57384ea743c05cdde7364331e53c0c8f81d30f4196d616b8f81050da162a9167e517ca7c2e243fc5102d998bb01a5149a81f86b49d3899f552dc466ab3765c1b5b942273baa74905db6150db6bbd2c9c5ca22669b7d12e9731dd5a968eaef87fafcae1d11dc833ee31db45</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dec. 4th Sat 2021</title>
    <link href="/2021/dec4th/"/>
    <url>/2021/dec4th/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0553f204f694143da35eaf90e3203d88c0f75103ed202b070da3fe1bb0dae367">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836c6c7931b62e770091bb48b927e8625849c05e40a270112dcaaff732cfecd1be4aacee19d102564c90eaf45c78112f727c534269b0b42f97e53396e2026eb940adac77f7b995a7e4bece5c9ce8c797595579d4e9e6a570dfff5aed29d110afff3cb2d16d89f1e2409705924eececeae31d5076d0ad30f76bed0b3acf19febb0f80a12a516206094d618b184de86ea09c752158adeb19cc1277983dde8a13cf54b777d530aab765870f42e2a14eb33afa6b282c5ec47dced12aba38da6794ca748a83b93d8f9f4f004ae0765e949e7f6e55957d239deacc329fbf909829d3b411d700af333a9c907c28e9aa3c13fb4fb47fa33ebc22e6732bab167e18cb0fbec64909c7ca2dc0f60a6a081fa714d34abe6a41c553d6b74471b94f3bc65fe69d3f39af381ee0e44a6567e8efdf07578ccefefab0de7a4d0038c99af7c223fdfaa752950dd3afeece30e4bcb66d28f797db0f264804cb3ef52d64ed783e0337fe5e04c22e4b198b2884541d59f0b6f78a445b476f3b2951a1f84f4d64ac2084a5514c4fcc92d36c47ea642976bcb9e5ac1ccc1b931f605a0c550b975a1902ff60bcfc23df442cd5b1dbe00dd9fec35d7b0d0d1a2bf1b105430a8a178809b7f57227515f9e1fe0bd6ec390296bc60aba080e6774e64656455958ab364d2e0e9bcc7df617d136b0ef97cf4d91b659879392411ad04dda93588001dd546775b867b3186d39dc40b474e837b1cc40b1b2c0b177a23156ec25966402c704411d5474ab14f4a8588ff12b7cda199b98b7fd486cb1176cb3e35534f69a6ef30e6bbb73241c58fdeaaee7da105bed29d5d584561b120ce3b4167457554bd83a3d3cd3e23bfa3c5374540ef3bb3c694fe2d3a2d3b83de120442e38ae8f932d8a812ee6cb4a921</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于OI，不知所言</title>
    <link href="/2021/oi/"/>
    <url>/2021/oi/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9f3585e22a66836443551219f8cc985ce9c1d2fb7bdd196264f2a6a9b16d681b">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bc5b7cd4f87baec3fd3e832a2262ad5bb4e54a69e5f79e2740b28436eb16a625322cf7c44f48a3dfef555fa1fa5c0374a4807959f4e79b8434393459190babd54289591efdc243d37e5fd015e9f5d41ea293f4e0ce207aa1662340e999e17e7862bf9dccdee6661d1152dea597bcefc21f864249576fac1fca28774fb86b481ffed27de5ab17032179518e27bb4cb35c032dbbbccbae0d9b20bffc505b36d9f80ae7e885222bb362bc3f3333c36c1dcff03789b373ff740af6ab6c6c951c2f4a8f6bf69724f6adf7e3eacf9cb8eb1f7a6768abe28e9c47851d00014da77ddc01e85b781a6873522e148751d4ec8475c892e40c74204e0e742ba0012b72bf7705529ebf87cefa4bcecac68a7490a03e0903075b9b560a8cc86be8a8007b7883211e4cd484fa834899315ebfe4993c91793f2eb5df6d6a71e33c18b06345fd20311dcf5437e5dfeec08d66367b3c2de4345f48c136a75c05da794936aeb2b80d91e87e28530e75f383c2d92fd132ad254048c3789a04c0b6a337393c4537abd2352cedb8771b3b67d275f6c82bce97959e3d8f1784d064c7edf0c8eb5786352797aad34d26bdfc2061e7d80f123be3dd72aa60524460b1ac33b9b5c4ee3c175c531d4838631129f971f21c87e17a3eb23cc1c67e850c7f3cc698184cee32aea5b622a1325c9daf5478c49d756226d56ac2f9344c327b7f74a9cf724c327b5d65c22f9599097ce2bd2210de05526d64f1d8a3e625a192274fc5d768d1cf375076a6f8b49e50be95af8b5d6cd49e8660766a0419ec855a55d790174cdcb31f267a61b2c80ee5816be1423376d3dcb770002baad90941933c6cb21f59659979fdb0294bf4ae1147bb3835c24192e616a156064c8999f00b384f453225313137e84585fe286f37b77ef505fcca47358513db57eefeb3dfaf78228fb75cdbafb34434e6aae4c67c98208a6e6ecf070142142fd1e2ce3f40758ba7753c5ab408bca01ec28d3aae81dd512a00c3930e5650344c02bb96edb2a6ae2e9c9a46b03800a592255a44452e17309c5447acf80c800f9fe5bc5f4cde3ba27c1b807526b65bf78396fe80b8cfbd61d761493d2b72e7eab4adeb93371fc07037e8e5e047b3ba883e20d59cf2fd1f6f34e8da855382624c460405f68e7d9e0b412fbe8e3edd719a39b5315a3defc3a4df50202ff23b002219679f78959c935fc76912668372a33790da063d784b36b8dafc600476297928ecbc4b83e6dcdf53b71610d1265f11f87aea7eb142a3cfaafe595c48bad557622b7fb4d53716810fd2ec999b6071d06442c4dca299670bf80b574ce063c399e7389c7e37b2c357980bfa4e38c331e5727cf4517e62bf6e368759de1efb7e48e88add1394481ff64a933935ff6cfca7ce403e67f397c5e8b791e07879e0c2a888e7b985c655389ab3393fff485aac477cd978db2760b0ca7d8b7980caa77cf1c79ba11bac444bd2cc9e4507ab28a8577ec41dd7ce9ae5f1e66c3b4a992215b2e5debdbdc248d889f2df3458d46e3c07d47f0fac9e848b6ac6986d228c7363f3b4eef4362bf7448b9ff6e14b11ea21b73969573b238de7b1117a485ee029daafad09abc5fabf39b16ef51cca23f1924375aa3181f7d3535045fc3c458dcebe5495695a5a9ed84ba5bd2a0491a0241d3a1a032724fc4db27a6030b2399a833412267b44da1658d9846047b9e8e2558ff27ec4ae60835d386fa9348d4a225c1bc17dedd7a6915b65288032dbc6be670d544053f07743e06a3ab50c099daed4bebcca9d4ef7cb1d66bfe4966d8369ac699e8439d53b94d894b848657845b2508420df6d1afc80a783883ea26b307a6458d4966fc03e4586d4d53c133800d3f86dcdd6ff789ee3383292014fd7419e8203dba7c67d1eee66d2337e1d9a6a8e53857354303df35d461b5d68924971d1ea6111533e200f03286e0953d12dabd3573917bf351bbf3fd1adff2c6c4d8016bf8587e9a63e2d01083ad60efc9a54d0b309b663d4535ed8e861c00a13fda0f2fc43fb2d8e154b9f7f0e5cc61e62b383a52c792f5654bd4a56b87284febda119103becda586e82e64270cf9bcb0c52c1a4676d7f2ab747ec82080d8167ce56ba9e5921e25f74cd50adc098bebdc34b817069b90c527f5e76d59d5a510c6d8665c2b55d255a2b7610736607a7ef5d59ad255c5260beb1ceea01a8a45efb1bc8926c8c3a38c9e95e1df720a6f2e44e2112f12fb5e09b95d21d47037d60a34f2435fcf01dfca031f215a3296c2e06cc44ac5ee7b1419a5a973eb5cd3b6bde165b0ce9351bda01e40e18b6587f7c67a33539a029ba59314e53dd33d22bd24e151d2d9cc03b21ce44bd5f50962f92f545643289f29bdc6009c7745ab68abc812a985b803cebb4e148f36ebef844759630b29f9580656b96604f288c1e8a09122c9c33edee304e2e974ef7d8f81ec52af32411200609e846c0e49588c6f7a56d0137e1a761fa237fee6ecb66416f1fd188918423cd3992559a4a6bf1f1d1bfb0ed5d0fefd15ee5b53363174633fa12c8786cfefa51dec6bd19aa7414d747cdac187eabf2cae18105ab3760d0f4b8cbdcf5408026b98441ba768806efe600ff2b645f20367256e9904e630a0f96795426ac692776d2e0cabf7b6cba69e98368f580eb7638a835590de8bdef47cd6fc9e6c959c4e975709db26e4539bb94b7969982b82c30da0c972c14972e8b863ae49b6685076d1c6aa6fb19c3f32d0a876c3fcdf678799fe0fb05d44a0685f94211430086bbdb27205d92ca4e8d4475b1489fdd79d2d2c6837ceec1503d0cbf86bc9e24a7c614eab473bcbd675c3c94c00f9aeb05ab9efec5e079b7ea20a4498ed0379cf6228cc12b6f255c38ca2f07d2978c4fd1fe9c1a2588fd8a949e350b937397f88e997aab98030f57471f31aa87b21c25e8ebb1fda6fef5f19f9fef3bac560735ba8b7b54dd7ea0ea42b888b3916430959349d576c8e1246f611b363b25330eedbbfa750df935594b6e621979502a5de2e26f5a90410f408aff55fafd5d4ce1cf9985cc1b6759ff535d2de168970dbb3e4d4e27507057a981a1c7dd753fba7dbffdccfbc92a402f7497876b0b95a1f9c2a5af97bc4a3ad44016ecd1c0ee0258f102aa8046b3a83fc374cb62923394bad5c1e6917d597d81bcc7bd8f610539cc304d1cfbb695d629c2a4fbc98d17f1fcaf0c296fd526f43698df7b31062abe41d413e0205363133ba9f9a8dbc68662d8ea657afd3dcae695ad1b3fd99be33715b4bb1cb53151dd9956c9b1e618bcbf8e0e252857275268bb86ac3eeb44b5784290ec511d28a5639ebc73bc67918535b72cc1b30b5302217d9dc418e59d998ed6ef3defefa5e338d741c20ac60af57e5bce9dabc85a5610380552184d7f7403ad67839cc50c8d4df8b5b0a40fcca08f1725350419d94e044a234098db9ed808d1184964ee9f39cc504ccc9b47f1ce8f67f393a8b181975f9ee8fcffbb16edbb02c47a7d482ff9e2a31ed32dfd1d301b1a25623aaff21435ca920add63cad195637d4a53952a721734a40c97264147cbc262e7665b3b81510d93106121ad5ce00200c719cc6fc4be5f7f5febcc77df14b047edd3483c18740384b9b082e888252c6c5e1e6529ffbe5155c001c67fd885058c62f0bcf30f25b817c9ddb71d9f94fc0805a78c5bc60e6fb38b5e8b0b0cffac94830adf54973267c3d34dfe6450c5ffbd65fa367df94dcaf5d2ee34ffebecbcfbbde81e34e8441e50cb80eebd358a78c00b0ebd16a91e46f56da2037f9e951e6b5d9ef5d6ab4812ffcc15dd4ed1cf0e3cd102dd66aff93bfa5ebdd0b2d361f72ed059e502e686bda49edacee3b9663da3258552cb38891eacb3752504c8d567342f54bfced11b30395518673fd2d00c69707b66f4e7b3617dd8472bb6819bd6bd7b721e7496c593dc0e70bea883b5629c313255cb5beaa0cb08bafe6cff42aec5a82e5cf5f70aa49685baf5c9430aca02cb970332964c0e70ce1c55488076099f8b712d3a3a7a46d040350b207177060f020f0f44c18d8365c915070c27708959954e9e89c3e0c6993e820413cd7927767baee669266e3fada478da9ba54e4590e43a19d1189f1cf84b9b019e4b40d065d8eaa411c4fbff29ec23128e5e7295dd1ed8e07ad21e2de9416ab463a25a18a4cd793a0633ad7c77c415d6f66852ea2760c8698eb5e3f4fc65693f2348eb8e6be5a91074aa7f728f8e7d6fd08dd5e834452e46e21bb7abe872b863b5061d6140fce47f6d44e9f99aecec90096da807ff537b6b1a044993d10522708583fff573666d76aab17e6fc3dc687e8ad5bf40400e082d5baa217e2f5cd808ecb28e4d964f2449b28e7da96545a605787b90690bf047218b2973e3628584bc425f2b440efcbd276f01c891fd2aa0c43ae573583f7fcd30e7d0c9d6ec201e8b614ae4d699cd8c05822ecb2a3dcbe87ab4e1ceea622fe297c17ae3991536fd644b5dc876a2814f3fc16193ba49510f60a32b4093a877d6935eb7e97c162219105f690d3db3858810d9d1bba06275a908fadfcec587bae9e7c8f7b5750bb19373817bf216d6c62dfab9a63b0c4609ff7692446040e5e90ae7ec6e939669f389bca7ee548498f827c44b152d52ad693b5c4c5ee5791af262bea638bbc6b4b8e6c5fc79b0bbd11634b2d49afc08be0e644e28ad5d52b1f1c2092550b0891a5bc97c4821c1f53595ecdec5b2c3c0ce83c43dcd9d7ac3eab1d91ea798f3d0189c1d5bf65d529a32e0fe5c22832653036a666f9d12f4852aa41cc1207df49b71922ebac64ae999ce18e25f068343e5e6e69b87fc2e8e99781d9e2dd678246a737de63f29dcbc7b4dbcad186e1837a750702c778797cd80c7e8b8aee11faf5cbc265730fc8a0093d739ec5410297b68918e7ae3e93b77fbf2d6c83496b9a31f833db9686c2fb9674148b244800c43eafa1b37ef2904cadcb1a1a5193463c36ff7a77277da70eb73a0d6c5eb06c354e9c41d3ac643e1870609f77f421bdb02ee7ba7ed891bbdefbd7ccded13b2b401d1914ed38c0328e78b8941ad676a3668e0a3f93648c844cc40772e1f57a239361074868ac47ae7c12fdf53562b284fbbf26ab4300461ef6215ffe5354a1b4eb7011085480be15c3e1cce1b60e58d8fc9b804665d190c547749b57f048fdd1dfa2c4f1d443c092f6a79a18effccab9b9277fa572357492cb8fbe05aa2a71c0a68bfe8413192b17f3d5be805ce898b8c5eb5d774b7d22149704ec9ff04b315766286381af3997d281b99ede3253eecfea4eb861433cec47f4d6c97533581ab1af0c35a66fea92fc64dfcd9e744d530d837c6cf04ba7d8b4f6a45f649ea8be95b5d558b284edfc7c11bf62a2efee85585dfa960289f911918cb69a60081eb107ccc202aee21dda7ad6131163a34f7ffd49acb4b0e9ab5bbe8d925fd0452dbaf288b88cf9528f4c2b392e63d404a4fea058a8b2c7f495b987f6da9c1824078d97fbd29d076c0b822fc16980d25a8f4f4461b30c32d54e42def521cf844e420ff3fcede6673fa6023dbaae0104582c4ca42ff4ce0638435de685953db05c836d13d4f3a50dcbe5f3db9dd14858571ccd93fb17a3e2345bbfe30f82e12e58de048697231a41a39d55428e64e56cdac9540e24c5ad5b4302ce8590797ca5a024d95d3ebe4be250242bb11aa8d5e1fb7da464a1ebc865dd73c80d88dca9937c295f695448a7638ddd2e8302056aab76e3b1b6818e730115e3a2bb8f7f83561f58a8b4f7cf2a61d0a0837f50df708f98b6d274685bdadc0bb81c4f4907b5b029f531b53b4afc2f3c2674c4bfb033cc4d6c10351b9e0fbaff2bdff81e52e228179845b26a449042dabde6d16cdf87f0622042b842a17e26affde4d294c7962beedbf4fb0a48e13dc65a4f9ea35450037c67cdc83e581d51f85a40fba87a9ec3581af31ba268c61440a3369643ebb042c9d24f033e0704e66155ef2404c30a03e78923c3449bf9d6c5de27c68e73b48adce65af0307ff238cb66c159bac64d500061619a47f77c2b5ed723b2219017c0ae3bfe5f1b073690ee3301b28a5bed3e5004f1394bc33276a93db82352e090c3b4de4e49660dc7e1f6b1290d55d7eee0aa8fa8ca8ad1e07f496a19225e2eaf6e056e024b1baf329ec5fed4f5c2abef6e1e1aead07d65021a095cec7d8b791483679a570fdacaaec268a626fe1a5849459b419eb593888a5c8d42fb7daac6437d3c8cde0a24d3b2f2361b100834dbe38cf0aa9fad8f6b12bad798ef30a5858ec460a4e087d0728b6d50c946c10128d65cd669e82fe4523e948e6662cc5710a7582c6b176edaf8c0829a787a98f58f91b9c82cdbb3074c3e9a42cd8a0cd678dbc0cfec247478c944904e1b399c2bd9cb6af151095322cda79fdfef412d9ea2c28d069a8bd92e489b49a2e053a4523af16972e14389f0682eeda8708f266f188cd03d587d7bc29c5e45efa566c98ed96632772c36beeff2b569828ce6ee82d542becb54bffe058c0946c352a1e2a388a165f68e4a9dd9c4030f9a326f240717208ec1afdf2dbb978d0fad12b81e826be2c9b2a76c1f0cd3d193dc349d775c495640b30200ecec96c91416341b223b0d2f38f673e384f3e2f8a79f25a9578a9e86db7e3dc84c96de472d34be7a9a080167a6c3a5a03648e9f65a0a29fd2083371226669df5efede05d021bc3147c42792c5c24033dc40e3658ffd863adf3e34ba54b9248167381ede806abf02f8f4d9cb01196fcab3df65bbca9c5dab0b9ca57e868a4a551d49276cfa11c069a7ee226710081e07704b99666494167aa78c48bacb3155a1f4dab41f625392ae5df3990d8d66d9a42b3b8848faaeada8a8af76191ccd44d4fd9a4f9ede1ef5ee1166a0cdd0a651aebc553d3d68496e1c6660f01f8307ef1587cf8b7a542a1a130a52b7d74bb088ce84deedcbfeb7f9dc9fb464cc8daea12789a90f0c47c0f0da3130f4a0fdcd1ce00311390a0a94c0f39164838ff8e151abb1390404589b684aacb0606797e831c3f4f96d53723ef75f02a26b41cad2c3308e8b31bbae7470fd3e720a951aee5e8646da5a0c5dec993157bfaa82256882f6d126523820dec39b91404f185de6f6d98dd8743422b1c3a0d49a8613d00f50d84ca97740e6e8ecd1a68a3dfe892866e604c9368d05b79cd8a458a7bfc3caca29c54ac03ecb4db130086643573c7c00c17829ef5693ea8b5628b22b7bab83a5c5d043f27fecdd9a48494549f1b2e3d8801ca205d033fdf2cd9cd859468138468d19a944439e600f4760070dc3510bf1643e45fc6b27b5e5ebc0d33d92baa29e285a845e4d513cde4c57fad4ac87c716bdcc3f8de536f06926894fa97c85ac3306791703d3fc2dd398608ab2f284c8d64450d668f4f6222e1c671d3d57792b32918383bfb1d26ab05f97c1047e539c560f17108f8eb07bdd5b183b321f088881f04ee7d2046fdede2c7a61810d192c25117e1a26191b17931c601e270aac4fef4ceb8533684f5bd94f9224c7354058d9729b3213ff156c95c8e6cd932fdb9d46efe39617e1c33251353b21713c5a97612badc09ecf283e85100a83053c5dee1278dc77da63174e11aedd8650915224d2c6c4a25c8e095359a25fbe708430bc90ee6cc4d1ba96d0172f0df72db98e8bd082b3baec8aafb708dc2357d8efb9bb034d8d6cdff4784900c84dbbf96e2772320b1ea2ddcaecad006e75924ab156eead24b5f5bae0b4e7bb9b4bfc9ca3b3568670190e7d3c087b857e7edf788757af709e05fbc8c4b773251e23b0afc21071ed30e6e1a6346e91082d2c5924a9445670677a9aa4e10a76bfdfd101b651894a20ac0366bcbf44aedca0b2d317a57cfddcf2735204bc06b47b46ebc6ffc08a6192d2968736c22095fdf7290c8f80a0f7487fe66bfaaba07dce5c783ed0dc3a6b6cc4c5641577e602eec5ce7af2002fd9186bf06f6512d15d4de44aceb08fa4e5140aba3f2a0f7fd300bac4b41bad0ee5a6d35dbd515ca2169cba299bdd4d733214f915c45f99c5acc27a72cc07cf65ac43d0bced31c6775df718025d70c5b65e65896893d03423237d66fbb3caf7e6caefdd74a266a647836e4a6e3bf3ca2aa0d9c55c6c7bcbdbc03b326520ff69dbca91be3473a4c0fde8218744856ecd9a6d4041769a6de682732556bdfbb341581a7a91dfbdfe3b4ea9878cef155dfe8033ae556bc72f5b52ef2166bbffd0c7d1547cc572822d26ef3b60d16b53d21ee33fb7e0feacd06776bd992b011ff8c89e4c6e159eb997e90f77e78a1b4027a4af21b7a7e59c8f29361818db9cd8a25e241e71a552e63b253e8f4c636eaed3459152e8d9abc55dd5f1086deeeb373fd6650c27c878109c62124ed1bd2cc0bc45146a0b45b02a51e88c3a8ebc2ca67d5a81e6802c9722f26cce660a7cdefe855d7571e75735f26e62ce2b5f1794d58a6a40810dbeec4f4f8e20139bf051613d77fe83ad59532adbe1224</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3225 矿场搭建  题解</title>
    <link href="/2021/lg3225-solution/"/>
    <url>/2021/lg3225-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>本题思路还是比较清晰的。</p><p>显然的，求出 v-DCC 并缩点，然后判断方案数。</p><p>在本题中，可以只用 Tarjan 算法求出割点。标记割点，从其他的点依次DFS，统计每颗搜索树上割点的数量（不重复统计）。</p><p>若图中没有割点，那么图中任选两个节点都能满足条件，答案 $(2,C_n^2)$</p><p>若搜索树上割点为1，则由于树上两点之间有且仅有一条简单路径，所以这颗搜索树中一定至少选一个点，累加答案，累乘方案数。</p><p>若割点多于 1，那么对答案是没有贡献的。</p><p>因为无论哪一个点被破坏，该搜索树都会分裂成为上述两种情况。</p><p>这种做法实现细节较多。</p><p>姑且算是 $ O(n^2)$？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<span class="hljs-type">int</span> t, n, m, num, cnt, fg, ans1, dfn[N], low[N], v[N], w[N];<span class="hljs-type">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++c]=y, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    R <span class="hljs-type">int</span> i, y;    dfn[x]=low[x]=++num, v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;        y=ver[i];        <span class="hljs-comment">// v数组在一定程度上起到了dfn数组的作用，可以少清空一个数组</span>        <span class="hljs-keyword">if</span>(!v[y]) &#123;            <span class="hljs-built_in">tarjan</span>(y);            low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);            <span class="hljs-keyword">if</span>(dfn[x]&lt;=low[y]) ++v[x];        &#125; <span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);    &#125;    <span class="hljs-keyword">if</span>((x==<span class="hljs-number">1</span>&amp;&amp;v[x]&gt;<span class="hljs-number">2</span>)||(x&gt;<span class="hljs-number">1</span>&amp;&amp;v[x]&gt;<span class="hljs-number">1</span>)) v[x]=<span class="hljs-number">2</span>;    <span class="hljs-comment">// 1为普通点，2为割点。注意v[x]在上面已经初始化为1</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> z)</span> </span>&#123;    R <span class="hljs-type">int</span> i, y;    v[x]=<span class="hljs-number">114514</span>, ++cnt;    <span class="hljs-comment">// 放置重复搜索，统计节点数</span>    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;        y=ver[i];        <span class="hljs-keyword">if</span>(v[y]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(y,z);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[y]==<span class="hljs-number">2</span>&amp;&amp;w[y]!=z) ++fg, w[y]=z;        <span class="hljs-comment">// 防止搜索成环</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">SET</span>(v,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(w,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>);    c=ans1=n=<span class="hljs-number">0</span>, ans2=<span class="hljs-number">1ll</span>;    R <span class="hljs-type">int</span> i, x, y;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);        n=<span class="hljs-built_in">max</span>(n,<span class="hljs-built_in">max</span>(x,y));    &#125;    <span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// luogu给出的数据是联通的</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>,num=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(v[i]==<span class="hljs-number">1</span>) &#123;        fg=cnt=<span class="hljs-number">0</span>, ++num;        <span class="hljs-built_in">dfs</span>(i,num);        <span class="hljs-keyword">if</span>(fg==<span class="hljs-number">1</span>)  ++ans1, ans2*=cnt;        <span class="hljs-comment">// 从非割点搜索</span>    &#125;    <span class="hljs-keyword">if</span>(!ans1) ans1=<span class="hljs-number">2</span>, ans2=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %d %lld\n&quot;</span>,++t,ans1,ans2);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m)&amp;&amp;m) <span class="hljs-built_in">sol</span>(); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1967 货车运输 题解</title>
    <link href="/2021/lg1967-solution/"/>
    <url>/2021/lg1967-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>题目要求不超过限重，不难想到因该最大化每条路的限重。所以在原图上求出最大生成树。</p><p>对于点 <span class="math inline">\((x,y)\)</span>，如果在并查集中<span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 不在同一个集合，则 <spanclass="math inline">\(x\)</span> 不能到达 <spanclass="math inline">\(y\)</span></p><p>接下来就是每辆车最多运送的货物，不难想到最多运送的货物就是 $ (x y)$路径上权值最小的边。</p><p>如果用朴素的算法去求最小的边权，那么复杂度会上天，<spanclass="math inline">\(O(n)\)</span>。</p><p>联系我们对求 LCA的倍增优化，可以对求路径上最小的边权进行倍增优化。</p><p>设 <span class="math inline">\(d(x,k)\)</span> 为节点 x$ 到它的 <spanclass="math inline">\(2^k\)</span> 辈祖先这条路径上最小的边权。</p><p>接着不难想到转移 <span class="math display">\[d(x,k)=\min_{k \le \log_2n}{ \{ d(x,k-1),d(f(x,k-1),k-1) \} }\]</span> 可以在求 $ f$ 数组的同时求出。</p><p>所以，在求 LCA 的过程中不断维护路径上最小的 $ d(x,k)$。</p><p>这题毒瘤数据，给出的图不一定联通。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>, M=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, q, t, o;<span class="hljs-type">int</span> fr[N], f[N][<span class="hljs-number">20</span>], d[N][<span class="hljs-number">20</span>], dep[N];<span class="hljs-type">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], g[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">pt</span> &#123; <span class="hljs-type">int</span> u, v, w; &#125; a[M];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver[++cnt]=y, g[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fr[x]? x:fr[x]=<span class="hljs-built_in">get</span>(fr[x]); &#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pt a,pt b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.w&gt;b.w; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>,cmp);    R <span class="hljs-type">int</span> i, x, y;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        x=<span class="hljs-built_in">get</span>(a[i].u), y=<span class="hljs-built_in">get</span>(a[i].v);        <span class="hljs-keyword">if</span>(x!=y) &#123;            fr[x]=y;            <span class="hljs-built_in">add</span>(a[i].u,a[i].v,a[i].w), <span class="hljs-built_in">add</span>(a[i].v,a[i].u,a[i].w);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> pre)</span> </span>&#123;    R <span class="hljs-type">int</span> i, y;    dep[x]=dep[pre]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">17</span>;++i) &#123;        f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];        d[x][i]=<span class="hljs-built_in">min</span>(d[x][i<span class="hljs-number">-1</span>],d[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=pre) &#123;        y=ver[i];        f[y][<span class="hljs-number">0</span>]=x, d[y][<span class="hljs-number">0</span>]=g[i], <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    R <span class="hljs-type">int</span> i, res=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x)!=<span class="hljs-built_in">get</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;        <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) res=<span class="hljs-built_in">min</span>(res,d[x][i]), x=f[x][i];        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) &#123;        res=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(res,d[x][i]),d[y][i]);        x=f[x][i], y=f[y][i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(res,d[x][<span class="hljs-number">0</span>]),d[y][<span class="hljs-number">0</span>]);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-type">int</span> i, x, y;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) fr[i]=i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i].u,&amp;a[i].v,&amp;a[i].w);    <span class="hljs-built_in">kruskal</span>();    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!dep[i]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">lca</span>(x,y));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生成树</tag>
      
      <tag>最近公共祖先</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF372C Watching Fireworks is Fun 题解</title>
    <link href="/2021/cf372c-solution/"/>
    <url>/2021/cf372c-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="题外话">题外话</h2><p>前天英语考试，作文是</p><blockquote><p>假如你是李华，你的美国朋友 Jack对中国传统文化很感兴趣，他写信希望你能够告诉他有关春节的事情，请你写一封回信给他。开头和结尾已经给出，不计入总词数……</p></blockquote><p>然后因为做过这道题，我就记住了 Firework这个词，在这篇作文中竟然用上了（</p><h2 id="solution">solution</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为第 <spanclass="math inline">\(i\)</span> 个烟花 <spanclass="math inline">\(blooms\)</span> 时，在第 <spanclass="math inline">\(j\)</span> 个位置所能得到的最大开心值。</p><p>边界 <span class="math inline">\(f_{0,i}=0 \quad i \in[1,n]\)</span>。</p><p>转移是显然的（好像这类题的朴素转移都挺显然的） <spanclass="math display">\[f_{i,j} = \min_{1 \le k \le n} { \{ f_{i-1,k} + b_i - \left| a_i-j\right| \} }\]</span> 然后得到了一个喜人的复杂度 <spanclass="math inline">\(O(mn^2)\)</span></p><p>考虑优化，期望复杂度 <span class="math inline">\(O(mn)\)</span>。</p><p>首先是 <span class="math inline">\(n \le 1.5 \times 10^5,m \le300\)</span>，空间不能承受，并且阶段 $ i$ 只与阶段 <spanclass="math inline">\(i-1\)</span> 有关，滚动数组优化即可。</p><p>优化后只有两维，设当前维度为 $ w$，另一维为 <spanclass="math inline">\(w \text{ xor } 1\)</span>。</p><p>不难发现转移的瓶颈在于枚举 <spanclass="math inline">\(k\)</span>，且状态符合 1D/1D模型，考虑单调队列优化。</p><p>设 $ i-1$ 阶段，位置在 <span class="math inline">\(k\)</span>。对于 $(i,j)$，能够向右移动到为区间为 <span class="math display">\[[k, \min \big( j+ d \cdot (t_i-t_{i-1}) \big) ]\]</span> 枚举每个合法的 <spanclass="math inline">\(k\)</span>，在单调队列中维护 <spanclass="math inline">\(f_{w \text{ xor } 1,j}\)</span> 单调减。</p><p>能够向左到达的区间为 <span class="math display">\[[ \max \big( 1,j- d \cdot (t_i-t_{i-1}) \big), k ]\]</span> 排除掉队首小于左边界的决策即可。</p><p>设队首为 $ k$。</p><p>最終の轉移！ <span class="math display">\[f_{w,j} = f_{w \text{ xor } 1,k}+b_i- \left| a_i-j \right|\]</span> 虽然有枚举合法区间内的决策，但无伤大雅，可以看作常数。</p><p>复杂度 <span class="math inline">\(O(mn)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">150005</span>, M=<span class="hljs-number">305</span>;<span class="hljs-type">int</span> n, m, d, l, r, w=<span class="hljs-number">1</span>, q[N];ll a[M], b[M], t[M], f[<span class="hljs-number">2</span>][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-type">int</span> i, j, k, o, u;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        l=k=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;            o=<span class="hljs-built_in">min</span>(<span class="hljs-number">1ll</span>*n,j+d*(t[i]-t[i<span class="hljs-number">-1</span>]));            u=<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,j-d*(t[i]-t[i<span class="hljs-number">-1</span>]));            <span class="hljs-keyword">for</span>(;k&lt;=o;++k) &#123;                <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[w^<span class="hljs-number">1</span>][q[r]]&lt;=f[w^<span class="hljs-number">1</span>][k]) --r;                q[++r]=k;            &#125;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;u) ++l;            f[w][j]=f[w^<span class="hljs-number">1</span>][q[l]]-<span class="hljs-built_in">abs</span>(a[i]-j)+b[i];        &#125;        w^=<span class="hljs-number">1</span>;       &#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-type">int</span> i;    R ll ans=-(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;d);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;a[i],&amp;b[i],&amp;t[i]);    <span class="hljs-built_in">sol</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[w^<span class="hljs-number">1</span>][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2680 运输计划 题解</title>
    <link href="/2021/lg2680-solution/"/>
    <url>/2021/lg2680-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>最小化完成所有任务的时间，考虑二分答案。</p><p>用 <span class="math inline">\(lca\)</span>算法预处理每个计划的距离，设第 <span class="math inline">\(i\)</span>个计划的距离为 <span class="math inline">\(W_i\)</span></p><p>如何判断完成任务的时间 <span class="math inline">\(t\)</span>是否可行呢？</p><p>不难想到，有以下两种情况。</p><ol type="1"><li>$ _{1 i m}{ { W_i }} t$。</li><li>将一条边权 为 <span class="math inline">\(dlt\)</span> 的边改为0（虫洞）后，$ _{1 i m}{ { W_i - dlt }} t$。</li></ol><p>第一种情况很容易判断。</p><p>对于第二种情况，不难发现：将一条边权为 <spanclass="math inline">\(len\)</span> 的边改为 0 后能使所有距离大于 <spanclass="math inline">\(t\)</span> 的计划距离都变成不大于<spanclass="math inline">\(t\)</span>，当且仅当这些计划交于此边，且 $ len _{1i m}{ { W_i - t }}$</p><p>这是显然的，证明略。</p><p>明确这个之后，问题仅仅在于，如何快速统计每条边被计划经过的次数和权。</p><p>边权不难求，用倍增 <span class="math inline">\(lca\)</span> 的 <spanclass="math inline">\(f\)</span> 与 <spanclass="math inline">\(dis\)</span> 数组即可。设 <spanclass="math inline">\((x \rightarrow f(x,0))\)</span> 边权为 <spanclass="math inline">\(d_x\)</span>，到根的距离为 <spanclass="math inline">\(dis_x\)</span></p><p>则 $ d_x=dis_x-dis(f(x,0)) $</p><p>考虑统计经过次数。</p><p>如果朴素地去统计，复杂度是 $ O(n)$ 的。可以用树上差分。</p><p>用一个计数数组 $ K$ 记录差分，计划 $ (x y)$，令 <spanclass="math display">\[K(x)+1,K(y+1),K(z)-2 \quad z=lca(x,y)\]</span>然而这个不像一般树上差分一样，统计子树信息。而且上述做法是边权差分，需要转化成点。</p><p>考虑每个计划路径是一条链，所以只需要统计每条链的信息就行了。</p><p>我们记录搜索树中每次访问到的点，即为 $ idf$。因为搜索树是一个DAG，所以这个东西倒序就是逆拓扑序。</p><p>按照这个顺序令 $ K(f(idf(x),0))+K(idf(x))$就能自底向上统计出每个点的信息。</p><p>然后判断上述两种情况就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> n, m, cnt, d[N], dis[N], f[N][<span class="hljs-number">18</span>], k[N], idf[N];<span class="hljs-type">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span> &#123; <span class="hljs-type">int</span> x, y, z, w; &#125; g[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=(a&lt;&lt;<span class="hljs-number">1</span>)+(a&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;    <span class="hljs-type">int</span> i, y, z;    idf[++cnt]=x, d[x]=d[fr]+<span class="hljs-number">1</span>, f[x][<span class="hljs-number">0</span>]=fr;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;d[x];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i], z=w[i];        dis[y]=dis[x]+z, <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;    <span class="hljs-type">int</span> i, j;    <span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=d[x]-d[y];j;++i,j&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) x=f[x][i];    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-type">int</span> i, tot=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(k,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(k));    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(g[i].w&gt;x) &#123;        ++k[g[i].x], ++k[g[i].y], k[g[i].z]-=<span class="hljs-number">2</span>;        ans=<span class="hljs-built_in">max</span>(ans,g[i].w-x), ++tot;    &#125;    <span class="hljs-keyword">if</span>(!tot) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=n;i;--i) k[f[idf[i]][<span class="hljs-number">0</span>]]+=k[idf[i]];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(k[i]==tot&amp;&amp;dis[i]-dis[f[i][<span class="hljs-number">0</span>]]&gt;=ans) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> i, x, y, z, l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, mid;    n=<span class="hljs-built_in">r_</span>(), m=<span class="hljs-built_in">r_</span>();    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), z=<span class="hljs-built_in">r_</span>();        r+=z, <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), z=<span class="hljs-built_in">lca</span>(x,y);        g[i].x=x, g[i].y=y, g[i].z=z;        g[i].w=dis[x]+dis[y]-(dis[z]&lt;&lt;<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">while</span>(l&lt;r) &#123;        mid=l+r&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分答案</tag>
      
      <tag>最近公共祖先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2446 大陆争霸 题解</title>
    <link href="/2021/lg2446-solution/"/>
    <url>/2021/lg2446-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>每个点都必须在到到达所有保护它的点后才能进入，我们用一种类似拓扑排序的方式求解。</p><p>设 <span class="math inline">\(p(x)\)</span> 为能够到达节点 <spanclass="math inline">\(x\)</span> 最早的时间，<spanclass="math inline">\(q(x)\)</span> 为能够进入节点 <spanclass="math inline">\(x\)</span> 最早的时间，<spanclass="math inline">\(d(x)\)</span> 为摧毁 <spanclass="math inline">\(x\)</span> 最早的时间。</p><p>设 <span class="math inline">\(ind(x)\)</span> 为保护节点 <spanclass="math inline">\(x\)</span> 的点的个数。</p><p>显然 <span class="math inline">\(p(x)\)</span>可以直接用最短路算法求出。</p><p>设 <span class="math inline">\((x \rightarrow y)\)</span>，则 <spanclass="math display">\[q(y)= \max{\{d(x)\}}\]</span> <span class="math inline">\(x\)</span> 被摧毁后自然能够到达<span class="math inline">\(y\)</span>。</p><p>当保护节点 <span class="math inline">\(x\)</span>的点处理完之后，就能进行 <span class="math inline">\(d(x)\)</span>的转移。</p><p>因为有无限多的机器人，所以节点 <span class="math inline">\(x\)</span>能够到达的那一刻就能够被摧毁。 <span class="math display">\[d(x)= \max{\{ p(x),q(x) \}}\]</span> 具体细节看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">10</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> n, m, d[N], p[N], q[N], ind[N];<span class="hljs-type">int</span> cnt, h[N], ver[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>], w[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> tc, hc[N], vc[M&lt;&lt;<span class="hljs-number">1</span>], nc[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">()</span> </span>&#123;R <span class="hljs-type">int</span> i, x, y, z;R priority_queue&lt;PII &gt; pq;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d)), <span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(p));d[<span class="hljs-number">1</span>]=p[<span class="hljs-number">1</span>]=q[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">size</span>()) &#123;x=pq.<span class="hljs-built_in">top</span>().second, pq.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(p[y]&gt;d[x]+z) &#123;p[y]=d[x]+z;<span class="hljs-keyword">if</span>(!ind[y]) d[y]=<span class="hljs-built_in">max</span>(p[y],q[y]), pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;&#125;<span class="hljs-keyword">for</span>(i=hc[x];i;i=nc[i]) &#123;y=vc[i], q[y]=<span class="hljs-built_in">max</span>(q[y],d[x]);<span class="hljs-keyword">if</span>(--ind[y]==<span class="hljs-number">0</span>) &#123;d[y]=<span class="hljs-built_in">max</span>(p[y],q[y]);pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;R <span class="hljs-type">int</span> i, j, x, y, z;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z), <span class="hljs-built_in">add</span>(x,y,z);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-keyword">while</span>(x--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y), ++ind[i], <span class="hljs-built_in">addc</span>(y,i);&#125;<span class="hljs-built_in">dijk</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,d[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3953 逛公园 题解</title>
    <link href="/2021/lg3953-solution/"/>
    <url>/2021/lg3953-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>首先跑最短路，本题并不卡那个死掉的算法。</p><p>求出 1 号节点到每个点的最短路 <spanclass="math inline">\(d\)</span>。</p><p>然后考虑计数。</p><p>计数可以考虑 DP，但是必须满足无后效性。</p><p>设计一个类似于分层图的状态。</p><p><span class="math inline">\(f(x,k)\)</span> 为 1 号节点到 <spanclass="math inline">\(x\)</span> 号节点，距离为 <spanclass="math inline">\(d(x)+k\)</span> 的方案数。</p><p>考虑转移，假定 <span class="math inline">\(f(y,k_2)\)</span> 能转移到<span class="math inline">\(f(x,k_1)\)</span>。</p><p>设 <span class="math inline">\((x \rightarrow y)\)</span> 边权为<span class="math inline">\(z\)</span>，则有 <spanclass="math display">\[d(y)+z+k_2=d(x)+k_1\]</span> <span class="math display">\[k_2=d(x)-d(y)-z+k_1\]</span></p><p>转移为 <span class="math display">\[f(x,k)= \sum_{x \rightarrow y} {f(y,d(x)-d(y)+k-z)}\]</span> 对于 <span class="math inline">\((x \rightarrowy)\)</span>，关于 <span class="math inline">\(x\)</span>的状态反而依赖关于 <span class="math inline">\(y\)</span>的状态。那么必定是建反图，然后记忆化搜索。</p><p>边界 <span class="math inline">\(f(1,0)=1\)</span></p><p>答案 <span class="math display">\[\sum_{0 \le i \le K} f(n,i)\]</span>  </p><p>考虑无解的情况。</p><p>题目描述中告诉我们有 0 边。</p><p>我们发现，有无穷多条合法路径，当且仅当有边权为 0的环。又因为没有负边权，所以 0 环一定由若干 0 边构成。</p><p>如何找出 0 环呢？</p><p>观察我们的转移，不难想到，在 0 边上，<spanclass="math inline">\(k=d(x)-d(y)+k-z\)</span>，即会递归到 <spanclass="math inline">\(f(y,k)\)</span></p><p>如果有 0 环，那么一定又会再次访问到 <spanclass="math inline">\(f(x,k)\)</span>。</p><p>所以对于每个 <span class="math inline">\(f(x,k)\)</span>，用 <spanclass="math inline">\(v(x,k)\)</span>来记录访问情况。每访问到一个状态，将其记为 1，访问完之后就改回0。如果访问到 1 的状态，就证明有 0 环，无解。</p><p>这也恰好说明了，这个状态是“无环”的。并不是真的不可能存在环，但是如果访问一圈回到<spanclass="math inline">\(f(x,k)\)</span>，说明存在环，也就直接无解了，不需要再考虑别的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> t, n, m, K, P, ans, QwQ, f[N][<span class="hljs-number">66</span>], d[N], fa[N];<span class="hljs-type">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> cnt2, h2[N], ver2[N&lt;&lt;<span class="hljs-number">1</span>], nxt2[N&lt;&lt;<span class="hljs-number">1</span>], w2[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N], vis[N][<span class="hljs-number">66</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=(a&lt;&lt;<span class="hljs-number">1</span>)+(a&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver2[++cnt2]=y, w2[cnt2]=z, nxt2[cnt2]=h2[x], h2[x]=cnt2; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">()</span> </span>&#123;priority_queue&lt;PII &gt; q;<span class="hljs-built_in">SET</span>(d,<span class="hljs-number">0x3f</span>);d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(k&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(vis[x][k]) &#123; QwQ=<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">if</span>(f[x][k]) <span class="hljs-keyword">return</span> f[x][k];<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;vis[x][k]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h2[x];i;i=nxt2[i]) &#123;<span class="hljs-type">int</span> y=ver2[i], z=w2[i];(ans+=<span class="hljs-built_in">dp</span>(y,d[x]-d[y]+k-z))%=P;<span class="hljs-keyword">if</span>(QwQ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;vis[x][k]=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> f[x][k]=ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-built_in">r_</span>();t--;) &#123;n=<span class="hljs-built_in">r_</span>(), m=<span class="hljs-built_in">r_</span>(), K=<span class="hljs-built_in">r_</span>(), P=<span class="hljs-built_in">r_</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), z=<span class="hljs-built_in">r_</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add2</span>(y,x,z);&#125;<span class="hljs-built_in">dijk</span>();<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;++i) ans=(ans+<span class="hljs-built_in">dp</span>(n,i))%P;<span class="hljs-keyword">if</span>(QwQ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);QwQ=cnt=cnt2=<span class="hljs-number">0</span>;        <span class="hljs-built_in">SET</span>(v,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(vis,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(h2,<span class="hljs-number">0</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1600 天天爱跑步 题解</title>
    <link href="/2021/lg1600-solution/"/>
    <url>/2021/lg1600-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><div class="note note-primary">            <p>本文重构于 2023.9.4。</p>          </div><p>考虑能观察到玩家的条件。</p><p>设 <span class="math inline">\(\text{dep}(x)\)</span> 为节点 <spanclass="math inline">\(x\)</span> 的深度，<spanclass="math inline">\(z_i=\text{LCA}(s_i,t_i)\)</span>。</p><p>我们把路径 <span class="math inline">\((s_i,t_i)\)</span> 分成 <spanclass="math inline">\((s_i,z_i)\)</span> 和 <spanclass="math inline">\((z_i,t_i)\)</span>。观察员 <spanclass="math inline">\(x\)</span> 能观察到玩家 <spanclass="math inline">\(i\)</span>，一定满足二者之一</p><ol type="1"><li>$ (s_i) - (x) =w_x$</li><li>$ (s_i) - (z_i)+ (x)-(z_i) =w_x$</li></ol><p>同时注意需要满足 <span class="math inline">\(\text{dep}(x) \ge\text{dep}(z_i)\)</span>。</p><p>整理可得</p><ol type="1"><li><span class="math inline">\(w_x + \text{dep}(x) =\text{dep}(s_i)\)</span></li><li><span class="math inline">\(w_x - \text{dep}(x) = \text{dep}(s_i) -2\text{dep}(z_i)\)</span></li></ol><p>问题转化为对于一个 <spanclass="math inline">\(x\)</span>，求满足上述条件的 <spanclass="math inline">\(i\)</span> 的数量，同时限定 <spanclass="math inline">\(x\)</span> 必须在路径 <spanclass="math inline">\((s_i,t_i)\)</span> 上。</p><p>把路径的贡献差分成前缀贡献，放到 <spanclass="math inline">\(s_i,t_i,z_i,fa(z_i)\)</span> 上，在 <spanclass="math inline">\(s_i\)</span> 与 <spanclass="math inline">\(t_i\)</span> 处产生贡献，在 <spanclass="math inline">\(z_i\)</span> 与 <spanclass="math inline">\(fa(z_i)\)</span>处消去贡献即可。问题转化为求对应值的子树和。</p><p>注意到值域不大，我们可以开一个桶，访问时和回溯时做个差就是答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P1600 [NOIP2016 提高组] 天天爱跑步</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P1600</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Date: 2023-07-17 19:45:32</span><span class="hljs-comment">// Memory Limit: 512 MB</span><span class="hljs-comment">// Time Limit: 2000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, a[N], ans[N], c1[N&lt;&lt;<span class="hljs-number">1</span>], c2[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">int</span> sz[N], fa[N], son[N], dep[N], top[N]; vector&lt;<span class="hljs-type">int</span>&gt; a1[N], a2[N], b1[N], b2[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;fa[x]=fr, dep[x]=dep[fr]+<span class="hljs-number">1</span>;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs1</span>(y,x);<span class="hljs-keyword">if</span>(!son[x]||sz[y]&gt;sz[son[x]]) son[x]=y;sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa[x]||y==son[x]) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">return</span> dep[x]&lt;dep[y]? x:y;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> dlt=c1[a[x]+dep[x]]+c2[a[x]-dep[x]+n];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa[x]) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:a1[x]) ++c1[y];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:b1[x]) --c1[y];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:a2[x]) ++c2[y+n];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:b2[x]) --c2[y+n];ans[x]=c1[a[x]+dep[x]]+c2[a[x]-dep[x]+n]-dlt;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,n) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> z=<span class="hljs-built_in">lca</span>(x,y);a1[x].<span class="hljs-built_in">pb</span>(dep[x]), b1[fa[z]].<span class="hljs-built_in">pb</span>(dep[x]);a2[y].<span class="hljs-built_in">pb</span>(dep[x]<span class="hljs-number">-2</span>*dep[z]), b2[z].<span class="hljs-built_in">pb</span>(dep[x]<span class="hljs-number">-2</span>*dep[z]);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<span class="hljs-built_in">rep</span>(x,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[x]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树论</tag>
      
      <tag>树上差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2491 消防 题解</title>
    <link href="/2021/lg2491-solution/"/>
    <url>/2021/lg2491-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>实际上就是 <ahref="https://www.luogu.com.cn/problem/P1099">树网的核</a>的数据加强版。</p><p>原题暴力枚举即可，本题也可以用复杂度为 <spanclass="math inline">\(O(n\log SUM)\)</span>的二分答案，这里只讲述单调队列的 <spanclass="math inline">\(O(n)\)</span> 算法。</p><p>题意：在树的直径上选择两个距离不超过 <spanclass="math inline">\(s\)</span> 的点，最小化「偏心距」。</p><p>「偏心距」：树中距离直径最远的节点到直径的距离。</p><p>显然，可以用单调队列维护。</p><p>设直径为 <span class="math inline">\(u\)</span>，其节点数为 <spanclass="math inline">\(o\)</span>，直径上两点为 <spanclass="math inline">\((u_i,u_j)\)</span>，<spanclass="math inline">\(f(x)\)</span> 为从 <spanclass="math inline">\(x\)</span>出发，不经过直径上的其他点，能够到达的最远距离。<spanclass="math inline">\(dis(x,y)\)</span> 为 <spanclass="math inline">\((x,y)\)</span> 之间的距离。</p><p>不难想到此时偏心距为 <span class="math display">\[\max_{dis(i,j)\in [1,s]} {\{\max_{i \le k \le j} { \{ f(k)\},dis(u_1,u_i),dis(u_j,u_s) \} } }\]</span> 仔细观察不难发现，<span class="math inline">\(f(k)\)</span>的定义域为 <spanclass="math inline">\([1,s]\)</span>，而无论如何选择两个点，最终一定取到<span class="math inline">\(\max_{k \in [1,s]} { \{f(s)\}}\)</span>。</p><p>所以上式可化为 <span class="math display">\[\max_{dis(i,j) \in [1,s]} { \{ \max_{k \in [1,s]}{\{ f(k)\}},dis(u_1,u_i),dis(u_j,u_o) \} }\]</span> 而 <span class="math inline">\(\max_{k \in [1,s]} { \{f(s)\}}\)</span> 是一个定值，设其为 <spanclass="math inline">\(K\)</span>。</p><p>求出 <span class="math inline">\(u\)</span> 上节点距离的前缀和数组<span class="math inline">\(S\)</span>。</p><p>则 <span class="math display">\[\max_{dis(i,j) \in [1,s]}{ \{ K, \max ( S(i),S(o)-S(j) )  \} }\]</span> 用单调队列维护队头为 满足 <spanclass="math inline">\(S(j)-S(i) \le s\)</span> 的最大的 <spanclass="math inline">\(j\)</span> 即可。</p><p>写的很麻烦……</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> n, s, t, mx, o, d[N], f[N], sum[N], a[N], b[N];<span class="hljs-type">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;    <span class="hljs-comment">// 这个是用来找直径的</span>f[x]=fa;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa) &#123;        <span class="hljs-type">int</span> y=ver[i], z=w[i];d[y]=d[x]+z;        <span class="hljs-keyword">if</span>(d[y]&gt;mx) mx=d[y], o=y;        <span class="hljs-built_in">DFS</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(!v[ver[i]]) &#123;        <span class="hljs-comment">// 不经过直径上的点</span>        <span class="hljs-type">int</span> y=ver[i], z=w[i];        <span class="hljs-built_in">dfs</span>(y);        f[x]=<span class="hljs-built_in">max</span>(f[x],f[y]+z);    &#125;    <span class="hljs-comment">// 找距离</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ddfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-type">int</span> y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(v[y]&amp;&amp;y!=fa) a[++t]=x, b[t]=z, <span class="hljs-built_in">ddfs</span>(y,x);&#125;    <span class="hljs-comment">// a[]存直径节点编号，b[]存边权</span>    <span class="hljs-comment">// 这种做法会漏掉直径最后一个点，不过不影响</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>, ans=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-type">int</span> x, y, z; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-type">int</span> p, q;    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), p=o, mx=d[o]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">DFS</span>(p,<span class="hljs-number">0</span>), q=o;    <span class="hljs-comment">// 这时候f[x]表示x的父亲</span>    <span class="hljs-keyword">while</span>(p!=q) v[q]=<span class="hljs-number">1</span>, q=f[q];    <span class="hljs-comment">// 标记直径上的点</span>    <span class="hljs-built_in">ddfs</span>(q,<span class="hljs-number">0</span>);    <span class="hljs-comment">// 累加直径上的边</span>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i) &#123;        <span class="hljs-built_in">dfs</span>(a[i]);        <span class="hljs-comment">// 这时候f[]表示能到达的最远距离</span>        k=<span class="hljs-built_in">max</span>(k,f[a[i]]);        sum[i]=sum[i<span class="hljs-number">-1</span>]+b[i];    &#125;    <span class="hljs-type">int</span> l, r, qq;    <span class="hljs-comment">// qq记录到直径最远的距离</span>    <span class="hljs-keyword">for</span>(l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;l&lt;=t;++l) &#123;        <span class="hljs-keyword">while</span>(r&lt;t&amp;&amp;sum[r+<span class="hljs-number">1</span>]-sum[l]&lt;=s) ++r;        qq=<span class="hljs-built_in">max</span>(k,<span class="hljs-built_in">max</span>(sum[l],sum[t]-sum[r]));        ans=<span class="hljs-built_in">min</span>(ans,qq);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调队列</tag>
      
      <tag>树的直径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3304 直径 题解</title>
    <link href="/2021/lg3304-solution/"/>
    <url>/2021/lg3304-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>两次 DFS 求出树的直径。</p><p>显然多条直径必定交于至少一点，且包含它们的中点。</p><p>则若舍去他们交点之外的边，剩下的边即为所求。</p><p>设直径左右端点为 $ l, r$。</p><p>在第二次 DFS 时能够求出 $ l$ 到直径每个节点的距离，所以从 $ r$ 向 $l$ 遍历。</p><p>对于直径上的每个点 <spanclass="math inline">\(i\)</span>，分别求出在不经过直径上其他点的情况的，所能达到的最远距离，记作<span class="math inline">\(d\)</span>。设它到直径左端点距离为 $ld$，到右端点距离为 $ rd$。</p><p>若 $ d=rd$，则令 $ r=i$。</p><p>若 <span class="math inline">\(d=ld\)</span>，则令 <spanclass="math inline">\(l=i\)</span>，且只会进行一次，这是因为我们的遍历顺序是从右到左。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> n, f[N];<span class="hljs-type">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];ll p, mxd, d[N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span> </span>&#123; ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;    f[x]=fa;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa) &#123;        <span class="hljs-type">int</span> y=ver[i], z=w[i];        d[y]=d[x]+z;        <span class="hljs-keyword">if</span>(d[y]&gt;mxd) &#123; mxd=d[y], p=y; &#125;        <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kawaii</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa&amp;&amp;!v[ver[i]]) &#123;        <span class="hljs-type">int</span> y=ver[i], z=w[i];        d[y]=d[x]+z;        <span class="hljs-keyword">if</span>(d[y]&gt;mxd) mxd=d[y];        <span class="hljs-built_in">kawaii</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> ans, l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, fg=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-type">int</span> x, y, z; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), l=p, mxd=d[p]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs</span>(p,<span class="hljs-number">0</span>), r=p;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mxd);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r;i;i=f[i]) v[i]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 直径上的点打标记</span>    <span class="hljs-type">int</span> l_=l, r_=r;    <span class="hljs-keyword">for</span>(i=f[r_];i!=l_;i=f[i]) &#123;        <span class="hljs-type">int</span> ld=d[i], rd=d[r_]-d[i];        <span class="hljs-comment">// </span>        mxd=d[i]=<span class="hljs-number">0</span>;        <span class="hljs-built_in">kawaii</span>(i,<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(mxd==rd) r=i;        <span class="hljs-keyword">if</span>(mxd==ld&amp;&amp;!fg) fg=<span class="hljs-number">1</span>, l=i;    &#125;    <span class="hljs-keyword">for</span>(i=f[r];i!=l;i=f[i]) ++ans;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树的直径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1083E The Fair Nut and Rectangles 题解</title>
    <link href="/2021/cf1083e-solution/"/>
    <url>/2021/cf1083e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>考虑 DP。</p><p>DP需要一定的顺序。因为给出的矩形没有包含的关系，所以我们按照每个矩形右上角点的横坐标<span class="math inline">\(x\)</span> 递增排序，那么纵坐标 $ y$一定是递减排序的。</p><p>设 <span class="math inline">\(S_i = x_i \times y_i\)</span>。</p><p>因为每个矩形都有选与不选两种选择，所以设 $ f(i)$ 为在排序后的 <spanclass="math inline">\([1,i]\)</span> 中，必须选择第 <spanclass="math inline">\(i\)</span>个矩形获得的最大收益，也就是选出的矩形面积之并减去代价。</p><p>初始值为 <span class="math inline">\(f(i) = S_i-a_i\)</span>。</p><p>因为状态中只限制了选择第 <span class="math inline">\(i\)</span>个，而矩形的选择是没有限制的。所以转移时找到 <spanclass="math inline">\(j \in [1,i)\)</span>，用选择 <spanclass="math inline">\(j\)</span> 的最大收益 <spanclass="math inline">\(f(j)\)</span> 选择 <spanclass="math inline">\(i\)</span> 的初始收益并且减去二者之交。或者说是<span class="math inline">\(f(j)\)</span> 加上 <spanclass="math inline">\(S_i \cup S_j\)</span> 减去代价。 <spanclass="math display">\[f(i)=\max_{j \in [1,i)}{ \{ f(j)+ S_i - a_i - S_i \cap S_j \} }\]</span> 有一个问题是，难道 <span class="math inline">\(i\)</span>不会和之前选择的一些矩形有重叠部分吗？在下图中，设宽为黑色的是 <spanclass="math inline">\(k\)</span>，红色的是 <spanclass="math inline">\(j\)</span>，蓝色的是 <spanclass="math inline">\(i\)</span>，满足 <span class="math inline">\(k&lt; j &lt; i\)</span>。那么计算 <spanclass="math inline">\(f(j)\)</span> 的时候必然已经减去了 <spanclass="math inline">\(S_j \cap S_k\)</span>，得到了 <spanclass="math inline">\(S_j \cup S_k\)</span>。排序后，<spanclass="math inline">\(S_i \cap S_j\)</span> 一定包含了 <spanclass="math inline">\(S_i \cap S_k\)</span>，也就是 <spanclass="math inline">\(S_i \cap S_j = S_i \cap (S_j \cupS_k)\)</span>，从而 <span class="math inline">\(S_i\)</span> 与 <spanclass="math inline">\(f(j)\)</span> 中选出的矩形面积之并就等于 <spanclass="math inline">\(f(j)+S_i - S_i \capS_j\)</span>。也就是不会出现这种问题。</p><p><img src="https://s2.loli.net/2022/06/28/vlLTqKgW8mos6nf.png" srcset="/img/loading.gif" lazyload /></p><p>答案为</p><p><span class="math display">\[\max_{1 \le i \le n}\{ f(i)  \}\]</span></p><p>复杂度为 $ O(n^2)$。</p><p>复杂度过高，考虑优化。</p><p>由于我们已经将矩形排序，所以</p><p><span class="math display">\[\forall j \le i \quad x_i \ge x_j,y_i \le y_j\]</span></p><p>即</p><p><span class="math display">\[S_i \cup S_j = x_j \times y_i\]</span></p><p>所以原方程可化简为 <span class="math display">\[f(i) = \max_{ 1 \le j &lt; i } { \{ f(j)+ x_iy_i - a_i -x_jy_i \} }\]</span> 按照套路去掉 <span class="math inline">\(\large \max\)</span>函数，移项得 <span class="math display">\[f(j)=y_ix_j +f(i) - x_iy_i + a_i\]</span> 即</p><p><span class="math display">\[\begin{cases}y=f(j) \\k=y_i \\x=x_j \\b= f(i)-x_iy_i+a_i\end{cases}\]</span></p><p>对应到坐标系里即为：</p><p>每个决策点为 $ (x_j,f(j))$，其斜率 $ y_i$单调递减，所以要维护一个上凸壳。</p><p>由于斜率 <span class="math inline">\(y_i\)</span> 单调递减，所以合法决策的斜率一定小于 <spanclass="math inline">\(y_i\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(y) (w[y].x)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> Y(x) (f[x])</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">6</span>;ll n, ans, q[N], f[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Squ</span> &#123; ll x, y, z; &#125; w[N];<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Squ a,Squ b) &#123; <span class="hljs-keyword">return</span> a.y&gt;b.y; &#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>(x)!=<span class="hljs-built_in">X</span>(y)? <span class="hljs-number">1.0</span>*(<span class="hljs-built_in">Y</span>(x)-<span class="hljs-built_in">Y</span>(y))/(<span class="hljs-built_in">X</span>(x)-<span class="hljs-built_in">X</span>(y)):<span class="hljs-number">1e9</span>; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;w[i].x,&amp;w[i].y,&amp;w[i].z);    <span class="hljs-built_in">sort</span>(w+<span class="hljs-number">1</span>,w+n+<span class="hljs-number">1</span>);    <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        f[i]=w[i].x*w[i].y-w[i].z;        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[l],q[l+<span class="hljs-number">1</span>])&gt;=w[i].y) ++l;        f[i]=<span class="hljs-built_in">max</span>(f[i],f[q[l]]+(w[i].x-w[q[l]].x)*w[i].y-w[i].z);        ans=<span class="hljs-built_in">max</span>(ans,f[i]);        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[r<span class="hljs-number">-1</span>],q[r])&lt;=<span class="hljs-built_in">calc</span>(q[r],i)) --r;        q[++r]=i;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>斜率优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2195 HXY造公园 题解</title>
    <link href="/2021/lg2195-solution/"/>
    <url>/2021/lg2195-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>我最喜欢的紫色水题（</p><p>给出一个森林，有两种操作。</p><ol type="1"><li>询问某个点所在的树的直径</li><li>在两个点所在的两棵树间连一条边，最小化其直径</li></ol><p>显然的，对于第一种操作，DP / DFS / BFS预处理直径，并查集维护每棵树的点就行了。</p><p>问题在于高效维护第二种操作。</p><p>不难想到，两棵树之间连一条边，相当于合并两个集合。</p><p>而最小化新树的直径，显然要在两树直径的中点处连边。</p><p>证明：</p><blockquote><p>反证法。若最优点不是直径中点，由于 直径有两个端点 且树上两点有且仅有一条简单路径，若在非直径中点的 <spanclass="math inline">\(x\)</span>点连边，则当其接近直径一端时，直径另一端到达它的距离就大于到达直径中点的距离，反之则显然。这与假设不符，故原命题正确。</p></blockquote><p>设从 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 之间连边，<spanclass="math inline">\(l(t)\)</span> 为点 <spanclass="math inline">\(t\)</span> 所在的树的直径。</p><p>则新树的直径只有三种可能。</p><ol type="1"><li>$ l(x)$</li><li><span class="math inline">\(l(y)\)</span></li><li>$ + + 1$</li></ol><p>合并后求最大值就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> n, m, q, ans, f[N], d[N], c[N];<span class="hljs-type">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=(a&lt;&lt;<span class="hljs-number">1</span>)+(a&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fr)</span> </span>&#123;    <span class="hljs-type">int</span> i, y;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i], <span class="hljs-built_in">dp</span>(y,x);        ans=<span class="hljs-built_in">max</span>(ans,d[x]+d[y]+<span class="hljs-number">1</span>), d[x]=<span class="hljs-built_in">max</span>(d[x],d[y]+<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">miku</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; ans=<span class="hljs-number">0</span>, <span class="hljs-built_in">dp</span>(x,<span class="hljs-number">0</span>), c[x]=ans; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">r_</span>(), m=<span class="hljs-built_in">r_</span>(), q=<span class="hljs-built_in">r_</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[i]=i;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;++i) x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x), f[<span class="hljs-built_in">get</span>(x)]=<span class="hljs-built_in">get</span>(y);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(f[i]==i) <span class="hljs-built_in">miku</span>(i);    <span class="hljs-keyword">while</span>(q --&gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">int</span> op=<span class="hljs-built_in">r_</span>(), x=<span class="hljs-built_in">r_</span>();        <span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,c[<span class="hljs-built_in">get</span>(x)]); <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-type">int</span> y=<span class="hljs-built_in">r_</span>();        x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">continue</span>;        c[x]=<span class="hljs-built_in">max</span>((c[x]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+(c[y]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">max</span>(c[x],c[y]));        f[y]=x;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树的直径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4819 杀人游戏 题解</title>
    <link href="/2021/lg4819-solution/"/>
    <url>/2021/lg4819-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h2 id="update-2022.2.9-修改了代码">update 2022.2.9 修改了代码</h2><p>不妨假设平民为白点，杀手为黑点，认识的关系为一条有向边。</p><p>求不访问黑点并且知道黑点的最小代价。</p><p>若有 <span class="math inline">\(n\)</span>个点，显然每个点为黑的概率为 <spanclass="math inline">\(\frac{1}{n}\)</span>。</p><p>而每访问一个白点，都能得知与它出边相连的点的颜色。</p><p>考虑强连通分量。</p><p>不难发现，对于每个强连通分量，只要以概率增加 <spanclass="math inline">\(\frac{1}{n}\)</span>为代价访问其中一个点，就能得知整个强连通分量的颜色情况。。</p><p>所以求出强连通分量后进行缩点，我们就得到了一个 DAG。</p><p>为了减少总访问次数，访问入度不为 0 的 SCC 是不划算的。</p><p>简单证明：设缩点后存在 <span class="math inline">\((x \rightarrowy)\)</span> 的边，则访问完 <span class="math inline">\(x\)</span>中所有的点后，必定能知道 <span class="math inline">\(y\)</span>中一个点的信息，所以对于 <spanclass="math inline">\(y\)</span>，不需要增加 <spanclass="math inline">\(\frac{1}{n}\)</span> 的访问代价。</p><p>所以设缩点后入度为 0 的点的数量为 <spanclass="math inline">\(s\)</span>，则访问到黑点的概率为 <spanclass="math inline">\(\frac{s}{n}\)</span>，答案为 $ $。</p><p> </p><p>考虑只含一个点的 SCC，设其为 <spanclass="math inline">\(c\)</span>，若其入度为0，且其能够到达的点的入度均大于 1，那么若最后访问 <spanclass="math inline">\(c\)</span>，整张图的情况已经被确定了。若未找到黑点，则$ c$ 为黑点。如果包含超过 1个节点，那么必须再访问它再能确定黑点。这样可以减少一次访问，且对于任意图，能且仅能减少一次。</p><p>所以若存在 <span class="math inline">\(c\)</span>，令 <spanclass="math inline">\(s-1\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>;<span class="hljs-type">int</span> n, m, k, num, ans, dfn[N], low[N], st[N];<span class="hljs-type">int</span> scc, c[N], deg[N], sz[N];<span class="hljs-type">int</span> cnt, h[N], ver[<span class="hljs-number">3</span>*N], nxt[<span class="hljs-number">3</span>*N];<span class="hljs-type">int</span> tc, hc[N], vc[<span class="hljs-number">3</span>*N], nc[<span class="hljs-number">3</span>*N];<span class="hljs-type">bool</span> v[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    dfn[x]=low[x]=++num, st[++k]=x;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=ver[i];        <span class="hljs-keyword">if</span>(!dfn[y]) &#123;            <span class="hljs-built_in">tarjan</span>(y);            low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);    &#125;    <span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;        ++scc;        <span class="hljs-keyword">do</span> y=st[k--], c[y]=scc, ++sz[scc]; <span class="hljs-keyword">while</span>(x!=y);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(deg[x]||sz[x]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hc[x];i;i=nc[i]) <span class="hljs-keyword">if</span>(deg[vc[i]]==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), <span class="hljs-built_in">add</span>(x,y);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;    <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(v));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-type">int</span> y=ver[i];        <span class="hljs-keyword">if</span>(c[x]!=c[y]&amp;&amp;!v[c[y]]) &#123;v[c[y]]=<span class="hljs-number">1</span>, ++deg[c[y]], <span class="hljs-built_in">adc</span>(c[x],c[y]);&#125;&#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=scc;++i) <span class="hljs-keyword">if</span>(!deg[i]) ++ans;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=scc;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(i)) &#123; --ans; <span class="hljs-keyword">break</span>; &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,<span class="hljs-number">1.0</span>*(n-ans)/n);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>强连通分量</tag>
      
      <tag>DAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回忆一夏</title>
    <link href="/2021/recollect-summer2021/"/>
    <url>/2021/recollect-summer2021/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fc70d6d78fba7e6f00498ea7a15e5171967658c1ca6e86cdf8db539141df00f6">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bc5b7cd4f87baec3fd3e832a2262ad5bb4e54a69e5f79e2740b28436eb16a625322cf7c44f48a3dfef555fa1fa5c0374a4807959f4e79b8434393459190babd54289591efdc243d37e5fd015e9f5d41ea293f4e0ce207aa1662340e999e17e7862bf9dccdee6661d1152dea597bcefc21f864249576fac1fca28774fb86b481ffed27de5ab17032179518e27bb4cb35c032dbbbccbae0d9b20bffc505b36d9f80ae7e885222bb362bc3f3333c36c1dcff03789b373ff740af6ab6c6c951c2f4a8f6bf69724f6adf7e3eacf9cb8eb1f7a6768abe28e9c47851d00014da77ddc01e85b781a6873522e148751d4ec8475c892e40c74204e0e742ba0012b72bf7705529ebf87cefa4bcecac68a7490a03e0903075b9b560a8cc86be8a8007b78832114bc19fac85dfe581d65216603ed809ea3175690d6a2dacf9dfae051233d9cbec1e25fc7da58089045bbeeb8fac7d1818466d3f1cdd123b855d7e14bdb856bc49b10a6bb97f2b0e2628c3a032f4b87e2aeb94828a50436e664bed07a27ead150d7a68122fbf8e6e62a02053ddf89a405739c2e480b543e82b1d0c7796e20f7ec993e9fcce12df6234522237f1dcd3b2ea0797ec9719a4f0d1498639b565d14a2d7e95c538d664f1aed9a9461af19920ee0e77201c9e1e55ad31caa31a0dce7c545791e83ef9fb0b15e641cabbad279711d0798b42cb67f6216547074837748ee5b2b05de193ec9319b97b0d17f3eea63453a95e65d41963ad54118b7bf5b0abc6d275cd9d7d7d9a5dbe34b831efb5bc845d9f39308268e37a003d922e9d47fb139e0a3b25b10a6a18a342d8d8599e2bc91b5e90f2d5f239651b60193ece2c13554da226b6480559464932c0102e261450116125fff50fd4b188405c2439b411f2cec9ed289eb19c16045b732e492d350a8d28c38a7a711df2154fb6dececf485db6330af26a780459688b874828a9be6feb3ab0684337605bda7afce8b837cb380fb3bd00efad03497ea88a128aed9154752a9a0761bf7cd79d098f590a62bebf9b233296fe137515c8d30b7ff1e850802de2435b771fdb1441fd8dcb901ca2e9e35de84f5444e3190ee3a43d8f18f77d47accf940474dd670a29961c293715cc1ac80636d8806cc178e855d0632c0c62e3e36e720cd01e83b792cc43adb34e5cfa510fa7c56fc335fcc3c94865e88c5131e1fecb8cb05d8e55408923aa8c2de2d7df780b5309c17aa4c275624056689b318ac420060db3daf2c54b072dfd450322b4da849d8c0a220fc971c3a25a0137395963193edb116841180b61c67072e3c0cbf8ac41044bc613ff0f179ecdcb3de5038df55532d42ac73beef33942b5f80661341ba8b826428356c7a8f2fee3264e058c79a670ff822fa9ad02df7fd78751fde39ad91a1c26ca74ba9d26e67ded6f69779dbf73d32c600c9564c755048a7165d1149498e27d4fbb17d3ebea5c989e82f645f9c74007fbaac2ddc2c8f62611b4829fea72d1533dfd3fd6b11e30be17d27bf7e4302ef5668a400b2df1a3c7f6d15a22dee082a017cff56265eb5696af658943088b2062851a2506460d369b2f08449685cae580101d1c83121ccb9374a1f0dc7ff6beb31000bee998222cbb4981a003821988a0cb7de62918d912505e4ac9427611f93ca9f01c2d9a53fd0d9d6100079f7d91284a38473d796e4e64c1bac5e9d868d3550d457fc89870c6487a9bf8a82ba8e9045ebaac1cbe0de98a762950fa3bf0ac28a019d72c1b8b35558af82ec67267c6809e7fab8a618db39fe0d0937c4963c19608a9ae14227e1c726da7047920fe2de505cfdb82463cb9bd42374d89dfe4ad4a4d5e78fc9a71d73522dd702b86e22682109564e0b6cdc31a9fa39986f02b1c5f92ca87a2633d1d2f5e94508f6b87ba6076619821b4a684d73035871ab2f99696c9cf4c1342f91140351d3fd6655f11d74c8f4622155a0672e6fd9dfad18f08d54aa0e07048af10dee0bed5a07ac2db6a52e66d574a2896fac6913ed83888310450eb6486825cef0f00ba957e932ceca2a828bd9f5d36b9887b7050d69f40960758bdb8ac16f86428d38647bf7656b56f32d960df60ed0cd2643f0cc0a46bcf2da73b0b22f653a7d40ff847beac2a1c68f6dd99408102edbe44fadb74107e2f941b0ed2399f07749662f7f97823f2131dda87f368ee5a7c28fcf2b721f7e1c04aa07a3c3921d08176650d295b44d8c27a1a70399d7c8bcea1289d0de5d4504861fe0a7a7160732cb12c328d8fdfab1043065fe0446c37a11be6a3c1123472c0e76895cb1d6f880308b30a17afddc7dd0454ec590fb877959cdc218de1ff2ef3c058b027f8b3f0124656cf5f988839b935cbdd10666c58305c20a8850edcaacbaabc989d97d8e36e62940dff8623470d36403eda2274fb8bf690186563e824dd8a36d886946c06609594c6b87ed1b76ecf515277f2143958c33a553e95fcf329d45291cc5b6422f8400be96b4cf355040d4845e33c36b2ed74f5070019a022ff86037f6020ea9c2f4aa3d6a01a532800e92a3af5a2ec1069271db02414e8c3337f4cd0b15def1ef321dbf2ea12cca08a51f6389d5c4dfb16f929a7e209f63776a9c36e368ea85e53d7832935b479b60ade1fac32a1e64cf8d2f27d90753c2595679b64ba74d39f2dea489556c741c585a2b400da8c3bd5c30d64997ff34d552e7e3322e71f8a06618c80b0d9f9971a2277e31199fc5189c0b95bae98daebd1cd7510345faeac9756437f815d1ac35fbe17ea778012e07e8a18c6e97329f130d9070cf6aad97e526e2fa0f7e13cc8526319ccbb0edb4bed4902d7bab30c35889ec3129f5edab1b7a426c50fd4539e50f09694e167a250ab0dc3757fd44ef892059e0e08c84ac2a149b5f59a608fa024a346c99fdf0b8bccab9f56275b3370bb3ab0a015ee84698d9b9fccccd39b0f97fe4159ddbde77aab668b23dd770689d3320c5cf5722b62b5c185e48177fc16b6e5626069c7db79e4dd1f84767b2a64a82716a45ec101e99dcd902c9f3955d4ba0c4c5f315b1683595c37a4d6aab26d47bc3f45465e66da5a342c15f8a09842eb00255cbb1701dc0b59dedfa22359fd05897d55ae2f0f2ca744b4e208f1f0bd71bd831774e14a373ff2efa75db913597bcc179b1687c5c1260f3847ceacd68a3ba4bbc90f4bd5c265436c92a53c6a669d0935e9fc10ee29de7c469c4da386e7e896b27e8a9efd4460a33f1fab9f0547cd39b3546d9bc5ae2fe812cc1dfad81f6b54b4b5eeb7b0805714beb6a9ce08542366e529d2895b2973eb64f5d3a7163e5292f81fdcf56f14d24e6cd578f5eef2cd8f9c79f8ff356e9be1e9c7cfdec6e9b653e87c0749d019896dbe463dd1b25360de21aec72d20ed16415715e69661b19bd1def314d11d8dd01c2f5211e76292715563b04e0a72c1d0881c3f42eff270ea65bb321ddf8da0ed3e0260523e332448969db5d166f3710c8833f0767a9206ab0e0f14eda939d601d29b9fcccdac16fabb8b7fb5af1111874f607e849dab79bb5e68f2af3ca84f99900f87b8211d66bc8a72299dc688d71491ede5575fb8d2d2a5e7493f026ceca76ad3dbdbefc59838451b6afb370f50671c3c422f032d8606058e2fd61578a4ad718e1927e9df86fe323091c8a85cee43a9a7d84cf7a9e312b290dac906a57b42a345b84c5ad16f0872ef95a4f9b93f52a2583a4a8a3ecc983c97eac9dc00ef8073d44d5bcd260f12622654e81cf96c1138d34992148c5017cc0077c8b085046d848c400771aa816e8a24641a1ac9e6078d0187c061f6004f8492dea01c0de9a90cb008c1dc8864318755d664977e88262b26f66bb1c9faf167d9c4bd98d570b532a07ffaf1dde589b3f9b22338477dda63c3aec42f60ea96ef45d2b5d1cb252c99119c460d097d11262951a96ebc81219c72a88fa54e08858d60a45ca41f16f824a01a933e84e92f4bc1e7fca37a44c3f129b1b69cc0ae990b813b4d004b222c8f76b80376b56db44453744660f4ff8b9ee0f15e5704852ed3a5d10a184fa25f5c97d5fe1bea7b6aa22424ad163a0d659bc4b2f49ea1ca3fb5f27c34af92b31073f522e90a7ff067d28ebee20ce0f0030805de4cd29bbe34f5cba3a8ec44d5ff9e34bd441c329c69a073b3775acaa058809dde6761d55e80abcdb6b54895684ec5fe59c40e9153101ec5ce6fa1665517c635d6925884bbce68d6dda2dddc416725f54b9cc11c618026b861c51211ba940ee9c846a7316a733df947b702428c6b109162f904d1c4d2cb22db95fadb98ddbf3759a3b3d9e95f5a8377b73f213877a05c4f2b05b181008e856456a9e426b152935d19d66153b553348b5fe202081e6c3d72b22f5a0ebb96ff0d0d986a9e1fb23ca7c505c1919f1a84f8f3ecc1a561d2ff5c4351ba7bbb486af078a61876e9b6397ecca0df7eda093b66d0992d5d42593342d419f5da8c4f4e3b6df50b8389d181c1e8a5aee976ba26faf5407848baf47aa27f77e7e17a33a2c46acbf8f051e12c776a8fa8ad03371631b7732643e23ad0af4c64440cc9f05312d3c252baf84ce3745e0c568a5d06a34e56a7e966085ed113a0503306f87bd7c373a8acfb766e6d008f04e62f5988746ed803eaf79473f1afb81561c9c428ecd4037e8aeb19d6ff09bd3dbe668a8053064a8c51a3a6b5886464a5c77545887dba747471b6fe85069021ffb0068f0525c14f1ee0c375d41a774eb7c8027be3f29a5e60b2109a6052e602024bbdeddabe3169a64b6b77e1f73808f21eb742a855a8a44c62bfe21bbd4db33e9db8c298c2d4c7ffee881fa6b89c8b8852f1c91294e5363ec530d63adbc28e21b51db9e394a0e272214ff9b60c1f629855d5fe472447d00b79fdf41bf39d586eb3d1ebefbb0201b8c0d69273f9f7e58527ed295fb01263f9d17aa6069e084dd71d8130c9648b21ad976f2ffb83f659d61b14e9226ae9828738f792fa46eaae075f6c3dcfb97eb06ed46a63de2ebe3e31a6b9733b6c48c41bcaf53cd32f50195a8fa140dabc18f5f0d6e97d629adddb1d59ae7b78f5279ac2a7c2b0dc27f6926a9f25c24da579391ff76b8fe19b5a87b71b7dafd8aebdf5f19979a62ee8b3bb5c14404e17be1e26d757b5bd70a4f24ef5d97fd3fdefd85d518976f0491c2eeb463023054f4eadb8331aa038684542297a12d6d6b6ca1b9b86c66adaa90a4fc6c1d8275de11e551fed72ae78d30a4f9941cdad05af8d3f635268bb98ddb25d925df2ea67ad7072918890e19038b45566404216ab93ad528ed3012aa3fda6c3985009d207bbf4fd801dc970eeb20a909fa313d9f1a383a488237d35d7c2e746633acb225d7e712aad5a9e43e0df71912bea1649837747cbf4245d53c76983fbe1e68401a6900d49a4ecf543dd43df44e6e04299766ad819831864475e524de98aa2c8a2146576ceed3cc37ce17bf77a2634bda0651cbf28357220fd6f706adaf428c424c6007c18b67120c78c6a1e3be300eb7c3016b4798a2f5c48eb8370571c7954bb9466910954065a188587307329c3fe3b04225d78cedbbbd3d1203344724e27045d3c6fc243b8d117584edd043e8bad4b48ea13a14526343b7283761bfbc276329cb424030edb9f18ed7f0b9b5362b68280217b152b274931c05e37c2d7ed0e2b3a8e6914bdea8156360b5ae08d1e0f5b41e35a502d616031702b77ed2b5b7ca13bd492ae3b465e555b29e23a9a0d75ff03cb0af8e802a3d35bae861ed6cfdba36353f43d7eda79939421a8b51239fd98c923a73c9ad49a8597260eef775b8f6ef93f5586fadf145baba9f9d68fe94ce2361504f1b0dafee3561ca1f769913e852505237c54b1f0a37ea4b91541119f7a6f4cf9ded6e49a74aa23c545cb2e73f1cf6e05cbe4e711fdfa4ba3a7e95e572996d9406769ebd0cfa6adcd9042481cc4982f4bf1769b18aa96facfd815139a1166ce5901e79646907ae71b40df073d728f8f7626cb8b42a1c2ed08c021bb0d280d164ecfb5890606f87e80cc80047e86f9ffea9b7c5b2986ca9a9f09b1ce011501a67cf5b665054e8d7bc4f73fa8840a14470d511aaaeb395ba81002efb4f9a6d3b5de2e1abaeaf013d042f53430d6e5c9f45ac7f2933af96299bd5a207bbb41def2f972969382fcf62d70f32009c8407fbaf5f5c9ecc6d43e4b16cf9445920d2c8a2693cf2924857f684af5edfb67a4bac414cbf888de2b95c6575a25131832889429bb4a58970a505fc28ac246d76d3e899ace8bc17782bf894403e8f971f514a70e9409caf270047ce3c432354541709ef533d4ef733571f7b1c293e0ec61ea64d2c9679cccdec556bc10b5279af831129546c5ebecb7dbaf7c940a631a0596b98f9fb14cf1c6dae8644b61658d92ac888d03826614040232bbb36fec8b520df74f7524a014afbd58235c33f08f487f721c9fb5a6fd49eb32d7264cca7a4bafd9e1ee1f7d9283f86d80b567d2b22249ae88cf9a72a33f3650aefc50d91aeace34afee47e561a357af11af3a2c6005c2779cf9edc6a2e824131e14dbfbf8801e177c7bddf4084237a161d80f0bfde6e8506ecda6739c9ab6d40c50c6fd4789948e86f3be41f48d9e75f00ec6d7f948062981d4162581f64f2a3f2383d855b1aef49910572364de6f966aa0f1ff0590fb2537cce39924337f1c1b263014f1ee63e44294ff74970dffb21ab71559115f6c245672e59453e07f3f50723b386d42a1088d181f92fc38f843ad98bf97175f155e100c9d7b869362004761ed6a378d5103291be4e2bf5c0d80805be8d8050601825b6149b6ce715271d0cddd29c6ab3b262c24e9ceb232366d01a9bb4bff596bdb10501328dc0e715a463b7e2e65f6515bd0eb602794daa6979877052f6039262d1b4168262d59085c7638c7e978b289ddb7508e2b3278c6b07caa7bf9f3ee6f5f5c694f8d69cf04e218c0139350804d275fd9af0eef6c553ce0fe7fcc9af72ba4c6418789f7f2b850253de3f1042cf1629ce60a5468b95a16a518b213a813a33fe6c71fa4b0e320a574a154b533175eef90cb1f81e5f8a680964afd9ef821586444bdd5d3aa2151a6b0f5a23fe4d29aaf18cd4bd03beba2256e0504e5ce8ace716f243e0b66c2b39a79e3ea91a6b177ac40e09f1cd5cd41838b921f112b814348b04f0e917bf01cd87f30ce4a4a119390da62329a0eddfd4a318cbaf3abf7406344fc80111f2c00a793729ddd40d22fee0f594c23613019adb6b24ed8ddc219a6b61a8aea64220ca466e785f6d77eda5e9e9814dab4adad2eb83ffd126dcdf20578a9e4c457e827f7164870ccf3aad14fc7616db70fc629970e23e1619cc07137b6baeb42a868c0ee5085d94063f20cada4fd2a92111250cd979df0c316e35098f318d3a3ae50b51f1e62a24734dc527970d922b7048eda2416b8c4882af54bc55f020afec849a76a42a6bab9cd83990b773821ad2bb3dbfd2d37547ff8987e36eadffcf00197fb36754992c5a9dcec6e488de3d18ae7f8f478e81d6e36605404f01ab24ee01518ae5f9bdff91a64e3f8224e120d7247afc04e9f0979deeed90d38a7f272fef2ba3c8af982652bd840897d63f250ef842e451fca75fb1832cbf70c0f0b2e7236677052a35cf4cb4eb701b09dccc14536f539b295f6d060c33ac12f49f0caf4327fe398416df2e074921b36fbe7cce940b0e42709e28bd5c1fb87bd4917a53e66ee18f1402a84f64577f8e8b9c194d16ca15ab3f1683e81951cadc4d5e0333f8c199e3af4f03c8a1598658dbe4a132c2c1dfb09c76bcc99cdf7d97e3bd2dc3f69d6d496efccac86ff494214ac96fb9e2a316eb12151f96001355304c9fb5769d96d7574a3f90344cc4822343e5514f8bc7cb92595f5f6b6d37ed8bda904193f698eaed627f8df1bc2e9a2e3ae20192ee1cc9ae98cf92a4a182e483196e673fcc087e80ce96c54a25a1d60fe76210b6cd22874e041fa394dd690ec32c2ebe26e27dbbcd8b479e7f5c45cdd99d4a839b1a3a038804a03203d314cfc550b00c074d996df225f09eb94df8cb667c4ebf08352e73955d9e2c0ed984d49841995851a84ea2f9fd7a95d3c6572c23fe120b747c71719b0fef7512d90bec7f233e13d932f7f5db32c89a6fe1a3bffa45d7da1eee3199a270eb5bf1dc22f65e350199821209005ccb596343dbc6da511fe2390ba86248172c090e8580d4e63f41e51d511db2ac79fb0d9c28f766e95d435433754b0b2e702c4a2d17474ace8bb5332dec1fbc7bfe7d5e564a6d8f38033f6d3ec77328f8b8340224533418d4a5efefe89481fbe95f63282de6040e391569b0ca92a466066772ad30b667e6f81b49a8ac1555919c9c26de62872976e4221f1f6a34b296f0629acddb69fa2d089e2d00dde500b198fca24b9ab10fa079f9a1fcbe74041f3fedc8016566cc001fd8a9cb8e9dd84bb1408c28095915ed3c00016e8c43108418318f0d94325993ef4348c1ff5c183aec8a6c85c696fb83fd3d3504cd0f65cd3dc6b7ce9d6bfad5da196d7ca2c03da0aa056bd8b878c36d66d83c4b177eb82819da13187b0cf688f480efadc46b2dae57bce7dd90f8aeb1474e600be813fe633d2fca701700ee77c0fba2d5047f4640f1141d68d1b5a3401d73e6b10cc59884278f72dc9c33d29cd105a534a81caaea751a00d1ed1850682f71adca0eaf31f623d70eaa65a94a167c5676e5c67b85bfa2c5a8fe1289209af9f25d7b6c4e003051c70fe364c613013801daee154c1efc1477d866b9c81f4b58dbabdb5f53a6642466b3f367d120e0227191460003963aa6d9fb68907743b1cc1802bfd895d308591814791d46373050e6316107a0a8d943ec82d01e7d4a0e9f46861d68d7aa81a17c07f46178c8417e9f8f804a76186e72570a7350d2f24d51435e41e4cc51d9cab282193e1aaf721c1f167a67181733da78f6707e84323cfb9ca774f1c0ed449291c7b14b06208650727c81d96f6bb4e2781ded59073730bc3e395db7f65df7f027da437a99541c453f6242f1bd6504c1b6853023d4e0f8ba67608bfeeaab8e58e2ffa6ca31f330dfe686dfd35aefab605747bc44ec98ddc5dea15a45ea42a0755f5cc01f0669a4576b60b8c04c46c6664e9e912ed24fcc17ba719e69e27b97bdb88d29a70b42e077caaf0f39949fa1d4d47d94edee1c44325bdda03be6a82f66df4feaf73bacc119ebbb06da4e63386fd35</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的夏天</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2568 GCD 题解</title>
    <link href="/2021/lg2568-solution/"/>
    <url>/2021/lg2568-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><p>设 <span class="math inline">\(p\)</span> 为质数且 <spanclass="math inline">\(p \le n\)</span>。</p><p>显然的，若 <span class="math inline">\(\gcd(x,y)=1\)</span>，则 <spanclass="math inline">\(\gcd(x \times p,y \times p)=p\)</span>。</p><p>问题转化为求互质的数对 <span class="math inline">\((x,y)\)</span>的个数。</p><p>这时候就要用上欧拉函数了！</p><p>由于欧拉函数是与一个数互质，那么用前缀和。</p><p>由于 <span class="math inline">\((x,y)\)</span> 与 <spanclass="math inline">\((y,x)\)</span> 算两种，所以计数时要乘 <spanclass="math inline">\(2\)</span>。</p><p>设 <span class="math inline">\(m\)</span> 为 <spanclass="math inline">\(n\)</span> 的约数个数，<spanclass="math inline">\(p_i\)</span> 为 <spanclass="math inline">\(n\)</span> 的第 <spanclass="math inline">\(i\)</span> 个约数。 则答案为</p><p><span class="math display">\[\sum_{i=1}^m{2 \times \varphi \Big(\frac{n}{p_i} \Big)-\varphi(1)}\]</span></p><p><span class="math display">\[2 \times  \sum_{i=1}^m{\varphi \Big(\frac{n}{p_i} \Big)-1}\]</span></p><p><span class="math display">\[2 \times  \Bigg(\sum_{i=1}^m{\varphi \Big(\frac{n}{p_i}\Big)} \Bigg) - m\]</span></p><p>实现的时候用欧拉筛。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">6</span>;ll n, m, ans, v[N], p[N], phi[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> i, j;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">if</span>(!v[i]) v[i]=i, p[++m]=i, phi[i]=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;            <span class="hljs-keyword">if</span>(p[j]&gt;v[i]||p[j]*i&gt;n) <span class="hljs-keyword">break</span> ;            v[p[j]*i]=p[j];            phi[p[j]*i]=phi[i]*(i%p[j]?p[j]<span class="hljs-number">-1</span>:p[j]);        &#125;        phi[i]+=phi[i<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) ans+=phi[n/p[i]];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans&lt;&lt;<span class="hljs-number">1</span>)-m);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>欧拉函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1061C Multiplicity 题解</title>
    <link href="/2021/cf1061c-solution/"/>
    <url>/2021/cf1061c-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><div class="note note-info">            <p>本文重写于 2023.9.1</p>          </div><p>朴素的状态就设 <span class="math inline">\(f(i,j)\)</span> 为考虑前<span class="math inline">\(i\)</span> 个数，选出了 <spanclass="math inline">\(j\)</span> 个数的方案数。</p><p>有转移 <span class="math display">\[f(i,j) = \begin{cases}f(i-1,j)+f(i-1,j-1) &amp; j \mid a_i\\f(i-1,j) &amp; j \nmid a_i\end{cases}\]</span> 考虑优化。</p><p>空间的问题可以通过滚动数组解决。</p><p>注意到对于一个 <span class="math inline">\(i\)</span>，只有 <spanclass="math inline">\(j&#39;\)</span> 为 <spanclass="math inline">\(i\)</span> 的约数时才会从 <spanclass="math inline">\(j&#39;\)</span> 贡献到 <spanclass="math inline">\(j&#39;+1\)</span>。然后在 <spanclass="math inline">\([1,10^6]\)</span> 的范围内，约数个数最多是 <spanclass="math inline">\(240\)</span>。</p><p>所以我们直接对每个 <span class="math inline">\(a_i\)</span>求约束集合，暴力从约数处转移过来就行。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-type">int</span> n, a[N], f[N];<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;vector&lt;<span class="hljs-type">int</span>&gt; factor;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;factor.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">if</span>(i*i!=x) factor.<span class="hljs-built_in">pb</span>(x/i);&#125;<span class="hljs-built_in">sort</span>(factor.<span class="hljs-built_in">begin</span>(),factor.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-keyword">return</span> factor;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>();f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;vector&lt;<span class="hljs-type">int</span>&gt; factor=<span class="hljs-built_in">divide</span>(a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:factor) <span class="hljs-keyword">if</span>(x&lt;=i) (f[x]+=f[x<span class="hljs-number">-1</span>])%=mod;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) (ans+=f[i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>致2021的夏</title>
    <link href="/2021/to-Natsu2021/"/>
    <url>/2021/to-Natsu2021/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ae5e16aa3636f7ef492be3475bed6630ee733a8ffb3109d70498fa84a85c8fa6">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bc5b7cd4f87baec3fd3e832a2262ad5bb4e54a69e5f79e2740b28436eb16a625322cf7c44f48a3dfef555fa1fa5c0374a4807959f4e79b8434393459190babd54289591efdc243d37e5fd015e9f5d41ea293f4e0ce207aa1662340e999e17e7862bf9dccdee6661d1152dea597bcefc21f864249576fac1fca28774fb86b481ffed27de5ab17032179518e27bb4cb35c032dbbbccbae0d9b20bffc505b36d9f80ae7e885222bb362bc3f3333c36c1dcff03789b373ff740af6ab6c6c951c2f4a8f6bf69724f6adf7e3eacf9cb8eb1f7a6768abe28e9c47851d00014da77ddc01e85b781a6873522e148751d4ec8475c892e40c74204e0e742ba0012b72bf7705529ebf87cefa4bcecac68a7490a03e0903075b9b560a8cc86be8a8007b78832114bc19fac85dfe581d65216603ed809ea3175690d6a2dacf9dfae051233d9cbecb66f1ce87a6135e48659439e11957d50c2969f2452a35bcdb6a5a4ccf0bd5838d8ce3eacf9b40ac8b7011d6d81bf98340c55e964fe859e9e02b540bef0dfb20b7753a4938f36ba8fb89789465232dab12e9906bda3f58c1ba9b222362a7cccfdf9c2c96784d61ee2605d2f27adc47cc666a81db84ce3c9416df47ad704e876752dbaaf6f42c6b446ff148e33ffc3dcc656d00763d6e2ba292cbacf33cdda0affdab9feb385a3fd223a2118556f4a62afae4226bd02e4a3d051207c5bb53903d20acdb6740bdf517ab538e1d8b6354116a016e9ec4e0b3fd027c6b8cb2f4da8560f3d1f2866d201139f95daaf8dc4905fa79b1bdea32baaab9d4d6f14c45e4c5b7ad20af05edfd458d199f770d28cc9f920bb41bc9632f5520778b87a4ef0cdeb77734b38114b768a51e669e472705aa1c7b35298716f6be3a91a0c453a1dc6e13612402022e3e48b59269b51e3aab06c189b36165859052bbf24280fc09da580b29a9bcf1fd6d85af09f4630a53f232ef60be71c4ad976222adc8af9e222ec3505b373ba1977b746925fdeff96d2565ea494d05b11baa013f40fa3fcce1ab6b5812402bf91c0af2774a81516101589f0f0224721f54b353c5d09a0cd20bb12db32435ce2e99b6e9f66f1a9aa52b7949f7c4edd65bacbef1a77ec82c165dcdc47f7a1cc8dfbde3cc56456932c5b7fb3cc6c9fa1678ba8da9b826beb88f4cf14f361545aa6fbdab421c80634c100d375e8b3338137c92ac4e9ad87d3fe259b326ec17c27ea1113092de72df6c5df8bc6c3734adc936d787a568f1deface121c77d60fbcb9ce2bb1be73a9b727902e2114d4319251a2fbe71289d91616c755330f073911a0ccbc0d36d1fcfc03f2a3c6b10084e5c43f0e25b5253a29618c7e2fbf0b47dc189af04187e7aa3a0d1e39894d7386f1d3b4c33d22e348e4c04a462bc153ca69afe2d5b1e58e073037cff66560e067804abafec0429b1e4399fddb1dad5e644d8769d5b26bc0155da487aa57bd51add000421460a836e212a69287060a651f9a87ed5b898c72982263a761060292d2ab5ad7b27504a62d62c81b6b8b4b2d496d13a3fce1acaba311193ef78ad4179be735663a01a1cbc1ab5d129220921a6806afb5f9c592c7e963a20e50ea989edad5eaa69b48645f9d7a75d8638f20b81c3c02c06f0046eefee9f80cfb7b48bf25007f396338a364ea8876b3e0d9208deb16c8b96914b1fde93a765d358ecf737cb572f8aa4ef9f310d44fdaeec43f3f98b20c045b7df26e9f2aba8982cd3e3ad07ec381cbaacfff2099c06678022b7a4a44e8624879d11969673fe8a859ab1a94838abc5823c75f8c044595a7eb781e8cd6dc3c69ea5731ebca4a96f239d53c50dc07c00148ceb196de616c640a901a789fc3d3694d1195899b3e0a975b1034f9a1c0eba96847eae1eb72204d798f7420179a033139d2d3476071c435218f7fac3b0108f186d2036d00a42c25ae62054a4f51fceb4364456d5d36bb0b46b24213176c3080bbf45c979189593b661b8d1d620550ae46bb5c8f910f5f563328c1ce8f0588131eb49fd8ad0cfe8531f8359b4fc1f610b63434f454c50be64b73a2b3d710223ff1925d26b586b6a1a92c26e56557e2eddc01c28f5043f6a43155a87fe78fe12db317918bd8cc95099b99fe67f068d649640691c3a5eb4b78dc329548003c9005478d7a0ce4045e03a8bc2030d33f233da6fb292a3c64049ad32c121555f2b0e014eafbacb636749e0ba37c17424133d7d4bf4ecfa3ae96c13decacfb503e447b6c0e202ec771e37dc4c0de66b01bda26c9d42451c75cad59323b834054def027120062cc06e3a9a08abb6c391347b6c4ec65f86fc1f86ad849b55962829d4c6f901f035e0113ebffeb953b82f31c75b27c8e9cd3957183dbad1b60754910355eb43c00a163fb165536b9e0c410f16bd805b5cccfe02dda726a38982a5ada77299a611038b3bb16575d0833c5280b87695e80a0f846c0e07a3f30d1f1d0dcdd32e3a8a7f823f728304522102dc74083b63c2882eeff2f39b44bd479b628c302be121bb68fef34e8258ce55d285ed775c997064321d1c91712ecda4e55d44c29048b7b5bb1fccef5cfc42fe6e3a25930964343a3b4439dc4ad9c432ab665b23f2983e9d97a7fa2b0fa67a4cb8f641bebbea446b79a805e7af725e39e3bd84cd4ce6c5d0adfb3bc78e6b141a155048c572dee4b60b6efb143aa48246e232dd9e926a5ced5d358c75a859a5465a05988ad2bbcdc71e5b9372ec1ead9b35213dbe826e1ee1936667c92178b3324502a55edcd751e8bd9be1569eb12e87627b0006fd2dfa906326a9efaa62c75f24dff55fccb8518e5f465d69f45520429a9175ac72fb5016d3694a9ea1f23c4459ab5ff611ac823566b2a4f99785a4ab05ed17b80766d0e31a1d25bbb5e46fa5c1975acc8f5eaa19c04661f3f218f0530a6196441bc16a82a37837553bb451578915c68c0b2cad544b627afcd8a6534b675cb8db69da06e43389f12cfccaac49dd8ab7fb498304212c93198427ca609a5b7be89e4ed63ff85fa0745635a5f452fa69ac55f26b952ad1ac7e05178e6c4e40b7b6c462c06c2550a777bb2d65d2e0e5ec98016bc82de76826b5d0402db7d3d148b772b460d208ebc94cf28e0c1e69dff7dbc44bfe9165d717fdec5bcaf38b9f00ab63a611311a0dc9078df77ddf99b0dc14aeb4a4ab4131a9f6e4f6f2111161d51146f5beed36def846a2230fd282e85be65a51940a312356956d28edf772ceae257b2cb49fc5c394166a176ed9ea904176bba6c2bb51affdaac4a6cf79cec4d1eb44527f8808c4183d0848692a32d450e718ba16a7071ede99ae1ef3eb61b3e45febcf92bbc7fd5f35e6bc730035bc198ec0d8e16174402bfe97600329ae4f415d958638563c0cae6f56cea07b568617e344d4838e8e1885bab78bd12db7d77c5d9707a911ddc7df765908d3371515bd04caabc74404de51c5a70b81cc15945919e39b9ea016fbaa76029effbe0f4075caac8acf93eeacdcb2b06defddbb3528bc1b587f5d0228f5a304bdd4081b930542db2c230aaf45a40b9979ced464e0676ebc24197b4d17d1ef6fe11add0066e3c3bc7cb2180adc920e2d1dd11204ffc9695f6c36c13c3846c71377dfadbc942f05d65b3c7c8fe949a25227451a7466485cfedf252967d0ed6bd5c659978ef8891b919f00ab795bc01ef8ffcac42dd764375e13c1a9f23077dda05ba97fd335a7cc91e6bd8d326a7a9868c64650675daab5725fa7eef08d46c8add3079258606bfbecccf1d8298797e0c1335f06d2404bb7837f382ddd0eea0296df9dfe7780ba639d4315ed4fc26b326d7b912bf628f75e98ff58eb7577de36f090db7bff8adcf7f51d955cea869834a2eaf38bddcf21aeff4ffc26b0a3b8efb09e53a0e28cd187daa19df0b3fec954828e2591b64730dd055eca453d796700fd7ed17e33b2187129c7ef567112a045e0a126dab1141a4c32ba8e984e419d6d10e563ebaf67662034a954a3921f8e7e508a3a0139d4eef8f3702456dda4850d6e723274be035aa2a4ef4d1dd2267680e91692740a5f06eefc77a82bddc57b687934b3ca0f86a5ca776a750cad45344eb14b53ee3ad6f69d3633f0e8ff40500c7fad74d25eb14f4b26fa21a499d43389a3692cfe6220e2816d96dc1b220dc09446a51c921cd052763c6250eb495afb9cb384f7521127fccded88bafb2863c702008c81d4ca42803e3c2a2ea28aaf276dbe572a4146f4e5853e413f44a7c0552257bb8c6e8f7dca40fdd25409993b263bb13a2968b7e2ee0753bc3bcab9b6e664613936af8749d4c412cbe4034f1de2cb6e648f608911dcbd96e3c4649d45c683da5fa50a7936a93c6b11e8f706562816e27223b697bd0bf55fd308784a679416b15539c94dbcb3e2338a1d7a6e5ad4cd86263d64a07d030e7e94eca6848e9b103556099d30895e127cc6d41102ab6f10d2aee071085848b2813427f714f9d4b7541b189ec6b5785979f7a067c12cf5ca47105905733993640caf0fdce4261d573f3cfb7ad3f2840a3744cff1620a4c7e07c45e9228c10ecfa9db6c3bdb59c30e2fcaa7f687dfd87cad9f4ab75472b5f2a43c532a6e9a7527bab7b31f67d5e32df842c834f389897c0396441364865912d90342019f68f2cf907225f68482f84a712db5c94672d479929026dce284c8e6ac8b06a06ce27807b4a723d40875da7f818d2a8fb2f791f1ecb7b2d9afdcc9dd926ee15f2bb023d15e2403d3ebf32fd57f5b612b33da025a0b1bc529b4d70e1633d7ac2cf8b5e1229eee524808d048ba4f41f6a015f66cee3c926d1846d7a20c55d22e4cf76e683cde4c7ed817cde1cf0aedbcc733777bdf9f82f36a097e9349682435b715a95c72e336a188bd9604879f5e210b2e40450e017bc958dd15df8121808e2980c6f62b47c7c9cf4e39f76243bf4f5c68c84a81cd720d5edee1eeafa74c2b9f3d0004432eded0e4fcc1ee64e1e5bdaa001d8371d4e93facb55a5fdeac5636eca72678e94348e038b59f1578b4a35dc0660ba2e803023d0305a29a4e9f8e64febf8cbc702ad7f84997c55ca9b435d9dc9c8cf96223af48a13bd7e376ac85b39739d5d0c2c1b237c165ba1d48ee527d2c3c776f31c11c04e68ed0e7cfe7d7b9c4bb283002f3740b4fe95215f63e283d92ec7e923fac8efab3a517c43aba004240e13f702f921523cb3a35a498b2716041ce93aed3a69304cb877c37552d19248fccc0ac27569ccce0c00fed9d4da0800c062936dc2332848f0bcfec41bd98ef4348d10f85e1e4c173b55b0c101bec693acde9780a71a853865d1247ea1f0aaa3ad193814c8413e75021f50f42092b37161409c2bfe19e9028283bb86298ba11ef2b3999faa2a4806c5bef4900387e601d8957988c866fe63c81a9175187ae5566e5d8c532ef47e2a6143d4a84cae7025eb49bdcf75ac102fb73fb9fa152876a5851ab63543e1e616be9af0e503a97756e78423eff49616b9e79d0b42359e3f4f316145360f6aa5a099a5eae539736b811efc1e25a3492103fdecf04185d75b28ec03ed17e02418d4f6e581aa76c6e436bfbb7caf6dbf19a5d3337dc65ae49a560c1d903bddc5bb01580761d37597719b1e6082f63ce1fb1501b4fb52fd671334b42d9dcb08f4c73aec559f34a07afc318e6de3340eaa839a5ed9731d24fe621e92ceb1618becfe9897b24fa4f42b66f944a43f1cebce67f19e1113e164bed4c3212c88685ea6482feec6dc5bf03298a4e021cb3103c1f0dbf8020418879d62854f6e0c8d2366b74e383e4dd712568a66e6aa79b98be6c5e42652cf02b095c0ecee08568cd1f4d5b1aed59695d2686314b913eba3aafef6b18eef964851505643189f1a4ffc501e9e4ee8cc47d764919fbc8d3bef94474f88080834f7edff341ba21ad1040cc5b48943e5c41fa92eb0feac5e25e6287082bc2d32a362a7f1afd599fb6e3ce66b33b22d8c200db72985229aaf567817000dbe028d79d9f259ee78e1fd8f035ee2c5ca99b69b9d43c7d6238448ab250ea1719578c4041fc33fa0d24ffe0067450a6ca27feeb4e8ccaf5ddfbb4770d13016ecc27798c973f36e8f8a8caca677dbb560ddafbfa2aa32906ae2c5c3e166a305b32f484c312ed564baa765697a4d80bb62a30cf53356bf164f09459d65af3c600ad3bf5316a1694b5866fab9900b5577ca2c868c1721da2de4d0acc0e713243549693bc3301b25a2f8781baf1c14b58e3121701710037619f8b7104458f410905ceb319ff4b671aa6212ed3d40d28c3e2b8379c062d10b04686fca081096be6e4883b3a633fd352669023eb355e12fadd3045790ee783bd2458eaf04b72b58216bf22f68fccaee84d5c2acdb7c2046b019a9fbd98a33bbecd28e61389fcce87fa0bd5d4145b3292a5f3143ab537f74a86997ecd949993c5fa2036ae22327f9dcefef60dab473a1a929bb7007db149c14127b831ab8a2cf2e2c04a9ebda04a0149cd65cd74974119088d6a8438055805b67d911d254bb3fa7099be33e30a3edb7531fcc4f05172dedeb947bcbacccca0a797cd0e26865ca077b8e6d919dd901a72850e4fd3d98c81552981d68f8b4c285ae82501aa874502453b842d694e2a9d6922310296b8b37649dce709aa038f9074b02cbe6a293fd358e519690bc2a163ace64c6b1696cc7d270e0fa59112906bdf63ba4918679a8ce08ab508822c236d892d31f0bcd2a4eb2c5193e01169fe7025d13212bd22030b73ac9c14836469ddcc10b43acda4a15ce411307e3c85ebb9213f6cdc96ac6706d74fe88686796c3bfcd80e5e50ae3bc1ba26e267b260bbd0fcb93c0c22940bb58a5b83fb02ac51be84b3c79e006f732d8935d2804d5f1373c37511516b8bfb58dbe09b1a4391c6c150a325b65ff82d5a27980869942065f3aed40f8ab057745938d3cae36fc6f001dca97e1c4885c425ac43ec5617e9a7488c3b53ad8733672515883a88cff23da95c3b6c47a5d3f6bbc515603454f5500793f3c1940946bb4fe38945679c049ed4faf52f5981171835c2476a363e5f4a19dcf66a964d722a85ef359ef5f4231ac7f7867faec684a0e0f74ed3cb3cdf5938a30a5184c096df0405c50db82fa3a454531d6fcd1132930ec37048b1647ac4f3ba72f9c264428e17974bff0a0e420b314c605e027bfe8efc000af0ad2833e13093e822f1694e41f8ccbb9dd46469c5aa25cc4d2e4c9c57eff621c4553a018fbfd85eb3628f2926b71f164b8afc44d968c0fa8c6c879e1b581e115d4a8ea981304f8142d9087889b439ac740a1ccea041ca0329f6647e8e8b5e82308fe6aa5f5f620eaf289fa18c2460a6e74495172132e073e68d52b020a2447cf8b10e24ca38a691a966a6327d1181de344f8d44917efd2cbc613b40bba809893b6f6e9ea302254fc091c4483b41104ef806300576ccf3530930092cd3c4b1f95201f7d89f51455f0869e2851221a971f65f01f232acfea42f046441a924500bd16240088e2cb9611263e0beb53d25847d68dfd35766778ebe0b0ddd2cf597ca1b2dc67b8e3d570bdfc7ce1fd218dbc0f6f2ac551b6dbc4f7ccdb1a7516ba5e5d3f8f7e4593877201fed519e028c93578dce318f726ea64945cfed6b31931eadf47741139afcce639364b76bd3e2279028939c983ce857fe3eed7e38e23ace027b159f325ca594ded7b75d13d6ebceade06da6c2ee15c1f04aac4318c1bdd17b7cec444ae62544d5e8ccf7eedd4eee730aa17f7ca090830ec97c5c9e7b9352105ca7d6113dca83cc4ed2672bb73114dda19146072c4add1d144c9c4d9e0f4e9fe24072986d3dae7decd6cec92629862ae4350b7afcf6c6de74ff16e68ff3d3c55b4c212f1a8e2c3dfefb6dc9115c01077c0835b8687989d7dda717faa3a3632d48b9cd00d54f9cb8039e554121442b2f7906b227d3acdf41d2cc24b66213fc6c550a7ae6f72af4e99007da23be0230bb9da9b1782c1b70457be95cd23a7c4cc40c431baa6e883076a72982b756dabfd389fba29867cd0989b836fa53bb1050d416715978c951d2bf20755ae27714d85b71e41069cd3f48b966e48a8d525202e619abcfb813e5880c0f6f83eef17b13577105b3b113862519362040ed6c868c1b624e4415b0679520e7ca99ee96000e138219aa482846f23d17a29ea51aac5f9c9ddd37144dfb40f11a54ba3da6e46923bc8ff89b3f3f960d21a4ccaa582f0a1441f44cd177da199361e54f91afa35f14bcb075f06c22383b0253423fe031b776389a725611ac7c74639d7ff5434637d03eeefb5b10008f765757cade030650ca75d791c6489c865388557e2d188c1d28a0dd45e20e7e5945302b6a136311a1e7ddd985cb11350ca4d36c8d6d907ea36565b4180a3379589000eb6483dabf1016f3cb0abb3731809715781ae168299a17c4f67c4b3a58365757eb345eadc53479af2bb3c7655062742c7d1a9fb3fc5f9040ef56b73903610ed8c2dcfac4739241ce65d1a3e740b64f3e07f7efc3499f94f77a0e4704e3df3add4bcde3dbff3ef590d5aad684b68b2dcf729be7206e52447a405217f36b6df46ef4f77a7dc04a7f35c482520aa1f0416d9d4f9211b6f3a3d107cf3657a7cad6dde0d1698e9080dd51b14970bf87c458406dce74f310222f0d1e26e53f5e95ad2faa935ebf9ebf1a1deb6582891855163030188d97c105cae64a60fcc09aa6cf1b9504a388513a42e606f17b6f3ce6d19649d24e5387839a5e8c0a02713e6eed020345c40ea41bce59a5f960443972daf03cf1e23c9702046ce61f02d2dcfecc2a2f844fd8f88f79e59defc7c087f53d16d61455208024aab92804a334f9c24d1d947afc1c5caa33ac8a882430c34b2398c8143ec39484a7fe253c2dda581dac344b12155d68314c7c1363613fbb98c859c2ea3fa76b0bace6081f55ab4c1c88918a5ae2b1aff16de638476026fece58184932866082761b82615a3db5d6cae988ac852c9797e071c368c90d272b14c3b85333123832b14d22bf1b456c3b0063da0baccfd1cd8b26c204ee546ddda1783c12a666f672ac6d616bfe8c4c02ea8785b807ec764b1dc2066600e6ea38c8e678694773c9afbe623cbf477a9652564b735d9859b427bd15270df3a106a41c3c9ce4c71467fe44204f28d37b7035ffe9727f8c8b290dbdee54ce387b1bfc06eab322c45ff4d423d18f91203ee21f1a55d7fca82360b7610b6d35f8a81a2d2a14278e7398e701351dafb3506fac34897f90f2aef092216f92447a15eb5a7ea28f6218bd7b7369346e4d9f85c36bc5b84e2b4e5429586b729b7c6060993fbe680e6ff973e6ad90bc4bc0756afeff937637c61fa541382b48fc65076ab3904c308f32cfcb1365e7b082f215f4f5db64f6f8a8eb29a9c6c474b97ee13925d63c1f61456655f3e54f6234e1bf6a20fe4bb6bb2916820e132e78c559672dfc9758108b1de5ee4ec5df4dff027967f1424713b9ee11da5f3a463b8f465f255592fbdb782bbe5058825afe57c14926336ba27cf547ae064df1e638383c33a1ea043e00b6ce6dd8d6621979011a64396ccf23f3786e1f7bae9664003e5510aae72818fbe816d4f5c56a16f89d561f05f612c92d6a358a53462c2dd8f132dcdaca144d8255c70ce715a033fce7ba917a4beba0b9c165acb251f9a9a92ecea7a4bd85a38bb45bc0430e2100d160fc910141df4ac2539399036d8d5a53aa0c7020704091cbbf475c5b8ec58de20ea0d42286c99d7065521bc35d5fcc852bed115d9321854ad015c1573749e79a3a8ea19839ae1410d9d4b16251ecafd235f6232bd682193e08df68370d7b25f09b996f9d8f135ba449c2fb64239a3d1230e0cac1110544986501e8a849fa40a671537778341e42c2a839a91bb517260e9f9cce6fd66d7433977d9e12df748a7f9f903c32ba7a3ce900252c8fdb7d225e77a59c41c63b2563f83f3d1da8108685290e513592c674d7ebabf240b84a0d847f22edea57d8f23b3ce197ccf7f335ebbd16c4032e07e677c9462a3532d7d0651a4c41571c228febc95f7195d0dcba76f4718b4e4f6c034c7500c942c078f0545f9ece9efeaab7fdb0d9a05d81d78961fb58a572b6ca6dab02cbe9c42d6f093ff7d7938ad31d32b786273b9f3811cd10276b7e08f59a96a1b8ea37200e727e466635d7b3579aba7c2d739f25d69edf6e410b7448d7530ba172387930f0389cf15ac9813d22a1a3d66601818e1d7d142cf56828b53e0797800615dd98da02b29f096778796d1d314623afc4224efb2c65e821df487d4640238f7af25b89c43ed7f073101ba5228538fa5945802bf6c9c080baf0e189084716cef77c0d89f3a4a068fe307e3d4243b76007bef22a02fdf2f7b373da34993d22747e76b0b517f191ed877bff6d00e07d2c90ecabf5dca25a3fc9b24862e3e020f03548d035e0fe64388fed71fa2bc9ba0613cf327dac8546e14245b518ea18341d1e842c2c1d8f93094799715f819ad11162db5330725a712e9dda198667ae81022f725f7781aff970557d79bdfd90da07d8d6481193f9df7ca53541c294a12721c710fdc70bb0b56fec2784889ca28fa506649132e32251ff0829a7b919e800222e0caf03d86bfaa44d36692b34e884a1dafd75a878d7c6bed2ca2103a0d4fb0bc71c8fc6add3d3764b0a422271ab5ea2f17e80f0b76de780b74505e61506f9a62c04ffdb49563c5c753da693aa388b38f91253c9e31031614fd369ea89a5bcab5609ace67091f23b0a45050c202bcc088f3b025e7f1076414b3449475dc605b70c682b9d5ca4ee528b33c3f62663d0ae24151ad3dfb7ae8e91738483c701077d9580e186ae0ca7ace6af9f4ce35b662fea7956ee635b8d2588457a388326c3343ebea1d51725c24380054340c44fa6cef593043d0ebb1973460440aa9f9f98eb66450f8224a93e32a4b9af764b9a62018a7b3de24f3cd607dc4c6b6b8b1bd22e9a49d427758eaf796ff6a9d1902b0ce5e4adb59aaf640c25e2833c938f26e0fecde04277b65579928ef175dce8f660ad56819c8723c16fdc16993c5aad0ec31b826313e07523de78ebaef30b3c3f688dc5321a154ee816969b2d22a1d223f30bcd97e9e71c41454f5e12e15ef2794d6ab80e79928a265dbdcb14ac416c03c52fc3f9f739db85ed32f1531b368968d673934f5f935bf2d8c04830ad27317b7a0f843819e6b8975fb8a5b222978abf5aae70dc9ee52aa49fdb619cdadcb177c068f4898423b21976dd22bb310635c137ce1dd3b872acda6ed1a731af84be5ce1b546bc996fb30c7a084f35aef95cba319a266d4e00686e3a14a408a4966f67cac01e9fc0df3cddec25df924c71b3c3685e5455f8f1f5c9c4192790f00ce03c6fa0936135159982c0373302318ca1a8164cf79fa8ed1b02d456eb5428ad6853744b31641a61334049240425c9567c2284a9bc92c02211ea85f633f318d26f0296b016f0714be6d0f004700d504739197dad3adaeba4b95f1b712962a10c6f5b8a632e7e5b072111c796480edd12a684a90d0e0d00bdfc96505970e5f2b3f037bddc7ba8f7662e0141e2266a7794f415a033b9e6ad6bb3e13b6f03b9da2028b116f935004e584cd57583b82729b2a4bcc1150a09b531b3c1bd7f19cad4480c9a9f33b896610cd89c942a7dc9fa70f58ac4b80fb0bfc2fc6e086d71819fbcced148378e8b9415a18b6b72bbdb3b6dcde5a9a30a314924c92353e9ac76be3afb8261458bd74cc29fb9f63e47a7002362d17e58eec1db8287898851d2c62925411ee00f0e71d008b537417218c43b71a03a4723d5acb7a74186e5455fcf9b697baae98770171ce516687f666505ab5497c7ffa27130d59d67bf243056b25f4c2711787bd912f7017409c6c5de5924017fa3236edb2ffd2e15f11d406e51303cf38fdd772ed1ee16770c6b45e4da1e8188734712298f919547918f5a226a64bed968e6f4017641b54b9e9a21e8fd1c6012c876d73b1b460c169fa0a6b3c90e50aaae48ace793f795d6ad64571b58ee842e114ecb5bf87012ebbdb0197bff73e728b473e335b368328d830824c12b7a1bfb6f341fb001acf481c62578722d1cca9df1b129ac209112919cda2dd83f5162a1f537939e53b5ed27f6a832a6a7e224327ca47206d79f918455a257e89cf1d2ea168e778544d0df6203cd1234c04de7bbe9bc9d0d8b97dbacb163a5c320e79300bd768f0e0866a666dbbaba0aef1ec055f2ec3dd890c28d9904c516e4c52e53fc7d976e3cba924c10e308e8490e98c29c52237f36476cdd178cbbd637dbd7627a00280e4fb3c847ad3ea8ef75476c72f2f7def4d1d3ffabff542e4cb53292764f38c395df90aa341078c89fbcb5e05a607513d980e54ca75b8229d1735e9acbecbac4ef67fd81afbf8db81e519f9ad499205360d7c852936df79bb3f7c97a732eb82fee5ba8d80c0633d0c76450a7c81309a1b232081806fd505dca148ab25ae8a15936f9519763a61e174e68aacb7d64af0e54a2b3f9da58e11d6c22d49b1bafefbfa9ec6c4ac03ffdda7642d6e11d21c0bc1828da6dce660df952aa446e925500439194faa04296dbedc2117f08f809703efcbe6e06776ba2bfccc7864cddddffed2b0eeeccfcbcebb7ae13e0c349c1918839e107136d7ca4b45f6583cde147b797791348b896867cfdbe5d4bbffb480a2adecb60a8795a32f1ef425ba5738235b4afdc76272f1d422bfce9ba50f71d257a1d5d054fcb115345a3409e70b1c945899d462b308f7bc3739dc6a1d974882d4fdbcb0ac4d2edc2e11b7930fea4d47c9b7cd1ba0430277ee8dfa92e4a8e63ff8299a6011902aee273f3c5f496da8058ad9357b45dee7ba4e120c2922647333f72dc31b9933e4d166fd2dcd1a9b1b80b4b8f6ffb23cc06aa3a8eae1b294e13bba97f4fd0bd349874e29f216f07ed4865277d1f6096521cd1e27fdc0f735f7469dc268fe31134e27c453e138e910914c525b1ab613cd1ce9dff6e56a26659225e97de4c8824fd0c420b16c4b333a47f797073e8b0712d80ebf079a5463686fe61cb471ce7bd22f19c9887a47800de4d41abf6cd2368cff6e9661bceba651f2e29c3ee48dd47fababbe166c07690f14ac8ac8a16fe9b4e2628b7827ad5744d17461145df33229d66de88212c133283c97bc47175bbf307e0fa942d0659620852076011bd5c5a49dcb54533a649fce8092187282f673d4e178027139c079ed22f1d6b885120ab695aaa060eea8d81da262a5a710a4a21dbdc54d2b803d8c4d898d933bdd3f3edbaedb327079a734d0b5ea1a32c1eee147b885dd9ba8194fee297eebb92c380ff121bd90a7fc4b4693a478c52d7d324e4d65cd8f41dd57aa9dd06a2dd4b5b1820731f3313d5220dfc74d012bf4daf7fb9590088ae49f6239c5382134bf6f5f78f78b538d0da77ba1f5302ddf32909fa9fd881147576a636fa5c325064a631f1da7727fc949a6008cb917d51c6109910e7ffa816302fb2722935c9980a7733bec8f67ff9a608a29a0f8c0ce20b4e17ebf8f0ddb206a7e9f77e7d31e371d7f0683ec373b6f088d68d19544f99e615095548c623ffd90e21b3161f70471ba08cdf0ddc779790f1cbe0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的夏天</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3778 商旅 题解</title>
    <link href="/2021/lg3778-solution/"/>
    <url>/2021/lg3778-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><div class="note note-primary">            <p>本文重构于 2023.9.4</p>          </div><p>预处理 <span class="math inline">\(w(i,j)\)</span> 表示从 <spanclass="math inline">\(i\)</span> 出发到达 <spanclass="math inline">\(j\)</span> 能得到的最大收益，<spanclass="math inline">\(d(i,j)\)</span> 表示 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的最短路。</p><p>然后我们把任意 <span class="math inline">\((i,j)\)</span>都提取出来，当成一张新图。</p><p>套路性地二分答案 <spanclass="math inline">\(mid\)</span>，这个答案可行的条件是存在环 <spanclass="math inline">\(C\)</span> 使得</p><p><span class="math display">\[\sum_{(x,y) \in C} w(x,y) - mid \times \sum_{(x,y) \in C} d(x,y) \ge 0\]</span> 把总和摊到每条边上。具体地，新图上 <spanclass="math inline">\((x,y)\)</span> 之间的边权为 <spanclass="math inline">\(w(x,y) - mid \times d(x,y)\)</span>。</p><p>用 <span class="math inline">\(\text{Floyd}\)</span>算法找一下是否存在权值非负的环即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Problem: P3778 [APIO2017] 商旅</span><span class="hljs-comment">// Contest: Luogu</span><span class="hljs-comment">// URL: https://www.luogu.com.cn/problem/P3778</span><span class="hljs-comment">// Author: yozora0908</span><span class="hljs-comment">// Memory Limit: 500 MB</span><span class="hljs-comment">// Time Limit: 3000 ms</span><span class="hljs-comment">// </span><span class="hljs-comment">// Let&#x27;s Daze</span><span class="hljs-comment">// </span><span class="hljs-comment">// Powered by CP Editor (https://cpeditor.org)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">1005</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-type">int</span> n, m, cnt;<span class="hljs-type">int</span> s[N][M], b[N][M], w[N][N];<span class="hljs-type">int</span> d[N][N], f[N][N];<span class="hljs-type">int</span> l, r;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(d[i][k]!=inf) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(d[k][j]!=inf) d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,cnt) <span class="hljs-keyword">if</span>(b[i][k]!=<span class="hljs-number">-1</span>&amp;&amp;s[j][k]!=<span class="hljs-number">-1</span>) &#123;w[i][j]=<span class="hljs-built_in">max</span>(w[i][j],s[j][k]-b[i][k]);&#125;r=<span class="hljs-built_in">max</span>(r,w[i][j]);&#125;<span class="hljs-built_in">floyd</span>();&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span> </span>&#123;<span class="hljs-type">int</span> ans=-inf;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(i==j) f[i][j]=-inf;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[i][j]==inf) f[i][j]=-inf;<span class="hljs-keyword">else</span> f[i][j]=w[i][j]-mid*d[i][j];&#125;<span class="hljs-built_in">rep</span>(k,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(f[i][k]!=-inf) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(f[k][j]!=-inf) &#123;f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][k]+f[k][j]);&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) ans=<span class="hljs-built_in">max</span>(ans,f[i][i]);<span class="hljs-keyword">return</span> ans&gt;=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), cnt=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,n) d[i][j]=inf;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123;b[i][j]=<span class="hljs-built_in">read</span>();s[i][j]=<span class="hljs-built_in">read</span>();&#125;&#125;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();d[x][y]=<span class="hljs-built_in">min</span>(d[x][y],z);&#125;<span class="hljs-built_in">prework</span>();<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-type">int</span> mid=(l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>分数规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDSC2021 游记</title>
    <link href="/2021/SDSC2021/"/>
    <url>/2021/SDSC2021/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><script src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.staticfile.org/meting/2.0.1/Meting.min.js"></script><h3 id="sd-summer-camp">SD summer camp!</h3><p>首先吐槽一句“数据结构提高班”只讲一天数据结构，“高级算法班”讲了线段树、平衡树、分块等等一堆数据结构。。。</p><p> </p><h2 id="报道">7.15 报道</h2><p>大老远坐车到日照，花了整整一上午时间QAQ。在车站坐公交车去山外，山外在最后一站，一路上一直在听歌。为了防止耳机没电就用的有线耳机。</p><p>报道时就已经有好多人了，官方没说明白路线，在学校里转了好久才找到报到处。拿到学员证（fanka）后知道了我在新8号楼，结果这是唯一没有桌子和wifi的宿舍楼、、(╬▔皿▔)╯。还有一些没什么用的信息。</p><p>在宿舍知道我市还有教练带队来的初中生，xxs，<del>没有高中的</del>。认识了来自德州的准高一学生zqr，这家伙还会网络流orz。</p><p>去超市买了可乐和阿萨姆，，，，这一晚上大概就是玩。</p><p> </p><h2 id="day01">7.16 day01</h2><p>山外的空调好冷≡(▔﹏▔)≡，开的16度但是晚上被冻醒好几次，早晨常规6点起床了，早饭吃到了山外最喜欢的豆角。。几乎每天每顿都有。</p><p>今天上午在报告厅上课，由来自莱州一中的 <del>孙名媛</del>孙铭远讲述图论相关知识。</p><p>先讲了 dijkstra以及堆优化与桶优化与次短路问题及其证明，有个大佬说可以用 A star搞。。好吧我不会 A star。</p><p>然后就讲了用 A star 的 K短路问题，很多人不那么理解估价函数，我大概明白了，然鹅我还是不会<del>实现</del>。</p><p>还有已经死掉的某算法以及 Floyd 与 johnson</p><p>接着是最长路问题，没啥好说的，然后下课了。</p><p><strong>这里有一个小插曲</strong>：报告厅在-1楼没有厕所，我们只能去楼上找了一个位置奇怪的厕所。。。然而那里只有两个位置，等着的却又很多人。有人说“这和排队接水是一样的”“你怎么知道每个人用的时间？” “估价函数！”简直笑死。。后来知道正经的厕所在六楼。</p><p>上课后讲了差分约数系统，大概就是一堆不等式的操作，，并且讲述了虚拟原点的作用。</p><p>然后是生成树相关。先介绍了两种常规MST算法与很有意思的 boruvka算法，然后讲述了最小瓶颈路/树和次小生成树。</p><p>随后详细讲了 kruskal重构树及其<strong>优美性质</strong>，今天的课程就结束了。</p><p><strong>各路大佬简直吊打我</strong></p><p>下午自己随便切了几道题目，这段时间的题目会在夏令营结束后选几题单独讲一下。吃完晚饭去机房，然而人却满了，，，有两个组的用同几间机房，白天上机时间错开，但是晚上就不行了。这一点很不满意(* ￣︿￣)</p><p>截至7.18 23:00，我晚上没有在机房抢到一个位置。</p><p>所以我和朋友在宿舍用热点切题去了~</p><p> </p><h2 id="day02">7.17 day02</h2><p>今天早上起晚了一点，，</p><p>依然是孙名媛讲述图论。</p><p>先讲了欧拉回路的定义、性质、<strong>美妙</strong>性质以及运用。</p><p>在讲 CF547D 的时候，“找到一条欧拉回路并对边定向”没有讲述过程，后面做这题的时候直接去世。</p><p>然后是树上相关问题。</p><p>括号序，欧拉序，dfs 序。</p><p>还有重链剖分。</p><p>我在十几天钱看过树上相关问题，对于这种在树上一顿dfs与bfs理解起来还是没有压力的。后面说树链剖分一般和数据结构同时出现（其实基本都是线段树），我/(ㄒoㄒ)/~~</p><p>一个多月前我还会写线段树板子，现在已经忘得差不多了。前几天k神给我一道线段树优化dp，我连读题的心都无了。。。</p><p>最后是 dsu ontree，也叫树上启发式合并。是一种基于重链剖分，合并重复扫描，从而降低复杂度的算法。也没啥复杂的，还是树上操作，实质上是一种<strong>暴力，但不完全暴力</strong> 的算法。</p><p>在最后的最后，甚至还提到了点分治。。真要讲了那真的是“数据结构提高班”了。</p><p>朋友在山外超商里买了一个耳机，花了几十元（忘了。。），同款的在某宝只要个位数就能买到（）。</p><p>认识了来自青岛平度的准高一学生官同学和与他玩mc的小朋友。他的 linux技术实在是太强了 orz。我连 wsl 都不会用 ╥﹏╥...</p><p> </p><p>下午举行了 %你赛 形式的练习</p><p>T1：次短路 T2：差分约束系统 T3：欧拉路径 T4：使用重链剖分求LCAT5：dsu on tree的课件例题 T6：dsu on tree简单习题</p><p>t1、t4我之前做过。t2是小k的农场，机房有大佬发现直接输出<code>Yes</code>可以得85分，还能下载数据。所以他们共同合作，特判数据，得到了比我快4s的速度。t3能想明白，但最后的实现上出了问题，，对边定向到底是个什么操作啊。</p><p>smy发了t5的标程（因为讲课时很多人都没听懂，就算懂了也不会实现），t6只要把t5的板子改一下就行了。</p><p>这个班是选手讲课的下界，往下的班就是教练上课了，但是没有真正意义上的%你赛，上机时还没人盯着(￣y▽,￣)╭</p><p>晚上听了yamf的讲座，讲述他羟基进pku的事情，我在下面玩游戏，大概听了半个多小时就回宿舍了。</p><p> </p><h2 id="day03">7.18 day03</h2><p>早上室内温度又低的离谱，室内比空调制冷的温度还低。</p><p>今天是yamf的数论课，但实际上讲得很少，从最基础的质数开始，最后连exgcd和欧拉函数都没有讲到。</p><p>下午的练习</p><p>T1：分解质因数</p><p>T2：线性筛质数</p><p>T3：GCD&amp;LCM</p><p>T4：进制转换</p><p>T5：同余</p><p>T6：乘法逆元</p><p>t1、t2做过了。t3是gcd和lcm一顿推，最终推出简化的式子。t5开桶统计，t6卡掉了我的费马小定理，，</p><p>唯独t4要单独说一下，<ahref="https://www.luogu.com.cn/problem/P4461">九连环</a></p><p>这道题实质上是一个递推求方案数的题（为什么写进制转换？），但是没有取模，不写高精最终只有30pts。</p><p>然而同机房的神仙发现，用python可以直接水过去，只跑了不到200ms！</p><p>所以我不要脸地去Trick了。 &lt;(＿　＿)&gt;</p><p>晚上是lyh的金牌之路，我听完了，但是大部分时间还是划水。</p><p><strong>想不到lyh也玩 <span class="math inline">\(osu!\)</span></strong></p><p>所以我一边听一边玩。</p><p>听完讲座后去超商买了零食。</p><p>还有好多琐事忘了。</p><p> </p><h2 id="day04">7.19 day04</h2><p>今日的课程可就友好太多了，基础算法，还是yamf。</p><p>yamf：今天的课程一定很轻松的~</p><p>然后他讲了鱼神出的 <ahref="https://www.luogu.com.cn/problem/P5344">【XR-1】逛森林</a></p><p>好多人都没听懂，我当时在打电动，没有听完 QwQ。</p><p>yamf：这题没什么思维难度，就是实现起来比较麻烦。</p><p><img src="https://i.loli.net/2021/07/23/XeU82IrZnlcfEVB.jpg" srcset="/img/loading.gif" lazyload /></p><p>还有二分，st表，倍增，倍增LCA，当然这些没啥好讲的，主要是讲题。</p><p>yamf说他把洛谷账号注销了，除了洛谷独占的题目，别的都是从loj之类的网站找的。</p><p>练习</p><p>T1：bfs</p><p>T2：RMQ（ST表）</p><p>T3：倍增优化数据结构</p><p>T4：使用倍增求LCA</p><p>T5：二分答案的课件例题</p><p>T6：二分答案简单习题</p><p>只有t2做过QAQ</p><p>t3是 <ahref="https://www.luogu.com.cn/problem/P3295">[SCOI2016]萌萌哒</a>，这题我自己想了好久，然而没有想到正解。正解是st表+魔改的并查集。</p><p>t6 <a href="https://www.luogu.com.cn/problem/CF1359F?">RC KaboomShow</a>是一道纯英文的CF题目，首先题面我就没看懂，还有一个类似于扫描线的过程。。。最后放弃了。但是洛谷唯一一篇题解是lyh写的诶~</p><p>晚上的讲座有变动，我没去。</p><p>高级算法班的同学们模拟赛出了三道题，分治，数学和lxl题。zqr只有50pts（</p><p>_rqy：题目太水了</p><p> </p><h2 id="day05">7.20 day05</h2><h3 id="我们最爱的-lxl-来啦">我们最爱的 <spanclass="math inline">\(lxl\)</span> 来啦！</h3><p>lxl：你们这里好热 orz</p><p>lxl讲了树状数组，线段树，单调队列，堆啥的，还有一些题（线段树讲得很浅，用的还是以前的课件，讲得和洛谷五一课几乎一样，然而这并不影响我们对lxl的热♂情）。</p><p>最后还有STL演示！</p><div class="code-wrapper"><pre><code class="hljs cpp">map &lt; string , string &gt; p1;map &lt; <span class="hljs-type">int</span> , <span class="hljs-type">int</span> &gt; p2;p1 [ <span class="hljs-string">&quot;CCF&quot;</span> ] = <span class="hljs-string">&quot;发财&quot;</span>;p1 [ <span class="hljs-string">&quot;lxl&quot;</span> ] = <span class="hljs-string">&quot;良心出题人&quot;</span>;p2 [ <span class="hljs-number">-1</span> ] = <span class="hljs-number">114514</span>;</code></pre></div><p><img src="https://i.loli.net/2021/07/23/Zpcq2zGvAMrhSeL.jpg" srcset="/img/loading.gif" lazyload /></p><p> </p><p><img src="https://i.loli.net/2021/07/23/iE9boYdGJvIyj4g.jpg" srcset="/img/loading.gif" lazyload /></p><p>lxl懒得搞练习题，所以下午自己切题了。</p><p>晚上是smy的dp讲座。</p><p> </p><p><img src="https://i.loli.net/2021/07/23/Rl8FaCMGomXdBxn.jpg" srcset="/img/loading.gif" lazyload /></p><p> </p><p>我究极绿宝石一周目通啦！</p><p>也就是在这一晚，我玩 <span class="math inline">\(OSU!\)</span>​时笔记本电脑突然卡住，关机重启之后x键就失灵了。。</p><p>在超商买了一盒某巢咖啡。</p><p>QWQ</p><p> </p><h2 id="day06">7.21 day06</h2><p>真是有意思的一天。</p><p>今天是lyh的dp课。</p><p>但是这个dp课啊，，，</p><p>从数字三角形开始讲，，，</p><p>是怕有人听不懂还是单纯的水时长啊 (#｀-_ゝ-)</p><p>线性dp，背包，区间dp，树形dp，数位dp，状压dp，单调队列优化（有人说不会单调队列，所有又讲了一遍，水了半小时）。</p><p>每一样都讲了，但是每一样都讲得不是很多，没有讲很多题。</p><p>课件一共讲 40+ 页，但是一共有一百多张。</p><p>最想吐槽的是树形dp。</p><p>例题只有没有上司的舞会和选课。</p><p>练习</p><p>T1 线性dp</p><p>T2 区间dp</p><p>T3/T4：背包（并不是那么显然，可能需要一些思考） T5/T6：树形dp</p><p>六道题我做过4道。。</p><p>估计某位yba神仙也是，然后直接提交上去了，瞬间400，rk1。</p><p>我直接做没做过的题了。</p><p>T4 垃圾（我）陷阱</p><p>显然地，是背包，只不过状态的设计花了我亿点时间。</p><p>T5 “访问”美术馆</p><p>背包属性dp，最难的地方在于读入和建树。</p><p>T5/T6 都是树形背包dp。</p><p>没有做状压dp的题，我不是很喜欢这种复杂度奇高，接近于暴搜的dp。</p><p>树形dp就很不错啊。</p><p>状态设计与转移都很优美，复杂度低，在各种树上问题都能用到，还有很多套路题可以水AC数和题解（</p><p><img src="https://i.loli.net/2021/07/23/yDVQbMRuHnd23xY.jpg" srcset="/img/loading.gif" lazyload /></p><p>晚上在机房切题了，<ahref="https://www.luogu.com.cn/problem/P1131">时态同步</a>和<ahref="https://www.luogu.com.cn/problem/P1453">城市环路</a></p><p>树形dp水题和基环树有点氵的题（因为我一开始的思路错了。。）</p><p>又去了超商。</p><p> </p><h2 id="day07">7.22 day07</h2><p>今天凌晨0:00，我去隔壁宿舍吃零食。</p><p>有个人让我和他们玩三国杀，我就和他们开了一把。</p><p>我的角色牌很垃圾，最后选了界吕蒙。</p><p>就没有然后了 ≡(▔﹏▔)≡</p><p>被管理员查水表了 QAQ</p><p>还做了半个小时的蹲姿 啊啊啊。</p><p>然而早上起来一点都不疼，就是特别困。</p><p>上午讲得dp优化，基本没在听。</p><p>单调队列优化，数据结构优化，斜率优化，杂题选讲。</p><p>斜率优化只听了个大概，不会推式子。</p><p><img src="https://i.loli.net/2021/07/23/baAxm4w9g5fUFlz.jpg" srcset="/img/loading.gif" lazyload /></p><p>下午一点就去练习</p><p>T1：数位dp T2/T3：状压dp T4：二分+单调队列优化 T5/T6：斜率优化</p><p>做得很慢，而且除了 T4 都是看着题解做的。</p><p>被各路神仙吊打。</p><p>好吧。 ╮(╯-╰)╭</p><p>就这样结束了。</p><p>大概明天会就这段时间的题目水几篇题解。</p><hr /><p>走出机房时，正循环播放着<ahref="http://music.163.com/song?id=454966322">ホタライズ -2015 SummerEdition-</a>。闷在耳机里阵阵电吉他声，将刺眼的夕阳染上橘黄色。</p><p>我大步穿行于熙熙攘攘的人群，仿佛自己也成为了他们中的一员。</p><p>仅仅是七天，但似乎不再孑然一身了啊。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的暑假</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
