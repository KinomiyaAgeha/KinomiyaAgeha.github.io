<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>yozora0908's blog - φ(゜▽゜*)♪</title><meta name="author" content="yozora0908"><meta name="copyright" content="yozora0908"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description"><link rel="shortcut icon" href="/img/4.png"><link rel="canonical" href="https://yozora0908.github.io/page/18/"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"prismjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"yozora0908's blog",isPost:!1,isHome:!0,isHighlightShrink:!1,isToc:!1,postUpdate:"2022-12-13 18:13:22"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image:url(https://s2.loli.net/2022/12/13/5fHjuPvxm9dwasc.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">yozora0908's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">yozora0908's blog</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg2446-solution/" title="luogu2446 大陆争霸 题解">luogu2446 大陆争霸 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-02T12:08:23.000Z" title="发表于 2021-10-02 20:08:23">2021-10-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</a></span></div><div class="content">每个点都必须在到到达所有保护它的点后才能进入，我们用一种类似拓扑排序的方式求解。 设 为能够到达节点 最早的时间， 为能够进入节点 最早的时间， 为摧毁 最早的时间。 设 为保护节点 的点的个数。 显然 可以直接用最短路算法求出。 设 ，则 被摧毁后自然能够到达 。 当保护节点 的点处理完之后，就能进行 的转移。 因为有无限多的机器人，所以节点 能够到达的那一刻就能够被摧毁。 具体细节看代码。 #include&lt;bits/stdc++.h&gt; using namespace std; #define R register #define PII pair&lt;int,int&gt; #define mp make_pair const int N=3e3+10, M=1e6+10; int n, m, d[N], p[N], q[N], ind[N]; int cnt, h[N], ver[M&lt;&lt;1], nxt[M&lt;&lt;1], w[M&lt;&lt;1]; int tc, hc[N], vc[M&l ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg3953-solution/" title="luogu3953 逛公园 题解">luogu3953 逛公园 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-02T09:13:58.000Z" title="发表于 2021-10-02 17:13:58">2021-10-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</a></span></div><div class="content">首先跑最短路，本题并不卡那个死掉的算法。 求出 1 号节点到每个点的最短路 。 然后考虑计数。 计数可以考虑 DP，但是必须满足无后效性。 设计一个类似于分层图的状态。 为 1 号节点到 号节点，距离为 的方案数。 考虑转移，假定 能转移到 。 设 边权为 ，则有 转移为 对于 ，关于 的状态反而依赖关于 的状态。那么必定是建反图，然后记忆化搜索。 边界 答案   考虑无解的情况。 题目描述中告诉我们有 0 边。 我们发现，有无穷多条合法路径，当且仅当有边权为 0 的环。又因为没有负边权，所以 0 环一定由若干 0 边构成。 如何找出 0 环呢？ 观察我们的转移，不难想到，在 0 边上，，即会递归到 如果有 0 环，那么一定又会再次访问到 。 所以对于每个 ，用 来记录访问情况。每访问到一个状态，将其记为 1，访问完之后就改回 0。如果访问到 1 的状态，就证明有 0 环，无解。 这也恰好说明了，这个状态是“无环”的。并不是真的不可能存在环，但是如果访问一圈回到 ，说明存在环，也就直接无解了，不需要再考 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg1600-solution/" title="luogu1600 天天爱跑步 题解">luogu1600 天天爱跑步 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-02T06:57:10.000Z" title="发表于 2021-10-02 14:57:10">2021-10-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/">树上差分</a></span></div><div class="content">经典树上差分。 考虑能观察到玩家的条件，不难发现，对于每个观察员 ，能观察到玩家 ，当且仅当满足 上述两式可化为 观察员可以看作点。 对于一条 的路径，由于玩家会经过路径上的每一个点，等号左边是个定值，所以问题可以转化为 对于每条路径，将路径上每一个点都加上两个权值为等号左边的物品。询问每个点权值等于等号右边的物品的个数，两种物品分别计数。   显然是树上差分。 对于每个玩家 ，求出 ，令 然后考虑计数。 用 记录两种加法操作，用 记录两种减法操作。 用值域数组 ，分别记录两种操作的物品个数。 则要对应着差分来计数，对于每个点的操作，令对应位置加 1 或减 1。 设计数前 。 计数后集合得到答案 注意 可能为负，平移一下下标就好了。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; #define pb push_back #define sz size const int ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg4381-solution/" title="luogu4381 Island 题解">luogu4381 Island 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-01T13:12:35.000Z" title="发表于 2021-10-01 21:12:35">2021-10-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/">基环树</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调队列</a></span></div><div class="content">不难发现，给出的是一个基环树森林。 渡船的使用条件，实际上是：离开一颗基环树后，就不能再回来。 题目要求走过的路最长，不难想到是基环树的直径。 显然基环树的直径有两种可能 在去掉环后的某棵子树中（若有负边权） 两端在在去掉环后的两颗子树中 / 把环断开后，树的直径 （但在本题中只有第二种就是了） 最终答案为每颗基环树直径的和。 对于第一种情况，找到环后，以环上的每个节点为根，在它的子树中跑 DP 求最长链就行了。 设以环上节点 为根，不经过换上节点，能够到达的最远距离为 ，两点间距离为 。 第二种情况仅仅是：选择两个环上的点 ，最大化 。 考虑环形 DP 的处理方案，我们将环断开并复制一倍，用单调队列优化点的枚举。 用前缀和处理两点间的距离，设其为 。 设环为 。 在队头维护：满足 的最大的 。 在队尾维护： 单调减。 环上两点有顺时针和逆时针两个距离，本题无负权，所以其中一个距离一定大于另一个。 若环上有 个节点，则在队头排除距离小于 的决策。 实现时注意细节。 #include&lt;bits/stdc++.h&gt; ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg2491-solution/" title="luogu2491 消防 题解">luogu2491 消防 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-01T12:38:50.000Z" title="发表于 2021-10-01 20:38:50">2021-10-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调队列</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">树的直径</a></span></div><div class="content">实际上就是 树网的核 的数据加强版。 原题暴力枚举即可，本题也可以用复杂度为 的二分答案，这里只讲述单调队列的 算法。 题意：在树的直径上选择两个距离不超过 的点，最小化「偏心距」。 「偏心距」：树中距离直径最远的节点到直径的距离。 显然，可以用单调队列维护。 设直径为 ，其节点数为 ，直径上两点为 ， 为从 出发，不经过直径上的其他点，能够到达的最远距离。 为 之间的距离。 不难想到此时偏心距为 仔细观察不难发现， 的定义域为 ，而无论如何选择两个点，最终一定取到 。 所以上式可化为 而 是一个定值，设其为 。 求出 上节点距离的前缀和数组 。 则 用单调队列维护队头为 满足 的最大的 即可。 写的很麻烦…… #include&lt;bits/stdc++.h&gt; using namespace std; const int N=3e5+10; int n, s, t, mx, o, d[N], f[N], sum[N], a[N], b[N]; int c, h[N], ver[N&lt;&lt;1], w[N&lt ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg3304-solution/" title="luogu3304 直径 题解">luogu3304 直径 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-01T11:33:01.000Z" title="发表于 2021-10-01 19:33:01">2021-10-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">树的直径</a></span></div><div class="content">两次 DFS 求出树的直径。 显然多条直径必定交于至少一点，且包含它们的中点。 则若舍去他们交点之外的边，剩下的边即为所求。 设直径左右端点为 。 在第二次 DFS 时能够求出 到直径每个节点的距离，所以从 向 遍历。 对于直径上的每个点 ，分别求出在不经过直径上其他点的情况的，所能达到的最远距离，记作 。设它到直径左端点距离为 ，到右端点距离为 。 若 ，则令 。 若 ，则令 ，且只会进行一次，这是因为我们的遍历顺序是从右到左。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; #define R register #define ll long long const int N=2e5+10; int n, f[N]; int c, h[N], ver[N&lt;&lt;1], nxt[N&lt;&lt;1], w[N&lt;&lt;1]; ll p, mxd, d[N]; bool v[N]; void add(int x,int y,int z) { ver[++ ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/cf1083e-solution/" title="CF1083E The Fair Nut and Rectangles 题解">CF1083E The Fair Nut and Rectangles 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-21T14:24:33.000Z" title="发表于 2021-09-21 22:24:33">2021-09-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/">斜率优化</a></span></div><div class="content">考虑 DP。 DP 需要一定的顺序。因为给出的矩形没有包含的关系，所以我们按照每个矩形右上角点的横坐标 递增排序，那么纵坐标 一定是递减排序的。 设 。 因为每个矩形都有选与不选两种选择，所以设 为在排序后的 中，必须选择第 个矩形获得的最大收益，也就是选出的矩形面积之并减去代价。 初始值为 。 因为状态中只限制了选择第 个，而矩形的选择是没有限制的。所以转移时找到 ，用选择 的最大收益 选择 的初始收益并且减去二者之交。或者说是 加上 减去代价。 有一个问题是，难道 不会和之前选择的一些矩形有重叠部分吗？在下图中，设宽为黑色的是 ，红色的是 ，蓝色的是 ，满足 。那么计算 的时候必然已经减去了 ，得到了 。排序后， 一定包含了 ，也就是 ，从而 与 中选出的矩形面积之并就等于 。也就是不会出现这种问题。 答案为 复杂度为 。 复杂度过高，考虑优化。 由于我们已经将矩形排序，所以 即 所以原方程可化简为 按照套路去掉 函数，移项得 即 对应到坐标系里即为： 每个决策点为 ，其斜率 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg5008-solution/" title="luogu5008 锦鲤抄 题解">luogu5008 锦鲤抄 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-20T09:26:48.000Z" title="发表于 2021-09-20 17:26:48">2021-09-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/DAG/">DAG</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">强连通分量</a></span></div><div class="content">update 2022.6.28 修改了证明部分 在 DAG 中，必然有入度为 0 的点，这些点是不能选择的。而其他的点则可以选择。 用 Tarjan 算法缩点，得到一个 DAG。 讨论每个 SCC 内部的选择。 若存在入度为不为 0 的 SCC，设其为 。 那么 内的点可以随便选。 证明： 如果 的入度不为 0，分以下情况讨论。 对于 中只有 1 个点的情况，显然成立。 否则， 至少由一个简单环构成，且一定存在入度 的点，设其为 。 对于 中的每个简单环，设其入度最大的点为 ，则至少可以删去 1 条 的入边，断开这个简单环。而只要 的入度不为 0，就不会影响到点的选择。最终可以得到一个多了若干条入边的 DAG。 因为 入度不为 0，所以这个 DAG 不存在入度为 0 的点，那么都可以删去，命题得证。   考虑入度为 0 的 SCC，设其为 。 仿照上述证明思路，我们仍以 内每个简单环删去若干边为代价，得到一个 DAG。 它是一个普通 DAG，而我们不能选择删去一个入度为 0 的点，设其为 。 通过不同 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg2195-solution/" title="luogu2195 HXY造公园 题解">luogu2195 HXY造公园 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-20T08:32:28.000Z" title="发表于 2021-09-20 16:32:28">2021-09-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">树的直径</a></span></div><div class="content">我最喜欢的紫色水题（ 给出一个森林，有两种操作。 询问某个点所在的树的直径 在两个点所在的两棵树间连一条边，最小化其直径 显然的，对于第一种操作，DP / DFS / BFS 预处理直径，并查集维护每棵树的点就行了。 问题在于高效维护第二种操作。 不难想到，两棵树之间连一条边，相当于合并两个集合。 而最小化新树的直径，显然要在两树直径的中点处连边。 证明： 反证法。若最优点不是直径中点，由于 直径有两个端点 且 树上两点有且仅有一条简单路径，若在非直径中点的 点连边，则当其接近直径一端时，直径另一端到达它的距离就大于到达直径中点的距离，反之则显然。这与假设不符，故原命题正确。 设从 与 之间连边， 为点 所在的树的直径。 则新树的直径只有三种可能。 合并后求最大值就行了。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int N=3e5+6; int n, m, q, ans, f[N], d[N], c ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/lg4819-solution/" title="luogu4819 杀人游戏 题解">luogu4819 杀人游戏 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-20T07:56:13.000Z" title="发表于 2021-09-20 15:56:13">2021-09-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/DAG/">DAG</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">强连通分量</a></span></div><div class="content">update 2022.2.9 修改了代码 不妨假设平民为白点，杀手为黑点，认识的关系为一条有向边。 求不访问黑点并且知道黑点的最小代价。 若有 个点，显然每个点为黑的概率为 。 而每访问一个白点，都能得知与它出边相连的点的颜色。 考虑强连通分量。 不难发现，对于每个强连通分量，只要以概率增加 为代价访问其中一个点，就能得知整个强连通分量的颜色情况。。 所以求出强连通分量后进行缩点，我们就得到了一个 DAG。 为了减少总访问次数，访问入度不为 0 的 SCC 是不划算的。 简单证明：设缩点后存在 的边，则访问完 中所有的点后，必定能知道 中一个点的信息，所以对于 ，不需要增加 的访问代价。 所以设缩点后入度为 0 的点的数量为 ，则访问到黑点的概率为 ，答案为 。   考虑只含一个点的 SCC，设其为 ，若其入度为 0，且其能够到达的点的入度均大于 1，那么若最后访问 ，整张图的情况已经被确定了。若未找到黑点，则 为黑点。如果包含超过 1 个节点，那么必须再访问它再能确定黑点。这样可以减少一次访问，且对于任意图，能且仅能减少一次。 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/17/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/#content-inner">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/#content-inner">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/#content-inner">21</a><a class="extend next" rel="next" href="/page/19/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">yozora0908</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="sticky_layout"><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/2-SAT/" style="font-size:1.1em;color:#999">2-SAT</a> <a href="/tags/2021%E7%9A%84%E5%A4%8F%E5%A4%A9/" style="font-size:1.14em;color:#999b9d">2021的夏天</a> <a href="/tags/2021%E7%9A%84%E6%9A%91%E5%81%87/" style="font-size:1.18em;color:#999ca1">2021的暑假</a> <a href="/tags/2022%E7%9A%84%E6%9A%91%E5%81%87/" style="font-size:1.1em;color:#999">2022的暑假</a> <a href="/tags/AtCoder/" style="font-size:1.14em;color:#999b9d">AtCoder</a> <a href="/tags/Codeforces/" style="font-size:1.42em;color:#99a6b7">Codeforces</a> <a href="/tags/DAG/" style="font-size:1.18em;color:#999ca1">DAG</a> <a href="/tags/DP/" style="font-size:1.5em;color:#99a9bf">DP</a> <a href="/tags/Floyd/" style="font-size:1.1em;color:#999">Floyd</a> <a href="/tags/KMP%E7%AE%97%E6%B3%95/" style="font-size:1.18em;color:#999ca1">KMP算法</a> <a href="/tags/Lucas%E5%AE%9A%E7%90%86/" style="font-size:1.1em;color:#999">Lucas定理</a> <a href="/tags/Miku/" style="font-size:1.1em;color:#999">Miku</a> <a href="/tags/NowCoder/" style="font-size:1.18em;color:#999ca1">NowCoder</a> <a href="/tags/OI/" style="font-size:1.18em;color:#999ca1">OI</a> <a href="/tags/SOS/" style="font-size:1.14em;color:#999b9d">SOS</a> <a href="/tags/SPFA/" style="font-size:1.1em;color:#999">SPFA</a> <a href="/tags/Trie/" style="font-size:1.18em;color:#999ca1">Trie</a> <a href="/tags/VOCALOID/" style="font-size:1.1em;color:#999">VOCALOID</a> <a href="/tags/yozora-Round/" style="font-size:1.3em;color:#99a1ac">yozora Round</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/" style="font-size:1.14em;color:#999b9d">中国剩余定理</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size:1.3em;color:#99a1ac">二分图</a> <a href="/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" style="font-size:1.34em;color:#99a3b0">二分答案</a> <a href="/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/" style="font-size:1.1em;color:#999">交互题</a> <a href="/tags/%E5%80%8D%E5%A2%9E/" style="font-size:1.14em;color:#999b9d">倍增</a> <a href="/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96/" style="font-size:1.1em;color:#999">决策单调性优化</a> <a href="/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/" style="font-size:1.14em;color:#999b9d">分数规划</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size:1.14em;color:#999b9d">分治</a> <a href="/tags/%E5%8C%BA%E9%97%B4DP/" style="font-size:1.34em;color:#99a3b0">区间DP</a> <a href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size:1.38em;color:#99a4b4">单调队列</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size:1.18em;color:#999ca1">双指针</a> <a href="/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size:1.1em;color:#999">双连通分量</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size:1.46em;color:#99a7bb">图论</a> <a href="/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/" style="font-size:1.14em;color:#999b9d">基环树</a> <a href="/tags/%E5%A4%B1%E9%85%8D%E6%A0%91/" style="font-size:1.1em;color:#999">失配树</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:1.26em;color:#999fa8">字符串</a> <a href="/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" style="font-size:1.18em;color:#999ca1">容斥原理</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size:1.1em;color:#999">差分</a> <a href="/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/" style="font-size:1.14em;color:#999b9d">差分约束系统</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size:1.22em;color:#999ea4">并查集</a> <a href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size:1.18em;color:#999ca1">强连通分量</a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By yozora0908</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType(){window.typed=new Typed("#subtitle",{strings:["Sky Arrow"],startDelay:300,typeSpeed:150,loop:!1,backSpeed:50})}"function"==typeof Typed?subtitleType():getScript("https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js").then(subtitleType)</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script></div></body></html>