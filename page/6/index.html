<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>yozora0908's blog - φ(゜▽゜*)♪</title><meta name="author" content="yozora0908"><meta name="copyright" content="yozora0908"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description"><link rel="shortcut icon" href="/img/4.png"><link rel="canonical" href="https://yozora0908.github.io/page/6/"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"prismjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"yozora0908's blog",isPost:!1,isHome:!0,isHighlightShrink:!1,isToc:!1,postUpdate:"2022-12-13 18:13:22"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image:url(https://s2.loli.net/2022/12/13/5fHjuPvxm9dwasc.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">yozora0908's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">yozora0908's blog</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/nc11247e-solution/" title="NowCoderL101E 水没都市 题解">NowCoderL101E 水没都市 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-04T08:53:13.000Z" title="发表于 2022-08-04 16:53:13">2022-08-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/">网络流</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/">最小割</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">最小生成树</a></span></div><div class="content">分析 时刻还有城镇没有被淹没， 时刻所有城镇将要被淹没。 一个思路是求出最后一个城镇被淹没的时刻 ，然后通过魔法调整使得所有城镇至少会在 时刻被淹没。显然 就是 到每一个点所有的路径中的最大边权取最小值，猜都能猜到是最小生成树中的最大边权，证明略。 求出 后，我们的目标是使得 所有路径中最大边权最小为 ，否则如果比 小则不满足条件，比 大则显然不优。 对于一条权值为 的边，代价为 ，其中 。考虑把 加入图中，那么问题就变成了选择权值和最小的边，使得 和 不连通。原因是如果 和 不连通，那么 的所有路径中不存在 的边，这就达到了目的。 以 为源点， 为汇点，求出图中的最小割即可。 注意这是一张无向图，加边的时候有一些细节。 CODE #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int N=30005, M=2e4+5, inf=1e15; int n, m, D, fa[N], d[N]; int tot=1, ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf1714-solution/" title="「Codeforces Round」#811 (Div 3)">「Codeforces Round」#811 (Div 3)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-04T08:08:24.000Z" title="发表于 2022-08-04 16:08:24">2022-08-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Codeforces/">Codeforces</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a></span></div><div class="content">CF1714. 最近摸得有点厉害，主要是被自己菜到了，心态有点差…… 老年人也就看看 Div 3 了。 A. Everyone Loves to Sleep 分析 转化成分钟乱搞即可。 CODE #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int t, n, H, M, D, ans, h[15], m[15], d[15]; int read() { int a=0, f=1; char c=getchar(); while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); } while(isdigit(c)) a=a*10+c-'0', c=getchar(); return a*f; } void solve() { n=read(), H=read(), M=read(); D=H*60+M; ans=1&lt;&lt;30; for(int i=1;i&lt;=n;++i) { h[i] ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/nc11202b-solution/" title="NowCoderT62B 置换 题解">NowCoderT62B 置换 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-01T13:48:44.000Z" title="发表于 2022-08-01 21:48:44">2022-08-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">组合数学</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">扩展中国剩余定理</a></span></div><div class="content">关于置换 根据《数学奥林匹克小丛书·组合数学》上关于置换的定义： 给定集合 ，置换 是从 到 上的一一映射，通常记为 由于是一一映射，所以这实际上是 的一个排列，满足 的 成为 的一个不动点。 直接感受就是，加了一堆概念得到的还只是一个排列，这么吃力不讨好的事情有啥用？但是看到这题题面之后就应该明白，「置换」本质上是一一映射，所以你可以用置换 再把 映射一遍…… 而对于「不动点」，无论如何用 去映射，都不会改变这些元素的值。（知道这个说不定能骗点分）。 关于置换的一些性质、题目和解题方法，刘汝佳的《入门经典训练指南》上还有所涉及。 分析 题意很简单，然而我一开始完全没有思路。注意到如果 中存在不动点，那么只要检查是否与 的对应位置相同即可。 手算不难发现对于一个 ，从 不断映射直到 ，经过的数字构成了一个环，含义是无论怎么置换都会如此循环。把环中数组当作下标，把 中对应的以元素列出来，记为 。能够发现正好相差一位（因为 把 映射了一次了）。如果其中不包含 ，那么必然无解。同时也把 中对应的元素列出来，记为 。判断从 的 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf1493d-solution/" title="CF1493D GCD of an Array 题解">CF1493D GCD of an Array 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-31T06:16:21.000Z" title="发表于 2022-07-31 14:16:21">2022-07-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a></span></div><div class="content">分析 本题的关键是 对于一个序列 ，将 分解为 的形式，那么 为所有出现过的质因数 的 次幂的乘积。 其中 表示出现过的 的最小幂次。 原序列可以看作依次插入。将 修改为 ，本质上是除去所有在 分解中的质因数的幂次，然后再将 插入并更新。 所以用std::map来维护某个 中所有质因数的幂次，用std::set来维护某个质因数的所有幂次（目的是快速插入，快速查找最小值）。 记录 表示序列中含有质因数 的数字的个数，一旦存在 ，那么答案要累乘 的最小次幂。 具体看代码。 CODE #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int N=2e5+5, mod=1e9+7; int n, m, cnt, ans=1, p[N], pr[N], rec[N]; map&lt;int,int&gt; mp[N]; multiset&lt;int&gt; st[N]; int read() { int a=0, f=1; cha ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf1389e-solution/" title="CF1389E Calendar Ambiguity 题解">CF1389E Calendar Ambiguity 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-31T02:50:50.000Z" title="发表于 2022-07-31 10:50:50">2022-07-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a></span></div><div class="content">分析 即求 满足 的解 的个数。 化简 设 ，那么有 考虑 。当 为定值时，由于 ，所以数量为 。 答案即为 发现这是个等差数列，直接求和即可。 首项 ，末项 ，公差 。 答案 CODE #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int N=5e5+5; int t, m, d, w; int read() { int a=0, f=1; char c=getchar(); while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); } while(isdigit(c)) a=a*10+c-'0', c=getchar(); return a; } int gcd(int x,int y) { return y? gcd(y,x%y):x; } void solve() { m=read(), d=read(), w=read(); int ans=0; ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf893e-solution/" title="CF893E Counting Arrays">CF893E Counting Arrays</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-31T02:19:33.000Z" title="发表于 2022-07-31 10:19:33">2022-07-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">组合数学</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a></span></div><div class="content">分析 为了方便起见，用 代替 ， 代替 。 不难发现无论 这些数字的符号是什么样的，只要恰当安排最后一位就一定能使结果是正数。由于每一位正负都可以选，所以这部分的方案数为 。 根据唯一分解定理，这个长度为 的序列中一定直接或间接包含了 的所有质因子。所以可以预处理出每一个质数。 对于质数 ，如果它是 的质因子，求出它在 的分解中的指数 。问题转化为在 这 个位置中，每个位置分配一个数，满足分配的数之和等于 ，求方案数。形式化地，求不定方程 的非负整数解的个数，显然是 。累乘即可。 特别地，当 含有大于 的质因子时，令答案 ，因为至多只有 个,否则就大于 了。 线性筛预处理质数，分解质因数时只枚举质数会快不少。 CODE #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int N=2e6+5, mod=1e9+7; int t, n, m, cnt, ans, fac[N], inv[N], p2[N], p[N], v[ ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf615ds-solution/" title="CF615D Multipliers 题解">CF615D Multipliers 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-31T01:49:42.000Z" title="发表于 2022-07-31 09:49:42">2022-07-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a></span></div><div class="content">分析 首先将 \(n\) 分解为 \(n= \prod_{i=1}^m p_i^{a_i}\)。那么 \(n\) 的约数个数为 \(d(n) = \prod_{i=1}^m (a_i +1)\)。 考虑每个质因子的贡献。 首先对于 \(p_i\)，它的整数次幂作为独立的一个约数时，一定有 \(p_i^1 p_i^2 \ldots p_i ^{a_i} = p_i^{\frac{a_i(a_i+1)}{2}}\)。 其次，\(p_i\) 还可以和其他约数组合，方案数为 \(\frac{d(n)}{a_i +1}\)。 那么 \(p_i\) 能够产生的贡献为 \((p_i^{\frac{a_i(a_i+1)}{2}})^{\frac{d(n)}{a_i+1}} = p_i^{\frac{a_i d(n)}{2}}\)，其含义为 \(p_i\) 作为一个独立的约数时，也可以和其他约数相乘成为新的约数，且在其中 \(p_i\) 的贡献是相同的。 指数可能很大，咋办？欧拉降幂公式，由于 \(p_i\) 和模数 \(10^9 +7\) 都是质数，这里只写出底数与模数互质 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/notes-number-theory-1/" title="「数论学习笔记」#1 扩展中国剩余定理">「数论学习笔记」#1 扩展中国剩余定理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-29T07:22:47.000Z" title="发表于 2022-07-29 15:22:47">2022-07-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">中国剩余定理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">扩展中国剩余定理</a></span></div><div class="content">中国剩余定理（CRT） 由于扩展中国剩余定理和中国剩余定理没啥关系，所以我们先来复习一下中国剩余定理。 同余方程组 当 两两互质时，对于任意正整数 ，此方程组有解，如下。 设 ，。 设 ，在 的意义下。 那么方程组的通解为 ，其中 。 最小正整数解只要令 ，后面那一块对 取模即可。 代码 MM=1; for(int i=1;i&lt;=n;++i) MM*=m[i]; for(int i=1;i&lt;=n;++i) { M[i]=MM/m[i]; int x, y; exgcd(M[i],m[i],x,y); t[i]=x; ans=(ans+a[i]*M[i]*t[i]%MM)%MM } ans=(ans%MM+MM)%MM; 证明略。 扩展中国剩余定理（exCRT） 当 不满足两两互质时，就要用到扩展中国剩余定理了。 考虑 转化一下 注意到此方程有解，当且仅当 。 设 ，，，代入得 由于 ，此方程有解当且仅当 。那么一定有 ，否则无解。 那么先求出一组特解 得到 代入原式 至 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/cf1265e-lg6835-solution/" title="CF1265E &amp; luogu6835 题解">CF1265E &amp; luogu6835 题解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-27T13:27:09.000Z" title="发表于 2022-07-27 21:27:09">2022-07-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/">概率论</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/">数学期望</a></span></div><div class="content">CF1265E Beautiful Mirrors solution 1 套路地设 为从 问到第 个镜子，且通过了第 个镜子的期望天数。 设 预处理 的逆元即可。 CODE #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int N=2e5+5, P=100, mod=998244353; int t, n, m, p[N], inv[N], f[N]; int read() { int a=0, f=1; char c=getchar(); while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); } while(isdigit(c)) a=a*10+c-'0', c=getchar(); return a; } signed main() { n=read(); for(int i=1;i&lt;=n;++i) p[i]=read(); inv[0]=inv[1]= ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/tititi-solution-1/" title="「杂题选讲」#1">「杂题选讲」#1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-26T02:57:28.000Z" title="发表于 2022-07-26 10:57:28">2022-07-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DP/">DP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%88%86%E6%B2%BB/">分治</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">单调队列</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%9D%82%E9%A2%98%E9%80%89%E8%AE%B2/">杂题选讲</a></span></div><div class="content">杂题选讲。 CF1548A Web of Lies 分析 发现编号为 的节点只会对编号大于 的节点造成影响。 设 为与 相连且编号大于 的点的数量。如果 是所在连通块编号最小的节点，那么只要 ， 就一定被删除。发现最终剩下的一定是满足 的点。维护即可。 CODE #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5; int n, m, cnt[N]; int main() { scanf("%d%d",&amp;n,&amp;m); int ans=n; for(int i=1;i&lt;=m;++i) { int x, y; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y) swap(x,y); if(++cnt[x]==1) --ans; } int q; scanf("%d",&amp;q); while(q--) { i ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/#content-inner">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/#content-inner">21</a><a class="extend next" rel="next" href="/page/7/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">yozora0908</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="sticky_layout"><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/2-SAT/" style="font-size:1.1em;color:#999">2-SAT</a> <a href="/tags/2021%E7%9A%84%E5%A4%8F%E5%A4%A9/" style="font-size:1.14em;color:#999b9d">2021的夏天</a> <a href="/tags/2021%E7%9A%84%E6%9A%91%E5%81%87/" style="font-size:1.18em;color:#999ca1">2021的暑假</a> <a href="/tags/2022%E7%9A%84%E6%9A%91%E5%81%87/" style="font-size:1.1em;color:#999">2022的暑假</a> <a href="/tags/AtCoder/" style="font-size:1.14em;color:#999b9d">AtCoder</a> <a href="/tags/Codeforces/" style="font-size:1.42em;color:#99a6b7">Codeforces</a> <a href="/tags/DAG/" style="font-size:1.18em;color:#999ca1">DAG</a> <a href="/tags/DP/" style="font-size:1.5em;color:#99a9bf">DP</a> <a href="/tags/Floyd/" style="font-size:1.1em;color:#999">Floyd</a> <a href="/tags/KMP%E7%AE%97%E6%B3%95/" style="font-size:1.18em;color:#999ca1">KMP算法</a> <a href="/tags/Lucas%E5%AE%9A%E7%90%86/" style="font-size:1.1em;color:#999">Lucas定理</a> <a href="/tags/Miku/" style="font-size:1.1em;color:#999">Miku</a> <a href="/tags/NowCoder/" style="font-size:1.18em;color:#999ca1">NowCoder</a> <a href="/tags/OI/" style="font-size:1.18em;color:#999ca1">OI</a> <a href="/tags/SOS/" style="font-size:1.14em;color:#999b9d">SOS</a> <a href="/tags/SPFA/" style="font-size:1.1em;color:#999">SPFA</a> <a href="/tags/Trie/" style="font-size:1.18em;color:#999ca1">Trie</a> <a href="/tags/VOCALOID/" style="font-size:1.1em;color:#999">VOCALOID</a> <a href="/tags/yozora-Round/" style="font-size:1.3em;color:#99a1ac">yozora Round</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/" style="font-size:1.14em;color:#999b9d">中国剩余定理</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size:1.3em;color:#99a1ac">二分图</a> <a href="/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" style="font-size:1.34em;color:#99a3b0">二分答案</a> <a href="/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/" style="font-size:1.1em;color:#999">交互题</a> <a href="/tags/%E5%80%8D%E5%A2%9E/" style="font-size:1.14em;color:#999b9d">倍增</a> <a href="/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96/" style="font-size:1.1em;color:#999">决策单调性优化</a> <a href="/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/" style="font-size:1.14em;color:#999b9d">分数规划</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size:1.14em;color:#999b9d">分治</a> <a href="/tags/%E5%8C%BA%E9%97%B4DP/" style="font-size:1.34em;color:#99a3b0">区间DP</a> <a href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size:1.38em;color:#99a4b4">单调队列</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size:1.18em;color:#999ca1">双指针</a> <a href="/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size:1.1em;color:#999">双连通分量</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size:1.46em;color:#99a7bb">图论</a> <a href="/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/" style="font-size:1.14em;color:#999b9d">基环树</a> <a href="/tags/%E5%A4%B1%E9%85%8D%E6%A0%91/" style="font-size:1.1em;color:#999">失配树</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:1.26em;color:#999fa8">字符串</a> <a href="/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" style="font-size:1.18em;color:#999ca1">容斥原理</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size:1.1em;color:#999">差分</a> <a href="/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/" style="font-size:1.14em;color:#999b9d">差分约束系统</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size:1.22em;color:#999ea4">并查集</a> <a href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" style="font-size:1.18em;color:#999ca1">强连通分量</a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By yozora0908</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType(){window.typed=new Typed("#subtitle",{strings:["Sky Arrow"],startDelay:300,typeSpeed:150,loop:!1,backSpeed:50})}"function"==typeof Typed?subtitleType():getScript("https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js").then(subtitleType)</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script></div></body></html>