<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「博弈论学习笔记」#1 组合游戏基础</title>
    <link href="/2023/notes-gt-1/"/>
    <url>/2023/notes-gt-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>OI 中的博弈论主要研究公平组合游戏（ICG）。</p><p>此外还有非公平组合游戏，比如大部分的棋类；反常游戏，ICG中的胜者改为败者。</p><h2 id="公平组合游戏">公平组合游戏</h2><h3 id="定义">定义</h3><p>如果一个游戏满足以下条件，就称其为一个公平组合游戏</p><ol type="1"><li>由两名玩家交替行动。</li><li>在游戏的任意时刻，能执行的合法操作与当前是那一名玩家无关。</li><li>先无法行动者告负。</li></ol><p>同时公平组合游戏一定只有先手必胜和先手必败两种情况。</p><h2 id="bash-game">Bash Game</h2><p>Bash 游戏形式如下</p><blockquote><p>有 <span class="math inline">\(n\)</span>个石子，两人博弈，每人每次可以拿 <span class="math inline">\(1 \simm\)</span> 个石子，无法拿石子的人告负。给定 <spanclass="math inline">\(n\)</span>，<spanclass="math inline">\(m\)</span>，求先手是否必胜。</p></blockquote><ul><li>若 <span class="math inline">\(n \lem\)</span>，那么先手直接全部拿走即可，必胜。</li><li>若 <span class="math inline">\(n =m+1\)</span>，那么先手不能一次都拿走且后手一定能全部拿走，先手必败。</li></ul><p>将上述情况进行扩展，如果 <span class="math inline">\(m+1 \midn\)</span>，那么若先手拿走 <span class="math inline">\(k\)</span>个，后手只要拿走 <span class="math inline">\(m+1-k\)</span>个，那么仍然满足 <span class="math inline">\(m+1 \mid n\)</span>。由于当<span class="math inline">\(n=0\)</span> 时 <spanclass="math inline">\(m+1 \midn\)</span>，所以如此循环往复下去先手一定会面临 <spanclass="math inline">\(n=0\)</span> 的局面，所以先手必败。</p><p>否则先手只要取 <span class="math inline">\(k\)</span> 个使得 <spanclass="math inline">\(m+1 \midn-k\)</span>，就能回到上述状态，只不过上面的「先手」是现在的后手，其必败，所以这种情况先手必胜。</p><h3 id="luogu4018">luogu4018</h3><p>题面</p><blockquote><p>将上题取 <span class="math inline">\(1 \sim m\)</span>个改为取任意能表示为 <span class="math inline">\(p^k\)</span>的数个，其中 <span class="math inline">\(p\)</span> 是质数且 <spanclass="math inline">\(k \in \mathbb{N^+}\)</span>，同时 <spanclass="math inline">\(p^k\)</span> 小于等于当前剩余石子数。</p></blockquote><p>考虑 <span class="math inline">\(n \in [1,5]\)</span>时，先手都可以一次取完。</p><p>而当 <span class="math inline">\(n=6\)</span> 时则不能。</p><p>由唯一分解定理容易发现任何 <span class="math inline">\(6\)</span>的倍数都不能写成 <span class="math inline">\(p^k\)</span> 的形式。</p><p>所以仿照上述操作，如果 <span class="math inline">\(6 \midn\)</span>，那么先手一定无法取 <span class="math inline">\(6\)</span>的倍数个，而后手一定能使得两次取走 <spanclass="math inline">\(6\)</span> 的倍数个，所以此时先手必败。</p><p>否则先手将 <span class="math inline">\(n\)</span> 取成 <spanclass="math inline">\(6\)</span> 的倍数个即可，必胜。</p><h2 id="nim-game">Nim Game</h2><blockquote><p><span class="math inline">\(n\)</span> 堆石头，第 <spanclass="math inline">\(i\)</span> 堆有 <spanclass="math inline">\(a_i\)</span>个石子。两名玩家博弈，每次可以选择一堆并取走其中任意非 <spanclass="math inline">\(0\)</span>个石子，无法取石子者告负。判断先手必胜还是必败。</p></blockquote><p>定理：</p><blockquote><p>Nim游戏先手必胜，当且仅当 <spanclass="math inline">\(\bigoplus_{i=1}^n a_i \neq 0\)</span>，也就是 nim和为 <span class="math inline">\(0\)</span>。</p></blockquote><p>证明：</p><blockquote><p>所有石子被取走的局面是失败局面，此时 nim 和为 <spanclass="math inline">\(0\)</span>。考虑一个 nim 和 <spanclass="math inline">\(x\)</span> 不为 <spanclass="math inline">\(0\)</span> 的情况，那么设 <spanclass="math inline">\(x\)</span> 最高为的 <spanclass="math inline">\(1\)</span> 在第 <spanclass="math inline">\(k\)</span> 位，一定存在至少一个 <spanclass="math inline">\(a_i\)</span> 满足第 <spanclass="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>。设它为 <spanclass="math inline">\(a_j\)</span>，那么有 <spanclass="math inline">\(a_j \oplus x &lt; a_j\)</span>，而 <spanclass="math inline">\(a_j \oplus x\)</span> 与 <spanclass="math inline">\(x \oplus a_j\)</span> 做异或运算为 <spanclass="math inline">\(0\)</span>，其中后者表示 nim 和除掉 <spanclass="math inline">\(a_j\)</span>。因此只要让 <spanclass="math inline">\(a_j\)</span> 变成 <span class="math inline">\(a_j\oplus x\)</span> 就能使得 nim 和为 <spanclass="math inline">\(0\)</span>，而后者小于前者，因此可以通过一次操作使得nim 和为 <span class="math inline">\(0\)</span>。</p><p>如此重复，一定能使得后手只会面临 nim 和为 <spanclass="math inline">\(0\)</span> 的局面，最终到无法取走石子。</p></blockquote><h3 id="hdu1850">hdu1850</h3><blockquote><p>Nim 游戏，先手第一次操作有多少种必胜方法。</p></blockquote><p>仿照证明过程，如果 nim 和不为 <spanclass="math inline">\(0\)</span>，那么任意选择一个 <spanclass="math inline">\(a_i \oplus x &lt; a_i\)</span> 的就行</p><h2 id="有向图游戏与-sg-函数">有向图游戏与 SG 函数</h2><h3 id="有向图游戏">有向图游戏</h3><p>给定一个 DAG，形式化地写作 <spanclass="math inline">\(G(X,F)\)</span>，其中点集 <spanclass="math inline">\(X\)</span> 为局面集合，<spanclass="math inline">\(F\)</span> 是 <spanclass="math inline">\(X\)</span> 上的函数，对于节点 <spanclass="math inline">\(x \in X\)</span>，<spanclass="math inline">\(F(x)\)</span>表示从其出发能够一步移动到的位置集合，表示了一个形式上的边集。如果 <spanclass="math inline">\(F(x) = \varnothing\)</span>，那么称 <spanclass="math inline">\(x\)</span> 为终点，如果 <spanclass="math inline">\(y\)</span> 不属于任何一个 <spanclass="math inline">\(F(x)\)</span>，那么称其为起点。</p><p>两人轮流移动初始在起点的一枚棋子，若其在 <spanclass="math inline">\(x_0\)</span>，那么可以移动到 <spanclass="math inline">\(F(x_0)\)</span> 内的任意节点。无法移动者告负。</p><p>任何一个 ICG 都能转化成有向图游戏，具体方法是将每个局面都带入点集<span class="math inline">\(X\)</span>，从局面 <spanclass="math inline">\(x\)</span> 能到达的局面集合构成 <spanclass="math inline">\(F(x)\)</span>。由 ICG的定义可知其不可能存在环，若存在环则游戏一定存在平局。</p><p>上文有一些很奇妙的内容。</p><p>我们能通过考虑小范围的胜负情况来让大范围的状态归约到它们上；失败局面可以倒推出先手必败局面；本来是先手必败的状态，经过一次操作之后就变成先手必胜了。</p><p>把这一切放到图上就容易理解了。由于 ICG只有先手必胜局面和先手必败局面，所以每个节点（状态）都是必胜或必败状态之一。而且状态可以转化，对于<span class="math inline">\(x\)</span>，<spanclass="math inline">\(F(x)\)</span>都是他的「子游戏」，二者之间相差一次操作。所以对于一条从终点倒推向起点的链，其节点状态必然是必败，必胜，必败，必胜。在一张图上，一个节点连到的点，他们到终点的长度不一样，自然有必胜也有必败。</p><p>比较简单的情况就是如果 <span class="math inline">\(F(x)\)</span>都是必败局面，那么无论怎么操作 <spanclass="math inline">\(x\)</span>，对方都一定面临必败局面，所以是必胜；反过来也一样。</p><p>但考虑到二者绝顶聪明，只要 <span class="math inline">\(F(x)\)</span>中又一个必败局面，当前玩家一定会这样操作。而如果 <spanclass="math inline">\(F(x)\)</span>中存在一个必胜局面，玩家绝对不会这样做。所以只有 <spanclass="math inline">\(F(x)\)</span> 全都是必胜局面，<spanclass="math inline">\(x\)</span> 才是必败局面。</p><p>此时引入概念<strong>后继状态</strong>。对于 <spanclass="math inline">\(x\)</span>，其后继状态为 <spanclass="math inline">\(F(x)\)</span>，在图上也可称后继节点。</p><h3 id="sg-函数">SG 函数</h3><p>定义 <span class="math display">\[SG(x)= \operatorname{mex} \big\{ SG(y) | y \in F(x) \big\}\]</span> 也就是 <span class="math inline">\(x\)</span> 所有后继状态的<span class="math inline">\(SG\)</span>函数值中没有出现过的最小非负整数。</p><p>整个游戏的 <span class="math inline">\(SG\)</span> 函数值为起点的<span class="math inline">\(SG\)</span> 函数值。</p><p>特殊规定终点的 <span class="math inline">\(SG\)</span> 函数值为 <spanclass="math inline">\(0\)</span>，同时要保证必败局面的 <spanclass="math inline">\(SG\)</span> 函数值都为 <spanclass="math inline">\(0\)</span>。</p><p>如果存在一个 <span class="math inline">\(SG(x) &gt; 0\)</span>，那么<span class="math inline">\(x\)</span> 的后继状态中一定存在 <spanclass="math inline">\(SG\)</span> 函数值为 <spanclass="math inline">\(0\)</span> 的状态，也就是存在必败局面，此时 <spanclass="math inline">\(x\)</span> 为必胜局面。否则 <spanclass="math inline">\(SG(x)=0\)</span>，那么 <spanclass="math inline">\(x\)</span> 的后继状态中一定不存在 <spanclass="math inline">\(SG\)</span> 函数值为 <spanclass="math inline">\(0\)</span> 的状态，也就是全部为必胜局面，此时<span class="math inline">\(x\)</span> 必败。</p><p>得到</p><ul><li>有向图游戏的某个局面 <span class="math inline">\(x\)</span>必胜，当且仅当 <span class="math inline">\(SG(x)&gt; 0\)</span>。</li><li>有向图游戏的某个局面 <span class="math inline">\(x\)</span>必败，当且仅当 <span class="math inline">\(SG(x) = 0\)</span>。</li></ul><h3 id="sg-定理">SG 定理</h3><p>设 <span class="math inline">\(G_1,G_2,\cdots G_m\)</span> 为 <spanclass="math inline">\(m\)</span> 个有向图游戏，存在一个有向图游戏 <spanclass="math inline">\(G\)</span>，其规则是选择其中一个有向图游戏 <spanclass="math inline">\(G_i\)</span>，在其之上操作一次，无法操作者告负。<spanclass="math inline">\(G\)</span> 也成为 <spanclass="math inline">\(\{G_i\}\)</span> 的和。</p><p>那么 <span class="math display">\[SG(G) = \bigoplus_{i=1}^m SG(G_i)\]</span> <span class="math inline">\(G\)</span> 先手必胜，当且仅当<span class="math inline">\(SG(G) &gt; 0\)</span>。</p><p>证明。</p><blockquote><p>类似与 Nim 游戏的做法，考虑 <span class="math inline">\(x =SG(G)\)</span>，那么仍然找到 <spanclass="math inline">\(SG(G_j)\)</span> 第 <spanclass="math inline">\(k\)</span> 为和 <spanclass="math inline">\(x\)</span> 第 <spanclass="math inline">\(k\)</span> 位都为 <spanclass="math inline">\(1\)</span>。此时 <spanclass="math inline">\(SG(G_j) \oplus x &lt; SG(G_j)\)</span>。考虑 <spanclass="math inline">\(\operatorname{mex}\)</span> 运算的本质，就能发现<span class="math inline">\(\big[0,SG(G_j)\big)\)</span> 都能在操作一次<span class="math inline">\(G_j\)</span>后得到，因此一定能通过一次操作使得 <span class="math inline">\(SG(G_j)\leftarrow SG(G_j) \oplus x\)</span>，从而使得 <spanclass="math inline">\(SG(G)=0\)</span>。</p></blockquote><h3 id="code">code</h3><p>随便写一下 Nim 游戏的 <span class="math inline">\(SG\)</span>函数做法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// sg[i]表示大小为i的石子堆的SG函数值</span>    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,N) &#123;        <span class="hljs-built_in">SET</span>(s,<span class="hljs-number">0</span>);        <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,i) s[sg[i-j]]=<span class="hljs-number">1</span>;        <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,i) <span class="hljs-keyword">if</span>(!s[j]) &#123; sg[i]=j; <span class="hljs-keyword">break</span>; &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">pre</span>();    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(), ans^=sg[a[i]];    <span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;win&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;lose&quot;</span>);&#125;</code></pre></div><h2 id="例题">例题</h2><h3 id="hdu2999">hdu2999</h3><p>考虑操作一次之后，这段序列就分成了互相独立的两段，可知这一段的一个后继状态的<span class="math inline">\(SG\)</span> 函数值等于两小段的异或起来。</p><p>所以预处理 <span class="math inline">\(SG(x)\)</span> 表示长度为<span class="math inline">\(x\)</span>的序列的函数值。处理的过程中枚举所有选那一个长度断开，然后枚举一遍断点即可。</p><p>排个序在枚举的时候理论上会快不少。</p><h3 id="poj2311">POJ2311</h3><p>剪出 <span class="math inline">\(1 \times 1\)</span>是必胜局面，不符合「终点为必败局面」的条件。</p><p>考虑到剪出 <span class="math inline">\(1 \times 1\)</span> 必须要<span class="math inline">\(1 \times x\)</span> 或者 <spanclass="math inline">\(x \times1\)</span>，那么可以把这二者作为终点。</p><p>设 <span class="math inline">\(SG(x,y)\)</span> 表示长 <spanclass="math inline">\(x\)</span> 宽 <spanclass="math inline">\(y\)</span> 的纸片的函数值。</p><p>一刀可以横着或者竖着切，那么对于 <spanclass="math inline">\((x,y)\)</span>，其后继局面可以是 <spanclass="math inline">\((x,i),(x,y-i)\)</span> 与 <spanclass="math inline">\((x-i,y),(i,y)\)</span>，每一组的 <spanclass="math inline">\(SG\)</span> 函数异或值就是 <spanclass="math inline">\((x,y)\)</span> 一个后继局面的 <spanclass="math inline">\(SG\)</span> 函数值。</p><p>枚举 <span class="math inline">\(i\)</span>，可以在 <spanclass="math inline">\(O(n^3)\)</span> 的时间里处理出所有 <spanclass="math inline">\(SG\)</span> 函数值。</p><h2 id="参考">参考</h2><p><ahref="https://do-while-true.github.io/2022/02/15/%E3%80%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%E5%8D%9A%E5%BC%88%E8%AE%BA/">「学习笔记」博弈论By do_while_true</a></p><p>《算法竞赛进阶指南》 By 李煜东</p><p>《算法竞赛》 By 罗勇军，郭卫斌</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构学习笔记」#3 树链剖分</title>
    <link href="/2023/notes-ds-3/"/>
    <url>/2023/notes-ds-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>树链剖分能够将一棵树按照某种法则剖分为若干条链，从而便于维护树上路径的信息。</p><p>按照剖出链的法则不同，其性质也不同，大体可将树剖分成重链剖分，长链剖分和用于Link-Cut Tree 的剖分（实链剖分）。</p><p>其中重链剖分用途最广泛，本文也只介绍重链剖分。</p><h2 id="重链剖分">重链剖分</h2><h3 id="定义与部分性质">定义与部分性质</h3><p>给出如下定义</p><ul><li><strong>重儿子</strong>。对于一个非叶子节点，其重儿子为其以它的所有儿子为根的子树中，最大子树所对应的那个子节点。如果最大不唯一则任取其一。</li><li><strong>轻儿子</strong>。对于一个非叶子节点，其重儿子之外的子节点都为轻儿子。</li><li><strong>重边</strong>。一个节点到其重儿子的边。</li><li><strong>重链</strong>。多条相连的重边构成的链，或者链接连续的重儿子的链。</li><li><strong>轻边</strong>。连接两条重链的边。</li><li><strong>链头</strong>。一条重链中深度最小的节点，其必定是轻儿子或根。</li></ul><figure><img src="https://oi-wiki.org/graph/images/hld.png" srcset="/img/loading.gif" lazyloadalt="图源 OI-wiki" /><figcaption aria-hidden="true">图源 OI-wiki</figcaption></figure><p>性质：同一条重链上的点，其 LCA 为链头。</p><p>重要性质：从叶子节点到根，最多经过 <spanclass="math inline">\(O(\log_2 n)\)</span> 条轻边（重链）。</p><p>证明：</p><blockquote><p>考虑从叶子节点 <span class="math inline">\(x\)</span>向上跳到根。如果 <span class="math inline">\(x\)</span>在重链上，那么直接跳到链头。如果 <span class="math inline">\(x\)</span>在轻边上，那么跳到的 <span class="math inline">\(fa(x)\)</span>必然是一条重链的链头，由于重儿子不是 <spanclass="math inline">\(x\)</span>，所以以其重儿子为根的子树大小加上 <spanclass="math inline">\(sz(x)\)</span>，大小必然超过 <spanclass="math inline">\(2sz(x)\)</span>。因此最多经过 <spanclass="math inline">\(O(\log_2 n)\)</span>条轻边，而轻边链接重链，所以经过 <span class="math inline">\(O(\log_2n)\)</span> 条重链。</p></blockquote><p>也不难看出对于任意两点，其间路径长度也是 <spanclass="math inline">\(O(\log_2 n)\)</span>。</p><h3 id="求-lca">求 LCA</h3><ul><li>如果 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 在同一条重链上，那么 <spanclass="math inline">\(lca(x,y)\)</span> 就是深度更小的那个点。</li><li>否则让所在链的链头深度大的那个点往上跳一条重链。</li><li>最后深度小的为 <span class="math inline">\(lca(x,y)\)</span>。</li></ul><p>由上述性质可知复杂度为 <span class="math inline">\(O(\log_2n)\)</span>。</p><p>代码如下</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;   <span class="hljs-comment">// top[x] x所在链的链头</span>    <span class="hljs-comment">// 如果x为轻儿子，则top[x]=x</span>    <span class="hljs-comment">// fa[x] x的父亲</span>    <span class="hljs-comment">// dep[x] x的深度</span>    <span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);        x=fa[top[x]];        <span class="hljs-comment">// top[x]跳到链头，fa[top[x]]跳到下一条链</span>    &#125;    <span class="hljs-keyword">return</span> dep[x]&lt;dep[y]? x:y;&#125;</code></pre></div><h3 id="树上问题转化序列问题">树上问题转化序列问题</h3><p>如果在<code>dfs</code>的过程中优先访问重儿子，那么可以发现每一条重链<span class="math inline">\(dfn\)</span>是连续的，对应着序列上的一个区间。而轻儿子则相对封闭，对应着序列上的一个单点。</p><figure><img src="https://oi-wiki.org/graph/images/hld.png" srcset="/img/loading.gif" lazyload alt="再次放图" /><figcaption aria-hidden="true">再次放图</figcaption></figure><p>对于树上两点 <span class="math inline">\((x,y)\)</span>，其路径必然是<span class="math inline">\(x \rightarrow lca(x,y)\)</span>，<spanclass="math inline">\(lca(x,y) \rightarrow y\)</span>。结合上面讲到的求<span class="math inline">\(lca\)</span>的方法，可以发现在这个过程中，每将那个点向上跳一步，就对应了一个区间，这些区间一定能不重不漏地覆盖此点到<span class="math inline">\(lca(x,y)\)</span>的所有点，跳完之后在一条重链上，而重链上两点之间路径的 <spanclass="math inline">\(dfn\)</span> 必然是一个区间。</p><p>因此，如果将 <span class="math inline">\(dfn\)</span>看作序列，用序列上的数据结构来处理链信息，那么最多处理 <spanclass="math inline">\(O(\log_2 n)\)</span> 次。</p><p>这个数据结构一般是线段树。</p><p>还有一个 dfs 本身的性质，以 <span class="math inline">\(x\)</span>为根的子树内，其所有 dfs 序构成一个区间 <spanclass="math inline">\([dfn(x),dfn(x)+sz_x-1]\)</span>。</p><p>因此能更快地维护子树信息。</p><h3 id="code">code</h3><p><code>dep[x]</code>，<code>fa[x]</code>，<code>top[x]</code>意义同求<span class="math inline">\(lca\)</span> 的那部分代码中。</p><p><code>son[x]</code>表示节点 <span class="math inline">\(x\)</span>的重儿子，<code>sz[x]</code>表示以 <spanclass="math inline">\(x\)</span>为根的子树大小，<code>id[x]</code>表示节点 <spanclass="math inline">\(dfn(x)\)</span>。</p><p>先用一遍<code>dfs</code>求出<code>dep[x]</code>，<code>fa[x]</code>，<code>son[x]</code>，<code>sz[x]</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    dep[x]=dep[fr]+<span class="hljs-number">1</span>, fa[x]=fr;    sz[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(y,x);        sz[x]+=sz[y];        <span class="hljs-keyword">if</span>(!son[x]||sz[son[x]]&lt;sz[y]) son[x]=y;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div><p>然后进行一次优先访问重儿子的<code>dfs</code>，求出<code>id[x]</code>，<code>top[x]</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> tp)</span> </span>&#123;id[x]=++num, top[x]=tp;    <span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">dfs2</span>(son[x],tp);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa[x]||y==son[x]) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs2</span>(y,y);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;</code></pre></div><p>然后</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-comment">// 处理(x -&gt; y)的点信息</span>    <span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);        <span class="hljs-comment">/*</span><span class="hljs-comment">        此时[id[top[x]],id[x]]就是路径上的一个区间</span><span class="hljs-comment">        这里用数据结构处理这个区间的信息</span><span class="hljs-comment">        */</span>        x=fa[top[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-comment">/*</span><span class="hljs-comment">    此时x为lca</span><span class="hljs-comment">    处理[id[x],id[y]]的信息</span><span class="hljs-comment">    */</span>&#125;</code></pre></div><p>查询同上。</p><h3 id="边权转化点权">边权转化点权</h3><p>上述操作都是建立在权值为点权的基础上的，不能直接解决边权问题。</p><p>考虑将边权转化为点权，一种方法是将边 <span class="math inline">\((x\rightarrow y)\)</span>，其中 <spanclass="math inline">\(dep(x)&lt;dep(y)\)</span>，其权值 <spanclass="math inline">\(z\)</span> 放到 <spanclass="math inline">\(y\)</span> 上。</p><p>如图。</p><p><imgsrc="https://cdn-us.imgs.moe/2023/01/27/63d331674ae07.png" srcset="/img/loading.gif" lazyload /></p><p><imgsrc="https://cdn-us.imgs.moe/2023/01/27/63d3316703f87.png" srcset="/img/loading.gif" lazyload /></p><p>可以发现如果要求得 <span class="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 的链信息，就要忽略 <spanclass="math inline">\(lca(x,y)\)</span> 的点权。</p><p>那么在修改和查询的时候忽略 <span class="math inline">\(lca\)</span>就可以了。</p><p>也就是说</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">// 以上省略</span>    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-comment">/*</span><span class="hljs-comment">    此时x为lca</span><span class="hljs-comment">    处理[id[x],id[y]]的信息</span><span class="hljs-comment">    改为</span><span class="hljs-comment">    处理[id[x]+1,id[y]]的信息</span><span class="hljs-comment">    */</span>&#125;</code></pre></div><h3 id="luogu7735-轻重边">luogu7735 轻重边</h3><p>题目里的「轻重边」只是一个新定义，不如用 <spanclass="math inline">\(0\)</span> 边和 <spanclass="math inline">\(1\)</span> 边代替。</p><p>发现如果局限于 0/1 两种状态的话并不好做。</p><p>不难发现如果 <span class="math inline">\((x \rightarrow y)\)</span>是 <span class="math inline">\(1\)</span> 边，那么 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>一定同时在某一次操作的链上，可以看作是同一次被覆盖。</p><p>然后这个显然是充要的。</p><p>如果把每个节点被覆盖的颜色看作点权，那么问题等价于路径上有多少相邻点的点权相同。考虑树剖然后用线段树维护。</p><p>如何维护？记录区间左右端点的被覆盖的颜色，然后就合并就行了。叶子节点的初始颜色为其<span class="math inline">\(dfn\)</span>，这样就能保证初始不存在 <spanclass="math inline">\(1\)</span> 边。</p><p>还有一个问题，要得到路径上轻边左右端点的信息，也就是要单点查询<code>id[top[x]]</code>和<code>id[fa[top[x]]]</code>的颜色。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> T, n, m, num, tim;<span class="hljs-keyword">int</span> sz[N], son[N], fa[N], top[N], dep[N], id[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> t[N&lt;&lt;<span class="hljs-number">2</span>], lt[N&lt;&lt;<span class="hljs-number">2</span>], rt[N&lt;&lt;<span class="hljs-number">2</span>], tag[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;lt[x]=lt[x&lt;&lt;<span class="hljs-number">1</span>], rt[x]=rt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];t[x]=t[x&lt;&lt;<span class="hljs-number">1</span>]+t[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(rt[x&lt;&lt;<span class="hljs-number">1</span>]==lt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) ++t[x];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span> </span>&#123;t[x]=r-l, lt[x]=rt[x]=k;tag[x]=k;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(tag[x]) &#123;<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid,tag[x]);<span class="hljs-built_in">maketag</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,tag[x]);tag[x]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;tag[x]=lt[x]=rt[x]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r) &#123; t[x]=<span class="hljs-number">0</span>, lt[x]=rt[x]=l; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="hljs-built_in">maketag</span>(x,l,r,k); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">modify</span>(L,R,k,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) <span class="hljs-built_in">modify</span>(L,R,k,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(R&gt;mid) ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-keyword">if</span>(L&lt;=mid&amp;&amp;R&gt;mid&amp;&amp;rt[x&lt;&lt;<span class="hljs-number">1</span>]==lt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) ++ans;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> lt[x];<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(k&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query2</span>(k,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query2</span>(k,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;dep[x]=dep[fr]+<span class="hljs-number">1</span>, fa[x]=fr;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs1</span>(y,x);sz[x]+=sz[y];<span class="hljs-keyword">if</span>(!son[x]||sz[y]&gt;sz[son[x]]) son[x]=y;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> tp)</span> </span>&#123;id[x]=++num, top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tim,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">modify</span>(id[top[x]],id[x],tim);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">modify</span>(id[x],id[y],tim);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);ans+=<span class="hljs-built_in">query</span>(id[top[x]],id[x]);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">query2</span>(id[fa[top[x]]])==<span class="hljs-built_in">query2</span>(id[top[x]])) ++ans;x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);ans+=<span class="hljs-built_in">query</span>(id[x],id[y]);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();tot=num=<span class="hljs-number">0</span>, tim=n;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) h[i]=son[i]=<span class="hljs-number">0</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">build</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> op=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) ++tim, <span class="hljs-built_in">upd</span>(tim,x,y);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">ask</span>(x,y));&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="参考">参考</h2><p><a href="https://oi-wiki.org/graph/hld/">OI wiki 树链剖分</a></p><p>《算法竞赛》 By 罗勇军，郭卫斌</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构学习笔记」#2 可持久化线段树</title>
    <link href="/2023/notes-ds-2/"/>
    <url>/2023/notes-ds-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="可持久化线段树">可持久化线段树</h2><h3 id="思想">思想</h3><p>可持久化线段树的思想如下</p><ul><li>建立多棵线段树，代表不同版本。</li><li>为了降低空间复杂度，每棵线段树只储存与上一棵不同的部分，结构并不完整。换句话说，每个节点都是先继承上个版本，如果自己的儿子信息被修改了，那么新建立一个节点代替自己。而对于根节点，无论修改是否改变了根节点的信息，根节点的版本都改变了，因此必须新建节点，同时也能代表版本。</li><li>任意两棵线段树都能相减得到一棵新线段树，利用这颗线段树的信息解决问题。</li></ul><p>多棵线段树，可以是 <span class="math inline">\(i \in[1,n]\)</span>，在每个 <span class="math inline">\([1,i]\)</span>上建树，这样相减能得到 <span class="math inline">\([l,r]\)</span>的线段树。也可以是每个「时间」的线段树，得到每段时间 <spanclass="math inline">\([s,t]\)</span> 的信息。</p><p>无论是上述哪一种方式，都可以发现相邻两个版本间的差距只有一次修改。</p><p>如果是单点修改的话，那么两棵树的差别就是一条长度为 <spanclass="math inline">\(O(\log_2 n)\)</span>的链。被修改了的节点会单独创建，否则就直接继承先前版本。</p><p>如图，蓝色的是前连续多少个版本的并集，而橙色是将节点 <spanclass="math inline">\(4\)</span> 加上 <spanclass="math inline">\(2\)</span> 的下一个版本。</p><p><imgsrc="https://pic2.zhimg.com/v2-e41c74ec213257cec4f3c3429e9d037d_r.jpg" srcset="/img/loading.gif" lazyload /></p><p>区间修改呢？可以证明普通线段树区间操作每层节点最多访问 <spanclass="math inline">\(4\)</span> 个，所以会访问的节点数量是 <spanclass="math inline">\(O(\log_2 n)\)</span>的。但是如果要下传标记呢？在一棵不完整的线段树上下传标记，如果暴力创建左右儿子那么空间就会爆炸，所以只能用标记永久化。</p><p> </p><p>可以发现，如果没有初始树，那么每次操作要开大小为 <spanclass="math inline">\(O(\log_2 n)\)</span> 的一棵树，总空间复杂度为<span class="math inline">\(O(m \log_2 n)\)</span>，有初始树的话要加上<span class="math inline">\(O(n \log_2 n)\)</span>。</p><p>而修改操作则与普通线段树相同。</p><h3 id="code">Code</h3><p>建初始树</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l==r) &#123;        <span class="hljs-comment">// init a node.</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(ls[x],l,mid);    <span class="hljs-built_in">build</span>(rs[x],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    root[<span class="hljs-number">0</span>]=++cnt;    <span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>]);&#125;</code></pre></div><p>单点修改</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-comment">// p是当前线段树，q是上一棵</span>    <span class="hljs-keyword">if</span>(l==r) &#123;        <span class="hljs-comment">// modify node p;</span>        <span class="hljs-keyword">return</span>;    &#125;    ls[p]=ls[q], rs[p]=rs[q];    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x&lt;=mid) ls[p]=++cnt, <span class="hljs-built_in">modify</span>(ls[p],ls[q],x,d,l,mid);    <span class="hljs-comment">// 要修改的点在左边，那么ls[p]必然和ls[q]不同，所以新建。右边同理。</span>    <span class="hljs-keyword">else</span> rs[p]=++cnt, <span class="hljs-built_in">modify</span>(rs[p],rs[q],x,d,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>(root[i]==<span class="hljs-number">0</span>) root[i]=++cnt;    <span class="hljs-built_in">modify</span>(root[i],root[i<span class="hljs-number">-1</span>],x,d);&#125;</code></pre></div><p>区间查</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x];    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query</span>(L,R,ls[x],l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid) ans+=<span class="hljs-built_in">query</span>(L,R,rs[x],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>（权值线段树）二分第 <span class="math inline">\(k\)</span> 大。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;    <span class="hljs-keyword">int</span> d=t[ls[p]]-t[ls[q]];    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(d&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[p],ls[q],k,l,mid);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[p],rs[q],k-d,mid+<span class="hljs-number">1</span>,r);&#125;</code></pre></div><p>考虑区间加法操作，我们只修改完全覆盖的区间的标记，不能完全覆盖则创建新节点，感性理解一下，时间和空间复杂度都是<span class="math inline">\(O(\log_2n)\)</span>，前文说到线段树区间操作最多访问一层中的 <spanclass="math inline">\(4\)</span>个节点，而不能被完全覆盖的最多只有两个。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    ls[p]=ls[q], rs[p]=rs[q], sum[p]=sum[q], tag[p]=tag[q];    <span class="hljs-comment">// 先继承</span>    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; tag[p]+=d, sum[p]+=(r-l+<span class="hljs-number">1</span>)*d; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// 被完全覆盖，直接在继承的基础上修改</span>    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-comment">// 否则就要创建新节点</span>    <span class="hljs-keyword">if</span>(L&lt;=mid) ls[p]=++cnt, <span class="hljs-built_in">modify1</span>(L,R,d,ls[p],ls[q],l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid) rs[p]=++cnt, <span class="hljs-built_in">modify1</span>(L,R,d,rs[p],rs[q],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>(!root[i]) root[i]=++cnt;    <span class="hljs-built_in">modify1</span>(l,r,root[i],root[i<span class="hljs-number">-1</span>]);&#125;</code></pre></div><p>区间查就要记录当前区间的标记来保证正确性，同时要注意标记可能会溢出。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> sum[x]+(r-l+<span class="hljs-number">1</span>)*tag[x];    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, ans=(<span class="hljs-built_in">min</span>(R,r)-<span class="hljs-built_in">max</span>(L,l)+<span class="hljs-number">1</span>)*tag[x];    <span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query1</span>(L,R,ls[x],l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid) ans+=<span class="hljs-built_in">query1</span>(L,R,rs[x],mid+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>关于这玩意的空间，为了保险起见可以开 <span class="math inline">\(2^5n\)</span></p><h3 id="静态区间-kth">静态区间 kth</h3><p>在每个 <span class="math inline">\(i\in[1,n]\)</span>，<spanclass="math inline">\([1,i]\)</span> 上建立可持久化的权值线段树。第<span class="math inline">\(r\)</span> 棵线段树减去第 <spanclass="math inline">\(l\)</span> 棵线段树就是 <spanclass="math inline">\([l,r]\)</span> 的线段树。</p><p>然后在全局二分第 <span class="math inline">\(k\)</span>大即可，很好写。</p><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/250565583">算法学习笔记(50):可持久化线段树 By Pecco</a></p><p><a href="https://oi-wiki.org/ds/persistent-seg/">OI wiki可持久化线段树</a></p><p>《算法竞赛》 By 罗勇军，郭卫斌</p><p>《算法竞赛进阶指南》 By 李煜东</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可持久化线段树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据结构学习笔记」#1 线段树相关</title>
    <link href="/2023/notes-ds-1/"/>
    <url>/2023/notes-ds-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="线段树上二分">线段树上二分</h2><p>用形式化的语言讲，线段树上二分求解的是这一类问题。</p><p>给定 <span class="math inline">\(L\)</span>，找到一个 <spanclass="math inline">\(R \in [L,n]\)</span> 满足 <spanclass="math display">\[f \Big( op\big([L,R-1]\big) \Big) = 1\]</span> <span class="math display">\[f\Big( op\big(R\big) \Big)=0\]</span></p><p>其中 <span class="math inline">\(f\)</span> 为某种合法性函数，<spanclass="math inline">\(op\)</span> 是将区间信息合并为 <spanclass="math inline">\(f\)</span> 能处理的信息的过程。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span>&amp; S,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>;</code></pre></div><p>其中 <span class="math inline">\(S\)</span>为当前已经合并的区间信息，<span class="math inline">\(x: [l,r]\)</span>为当前节点。</p><p> </p><p>如何进行求解？既然要以 <span class="math inline">\(L\)</span>为左端点进行区间合并，那么无论何时我们都优先递归左儿子，对于一个 <spanclass="math inline">\([l,r]\)</span>，若 <spanclass="math inline">\(r&lt;L\)</span>，就不再往下递归了。</p><p>此后便一定能找到 <span class="math inline">\(L \lel\)</span>，且第一次找到时一定满足 <spanclass="math inline">\(L=l\)</span>，于是就合并信息。如果此时 <spanclass="math inline">\(f(S)=1\)</span>，那么往继续往右边找，结束递归。如果<span class="math inline">\(f(S)=0\)</span> 且 <spanclass="math inline">\(l=r\)</span>，答案 <spanclass="math inline">\(R=l\)</span>。</p><p>如果 <span class="math inline">\(l &lt; L \operatorname{ and } L \ler\)</span>，往下递归即可。</p><p>借用<ahref="https://www.zhihu.com/people/yan-ge-ge-32-1">严格鸽</a>的图，不难看出合并区间的过程是连续的。按顺序合并了<span class="math inline">\(7,8,9,10,11\)</span>，在 <spanclass="math inline">\(12\)</span> 处找到了答案。</p><p><imgsrc="https://pic4.zhimg.com/v2-f3c0d4b007aa1e68655f0e9f078cde37_r.jpg" srcset="/img/loading.gif" lazyload /></p><p><imgsrc="https://pic1.zhimg.com/v2-8f097f2ef9d9cf2fca3816843a9000b4_r.jpg" srcset="/img/loading.gif" lazyload /></p><p><imgsrc="https://pic2.zhimg.com/v2-b1fb9d1bcb102eb61797eb2727a4ae21_r.jpg" srcset="/img/loading.gif" lazyload /></p><p> </p><p>那这玩意复杂度是多少？</p><ol type="1"><li>找 <span class="math inline">\(L\)</span>的过程相当于优先递归左端点的单点查找，但是如果和 <spanclass="math inline">\([L,n]\)</span> 无交便不会递归下去，复杂度 <spanclass="math inline">\(O(\log_2 n)\)</span>。</li><li>之后只有合并后 <span class="math inline">\(f\)</span> 值为 <spanclass="math inline">\(0\)</span>才往下递归，否则就合并信息。临界点又是固定的，所以每递归一次区间长度就减半，所以复杂度还是<span class="math inline">\(O(\log_2 n)\)</span>。</li></ol><p>因此总复杂度 <span class="math inline">\(O(\log_2n)\)</span>。</p><p>下面给出模板。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,node&amp; S,<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(r&lt;L) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(L&lt;=l) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(<span class="hljs-built_in">op</span>(S,x))) &#123;S=<span class="hljs-built_in">op</span>(S,x);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;&#125;<span class="hljs-built_in">pushdown</span>(x,l,r);<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> res=<span class="hljs-built_in">query</span>(L,S,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);<span class="hljs-keyword">if</span>(res==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(L,S,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><p>这种带着引用的写法存在一定局限性，但是某种程度上更加便于理解。</p><p> </p><p>考虑这样一个模板题</p><blockquote><p>维护一个 01 序列，求 <span class="math inline">\([L,n]\)</span>从左往右第 <span class="math inline">\(k\)</span> 个 1 的位置。</p></blockquote><p>转化为</p><blockquote><p>给定 <span class="math inline">\(L\)</span>，找到 <spanclass="math inline">\(R\)</span> 满足 <spanclass="math inline">\([L,R-1]\)</span> 中有不超过 <spanclass="math inline">\(k\)</span> 个 <spanclass="math inline">\(1\)</span>。</p></blockquote><p>因此<code>node&amp; S</code>就是当前还需要找到 <spanclass="math inline">\(S\)</span> 个 <spanclass="math inline">\(k\)</span>，<code>op(S,x)</code>就是 <spanclass="math inline">\(S\)</span> 减去区间内 <spanclass="math inline">\(1\)</span> 的个数，<spanclass="math inline">\(f\)</span> 就是看是不是大于 <spanclass="math inline">\(0\)</span>（还要给 <spanclass="math inline">\(R\)</span> 留一个 1 的位置）。</p><p> </p><p>这玩意的用法很灵活。</p><h3 id="luogu4198-楼房重建">luogu4198 楼房重建</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <spanclass="math inline">\(m\)</span>次操作，每次操作单点修改，操作完之后查询全局有多少 <spanclass="math inline">\(a_i\)</span>，满足对于 <spanclass="math inline">\(j \in [1,i-1]\)</span>，<spanclass="math inline">\(a_j &lt; a_i\)</span>。规模 <spanclass="math inline">\(10^5\)</span>。</p></blockquote><p>由于只查全局，所以考虑线段树直接维护。设 <spanclass="math inline">\(s\big(x:[l,r]\big)\)</span> 为 <spanclass="math inline">\([l,r]\)</span> 内满足条件的 <spanclass="math inline">\(a_i\)</span> 的个数，<spanclass="math inline">\(t\big(x:[l,r]\big)\)</span> 为 <spanclass="math inline">\([l,r]\)</span> 内的最大值。</p><p>对于一个区间 <spanclass="math inline">\(x:[l,r]\)</span>，首先它会直接继承 <spanclass="math inline">\(s(x)\)</span>，然后加上 <spanclass="math inline">\([mid+1,r]\)</span>中的一个子序列，满足严格递增且第一个元素大于 <spanclass="math inline">\(t(x)\)</span>。</p><p>看起来不好做，但是考虑那第一个大于 <spanclass="math inline">\(t(x)\)</span> 的值，如果它在某个节点 <spanclass="math inline">\(y\)</span>的左儿子内，那么其右儿子内大于它的数量一定是 <spanclass="math inline">\(s(y)-s\big(lson(y)\big)\)</span>。</p><p>这样线段树上二分，在 <span class="math inline">\([mid+1,r]\)</span>内查找第一个大于 <span class="math inline">\(t\big(lson(x)\big)\)</span>的数，顺便加上上面那个即可。</p><h3 id="cf1440e-greedy-shopping">CF1440E Greedy Shopping</h3><blockquote><p><span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 次操作，一种操作是前缀取 <spanclass="math inline">\(\max\)</span>，另一种操作是给定 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(k\)</span>，从 <spanclass="math inline">\(L\)</span> 到 <spanclass="math inline">\(n\)</span>，如果到 <spanclass="math inline">\(i\)</span> 时有 <span class="math inline">\(a_i\le k\)</span>，那么就让让答案加 1，<spanclass="math inline">\(k-a_i\)</span>，表示购买。<spanclass="math inline">\(\{a\}\)</span> 单调不增，规模 <spanclass="math inline">\(2 \cdot 10^5\)</span>。</p></blockquote><p>容易看出来购买的一定是若干个连续段。</p><p>单独求一个连续段是容易的，在 <spanclass="math inline">\([L,n]\)</span> 上查找第一个满足 <spanclass="math inline">\(Sum[L,i+1] &gt; k\)</span> 的 <spanclass="math inline">\(i\)</span>即可。多个的话，可以再二分第一个小于等于剩下的 <spanclass="math inline">\(k\)</span> 的位置。</p><p>考虑一个性质，如果已经无法购买，说明剩下的 <spanclass="math inline">\(k\)</span>不会多于之前的一半了，否则由于序列单调，必然可以购买，所以最多二分 <spanclass="math inline">\(O(\log_2 \max\{Y\})\)</span> 次。</p><p>然后记录区间最小值可以做到可行性剪枝。</p><p>考虑前缀取 <span class="math inline">\(\max\)</span>的操作，区间内是有不同的数的，比较好的解决方法是记录区间最大值，只在取<span class="math inline">\(\max\)</span>的值不小于区间最大值时再打标记，<code>pushup</code>维护即可。</p><p> </p><p>这玩意也能在权值线段树（主席树）上用。</p><h2 id="动态开点">动态开点</h2><p>很多时候值域很大又不能离散化，为了降低空间复杂度，可以抛弃二叉树的结构，直接记录左右儿子，且一个节点被创建当且仅当被使用到。</p><p>如果是动态操作且值域较大，那么可以考虑动态开点。</p><p>那么如果一次操作复杂度是 <span class="math inline">\(O(\log_2n)\)</span> 的话，用到的节点数也是 <spanclass="math inline">\(O(\log_2n)\)</span> 的，<spanclass="math inline">\(m\)</span> 次操作时候节点数量为 <spanclass="math inline">\(O(m \log_2 n)\)</span>。</p><p>写法倒是很简单，而且能直接套上普通线段树的<code>pushup</code>和<code>pushdown</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) x=++cnt;<span class="hljs-keyword">if</span>(l==r) &#123;ls[x]=rs[x]=<span class="hljs-number">0</span>;        <span class="hljs-comment">// init a node.</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">modify</span>(ls[x],p,l,mid);<span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(rs[x],p,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(x);&#125;</code></pre></div><p>下面是摘自<ahref="https://oi-wiki.org/ds/seg/">OI-wiki</a>的两段代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// root 表示整棵线段树的根结点；cnt 表示当前结点个数</span><span class="hljs-keyword">int</span> n, cnt, root;<span class="hljs-keyword">int</span> sum[n * <span class="hljs-number">2</span>], ls[n * <span class="hljs-number">2</span>], rs[n * <span class="hljs-number">2</span>];<span class="hljs-comment">// 用法：update(root, 1, n, x, f); 其中 x 为待修改节点的编号</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> f)</span> </span>&#123;  <span class="hljs-comment">// 引用传参</span>  <span class="hljs-keyword">if</span> (!p) p = ++cnt;  <span class="hljs-comment">// 当结点为空时，创建一个新的结点</span>  <span class="hljs-keyword">if</span> (s == t) &#123;    sum[p] += f;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);  <span class="hljs-keyword">if</span> (x &lt;= m)    <span class="hljs-built_in">update</span>(ls[p], s, m, x, f);  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">update</span>(rs[p], m + <span class="hljs-number">1</span>, t, x, f);  sum[p] = sum[ls[p]] + sum[rs[p]];  <span class="hljs-comment">// pushup</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 用法：query(root, 1, n, l, r);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果结点为空，返回 0</span>  <span class="hljs-keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> sum[p];  <span class="hljs-keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>), ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (l &lt;= m) ans += <span class="hljs-built_in">query</span>(ls[p], s, m, l, r);  <span class="hljs-keyword">if</span> (r &gt; m) ans += <span class="hljs-built_in">query</span>(rs[p], m + <span class="hljs-number">1</span>, t, l, r);  <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>没啥可说了。</p><h2 id="线段树合并">线段树合并</h2><p>两棵结构相同的线段树可以直接进行合并。</p><p>用两个指针 <span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span>，同步遍历两棵树。</p><ol type="1"><li>若 <span class="math inline">\(p\)</span> 或 <spanclass="math inline">\(q\)</span>为空，那么非空的那个作为合并后的节点。</li><li>否则将 <span class="math inline">\(q\)</span> 的信息合并到 <spanclass="math inline">\(p\)</span>，遍历左右儿子然后<code>pushup</code>。</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p,<span class="hljs-keyword">int</span> q,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;<span class="hljs-keyword">if</span>(!p||!q) &#123; p|=q; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(l==r) &#123;<span class="hljs-comment">// 合并叶子节点</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">merge</span>(ls[p],ls[q],l,mid);<span class="hljs-built_in">merge</span>(rs[p],rs[q],mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(p);&#125;</code></pre></div><p>复杂度？</p><p><del>我不会证</del>。</p><figure><img src="https://cdn-us.imgs.moe/2023/01/23/63ceab4b00b39.png" srcset="/img/loading.gif" lazyloadalt="orz" /><figcaption aria-hidden="true">orz</figcaption></figure><figure><img src="https://cdn-us.imgs.moe/2023/01/23/63ce9354ef0d8.png" srcset="/img/loading.gif" lazyloadalt="势能分析恐怖如斯" /><figcaption aria-hidden="true">势能分析恐怖如斯</figcaption></figure><h3 id="luogu3224-永无乡">luogu3224 永无乡</h3><p>板子题，并查集维护连通块，顺便进行合并，查询的时候全局线段树上二分即可。</p><h3 id="luogu3201-梦幻布丁">luogu3201 梦幻布丁</h3><p>每种颜色开一棵线段树，叶子为 <span class="math inline">\(1\)</span>表示这个位置的颜色是它。那么这棵线段树对答案的贡献就是连续 <spanclass="math inline">\(1\)</span>段的段数。记录区间左右端点的颜色，容易维护。</p><p>合并两种颜色就相当于合并这两棵线段树，对答案的影响显然与其它颜色段无关，随便搞一下就完了。</p><h2 id="标记永久化">标记永久化</h2><p>通过摒弃下传标记来降低常数。</p><ul><li>遇到一个被完全覆盖的区间直接打标记</li><li>否则直接通过这个区间与操作区间的交修改区间信息</li><li>查询的时候加上标记</li></ul><p>下面给出区间加法的代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; tag[x]+=d; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=mid) <span class="hljs-built_in">modify</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid)  <span class="hljs-built_in">modify</span>(L,R,d,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,<span class="hljs-keyword">int</span> r=n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="hljs-keyword">return</span> t[x]+tag[x]*(r-l+<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>, ans=tag[x]*(<span class="hljs-built_in">min</span>(R,r)-<span class="hljs-built_in">max</span>(L,l)+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(L&lt;=mid) ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>,l,mid);    <span class="hljs-keyword">if</span>(R&gt;mid)  ans+=<span class="hljs-built_in">query</span>(L,R,x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>这不就是分块时维护的标记吗？</p><h2 id="参考">参考</h2><p><ahref="https://zhuanlan.zhihu.com/p/573489802">ACM——线段树上二分教程 By严格鸽</a></p><p><a href="https://zhuanlan.zhihu.com/p/575513452">算法学习笔记(88):线段树合并 By Pecco</a></p><p><ahref="https://www.cnblogs.com/Y-B-X/p/15091099.html">关于线段树合并的时间复杂度By Y_B_X</a></p><p><a href="https://oi-wiki.org/ds/seg">OI wiki 线段树</a></p><p>《算法竞赛》 By 罗勇军，郭卫斌</p><p>《算法竞赛进阶指南》 By 李煜东</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回归</title>
    <link href="/2023/return/"/>
    <url>/2023/return/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>关于为啥失踪这么久……</p><p>NOIP 挂了太多的分。</p><p>由于疫情就回家上网课去了。</p><p>文化课实在是令人厌倦，但是又对 OI没啥信心了，所以就开始了大摸鱼时代。</p><p>期间几经辗转终于买到了新书《算法竞赛》，想着最后学点东西，结束 OI生涯了。</p><p>可是文化课实在是过于恶心人，一句话不如 OI。</p><p>由于一些原因，我弃置了所有原有的 OJ 账号。</p><p>然后再次。</p><p>只不过我上学期是把自己的电脑放到机房里了，下学期很可能找不到时机带进去，所以我应该只能在洛谷博客上同步更新了。而且这个博客换了更加高效的主题，还有很多地方没时间进行调整，观感可能也不是很好。</p><p><a href="https://www.luogu.com.cn/blog/yozora0908/">LuoguBlog</a></p>]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8817 假期计划 题解</title>
    <link href="/2022/lg8817-solution/"/>
    <url>/2022/lg8817-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>用 <span class="math inline">\(n\)</span> 次 BFS求出任意两点之间的距离。</p><span id="more"></span><p>枚举 <span class="math inline">\(b,c\)</span>，预处理 <spanclass="math inline">\(p(b,0/1/2)\)</span>，表示能到达 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大/次大/第三大值，<spanclass="math inline">\(q(c,0/1/2)\)</span> 同理。</p><p>那么接下来就是要求选出的两个点不等于 <spanclass="math inline">\(b,c\)</span> 且不相等，是一个大分类讨论。</p><p>但是注意到最多 <span class="math inline">\(9\)</span>种搭配，所以只要求合法的最大值即可。</p><p>教训：不要上来就刚分类讨论，一定要把思路完善到底。对于这类有着很有限的情况和很复杂的分类，可以枚举所有合法方案取最优。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2505</span>;<span class="hljs-keyword">int</span> n, m, k, ans, a[N], p[N][<span class="hljs-number">3</span>], q[N][<span class="hljs-number">3</span>], d[N][N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">8</span>*N], nxt[<span class="hljs-number">8</span>*N];<span class="hljs-comment">// 边数用了2*N，调了好久才破案，教训+1</span><span class="hljs-keyword">int</span> v[N], vis[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span>* d)</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) vis[i]=<span class="hljs-number">0</span>;d[s]=<span class="hljs-number">0</span>;vis[s]=<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;vis[y]=<span class="hljs-number">1</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doit</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(d[<span class="hljs-number">1</span>][j]&gt;k+<span class="hljs-number">1</span>||d[j][i]&gt;k+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(a[j]&gt;a[p[i][<span class="hljs-number">0</span>]]) &#123;p[i][<span class="hljs-number">2</span>]=p[i][<span class="hljs-number">1</span>], p[i][<span class="hljs-number">1</span>]=p[i][<span class="hljs-number">0</span>], p[i][<span class="hljs-number">0</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[p[i][<span class="hljs-number">1</span>]]) &#123;p[i][<span class="hljs-number">2</span>]=p[i][<span class="hljs-number">1</span>], p[i][<span class="hljs-number">1</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[p[i][<span class="hljs-number">2</span>]]) p[i][<span class="hljs-number">2</span>]=j;<span class="hljs-keyword">if</span>(a[j]&gt;a[q[i][<span class="hljs-number">0</span>]]) &#123;q[i][<span class="hljs-number">2</span>]=q[i][<span class="hljs-number">1</span>], q[i][<span class="hljs-number">1</span>]=q[i][<span class="hljs-number">0</span>], q[i][<span class="hljs-number">0</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[q[i][<span class="hljs-number">1</span>]]) &#123;q[i][<span class="hljs-number">2</span>]=q[i][<span class="hljs-number">1</span>], q[i][<span class="hljs-number">1</span>]=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]&gt;a[q[i][<span class="hljs-number">2</span>]]) q[i][<span class="hljs-number">2</span>]=j;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!d[i][j]) d[i][j]=<span class="hljs-number">114514</span>;    <span class="hljs-comment">// 图可能不连通，这个函数很重要</span>&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">bfs</span>(i,d[i]);<span class="hljs-built_in">check</span>();<span class="hljs-built_in">doit</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b=<span class="hljs-number">2</span>;b&lt;=n;++b) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c=<span class="hljs-number">2</span>;c&lt;=n;++c) &#123;<span class="hljs-keyword">if</span>(!p[b][<span class="hljs-number">0</span>]) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(b==c||d[b][c]&gt;k+<span class="hljs-number">1</span>||p[c][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j) &#123;<span class="hljs-keyword">if</span>(p[b][i]&amp;&amp;q[c][j]&amp;&amp;p[b][i]!=q[c][j]&amp;&amp;p[b][i]!=c&amp;&amp;q[c][j]!=b)ans=<span class="hljs-built_in">max</span>(ans,a[p[b][i]]+a[q[c][j]]+a[b]+a[c]);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7715 Shape 题解</title>
    <link href="/2022/lg7715-solution/"/>
    <url>/2022/lg7715-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>直接枚举 <span class="math inline">\((x_1,y_1)\)</span>，<spanclass="math inline">\((x_2,y_2)\)</span>，对每行每列都做前缀和，可以得到20pts。</p><span id="more"></span><p>枚举点不如枚举横杠，设 <span class="math inline">\(f(x,y)\)</span>为在节点 <spanclass="math inline">\((x,y)\)</span>，同时往上下方向扩展的格数。对于一个<span class="math inline">\(x\)</span>，枚举 <spanclass="math inline">\(y_1,y_2\)</span>，如果 <spanclass="math inline">\((x,y_1)\)</span> 和 <spanclass="math inline">\((x,y_2)\)</span> 构成一个横杠，那么贡献为 <spanclass="math inline">\(\min\{ f(x,y_1),f(x,y_2) \}\)</span>。</p><p>可以拿到 50pts。</p><p>枚举横杠又不如枚举极长横杠。</p><p>考虑对于每一行 <spanclass="math inline">\(x\)</span>，直接处理两个黑色格子中间的部分，设为<span class="math inline">\([l,r]\)</span>，那么贡献为 <spanclass="math display">\[\sum_{y_1=l}^r \sum_{y2=y_1+1}^r \min\{f(x,y_1),f(x,y_2)\}\]</span> 考虑如果将 <span class="math inline">\(f(x,y)\)</span>递增排序，那么对于排名为 <span class="math inline">\(k\)</span> 的 <spanclass="math inline">\(f(x,y_0)\)</span> 会贡献出 <spanclass="math inline">\(r-k\)</span> 次。</p><p>于是乎这部分的复杂度为 <span class="math inline">\(O(nm \log_2m)\)</span>，可以通过。</p><p>关于 <span class="math inline">\(f\)</span>的预处理，要摒弃求前缀和暴力判断的做法，下面给出官方题解中的 <spanclass="math inline">\(O(nm)\)</span> 做法。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e3</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, ans, t[N], a[N][N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=l;i&lt;=r;++i) t[++cnt]=f[x][i];<span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+cnt+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i) ans+=t[i]*(cnt-i);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;a[i][j]=<span class="hljs-built_in">read</span>()? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,p=<span class="hljs-number">-1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!a[i][j]) p=<span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span> ++p;f[i][j]=p;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=n,p=<span class="hljs-number">-1</span>;i;--i)&#123;<span class="hljs-keyword">if</span> (!a[i][j]) p=<span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span> ++p;f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],p);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;<span class="hljs-keyword">int</span> pre=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;y&lt;=m;++y) <span class="hljs-keyword">if</span>(!a[x][y]) ans+=<span class="hljs-built_in">calc</span>(x,pre,y<span class="hljs-number">-1</span>), pre=y+<span class="hljs-number">1</span>;ans+=<span class="hljs-built_in">calc</span>(x,pre,m);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6748 Fallen Lord 题解</title>
    <link href="/2022/lg6748-solution/"/>
    <url>/2022/lg6748-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>值得一提的是，我一开始读错题，认为对于节点 <spanclass="math inline">\(x\)</span>，是根到它的路径上的中位数不能超过 <spanclass="math inline">\(a_x\)</span>，导致连暴力都不会打。</p><span id="more"></span><h2 id="分析">分析</h2><p>发现每条边 <span class="math inline">\((x,y)\)</span> 的权值只可能是<span class="math inline">\(a_x\)</span>，<spanclass="math inline">\(a_y\)</span>，<spanclass="math inline">\(m\)</span>。</p><p>对于一个节点 <spanclass="math inline">\(x\)</span>，与它相连的所有边权的中位数不超过 <spanclass="math inline">\(a_x\)</span>，那么 <spanclass="math inline">\(deg_x\)</span> 条边中，最多有 <spanclass="math inline">\(\lfloor \frac{deg_x}{2} \rfloor + 1\)</span>条边小于等于 <span class="math inline">\(a_x\)</span>，也就是至多有<span class="math inline">\(\lceil \frac{deg_x}{2} \rceil - 1\)</span>条边权大于 <span class="math inline">\(a_x\)</span>。设其为 <spanclass="math inline">\(t\)</span>。</p><p>设 <span class="math inline">\(f(x,0/1)\)</span> 表示 <spanclass="math inline">\((x,fa_x)\)</span> 的权值是小于等于还是大于 <spanclass="math inline">\(a_x\)</span>。</p><p>对于 <span class="math inline">\(f(x,0)\)</span>，在 <spanclass="math inline">\(x\)</span> 连向子节点的边中，最多可以有 <spanclass="math inline">\(t\)</span> 条边大于 <spanclass="math inline">\(a_x\)</span>。</p><p>对于 <span class="math inline">\(f(x,1)\)</span>，这样的边数为 <spanclass="math inline">\(t-1\)</span>。</p><p>考虑 <span class="math inline">\(x\)</span> 的子节点 <spanclass="math inline">\(y\)</span>，设 <spanclass="math inline">\(g(y,0)\)</span> 为 <spanclass="math inline">\((x,y)\)</span> 的边小于等于 <spanclass="math inline">\(a_x\)</span> 时，以 <spanclass="math inline">\(y\)</span> 为根的子树加上这条边的最大权值，<spanclass="math inline">\(g(y,1)\)</span> 则反之。 <spanclass="math display">\[g(y,0) = \max\{ f(y,0) +\min(a_x,a_y), f(y,1)+a_x\}\]</span></p><p><span class="math display">\[g(y,1) = \max\{ f(y,0) + a_y, f(y,1) + m \}\]</span></p><p>对于每个 <span class="math inline">\(y\)</span>，只会为 <spanclass="math inline">\(f(x)\)</span> 贡献其中一个。</p><p>显然 <span class="math inline">\(g(y,1) \ge g(y,0)\)</span>，那么设<span class="math inline">\(g(y,0)\)</span> 的和为 <spanclass="math inline">\(s\)</span>。</p><p>将所有 <span class="math inline">\(g(y,1)-g(y,0)\)</span>递减排序，记为 <span class="math inline">\(g\)</span>。 <spanclass="math display">\[f(x,0) = s +\sum_{i=1}^t g(i)\]</span></p><p><span class="math display">\[f(x,1) = s + \sum_{i=1}^{t-1} g(i)\]</span></p><p>特别的，当 <span class="math inline">\(t=0\)</span> 时，<spanclass="math inline">\(f(x,1) = -\infty\)</span></p><p>答案是 <span class="math inline">\(\max\{f(1,0),f(1,1)\}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, a[N], c[N], g[N], f[N][<span class="hljs-number">2</span>], deg[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);++deg[x], ++deg[y];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>, s=<span class="hljs-number">0</span>, t=(deg[x]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=t;++i) g[i]=c[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> g1=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>]+a[y],f[y][<span class="hljs-number">1</span>]+m);<span class="hljs-keyword">int</span> g0=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>]+<span class="hljs-built_in">min</span>(a[x],a[y]),f[y][<span class="hljs-number">1</span>]+a[x]);s+=g0;c[++cnt]=g1-g0;&#125;<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i) g[i]=g[i<span class="hljs-number">-1</span>]+c[i];f[x][<span class="hljs-number">0</span>]=s+g[t];<span class="hljs-keyword">if</span>(t) f[x][<span class="hljs-number">1</span>]=s+g[t<span class="hljs-number">-1</span>]; <span class="hljs-keyword">else</span> f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">-1e15</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">max</span>(f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF981D Bookshelves 题解</title>
    <link href="/2022/cf981d-solution/"/>
    <url>/2022/cf981d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>按位贪心。</p><span id="more"></span><p>由于高位的 <span class="math inline">\(1\)</span> 优于低位的所有<spanclass="math inline">\(1\)</span>，所以考虑一个过程<code>check(x)</code>，表示是否能够在保证更高位的<span class="math inline">\(1\)</span>不会减少的情况下，使得当前这一位为 <spanclass="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 本书，划分成 <spanclass="math inline">\(j\)</span> 段是否可行。 <spanclass="math display">\[f(i,j) = \operatorname{OR}_{k=0}^{i-1} f(k,j-1) \operatorname{AND}[sum(k+1,i) \&amp; x = x]\]</span> 如果 <span class="math inline">\(sum(k+1,i) \&amp; x =x\)</span>，那么说明这一段在满足之前所有 <spanclass="math inline">\(1\)</span> 的情况下还能满足这一位是 <spanclass="math inline">\(1\)</span>。至于其他位则不必关心。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-keyword">int</span> n, k, s[N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;++k) &#123;f[i][j]|=f[k][j<span class="hljs-number">-1</span>]&amp;(((s[i]-s[k])&amp;x)==x);&#125;&#125;<span class="hljs-keyword">return</span> f[n][k];&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">62</span>;~i;--i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(ans|(<span class="hljs-number">1ll</span>&lt;&lt;i))) ans|=(<span class="hljs-number">1ll</span>&lt;&lt;i);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8162 让我们赢得选举 题解</title>
    <link href="/2022/lg8162-solution/"/>
    <url>/2022/lg8162-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先让自己和协作者在多个不同的州演讲一定不优。</p><span id="more"></span><p>证明：反证法。假设更优，那么由于自己和协作者的演讲速度相同，所以在同样的时间里，让协作者为自己「加速」和分头演讲的总量是不变的。而让自己加速能够在更短的时间里得到正在演讲的那个州的票，矛盾。</p><p>其次，对于任意一个州，它的演讲时间只能为 <spanclass="math inline">\(A_i\)</span>，<span class="math inline">\(B_i[B_i\neq -1]\)</span>，<spanclass="math inline">\(0\)</span>。这个是显然的。为了方便起见，分别称之为2 类州，1 类州和 3 类州。</p><p>对于所有 1 类州，一定最先被演讲完。</p><p>证明：微扰。如果存在一个 1 类州在一个 2 类州之后，将二者交换后，在<span class="math inline">\(j\)</span> 演讲的时候就多了一个演讲者，在<span class="math inline">\(B_i\)</span>演讲时演讲者数量不变，显然更优。</p><p>对于所有 1 类州，一定按照 <span class="math inline">\(B_i\)</span>为第一关键字，<span class="math inline">\(A_i\)</span>为第二关键字递增排序。</p><p>证明：微扰。如果存在一种不符合这个法则的方案，设他们为 <spanclass="math inline">\((i,j)\)</span>，那么得到两张票的用时为 <spanclass="math display">\[\frac{B_i}{k} + \frac{B_j}{k+1}\]</span> 交换后为 <span class="math display">\[\frac{B_i}{k+1} + \frac{B_j}{k}\]</span></p><p>同乘 <span class="math inline">\(k(k+1)\)</span></p><p><span class="math display">\[B_i(k+1) + B_jk\]</span></p><p><span class="math display">\[B_ik + B_j (k+1)\]</span></p><p>由于 <span class="math inline">\(B_i &gt;B_j\)</span>，根据排序不等式，后者不劣于前者。</p><p>具体实现时只要将所有州按照这个法则排序即可。</p><p> </p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个州，得到了 <spanclass="math inline">\(j\)</span> 张票，其中总管有 <spanclass="math inline">\(d\)</span> 1 类州，已经完成了 <spanclass="math inline">\(k\)</span> 个的最小代价。 <spanclass="math display">\[f(i,j,k) \rightarrow f(i+1,j,k)\]</span></p><p><span class="math display">\[f(i,j,k) + \lfloor \frac{A_{i+1}}{d+1} \rfloor \rightarrow f(i,j+1,k)\]</span></p><p><span class="math display">\[f(i,j,k) + \lfloor \frac{B_{i+1}}{k+1} \rfloor  \rightarrowf(i+1,j+1,k+1)\]</span></p><p>采用刷表法的原因：转移方式较多，状态较为复杂。</p><p>由于 1 类州的数量无法确定且没有什么性质，所以要枚举。</p><p>复杂度 <span class="math inline">\(O(n^3K)\)</span>，可以得到 56pts的高分。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> d)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=n;++k) f[i][j][k]=<span class="hljs-number">1.0</span>*inf;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=K;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=d;++k) &#123;f[i+<span class="hljs-number">1</span>][j][k]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j][k],f[i][j][k]);f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k],f[i][j][k]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].a/(d+<span class="hljs-number">1</span>));f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>],f[i][j][k]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].b/(k+<span class="hljs-number">1</span>));&#125;&#125;&#125;<span class="hljs-keyword">return</span> f[n][K][d];&#125;</code></pre></div><p>考虑下面那一档性质分。发现 <span class="math inline">\(K=n\)</span>时可以略去 <span class="math inline">\(j\)</span> 那一维，复杂度 <spanclass="math inline">\(O(n^2K)\)</span>，可以多拿 11pts。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">solve2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> d)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) g[i][j]=<span class="hljs-number">1.0</span>*inf;g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=d;++j) &#123;g[i+<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">min</span>(g[i+<span class="hljs-number">1</span>][j],g[i][j]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].a/(d+<span class="hljs-number">1</span>));g[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(g[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>],g[i][j]+<span class="hljs-number">1.0</span>*s[i+<span class="hljs-number">1</span>].b/(j+<span class="hljs-number">1</span>));&#125;&#125;<span class="hljs-keyword">return</span> g[n][d];&#125;</code></pre></div><p>考虑优化。</p><p>当完成了所有 1类州的演讲时，剩下的肯定是挑选时间最小的那些州进行演讲。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为前 <spanclass="math inline">\(i\)</span> 个州，选出了 <spanclass="math inline">\(j\)</span> 个 1 类州的最小时间。</p><p>由于边界条件的原因，不能使用刷表法了。</p><p>不选 <span class="math inline">\(i\)</span> <spanclass="math display">\[f(i-1,j) + \lfloor \frac{A_i}{d+1} \rfloor \rightarrow f(i,j)\]</span> 选 <span class="math display">\[f(i-1,j-1) + \lfloor \frac{B_i}{j} \rfloor \rightarrow f(i,j)\]</span> 然后取一个 <span class="math inline">\(\delta = \min_{i=K}^n\{ f(i,d) \}\)</span>，这代表在寻找最优的 1 类州时已经完成 <spanclass="math inline">\(K\)</span> 张票的最小时间。</p><p>枚举 <span class="math inline">\(i \in [d,K-1]\)</span>，找到 <spanclass="math inline">\([i,n]\)</span> 中前 <spanclass="math inline">\(K-i\)</span> 小的 <spanclass="math inline">\(A_i\)</span> 的和 <spanclass="math inline">\(val\)</span>，<span class="math inline">\(f(i,d) +\lfloor \frac{val}{d+1} \rfloor\)</span> 即为这部分的最小时间。</p><p>取最小值即可。</p><p>这样复杂度就变成了 <span class="math inline">\(O(nK^2)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>, inf=<span class="hljs-number">1e9</span>;<span class="hljs-keyword">int</span> n, K;<span class="hljs-keyword">double</span> ans=<span class="hljs-number">1.0</span>*inf, t[N], f[N][N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> a, b;&#125; s[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node x,node y) &#123;<span class="hljs-keyword">if</span>(x.b!=y.b) <span class="hljs-keyword">return</span> x.b&lt;y.b;<span class="hljs-keyword">return</span> x.a&lt;y.a;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> d)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) t[i]=<span class="hljs-number">1.0</span>*s[i].a;<span class="hljs-keyword">double</span> ans=<span class="hljs-number">1.0</span>*inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) f[i][j]=<span class="hljs-number">1.0</span>*inf;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-built_in">min</span>(d,i);++j) &#123;f[i][j]=f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1.0</span>*s[i].a/(d+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(j&amp;&amp;s[i].b!=<span class="hljs-number">1e15</span>) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1.0</span>*s[i].b/j);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=K;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,f[i][d]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=K<span class="hljs-number">-1</span>;i&gt;=d;--i) &#123;<span class="hljs-built_in">sort</span>(t+i+<span class="hljs-number">1</span>,t+n+<span class="hljs-number">1</span>);        <span class="hljs-comment">// 对这个后缀排序</span><span class="hljs-keyword">double</span> val=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=K-i;++j) val+=t[i+j];ans=<span class="hljs-built_in">min</span>(ans,f[i][d]+val/(d+<span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), K=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;s[i].a=<span class="hljs-built_in">read</span>(), s[i].b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(s[i].b==<span class="hljs-number">-1</span>) s[i].b=<span class="hljs-number">1e15</span>;&#125;<span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;++i) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">solve</span>(i));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.15lf\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题选讲4</title>
    <link href="/2022/tititi-solution-4/"/>
    <url>/2022/tititi-solution-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>杂题选讲</strong> 4.</p><span id="more"></span><h1 id="luogu8110-矩阵">luogu8110 矩阵</h1><h2 id="分析">分析</h2><p>萌萌题。 <span class="math display">\[A^2_{i,j} = \sum_{i=k}^n A_{i,k} \cdot A_{k,j} = \sum_{k=1}^na_ib_ka_kb_j = a_ib_j\Big( (\sum_{k=1}^n a_ib_i)  = d\Big)\]</span></p><p><span class="math display">\[\sum_{i=1}^n \sum_{j=1}^n A^2_{i,j} = \sum_{i=1}^n \sum_{j=1}^n a_ib_jd= \Big( \sum_{i=1}^n a_i \cdot \sum_{i=1}^n b_i \Big) d\]</span></p><p>归纳一下得到答案。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n, k, sa, sb, a[N], b[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=(<span class="hljs-built_in">read</span>()%mod+mod)%mod;(sa+=a[i])%=mod;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=(<span class="hljs-built_in">read</span>()%mod+mod)%mod;(sb+=b[i])%=mod;&#125;<span class="hljs-keyword">if</span>(!k) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">int</span> d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) (d+=a[i]*b[i]%mod)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sa*sb%mod*<span class="hljs-built_in">fp</span>(d,k<span class="hljs-number">-1</span>)%mod);&#125;</code></pre></div><h1 id="luogu6599-异或">luogu6599 异或</h1><h2 id="分析-1">分析</h2><p>按位贪心。</p><p>若答案的第 <span class="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>，设 <spanclass="math inline">\(x\)</span> 为序列中第 <spanclass="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span> 的个数。不难发现它会与所有第 <spanclass="math inline">\(k\)</span> 位不是 <spanclass="math inline">\(1\)</span> 的数产生 <spanclass="math inline">\(2^k\)</span> 的贡献。</p><p>那么总贡献为 <span class="math inline">\(2^k \cdot x \times(l-x)\)</span>，当 <span class="math inline">\(x = \lfloor \frac{l}{2}\rfloor\)</span> 时有最大值。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> t, n, l;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), l=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> base=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">40</span>, x=l&gt;&gt;<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(base) &#123;base&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(n&lt;base) <span class="hljs-keyword">continue</span>;(ans+=base*x%mod*(l-x))%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="luogu7714-排列排序">luogu7714 排列排序</h1><h2 id="分析-2">分析</h2><p>容易想到，一定存在一种排序方法，使得每个数之多被操作 <spanclass="math inline">\(1\)</span> 次（因为代价的上界为 <spanclass="math inline">\(n\)</span>）。</p><p>考虑这样的区间是什么样的。</p><p>设其为 <span class="math inline">\([l,r]\)</span>。其中 <spanclass="math inline">\([1,l-1]\)</span> 中的数要严格小于 <spanclass="math inline">\([l,r]\)</span> 中的最小值，<spanclass="math inline">\([r+1,n]\)</span> 中的数要严格大于 <spanclass="math inline">\([l,r]\)</span> 中的最大值。</p><p>双指针找即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, p[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=n) &#123;<span class="hljs-keyword">if</span>(p[l]==l) ++l;        <span class="hljs-comment">// 跳过已经有序的部分</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> r=l+<span class="hljs-number">1</span>, mx=<span class="hljs-built_in">max</span>(p[l],p[r]);<span class="hljs-keyword">while</span>(mx&gt;r) &#123;                <span class="hljs-comment">// 直到最大值和右端点相等</span>++r;mx=<span class="hljs-built_in">max</span>(mx,p[r]);&#125;ans+=r-l+<span class="hljs-number">1</span>;l=r+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="luogu8161-自学-self-study">luogu8161 自学 (Self Study)</h1><h2 id="分析-3">分析</h2><p>二分答案 <spanclass="math inline">\(mid\)</span>，以课程数量作为限制。</p><p>对于一个 <span class="math inline">\(i\)</span>，如果 <spanclass="math inline">\(b_i &gt;a_i\)</span>，那么就没必要上课，全部自学即可。</p><p>否则贪心的多上课。如果上课就足够满足了，那么就上那么多课，否则就占用自学的课程。</p><p>如果某个时刻需要的课程数量超过了 <spanclass="math inline">\(nm\)</span>，那么不行。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, a[N], b[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x+y<span class="hljs-number">-1</span>)/y; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> nd=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&lt;b[i]) nd+=<span class="hljs-built_in">cil</span>(x,b[i]);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(a[i]*m&gt;=x) nd+=<span class="hljs-built_in">cil</span>(x,a[i]);<span class="hljs-keyword">else</span> nd+=m+<span class="hljs-built_in">cil</span>(x-a[i]*m,b[i]);&#125;<span class="hljs-keyword">if</span>(nd&gt;n*m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1000000000000000010</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div><h1 id="luogu8432-ぽかぽかの星">luogu8432 ぽかぽかの星</h1><h2 id="分析-4">分析</h2><p>发现直接做比较困难。</p><p>考虑从值域下手。把相加为 <span class="math inline">\(k+1\)</span>的数两两分组，<span class="math inline">\((1,k)\)</span>，<spanclass="math inline">\((2,k-1)\)</span>，<spanclass="math inline">\(\cdots\)</span>。</p><p>对于任意一组，至少有一个数出现的次数为 <spanclass="math inline">\(0\)</span>。</p><p>设 <span class="math inline">\(m\)</span> 为组数。</p><p>当 <span class="math inline">\(2 \mid k\)</span>时，有正好偶数组。</p><p>枚举非全 <span class="math inline">\(0\)</span> 的组数 <spanclass="math inline">\(i\)</span>，方案数 <spanclass="math inline">\(\binom{m}{i}\)</span>，将 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(1\)</span> 分配到 <spanclass="math inline">\(i\)</span> 组中，每一组不能为 <spanclass="math inline">\(0\)</span>，方案数 <spanclass="math inline">\(\binom{n-1}{i-1}\)</span>，每一组有 <spanclass="math inline">\(2\)</span> 种方法，方案数为 <spanclass="math inline">\(2^i\)</span>。</p><p>答案为 <span class="math display">\[\sum_{i=1}^{\min(n,m)} \binom{m}{i} \binom{n-1}{i-1} 2^i\]</span> 当 <span class="math inline">\(2 \nmid k\)</span>时，存在一个孤立的数字。</p><p>那么一次统计去掉它的方案数，一次强制选择它，累加即可。</p><p>答案 <span class="math display">\[\sum_{i=1}^{\min(n,m)} \binom{m}{i} \binom{n-1}{i-1} 2^i +\sum_{i=1}^{\min(n-1,m)} \binom{m}{i} \binom{n-2}{i-1} 2^i\]</span></p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> t, n, k, fac[N], inv[N], p2[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">1</span>]=inv[<span class="hljs-number">0</span>]=p2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;p2[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">5e6</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod, p2[i]=p2[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;inv[N<span class="hljs-number">-5</span>]=<span class="hljs-built_in">fp</span>(fac[N<span class="hljs-number">-5</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=N<span class="hljs-number">-6</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> n&lt;=m? <span class="hljs-number">1</span>:fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,k);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">int</span> m=k/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(n,m);++i) (ans+=<span class="hljs-built_in">C</span>(m,i)*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,i<span class="hljs-number">-1</span>)%mod*p2[i]%mod)%=mod;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> m=(k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(n,m);++i) (ans+=<span class="hljs-built_in">C</span>(m,i)*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,i<span class="hljs-number">-1</span>)%mod*p2[i]%mod)%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(n<span class="hljs-number">-1</span>,m);++i) (ans+=<span class="hljs-built_in">C</span>(m,i)*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-2</span>,i<span class="hljs-number">-1</span>)%mod*p2[i]%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="luogu5689-多叉堆">luogu5689 多叉堆</h1><h2 id="分析-5">分析</h2><p>套路题。</p><p>设 <span class="math inline">\(f_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的树的方案数。</p><p>对于 <span class="math inline">\(x\)</span> 合并到 <spanclass="math inline">\(y\)</span>，只需要钦定 <spanclass="math inline">\(y\)</span> 的根为 <spanclass="math inline">\(0\)</span>，随便选出 <spanclass="math inline">\(sz_x\)</span> 个数放到 <spanclass="math inline">\(x\)</span> 里面，都有 <spanclass="math inline">\(f_x\)</span> 种方法，其他的节点的方案数为 <spanclass="math inline">\(f_y\)</span>，所以得到 <spanclass="math display">\[f_y = \binom{sz_y + sz_x -1}{sz_x} f_x f_y\]</span> 用并查集维护合并操作即可。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, q, fa[N], sz[N], fac[N], inv[N], f[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);sz[y]+=sz[x];fa[x]=y;f[y]=(f[y]*f[x]%mod*<span class="hljs-built_in">C</span>(sz[y]<span class="hljs-number">-1</span>,sz[x])%mod)%mod;<span class="hljs-comment">// do DP</span>&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) fa[i]=i, f[i]=<span class="hljs-number">1</span>, sz[i]=<span class="hljs-number">1</span>;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[n]=<span class="hljs-built_in">fp</span>(fac[n],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-keyword">int</span> lst=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> op=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> x=(<span class="hljs-built_in">read</span>()+lst)%n, y=(<span class="hljs-built_in">read</span>()+lst)%n;<span class="hljs-built_in">merge</span>(x,y);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> x=(<span class="hljs-built_in">read</span>()+lst)%n;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,lst=f[<span class="hljs-built_in">get</span>(x)]);&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>二分答案</tag>
      
      <tag>组合数学</tag>
      
      <tag>并查集</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8112 符文破译 题解</title>
    <link href="/2022/lg8112-solution/"/>
    <url>/2022/lg8112-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>显然 <span class="math inline">\(Z\)</span> 函数。</p><p>由于在 <span class="math inline">\(Z\)</span>函数中考虑的是匹配串的后缀，所以从后往前考虑。</p><span id="more"></span><p>设 <span class="math inline">\(f_i\)</span> 为考虑 <spanclass="math inline">\([i,n]\)</span>，能够划分的最小段数，设 <spanclass="math inline">\(g_i\)</span> 为匹配串的 <spanclass="math inline">\([i,n]\)</span> 与模式串的 LCP 长度。</p><p>转是显然的。</p><p><span class="math display">\[f_i = \min_{j \in [i+1,i+g_i]} \{ f_j  \} + 1\]</span></p><p>虽然 <span class="math inline">\(i+g_i\)</span>不存在单调性，但是考虑如果存在 <spanclass="math inline">\(i&lt;j\)</span>，满足 <spanclass="math inline">\(g_i &gt; g_j\)</span>，那么从 <spanclass="math inline">\(j\)</span> 划分一定不优，于是直接把 <spanclass="math inline">\(j\)</span>删掉就行，这样就满足单调性，可以用单调队列优化。</p><p>不难证明，如果这样做后无解，那么不这样做一定无解。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, z[N], g[N], f[N], q[N];<span class="hljs-keyword">char</span> s[N], t[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;z[<span class="hljs-number">0</span>]=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) z[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;z[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(i+z[i]&lt;n&amp;&amp;t[z[i]]==t[i+z[i]]) ++z[i];<span class="hljs-keyword">if</span>(r&lt;i+z[i]<span class="hljs-number">-1</span>) l=i, r=i+z[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exkmp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">Z</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">-1</span>, r=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) g[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;g[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(i+g[i]&lt;m&amp;&amp;t[g[i]]==s[i+g[i]]) ++g[i];<span class="hljs-keyword">if</span>(r&lt;i+g[i]<span class="hljs-number">-1</span>) l=i, r=i+g[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,t,s);<span class="hljs-built_in">exkmp</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-keyword">int</span> k=i+g[i];<span class="hljs-keyword">if</span>(j&gt;k) g[i]=inf; <span class="hljs-keyword">else</span> j=k;&#125;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[m]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;q[l]=m;<span class="hljs-comment">// 初始决策，使得f[q[l]]=0</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;~i;--i) <span class="hljs-keyword">if</span>(g[i]!=inf) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;i+g[i]) ++l;f[i]=f[q[l]]+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[q[r]]&gt;=f[i]) --r;q[++r]=i;&#125;<span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>]&lt;inf) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">0</span>]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Fake&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
      <tag>字符串</tag>
      
      <tag>扩展kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6381 Odyssey 题解</title>
    <link href="/2022/lg6381-solution/"/>
    <url>/2022/lg6381-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题的 Subtask 1,2,4 都很显然，就不说了。</p><p>先介绍一种很好想的 Subtask 3 做法。</p><span id="more"></span><p>考虑完全平方数 <span class="math inline">\(ab\)</span> 和 <spanclass="math inline">\(bc\)</span>，易得 <spanclass="math inline">\(ac\)</span> 也是完全平方数。</p><p>推广到一个满足条件的路径，任意两个权值之积为完全平方数。</p><p>定义极长点对 <span class="math inline">\((x,y)\)</span> 表示 <spanclass="math inline">\(x\)</span> 入度为 <spanclass="math inline">\(0\)</span>，<span class="math inline">\(y\)</span>出度为 <span class="math inline">\(0\)</span> 的点对。</p><p>枚举极长点对 <spanclass="math inline">\((x,y)\)</span>，记录所有路径。问题转化为对于一个序列，找到<span class="math inline">\(l\)</span>之和最长的连续的一段，满足任意两个数之积为完全平方数。</p><p>考虑这样的序列是什么样的，不难发现，对于一个质因子 <spanclass="math inline">\(p_i\)</span>，每个数上都有奇数次幂或偶数次幂。</p><p>用<code>std::unordered_map</code>维护这个序列质因子的信息，就可以双指针做了。</p><p>不难证明这样一定能枚举到所有的情况。</p><p>复杂度？</p><p>先要预处理这个序列 <span class="math inline">\(l\)</span>的前缀和。</p><p>对于每个点对 <spanclass="math inline">\((x,y)\)</span>，其间每条路径都是 <spanclass="math inline">\(O(n)\)</span>级别的。但是由于枚举的是极长点对，所以点的数量在平均情况下极少。最极端的情况是菊花，但是路径长度都是<spanclass="math inline">\(1\)</span>，因此让极长点对数量增加必然导致路径长度减少，所以复杂度是<span class="math inline">\(O(\text{可过})\)</span>。</p><p>其实根据正解的那个结论，再加一定的推导和实现就能过 Subtask 6。</p><p>上自习课想的，没写代码。</p><p> </p><p>接下来讲正解。</p><p>对于 <span class="math inline">\(ab = c^k\)</span>，不难想到把 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 都分解。 <span class="math display">\[a= \prod_{i=1}^{c_a} p^{x_i}_i\]</span></p><p><span class="math display">\[b=\prod_{i=1}^{c_b} p^{y_i}_i\]</span></p><p>对于一个 <span class="math inline">\(p_i\)</span>，一定有 <spanclass="math inline">\(x_i + y_i \equiv 0 \pmod{k}\)</span>。</p><p>不难想到，一旦 <span class="math inline">\(a\)</span>确定了，就可以限定 <span class="math inline">\(b\)</span>。</p><p>对于一个 <span class="math inline">\(w\)</span>，可以预处理出其分解中所有指数在对 <span class="math inline">\(k\)</span>取模的意义下的值。 <span class="math display">\[w_1 = \prod_{i=1}^{c_w} p^{x_i \bmod k}_i\]</span> 和 <span class="math display">\[w_2 = \prod_{i=1}^{c_w} p^{k - x_i \bmod k}_i\]</span> 将所有 <span class="math inline">\(w_i\)</span>都这样处理，合法路径就都被确定了。两条边 <spanclass="math inline">\((i,j)\)</span> 形成的路径合法，当且仅当 <spanclass="math inline">\(w_2(i) =w_1(j)\)</span>。这相当于是一张分层图。</p><p>为了处理点与边，所以状态设计得比较不可读。</p><p>设 <span class="math inline">\(f_{x,d}\)</span> 为以节点 <spanclass="math inline">\(x\)</span> 结尾，出边 <spanclass="math inline">\(i\)</span> 满足 <spanclass="math inline">\(w_2(i)=d\)</span> 的最长路径。拓扑排序即可。 <spanclass="math display">\[f_{x,w2(i)} + z \rightarrow f_{y,w1(i)}\]</span> 其中 <span class="math inline">\(z=l(i)\)</span>。</p><p><span class="math inline">\(f_y\)</span> 依赖于 <spanclass="math inline">\(f_x\)</span>，不需要建反图。</p><p><span class="math inline">\(w_1\)</span> 和 <spanclass="math inline">\(w_2\)</span>的范围可能很大，使用<code>std::unordered_map</code>实现 <spanclass="math inline">\(f\)</span> 即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, k, ans, in[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N], w[<span class="hljs-number">2</span>*N], e[<span class="hljs-number">2</span>*N], l[<span class="hljs-number">2</span>*N];unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; f[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">devide1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i, ++c;c%=k;<span class="hljs-keyword">while</span>(c--) ans*=i;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>&amp;&amp;k!=<span class="hljs-number">1</span>) ans*=x;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">devide2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i, ++c;c%=k;<span class="hljs-keyword">if</span>(c) &#123;<span class="hljs-keyword">int</span> tc=k-c;<span class="hljs-keyword">while</span>(tc--) ans*=i;&#125;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> tc=k<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(tc--) ans*=x;&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z,<span class="hljs-keyword">int</span> li)</span> </span>&#123;to[++tot]=y, w[tot]=<span class="hljs-built_in">devide1</span>(z), e[tot]=<span class="hljs-built_in">devide2</span>(z), l[tot]=li;nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">// do DP</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], w1=w[i], w2=e[i], z=l[i];f[y][w1]=<span class="hljs-built_in">max</span>(f[y][w1],f[x][w2]+z);ans=<span class="hljs-built_in">max</span>(ans,f[y][w1]);<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>(), li=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z,li), ++in[y];&#125;    <span class="hljs-built_in">toposort</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>数论</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8564 ρars/ey 题解</title>
    <link href="/2022/lg8564-solution/"/>
    <url>/2022/lg8564-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>设 <span class="math inline">\(c(i)\)</span>为一次删去同一棵子树内不包括根的 <spanclass="math inline">\(i-1\)</span> 个节点的代价。</p><span id="more"></span><h3 id="链">链</h3><p>将 <span class="math inline">\(1\)</span> 号节点作为链首，不难想到设<span class="math inline">\(f_i\)</span> 为删掉以 <spanclass="math inline">\(i\)</span>为根的子树的最小代价，每次删掉的都是连续的一段，所以 <spanclass="math display">\[f_i = \min_{j \in [i+1,n]}\{ f_j + c(j-i+1)\}\]</span> 答案 <span class="math inline">\(f_1\)</span>。</p><h3 id="菊花">菊花</h3><p>显然，答案为 <span class="math inline">\(c(n)\)</span>。</p><h3 id="正解">正解</h3><p>设 <span class="math inline">\(f_{x,j}\)</span> 为以 <spanclass="math inline">\(x\)</span>为根的子树，完成所有子节点的删除操作后，还剩下 <spanclass="math inline">\(j\)</span> 个节点的最小代价。</p><p>注意到 <span class="math inline">\(j\)</span> 就是 <spanclass="math inline">\(x\)</span>的所有儿子节点剩下的节点数量之和，这个可以转化为用一个类似于树形背包的转移。</p><p>树形背包的实现方式是「对于一个节点 <spanclass="math inline">\(x\)</span>，将其子树 <spanclass="math inline">\(y\)</span> 依次加入以 <spanclass="math inline">\(x\)</span>为根的子树，同时合并信息」。这个状态也可以这样去合并。但为什么这个不是树形背包呢？因为并没有所谓「一个固定的容积」，这就导致了处理<span class="math inline">\(f\)</span>时必须严格维护当前树的大小，同时只处理 <spanclass="math inline">\(sz(x)\)</span> 位，</p><p>先对于 <span class="math inline">\(x\)</span> 的儿子节点 <spanclass="math inline">\(y\)</span>，进行一个合并 <spanclass="math display">\[f_{x,j+k} = \min_{k \in [1,sz(y)]}\{ f_{x,j} + f_{y,k} \}\]</span> <span class="math inline">\(j \in [cnt+1,s+1]\)</span>，其中<span class="math inline">\(cnt\)</span> 是在加入 <spanclass="math inline">\(y\)</span> 之前，已经加入的子树个数，<spanclass="math inline">\(s\)</span> 就是这些子树的大小之和。</p><p>然后进行 <span class="math inline">\(x\)</span> 的一次删除。 <spanclass="math display">\[f_{x,1} = \min\{ f_{x,k} + c(k) \}\]</span> 复杂度是 <span class="math inline">\(O(n^2)\)</span>的，实现不当则会退化成 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> n, a[N], sz[N], f[N][N], F[N], deg[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-keyword">namespace</span> sub1 &#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,a[n]);&#125;&#125;;<span class="hljs-keyword">namespace</span> sub2 &#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">SET</span>(F,<span class="hljs-number">0x3f</span>);F[n]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;F[i]=<span class="hljs-built_in">min</span>(F[i],F[j]+a[j-i+<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,F[<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-keyword">namespace</span> bf &#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);sz[x]+=sz[y];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;sz[x];++i) f[x][i]=<span class="hljs-number">1e15</span>;f[x][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>, s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=s+<span class="hljs-number">1</span>;j&gt;=cnt+<span class="hljs-number">1</span>;--j) &#123;                <span class="hljs-comment">// 倒序循环</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=sz[y];++k) f[x][j+k]=<span class="hljs-built_in">min</span>(f[x][j+k],f[x][j]+f[y][k]);f[x][j]=<span class="hljs-number">1e15</span>;                <span class="hljs-comment">// 顺便置为正无穷</span>&#125;++cnt, s+=sz[y];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=cnt;j;--j) f[x][j]=<span class="hljs-number">1e15</span>;&#125;f[x][<span class="hljs-number">1</span>]=a[sz[x]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=cnt+<span class="hljs-number">1</span>;k&lt;=sz[x];++k) f[x][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[x][<span class="hljs-number">1</span>],f[x][k]+a[k]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-keyword">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(deg[i]&gt;=<span class="hljs-number">2</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(deg[<span class="hljs-number">1</span>]!=<span class="hljs-number">1</span>&amp;&amp;fg) sub1::<span class="hljs-built_in">solve</span>(); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(deg[<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>&amp;&amp;fg) sub2::<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">else</span> bf::<span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu8231 沈阳大街 2 题解</title>
    <link href="/2022/lg8231-solution/"/>
    <url>/2022/lg8231-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>以下部分内容来自洛谷题解</p><span id="more"></span><p>把两个序列看成二分图，对于一个排列 <spanclass="math inline">\(p\)</span>，左面点 <spanclass="math inline">\(i\)</span> 和右面点 <spanclass="math inline">\(p_i\)</span>连一条边，这样就恰好形成一组完美匹配。</p><p>现在我们变成这样一个问题：<span class="math inline">\((i,j)\)</span>的边权是 <spanclass="math inline">\(\min(A_i,B_j)\)</span>，定义一个完美匹配权值是所有边权的积，你要求所有完美匹配权值之和。</p><p>这样还是不太好做，考虑两个序列都从大到小排序，然后把边定向，定义成点权较小的点向点权较大的点的有向边。</p><p>这样定向后就有一个性质：<strong>每个点的出边边权相同并且为这个点的点权，而且这些边指向的点为对面点一个前缀。</strong></p><p>设 <span class="math inline">\(f(i,j)\)</span> 为考虑 <spanclass="math inline">\([1,i]\)</span> 的匹配，匹配了 <spanclass="math inline">\(j\)</span> 个的值。</p><p>设 <span class="math inline">\(k\)</span> 为 <spanclass="math inline">\([1,i-1]\)</span> 中与 <spanclass="math inline">\(i\)</span> 在二分图中不在同一边的节点个数，<spanclass="math inline">\(c_i\)</span> 为 <spanclass="math inline">\(i\)</span> 的值。 <span class="math display">\[f(i,j) = f(i-1,j-1) \cdot c_i \cdot \big(k-(j-1)\big) + f(i-1,j)\]</span> 答案是 <span class="math inline">\(f(2n,n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, f[<span class="hljs-number">2</span>*N][N], sa[<span class="hljs-number">2</span>*N], sb[<span class="hljs-number">2</span>*N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IEE</span> &#123;</span><span class="hljs-keyword">int</span> q, val;&#125; a[<span class="hljs-number">2</span>*N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(IEE a,IEE b) &#123;<span class="hljs-keyword">if</span>(a.val!=b.val) <span class="hljs-keyword">return</span> a.val&gt;b.val;<span class="hljs-keyword">return</span> a.q&lt;b.q;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=(IEE)&#123;<span class="hljs-number">1</span>,<span class="hljs-built_in">read</span>()&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i+n]=(IEE)&#123;<span class="hljs-number">2</span>,<span class="hljs-built_in">read</span>()&#125;;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) sa[i]=sa[i<span class="hljs-number">-1</span>]+(a[i].q==<span class="hljs-number">1</span>), sb[i]=sb[i<span class="hljs-number">-1</span>]+(a[i].q==<span class="hljs-number">2</span>);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) &#123;<span class="hljs-keyword">int</span> lim=a[i].q==<span class="hljs-number">1</span>? sb[i]:sa[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-built_in">min</span>(n,i);++j) &#123;<span class="hljs-keyword">if</span>(j&amp;&amp;lim-j+<span class="hljs-number">1</span>&gt;<span class="hljs-number">0</span>) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]*a[i].val%mod*(lim-j+<span class="hljs-number">1</span>)%mod;(f[i][j]+=f[i<span class="hljs-number">-1</span>][j])%=mod;&#125;&#125;<span class="hljs-keyword">int</span> d=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) d=d*i%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">2</span>*n][n]*<span class="hljs-built_in">fp</span>(d,mod<span class="hljs-number">-2</span>)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题选讲3</title>
    <link href="/2022/tititi-solution-3/"/>
    <url>/2022/tititi-solution-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>杂题选讲 3</strong>.</p><span id="more"></span><h1 id="luogu2135-方块消除">luogu2135 方块消除</h1><h2 id="分析">分析</h2><p>把同颜色方块区域转化成同色方块相邻，排成一列。</p><p>发现是套路区间 DP。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span>，其中右侧有 <spanclass="math inline">\(k\)</span> 个和 <spanclass="math inline">\(j\)</span> 同色的东西。</p><p>设 <span class="math inline">\(c_i\)</span> 为 <spanclass="math inline">\(i\)</span> 的颜色，<spanclass="math inline">\(d_i\)</span> 为和 <spanclass="math inline">\(i\)</span> 颜色相同的方块数量。</p><p>一个显然的结论：同色方块会被同时删掉。</p><p>证明略。</p><p>这个结论可以把我们的状态中的 <spanclass="math inline">\([i,j]\)</span> 变成从第 <spanclass="math inline">\(i\)</span> 中颜色到第 <spanclass="math inline">\(j\)</span> 种颜色。</p><p>直接删去右边这一段 <span class="math display">\[f(i,j,k) = f(i,j-1,0) + (d_j + k) ^ 2\]</span> 套路性地枚举断点 <span class="math display">\[f(i,j,k) = \max_{l \in [1,r-1]} \{ f(i,l,d_j + k) + f(l+1,j-1,0) \}\]</span> 其中 <span class="math inline">\(c_l = c_j\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">55</span>;<span class="hljs-keyword">int</span> n, c[N], d[N], f[N][N][<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span> </span>&#123;<span class="hljs-keyword">int</span> rr=d[r]+p;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> rr*rr;<span class="hljs-keyword">if</span>(~f[l][r][rr]) <span class="hljs-keyword">return</span> f[l][r][rr];<span class="hljs-keyword">int</span>&amp; x=f[l][r][rr];x=<span class="hljs-built_in">dp</span>(l,r<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+rr*rr;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l;k&lt;r;++k) <span class="hljs-keyword">if</span>(c[k]==c[r]) &#123;x=<span class="hljs-built_in">max</span>(x,<span class="hljs-built_in">dp</span>(l,k,rr)+<span class="hljs-built_in">dp</span>(k+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>));&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) d[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>));&#125;</code></pre></div><h1 id="luogu6146-help-yourself">luogu6146 Help Yourself</h1><h2 id="分析-1">分析</h2><p>看到子集，显然统计贡献。</p><p>根据必修一的知识，我们知道对于一个元素 <spanclass="math inline">\(i\)</span>，它在全集的任意一个子集中，只有选和不选两种方案。</p><p>设 <span class="math inline">\(f_i\)</span> 为前 <spanclass="math inline">\(i\)</span> 条线段所产生的贡献。</p><p>不选 <spanclass="math inline">\(i\)</span>，那么不会产生任何贡献。</p><p>选 <span class="math inline">\(i\)</span>，那么如果存在 <spanclass="math inline">\(j\)</span>，满足 <span class="math inline">\(r_j&lt; l_i\)</span>，那么 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span> 必然不连通。设这样的 <spanclass="math inline">\(j\)</span> 的数量为 <spanclass="math inline">\(x\)</span>，那么贡献为 <spanclass="math inline">\(2^x\)</span>。</p><p>那么 <span class="math display">\[f_i = f_{i-1} + f_{i-1} + 2^x\]</span> 简单维护线段右端点的信息即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, f[N], c[<span class="hljs-number">2</span>*N];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r second</span>pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; a[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i].l=<span class="hljs-built_in">read</span>(), a[i].r=<span class="hljs-built_in">read</span>(), ++c[a[i].r];<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) c[i]+=c[i<span class="hljs-number">-1</span>];f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]%mod+<span class="hljs-built_in">fp</span>(<span class="hljs-number">2</span>,c[a[i].l<span class="hljs-number">-1</span>]))%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div><h1 id="luogu6733-间歇泉">luogu6733 间歇泉</h1><h2 id="分析-2">分析</h2><p>考虑二分第 <span class="math inline">\(k\)</span> 大的温度 <spanclass="math inline">\(T\)</span>。</p><p>问题转化为求满足下面式子的 <span class="math inline">\((i,j)\)</span>的个数是否大于等于 <span class="math inline">\(k\)</span>。 <spanclass="math display">\[T \le \frac{a_i c_i + a_j c_j}{a_i + a_j}\]</span> 把式子拆开 <span class="math display">\[a_iT + a_j T \le a_i c_i + a_j c_j\]</span></p><p><span class="math display">\[a_i c_i - a_i T \ge a_j T - a_j c_j\]</span></p><p>发现这些变量的数量是 <span class="math inline">\(O(n)\)</span>级别的。</p><p>求出对于每个 <span class="math inline">\(i\)</span>，满足条件的 <spanclass="math inline">\(j\)</span> 的数量即可。</p><p>排序后双指针。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-5</span>;<span class="hljs-keyword">int</span> n, k, a[N], c[N];<span class="hljs-keyword">double</span> p[N], q[N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">double</span> u=<span class="hljs-number">1.0</span>*a[i]*c[i], v=x*a[i];p[i]=u-v, q[i]=v-u;<span class="hljs-keyword">if</span>(q[i]-p[i]&lt;eps) --cnt;        <span class="hljs-comment">// 如果相等了，那么只能算1个</span>&#125;<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>((q[j+<span class="hljs-number">1</span>]-p[i])&lt;eps&amp;&amp;j+<span class="hljs-number">1</span>&lt;=n) ++j;cnt+=j;&#125;<span class="hljs-keyword">return</span> (cnt/<span class="hljs-number">2</span>&lt;k);    <span class="hljs-comment">// 数对是无序的，所以要/2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">double</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">1e9</span>;<span class="hljs-keyword">while</span>(r-l&gt;eps) &#123;<span class="hljs-keyword">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf\n&quot;</span>,l);&#125;</code></pre></div><h1 id="luogu8161-自学-self-study">luogu8161 自学 (Self Study)</h1><h2 id="分析-3">分析</h2><p>二分答案 <span class="math inline">\(x\)</span>。</p><p>如果某个科目，自学的收益完全大于上课，那么直接全部自学。</p><p>否则如果上满 <span class="math inline">\(m\)</span> 节课能够到达<span class="math inline">\(x\)</span>，那么就上课。</p><p>否则就自学。</p><p>维护一个总共需要的课程数量，如果大于 <spanclass="math inline">\(nm\)</span>，那么无解。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, a[N], b[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x+y<span class="hljs-number">-1</span>)/y; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> nd=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&lt;b[i]) nd+=<span class="hljs-built_in">cil</span>(x,b[i]);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(a[i]*m&gt;=x) nd+=<span class="hljs-built_in">cil</span>(x,a[i]);<span class="hljs-keyword">else</span> nd+=m+<span class="hljs-built_in">cil</span>(x-a[i]*m,b[i]);&#125;<span class="hljs-keyword">if</span>(nd&gt;n*m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1000000000000000010</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div><h1 id="luogu8359-垃圾回收">luogu8359 垃圾回收</h1><p>删边转化倒序加边，并查集维护连通块。</p><p>没啥可说的，实现注意细节。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">4e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, q, cnt, fa[N], w[N], r[N], alive[N];<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;string str;<span class="hljs-keyword">bool</span> v[N], vis[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> x, y; &#125; e[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pp</span> &#123;</span> <span class="hljs-keyword">int</span> op, x; &#125; p[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);x=<span class="hljs-built_in">get</span>(x),  y=<span class="hljs-built_in">get</span>(y);fa[x]=y;    <span class="hljs-comment">// 加边也是合并</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(vis[x]) <span class="hljs-keyword">return</span>;vis[x]=<span class="hljs-number">1</span>;r[++cnt]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-built_in">dfs</span>(y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<span class="hljs-built_in">dfs</span>(x);    <span class="hljs-comment">// 找出x所在连通块的所有点</span>&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) e[i].x=<span class="hljs-built_in">read</span>(), e[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;cin&gt;&gt;str;<span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;GC&quot;</span>) p[i].op=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> p[i].op=<span class="hljs-number">1</span>, p[i].x=<span class="hljs-built_in">read</span>(), v[p[i].x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) w[i]=<span class="hljs-built_in">read</span>(), fa[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!v[i]) <span class="hljs-built_in">addedge</span>(e[i].x,e[i].y);    <span class="hljs-comment">// 没有被删去的边</span><span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i) alive[r[i]]=q+<span class="hljs-number">1</span>;    <span class="hljs-comment">// q+1时刻被删去的点</span><span class="hljs-keyword">int</span> lst=q+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=q;i;--i) &#123;<span class="hljs-keyword">if</span>(p[i].op==<span class="hljs-number">2</span>) lst=i;        <span class="hljs-comment">// 维护上一次删点的时刻</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> x=e[p[i].x].x, y=e[p[i].x].y;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">get</span>(x)) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)==<span class="hljs-built_in">get</span>(x)&amp;&amp;<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">get</span>(y)) &#123;<span class="hljs-built_in">find</span>(y);                <span class="hljs-comment">// y被合并，y所在连通块要等到(x,y)被删掉之后的lst时间才会被删除</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;++j) alive[r[j]]=lst;&#125;<span class="hljs-built_in">addedge</span>(x,y);&#125;&#125;<span class="hljs-keyword">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) <span class="hljs-keyword">if</span>(p[i].op==<span class="hljs-number">2</span>) &#123;fg=i;<span class="hljs-keyword">break</span>;&#125;    <span class="hljs-comment">// 这些点从始至终和1不连通</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>)!=<span class="hljs-built_in">get</span>(i)) alive[i]=fg;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=w[i]*alive[i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="luogu6394-樱花还有你">luogu6394 樱花，还有你</h1><p>过于套路了。。。</p><p>放个代码就完了。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e3</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">10086001</span>;<span class="hljs-keyword">int</span> n, k, sum, ans, a[N], s[N], f[N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) a[i]=<span class="hljs-built_in">read</span>(), sum+=a[i];<span class="hljs-keyword">if</span>(sum&lt;n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=a[<span class="hljs-number">1</span>];++i) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]&gt;=n) ++ans;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(j&gt;a[i]) (f[j]=s[j]-s[j-a[i]<span class="hljs-number">-1</span>]+mod)%=mod;<span class="hljs-keyword">else</span> f[j]=s[j];&#125;s[<span class="hljs-number">0</span>]=f[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) s[j]=(s[j<span class="hljs-number">-1</span>]+f[j])%mod;(ans+=f[n])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="luogu8365-吃">luogu8365 吃</h1><h2 id="分析-4">分析</h2><p>显然加法在乘法前面。</p><p>如果 <span class="math inline">\(a_i = 1\)</span>，那么必然选择加上<span class="math inline">\(b_i\)</span>。</p><p>注意到除了上述情况，加法最多进行 <spanclass="math inline">\(1\)</span> 次。</p><blockquote><p>证明：</p><p>我们的目的是最大化体重。</p><p>假如第一次加了 <span class="math inline">\(b_i\)</span>，第二次加了<span class="math inline">\(b_j\)</span>，钦定 <spanclass="math inline">\(b_i \le b_j\)</span>，那么收益为 <spanclass="math inline">\(b_i + b_j\)</span>。而此时所有的 <spanclass="math inline">\(a_i \neq 1\)</span>，所以选择乘上 <spanclass="math inline">\(a_j\)</span> 的收益至少是 <spanclass="math inline">\(2b_i\)</span>，显然不劣于 <spanclass="math inline">\(b_i + b_j\)</span>。</p><p>证毕。</p></blockquote><p>直接挑最大的加上显然是错的。</p><p>考虑从 <span class="math inline">\(j\)</span> 做加法的收益 <spanclass="math inline">\(d + \frac{\prod_{i=1}^n a_i}{a_j} +b_j\)</span>。其中 <span class="math inline">\(d\)</span> 为满足 <spanclass="math inline">\(a_i = 1\)</span> 的 <spanclass="math inline">\(b_i\)</span> 之和。</p><p>注意到分子会爆，但是又不能取模。考虑我们只关心相对大小，那么直接判断<span class="math inline">\(\frac{d+b_j}{a_j}\)</span> 的大小即可。</p><p>然后就做完了。</p><h2 id="code-6">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, d=<span class="hljs-number">1</span>;<span class="hljs-keyword">bool</span> v[N];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span>PII a[N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i].x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i].x==<span class="hljs-number">1</span>) d+=a[i].y, v[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">double</span> w=d;<span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">double</span> dlt=<span class="hljs-number">1.0</span>*(d+a[i].y)/a[i].x;<span class="hljs-keyword">if</span>(dlt&gt;w) w=dlt, p=i;&#125;(d+=a[p].y)%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]&amp;&amp;i!=p) (d*=a[i].x)%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d);&#125;</code></pre></div><h1 id="luogu8552-rabbit">luogu8552 Rabbit</h1><h2 id="分析-5">分析</h2><p>直接没有原则地选点是很盲目的。</p><p>注意到如果某个点是全局最大点，那么它与任意两点相连，都能构成一次合法的操作。</p><p>考虑这样一个事实：连通块信息是很好维护的。</p><p>把上面两点看作两个独立的连通块，从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 枚举最大点，用并查集维护即可。</p><p>容易证明所有合法操作都能转化成上述形式，且不重不漏。</p><p>对于边 <span class="math inline">\((x,y)\)</span>，连边 <spanclass="math inline">\(\big(\max(x,y),\min(x,y)\big)\)</span>。按照节点编号从 <span class="math inline">\(1\)</span> 到<span class="math inline">\(n\)</span>加边，用并查集维护上述关系即可。</p><h2 id="code-7">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, ans, fa[N], remain[N];<span class="hljs-keyword">int</span> tot, h[N], to[N], nxt[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-number">0</span>, fa[i]=i, remain[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(<span class="hljs-built_in">max</span>(x,y),<span class="hljs-built_in">min</span>(x,y));&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=<span class="hljs-built_in">get</span>(to[i]);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(remain[y]) ++cnt;remain[x]+=remain[y];            <span class="hljs-comment">// remain[x]是x所在连通块内没有被标记的点的数量</span>fa[y]=x;&#125;<span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">2</span>) remain[x]-=<span class="hljs-number">3</span>, ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>贪心</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF402D Upgrading Array 题解</title>
    <link href="/2022/cf402d-solution/"/>
    <url>/2022/cf402d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>注意到 <span class="math inline">\(f\)</span>的过程就是唯一分解的过程。</p><span id="more"></span><p>考虑 <span class="math inline">\(g = \gcd\{a_{1 \simi}\}\)</span>，发现除去 <span class="math inline">\(g\)</span>之后，相当于原来的总和减去 <spanclass="math inline">\(f(g)\)</span>，贡献为 <spanclass="math inline">\(i \times -f(g)\)</span>。</p><p>设 <span class="math inline">\(F(i)\)</span> 为以 <spanclass="math inline">\(i\)</span> 结尾的前缀，能够产生的最大贡献。</p><p>由于可以进行多次，所以可能在让 <span class="math inline">\(a_{1 \simi}\)</span> 除去 <span class="math inline">\(g\)</span>之前，其中某些数已经被修改过了，所以枚举 <span class="math inline">\(j\in [1,i-1]\)</span>，表示前缀 <spanclass="math inline">\([1,j]\)</span> 中已经没有了 <spanclass="math inline">\(g\)</span> 这个因子，因此 <spanclass="math display">\[F(i) = \min_{j \in [0,i-1]} \{ F(j) + (i-j) \times - f(g) \}\]</span> 通过操作产生的最大贡献为 <spanclass="math inline">\(F_{\max}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, dlt, ans, a[N], f[N];<span class="hljs-keyword">int</span> cnt, v[N], p[N];unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt; bad;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=<span class="hljs-number">1e5</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;p[i]*p[i]&lt;=x;++i) <span class="hljs-keyword">if</span>(x%p[i]==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%p[i]==<span class="hljs-number">0</span>) x/=p[i], ++tot;d+=bad[p[i]]? -tot:tot;&#125;<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">1</span>) d+=bad[x]? <span class="hljs-number">-1</span>:<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">ora</span>();n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) bad[<span class="hljs-built_in">read</span>()]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) dlt+=<span class="hljs-built_in">F</span>(a[i]);<span class="hljs-keyword">int</span> g=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;g=<span class="hljs-built_in">gcd</span>(g,a[i]);<span class="hljs-keyword">int</span> d=<span class="hljs-built_in">F</span>(g);f[i]=i*(-d);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) f[i]=<span class="hljs-built_in">max</span>(f[i],f[j]+(i-j)*(-d));ans=<span class="hljs-built_in">max</span>(ans,f[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dlt+ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF847E Packmen 题解</title>
    <link href="/2022/cf847e-solution/"/>
    <url>/2022/cf847e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>最小化时间，可以考虑二分答案。</p><span id="more"></span><p>考虑将 Packmen 和物品的位置划分的成两个集合。由于 Packmen之间互不影响，所以只要分别贪心就好了。</p><p>不难想到，每个人去走的物品一定是连续的。</p><p>对于一个位置为 <span class="math inline">\(p_i\)</span> 的人 <spanclass="math inline">\(i\)</span> 和一个物品区间 <spanclass="math inline">\([l,r]\)</span>，能够在时间限制 <spanclass="math inline">\(x\)</span> 内完成，当且仅当 <spanclass="math inline">\(\Big( \min(|p_i - l|,|p_i - r|) + |r-l| \Big) \lex\)</span>。</p><p>维护 <span class="math inline">\(l\)</span> 和 <spanclass="math inline">\(r\)</span> 集合，<code>check</code>的复杂度是<span class="math inline">\(O(n)\)</span> 的。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">char</span> s[N];vector&lt;<span class="hljs-keyword">int</span>&gt; a, b;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">can</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> t)</span> </span>&#123;<span class="hljs-keyword">int</span> d=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(p-l),<span class="hljs-built_in">abs</span>(p-r))+<span class="hljs-built_in">abs</span>(r-l);<span class="hljs-keyword">return</span> d&lt;=t;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i) &#123;r=l;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;r&lt;b.<span class="hljs-built_in">size</span>()&amp;&amp;<span class="hljs-built_in">can</span>(a[i],b[l],b[r],x)) ++r;l=r;&#125;<span class="hljs-keyword">return</span> l==b.<span class="hljs-built_in">size</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;*&#x27;</span>) b.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;P&#x27;</span>) a.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">5</span>*n;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1067A Array Without Local Maximums 题解</title>
    <link href="/2022/cf1067a-solution/"/>
    <url>/2022/cf1067a-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>套路题。</p><span id="more"></span><p>注意到值域是 <span class="math inline">\(200\)</span>。</p><p>设 <span class="math inline">\(f(i,j,0/1)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 位，第 <spanclass="math inline">\(i\)</span> 位放 <spanclass="math inline">\(j\)</span>，大于或小于等于第 <spanclass="math inline">\(i-1\)</span> 位的方案数。</p><p>可以钦定第 <span class="math inline">\(1\)</span> 位大于第 <spanclass="math inline">\(0\)</span> 位，第 <spanclass="math inline">\(n\)</span> 位小于等于第 <spanclass="math inline">\(n-1\)</span> 位。</p><p>转移 <span class="math display">\[f(i,j,0) = \sum_{k=1}^{j-1} \Big( f(i-1,k,0) + f(i-1,k,1) \Big)\]</span> 不管 <span class="math inline">\(k\)</span> 和 <spanclass="math inline">\(a_{i-2}\)</span> 的关系如何，都一定满足条件。<span class="math display">\[f(i,j,1) = \sum_{k=j}^{200} \Big( f(i-1,k,1) \Big) + f(i-1,j,0)\]</span> 当 <span class="math inline">\(a_{i-1} = j\)</span> 时，<spanclass="math inline">\(a_{i-2}\)</span>无论是多少都能满足条件，否则必须保证 <span class="math inline">\(a_{i-2}\ge a_{i-1}\)</span>。</p><p>当 <span class="math inline">\(a_i \neq -1\)</span>的时候，只要在转移稍加限制即可。</p><p>前缀和优化一下就过了，复杂度 <spanclass="math inline">\(O(200n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, a[N], f[N][<span class="hljs-number">205</span>][<span class="hljs-number">2</span>], s[N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>) f[<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, s[a[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i) f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, s[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i) s[i][<span class="hljs-number">0</span>]+=s[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">// for(int k=1;k&lt;a[i];++k) (f[i][a[i]][0]+=(f[i-1][k][0]+f[i-1][k][1])%mod)%=mod;</span><span class="hljs-comment">// for(int k=a[i];k&lt;=200;++k) (f[i][a[i]][1]+=f[i-1][k][1])%=mod;</span>f[i][a[i]][<span class="hljs-number">0</span>]=(s[a[i]<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+s[a[i]<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])%mod;f[i][a[i]][<span class="hljs-number">1</span>]=(s[<span class="hljs-number">200</span>][<span class="hljs-number">1</span>]-s[a[i]<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+mod)%mod;(f[i][a[i]][<span class="hljs-number">1</span>]+=f[i<span class="hljs-number">-1</span>][a[i]][<span class="hljs-number">0</span>])%=mod;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">200</span>;++j) &#123;f[i][j][<span class="hljs-number">0</span>]=(s[j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+s[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])%mod;f[i][j][<span class="hljs-number">1</span>]=(s[<span class="hljs-number">200</span>][<span class="hljs-number">1</span>]-s[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+mod)%mod;(f[i][j][<span class="hljs-number">1</span>]+=f[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>])%=mod;<span class="hljs-comment">// for(int k=1;k&lt;j;++k) &#123;</span><span class="hljs-comment">// (f[i][j][0]+=(f[i-1][k][0]+f[i-1][k][1])%mod)%=mod;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// for(int k=j;k&lt;=200;++k) &#123;</span><span class="hljs-comment">// (f[i][j][1]+=f[i-1][k][1])%=mod;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// (f[i][j][1]+=f[i-1][j][0])%=mod;</span>&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">200</span>;++j) &#123;s[j][<span class="hljs-number">0</span>]=(s[j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+f[i][j][<span class="hljs-number">0</span>])%mod;s[j][<span class="hljs-number">1</span>]=(s[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+f[i][j][<span class="hljs-number">1</span>])%mod;&#125;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a[n]!=<span class="hljs-number">-1</span>) ans=f[n][a[n]][<span class="hljs-number">1</span>];<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i) (ans+=f[n][i][<span class="hljs-number">1</span>])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1312E Array Shrinking 题解</title>
    <link href="/2022/cf1312e-solution/"/>
    <url>/2022/cf1312e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>挺有启发意义的题目。</p><span id="more"></span><p>第一眼看上去像一个套路的区间 DP，但是区间想要合并必须满足值相等。</p><p>考虑设 <span class="math inline">\(g(i,j)\)</span> 为区间 <spanclass="math inline">\([i,j]\)</span> 最终合并成的值，如果不能合并为<span class="math inline">\(1\)</span> 个元素，那么为 <spanclass="math inline">\(-1\)</span>。</p><p>设 <span class="math inline">\(f(i)\)</span> 为以 <spanclass="math inline">\(i\)</span> 结尾的序列，能够划分的最短长度。 <spanclass="math display">\[f(i) = \min_{g(j,i) &gt; 0}\{ f(j-1) + 1\}\]</span> <span class="math inline">\(j\)</span> 实际上是个断点。</p><p>而 <span class="math inline">\(g(i,j)\)</span> 可以用类似于区间 DP的方式实现。</p><p>线性 DP 套一个区间 DP。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>;<span class="hljs-keyword">int</span> n, a[N], f[N], g[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123;<span class="hljs-keyword">if</span>(g[i][j]) <span class="hljs-keyword">return</span> g[i][j];<span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">return</span> g[i][j]=a[i];<span class="hljs-keyword">int</span>&amp; x=g[i][j];x=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;j;++k) &#123;<span class="hljs-keyword">int</span> p=<span class="hljs-built_in">dp</span>(i,k), q=<span class="hljs-built_in">dp</span>(k+<span class="hljs-number">1</span>,j);<span class="hljs-keyword">if</span>(p&gt;<span class="hljs-number">0</span>&amp;&amp;p==q) <span class="hljs-keyword">return</span> x=p+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dp</span>(j,i)&gt;<span class="hljs-number">0</span>) f[i]=<span class="hljs-built_in">min</span>(f[i],f[j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<span class="hljs-comment">// printf(&quot;kkk=[%lld,%lld]\n&quot;,i,j);</span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF845C Two TVs 题解</title>
    <link href="/2022/cf845c-solution/"/>
    <url>/2022/cf845c-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>离散化，然后如果某个时间同时存在至少 <spanclass="math inline">\(3\)</span> 个未结束的节目，那么无解。</p><p>差分即可。</p><span id="more"></span><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, c[<span class="hljs-number">2</span>*N], d[<span class="hljs-number">2</span>*N];pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;p[i].x=<span class="hljs-built_in">read</span>(), p[i].y=<span class="hljs-built_in">read</span>();c[++m]=p[i].x, c[++m]=p[i].y;&#125;<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>)-c<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;p[i].x=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>,p[i].x)-c;p[i].y=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+m+<span class="hljs-number">1</span>,p[i].y)-c;&#125;<span class="hljs-comment">// sort(p+1,p+n+1);</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;++d[p[i].x], --d[p[i].y+<span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">int</span> cc=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;cc+=d[i];<span class="hljs-keyword">if</span>(cc&gt;=<span class="hljs-number">3</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3594 WIL 题解</title>
    <link href="/2022/lg3594-solution/"/>
    <url>/2022/lg3594-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>显然，置零的区间长度一定为 <spanclass="math inline">\(d\)</span>，否则一定不优。</p><p>那么答案大于等于 <span class="math inline">\(d\)</span>。</p><span id="more"></span><p>暴力做法，枚举左右端点 <spanclass="math inline">\([i,j]\)</span>，贪心地减去区间里长度为 <spanclass="math inline">\(d\)</span> 的最大的一块，用前缀和搞一下，<spanclass="math inline">\(O(n^3)\)</span>。</p><p>考虑一个双指针做法，固定左端点 <spanclass="math inline">\(i\)</span>，贪心地让右端点在 <spanclass="math inline">\([i+d,n]\)</span> 中增长，维护区间内最大的长度为<span class="math inline">\(d\)</span> 的块。如果区间和大于 <spanclass="math inline">\(p\)</span> 了，那么看减去最大块之后是否合法，<spanclass="math inline">\(O(n^2)\)</span>。</p><p>考虑优化这个做法。</p><p>不难发现对于每个固定 <span class="math inline">\(i\)</span> 找 <spanclass="math inline">\(j\)</span>的过程，都要维护区间最大块，但是很多是重复的。反过来，固定右端点，维护最靠前的合法左端点，这个过程是个滑动窗口。而要维护的区间最大块，在这个过程中也是一个滑动窗口。</p><p>用单调队列维护当前 <span class="math inline">\([i,j]\)</span>区间最大块即可，复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, p, d, ans, a[N], s[N], q[N], c[N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), p=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=d;i&lt;=n;++i) c[i]=s[i]-s[i-d];     <span class="hljs-comment">// c[i]表示以i结尾的，长度为d的块的和</span><span class="hljs-keyword">int</span> w=s[d];<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;q[l]=d;ans=d;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=d+<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-comment">// 这里写的是[j,i]</span>w+=a[i];<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;c[q[r]]&lt;=c[i]) --r;q[++r]=i;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;(w-c[q[l]])&gt;p) &#123;            <span class="hljs-comment">// 当前区间和减去最大块也不能满足</span><span class="hljs-keyword">if</span>(q[l]&lt;j+d) ++l;            <span class="hljs-comment">// q[l]&lt;j+d时，q[l]才非法</span>w-=a[j++];            <span class="hljs-comment">// 这个j就不可能作为左端点了</span>        &#125;ans=<span class="hljs-built_in">max</span>(ans,i-j+<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调队列</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Edu Codeforces Round」#134</title>
    <link href="/2022/cf1721-solution/"/>
    <url>/2022/cf1721-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1721</strong>.</p><span id="more"></span><h1 id="a.-image">A. Image</h1><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string a, b;cin&gt;&gt;a&gt;&gt;b;a+=b;<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:a) <span class="hljs-keyword">if</span>(++c[x-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>) ++ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-deadly-laser">B. Deadly Laser</h1><h2 id="分析">分析</h2><p>最优解一定是 <span class="math inline">\((1,1) \rightarrow (1,m)\rightarrow (n,m)\)</span> 或者 <span class="math inline">\((1,1)\rightarrow (n,1) \rightarrow (n,m)\)</span>。</p><p>前者距离 <span class="math inline">\((s_x,s_y)\)</span> 最近的距离是<span class="math inline">\(\min(s_x-1,m-s_y)\)</span>，后者是 <spanclass="math inline">\(\min(s_y-1,n-s_x)\)</span>。</p><p>如果二者都小于等于 <spanclass="math inline">\(d\)</span>，那么无解。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n, m, x, y, d;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(x<span class="hljs-number">-1</span>,m-y)&lt;=d&amp;&amp;<span class="hljs-built_in">min</span>(y<span class="hljs-number">-1</span>,n-x)&lt;=d) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n+m<span class="hljs-number">-2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-min-max-array-transformation">C. Min-Max ArrayTransformation</h1><h2 id="分析-1">分析</h2><p>对于 <span class="math inline">\(a_i\)</span>，<spanclass="math inline">\(d_i\)</span> 最小值显然是大于 <spanclass="math inline">\(a_i\)</span> 的最小的 <spanclass="math inline">\(b_i\)</span> 与它的差。</p><p>最大值则要复杂一些。例如样例 4 中，如果 <spanclass="math inline">\(d_1\)</span> 取 <spanclass="math inline">\(45\)</span>，那么 <spanclass="math inline">\(40\)</span>就没有合法决策了。而其它的数字，无论怎么选，都一定存在合法决策，贪心地取了最大的<span class="math inline">\(33\)</span>。</p><p>由于 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span> 都是有序的，所以从 <spanclass="math inline">\(n\)</span> 到 <spanclass="math inline">\(1\)</span> 考虑。<spanclass="math inline">\(40\)</span> 只能变成 <spanclass="math inline">\(55\)</span> 是因为前面所有的 <spanclass="math inline">\(b_i\)</span> 都小于 <spanclass="math inline">\(40\)</span>，而后面的数的决策区间也因此不包含<span class="math inline">\(55\)</span>。</p><p>维护最大值决策 <span class="math inline">\(j\)</span>，初始化为 <spanclass="math inline">\(n\)</span>，显然 <spanclass="math inline">\(j\)</span> 是单调不增的。对于 <spanclass="math inline">\(a_i\)</span>，当 <span class="math inline">\(b_1\sim b_{i-1}\)</span> 都小于 <span class="math inline">\(a_i\)</span>时，<span class="math inline">\([1,i-1]\)</span> 必然不能取 <spanclass="math inline">\(j \in[i,n]\)</span>，否则由于数字是一一对应的，<spanclass="math inline">\(a_i\)</span> 将无法决策。所以只要第一个大于等于<span class="math inline">\(a_i\)</span> 的是 <spanclass="math inline">\(b_i\)</span> 的话，那么令 <spanclass="math inline">\(j = i-1\)</span>，否则 <spanclass="math inline">\(d_i = b_j - a_i\)</span> 一定是最大决策。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N], b[N], d1[N], d2[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> j=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) &#123;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>,a[i])-b;d1[i]=b[k]-a[i];d2[i]=b[j]-a[i];<span class="hljs-keyword">if</span>(k==i) j=i<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,d1[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,d2[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-maximum-and">D. Maximum AND</h1><h2 id="分析-2">分析</h2><p>按位贪心。</p><p>答案的某一位是 <span class="math inline">\(1\)</span>，说明每个 <spanclass="math inline">\(c_i\)</span> 的这一位都是 <spanclass="math inline">\(1\)</span>，因此对于这一位，<spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 中必须存在两两对应的 <spanclass="math inline">\(n\)</span> 对 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 才行。</p><p>直接处理复杂度过高。</p><p>假设当前处理到了第 <span class="math inline">\(k\)</span>位，如果答案第 <span class="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>，那么在满足存在两两对应的 <spanclass="math inline">\(n\)</span> 对 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>之外，还要满足之前的位仍然不变，否则一定不优。</p><p>设答案为 <span class="math inline">\(d\)</span>，先让 <spanclass="math inline">\(d+2^k\)</span>，尝试将配对。<spanclass="math inline">\(a_i \&amp; d\)</span> 表示 <spanclass="math inline">\(a_i\)</span> 在此时 <spanclass="math inline">\(d\)</span> 中的有效位，<spanclass="math inline">\(b_i \&amp; d \oplus d\)</span> 表示 <spanclass="math inline">\(b_i\)</span> 的有效位关于 <spanclass="math inline">\(d\)</span> 的补集，如果它和某个 <spanclass="math inline">\(a_j \&amp; d\)</span> 相等，说明二者异或起来为<span class="math inline">\(d\)</span>，进而 <spanclass="math inline">\(a_j \oplus b_i\)</span> 一定满足第 <spanclass="math inline">\(k\)</span> 位位为 <spanclass="math inline">\(1\)</span> 和之前的所有条件。</p><p>使用<code>std::map</code>统计是否能够两两配对即可。</p><p>时间复杂度 <span class="math inline">\(O(n \log^2_2 n)\)</span>。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, d, a[N], b[N];map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">29</span>;~k;--k) &#123;d|=<span class="hljs-number">1</span>&lt;&lt;k;p.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;++p[a[i]&amp;d];--p[(b[i]&amp;d)^d];&#125;<span class="hljs-keyword">bool</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(p[a[i]&amp;d]!=<span class="hljs-number">0</span>) &#123; d^=<span class="hljs-number">1</span>&lt;&lt;k; <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NowCoder Round X」#56</title>
    <link href="/2022/nxc56-solution/"/>
    <url>/2022/nxc56-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>NowCoderX56</strong>.</p><p>水。</p><span id="more"></span><h1 id="a.-阿宁的柠檬">A. 阿宁的柠檬</h1><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> n, a, b;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,n,(a+b)*n);&#125;</code></pre></div><h1 id="b.-阿宁与猫咪">B. 阿宁与猫咪</h1><p>注意到全部填 <span class="math inline">\(1\)</span>时，烦躁值不会超过 <span class="math inline">\(2\)</span>。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> m;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);&#125;</code></pre></div><h1 id="c.-阿宁吃粽子">C. 阿宁吃粽子</h1><p>贪心地将最小值放在 <span class="math inline">\(2^0\)</span>的位置，次小值放在 <span class="math inline">\(2^1\)</span> 的位置。</p><p>注意第一个 <span class="math inline">\(2^0\)</span> 的位置是 <spanclass="math inline">\(a_{10}\)</span>。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, a[N], ans[N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">9</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;i&lt;=n;i+=<span class="hljs-number">10</span>) ans[i]=a[pos++];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;i+j&lt;=n;j+=<span class="hljs-number">10</span>) ans[i+j]=a[pos++];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div><h1 id="d.-阿宁的质数">D. 阿宁的质数</h1><h2 id="分析">分析</h2><p>做法很显然，但是筛不出值域那么大的一张质数表。</p><p>注意到对于 <span class="math inline">\(x = 1,2,3\ldots\)</span>，答案单调不减，且答案一定为质数。也就是最大为第 <spanclass="math inline">\(2 \times 10^5\)</span> 个质数。不难发现线性筛<span class="math inline">\([2,3.5 \times 10^6]\)</span>这个区间就行了。</p><p>然后瞎搞，预处理每个前缀的答案，用<code>std::unordered_map</code>实现的话，复杂度是<span class="math inline">\(O(n)\)</span> 的。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">3e6</span>+<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m, q, a[N], r[N], p[M];<span class="hljs-keyword">bool</span> v[M];unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt; st;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">3e6</span>+<span class="hljs-number">5e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++m]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m&amp;&amp;i*p[j]&lt;=<span class="hljs-number">3e6</span>+<span class="hljs-number">5e5</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]==p[pos]) &#123;++pos;<span class="hljs-keyword">while</span>(st[p[pos]]) ++pos;r[i]=p[pos];&#125; <span class="hljs-keyword">else</span> r[i]=p[pos];st[a[i]]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,r[x]);&#125;&#125;</code></pre></div><h1 id="e.-阿宁睡大觉">E. 阿宁睡大觉</h1><h2 id="分析-1">分析</h2><p>只有完全删去夹在两个<code>Z</code>中间的<code>z</code>才会产生 <spanclass="math inline">\(4\)</span> 的贡献。</p><p>贪心地删去夹在两个<code>Z</code>中间的，长度更短的若干个<code>z</code>。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, k, ans;<span class="hljs-keyword">char</span> s[N];vector&lt;<span class="hljs-keyword">int</span>&gt; rec;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=n;<span class="hljs-keyword">while</span>(s[l]==<span class="hljs-string">&#x27;z&#x27;</span>&amp;&amp;l&lt;=n) ++l;<span class="hljs-keyword">while</span>(s[r]==<span class="hljs-string">&#x27;z&#x27;</span>&amp;&amp;r) --r;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> j=i;<span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=r&amp;&amp;s[j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;Z&#x27;</span>) ++j;ans+=<span class="hljs-number">4</span>*(j-i);        <span class="hljs-comment">// [i,j]全部为Z</span>        ++j;        <span class="hljs-keyword">int</span> d=j;        <span class="hljs-keyword">if</span>(j&gt;r) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=r&amp;&amp;s[j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;z&#x27;</span>) ++j;rec.<span class="hljs-built_in">push_back</span>(j-d+<span class="hljs-number">1</span>);        <span class="hljs-comment">// [d,j]全部为z，且删去这部分的代价为j-d+1</span>i=j;&#125;<span class="hljs-built_in">sort</span>(rec.<span class="hljs-built_in">begin</span>(),rec.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 贪心删去代价小的</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:rec) &#123;<span class="hljs-keyword">if</span>(k&gt;=x) ans+=<span class="hljs-number">4</span>, k-=x;<span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="f.-阿宁去游玩">F. 阿宁去游玩</h1><h2 id="分析-2">分析</h2><p>注意到使用膜法对后续操作完全没有限制，那么对于每对点 <spanclass="math inline">\((x,y)\)</span>，都能找到一个花费最小的方案。</p><p>然后跑最短路即可。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, X, Y, Z, a[N], d[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N], w[<span class="hljs-number">2</span>*N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), X=<span class="hljs-built_in">read</span>(), Y=<span class="hljs-built_in">read</span>(), Z=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">auto</span> f=[&amp;](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) &#123;<span class="hljs-keyword">return</span> a[x]==a[y]? <span class="hljs-built_in">min</span>(X,Y+Z):<span class="hljs-built_in">min</span>(Y,X+Z);&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y,<span class="hljs-built_in">f</span>(x,y));&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>贪心</tag>
      
      <tag>最短路</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NowCoder Round X」#55</title>
    <link href="/2022/ncx55-solution/"/>
    <url>/2022/ncx55-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>NowCoderX55</strong>.</p><span id="more"></span><h1 id="a.-至至子的等差中项">A. 至至子的等差中项</h1><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> a, b;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">2</span>*b-a);&#125;</code></pre></div><h1 id="b.-至至子的按位与">B. 至至子的按位与</h1><p>从高位往低位贪心即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> a, b;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">62</span>;~i;--i) &#123;<span class="hljs-keyword">int</span> x=(a&gt;&gt;i)&amp;<span class="hljs-number">1</span>, y=(b&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x==y) c|=<span class="hljs-number">1ll</span>&lt;&lt;i;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,c);&#125;</code></pre></div><h1 id="c.-至至子的斐波那契">C. 至至子的斐波那契</h1><p>注意到 <span class="math inline">\(fib_{92}\)</span>是范围内最大的一项。二分查找即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> T, R, f[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">92</span>, k=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(f[mid]&lt;=x) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;k=l;<span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">abs</span>(f[k]-x)&lt;=<span class="hljs-built_in">abs</span>(f[k+<span class="hljs-number">1</span>]-x)? k:k+<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">1</span>]=f[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">92</span>;++i) f[i]=f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>];T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-至至子的鸿门宴">D. 至至子的鸿门宴</h1><h2 id="分析">分析</h2><p>由于双方足够聪明，所以最终的局面一定是 <spanclass="math inline">\(a_1 = 1,a_2 = 2 , \ldots a_n = n\)</span>。</p><p>所以判断总操作数 <span class="math inline">\(\sum_{i=1}^n (a_i -i)\)</span> 的奇偶性即可。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=<span class="hljs-built_in">read</span>()-i;<span class="hljs-keyword">if</span>(ans&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ZZZ&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;SSZ&quot;</span>);&#125;</code></pre></div><h1 id="e.-至至子的长链剖分">E. 至至子的长链剖分</h1><h2 id="分析-1">分析</h2><p>树根一定是最大值，如果最大值不唯一，那么一定无解。</p><p>显然最终值为 <span class="math inline">\(i\)</span> 的节点一定是值为<span class="math inline">\(i+1\)</span>的节点的儿子，而儿子节点的数量一定不多于父节点，否则无解。</p><p>然后一顿瞎连就行了。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> T, n, mx, root, cnt, h[N];vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; p[N], ans;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();mx=root=cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;h[i]=<span class="hljs-built_in">read</span>(), mx=<span class="hljs-built_in">max</span>(mx,h[i]);p[i].<span class="hljs-built_in">clear</span>();&#125;p[<span class="hljs-number">0</span>].<span class="hljs-built_in">clear</span>();ans.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(h[i]==mx) ++cnt, root=i;p[h[i]].<span class="hljs-built_in">pb</span>(&#123;h[i],i&#125;);&#125;<span class="hljs-keyword">if</span>(cnt!=<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;mx;++i)<span class="hljs-keyword">if</span>(p[i].<span class="hljs-built_in">size</span>()&lt;p[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>())  &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;mx;++i) &#123;<span class="hljs-keyword">int</span> sz=p[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;p[i].<span class="hljs-built_in">size</span>();++j) &#123;ans.<span class="hljs-built_in">pb</span>(&#123;p[i][j].sc,p[i+<span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(sz<span class="hljs-number">-1</span>,j)].sc&#125;);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,root);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pp:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,pp.fr,pp.sc);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="f.-至至子的公司排队">F. 至至子的公司排队</h1><h2 id="分析-2">分析</h2><p>每棵树是互相独立的，因此可以分别考虑，合并答案。</p><p>对于一棵树 <span class="math inline">\(i\)</span>，设 <spanclass="math inline">\(f_x\)</span> 为在以 <spanclass="math inline">\(x\)</span>为根的子树中，满足条件的排列方法数量。</p><p>先不考虑每个子节点子树内的情况，设子节点集合为 <spanclass="math inline">\(\{y\}\)</span>，大小为 <spanclass="math inline">\(m\)</span>。</p><p>转移方法有两种。</p><p>一，多重集的全排列。。那么对于 <spanclass="math inline">\(y_i\)</span>，相当于存在 <spanclass="math inline">\(sz_{y_i}\)</span> 个相同元素，总的元素个数为 <spanclass="math inline">\(sz_x - 1\)</span>，最后对于每个 <spanclass="math inline">\(y_i\)</span>，其内部的方案数为 <spanclass="math inline">\(f_{y_i}\)</span>，相乘即可。 <spanclass="math display">\[f_x = \prod_{i=1} f_{y_i} \frac{(sz_x - 1)!}{\prod_{i=1}^m (sz_{y_i}!)}\]</span>二，子树合并。其实我也不太明白这种东西是怎么证明的，但是看起来比较直观一些。<span class="math display">\[f_x = \prod_{i=1}^m f_{y_i} C_{sz_x&#39; - 1}^{sz_{y_i}}\]</span> 其中 <span class="math inline">\(sz_x&#39;-1 = \sum_{j=1}^isz_{y_i}\)</span>。</p><p> </p><p>最后合并不同树的时候，也可以使用上述两种方法。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, cnt, ans=<span class="hljs-number">1</span>, c[N], f[N], fac[N], inv[N], sz[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> d=<span class="hljs-number">1e5</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=d;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[d]=<span class="hljs-built_in">fp</span>(fac[d],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=d<span class="hljs-number">-1</span>;~i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>, f[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> F=<span class="hljs-number">1</span>, g=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dp</span>(y,x);sz[x]+=sz[y];(f[x]*=f[y]*<span class="hljs-built_in">C</span>(sz[x]<span class="hljs-number">-1</span>,sz[y])%mod)%=mod;<span class="hljs-comment">// (F*=f[y])%=mod, (g*=inv[sz[y]])%=mod;</span>&#125;<span class="hljs-comment">// f[x]=(F*fac[sz[x]-1]%mod*g%mod)%mod;</span>    <span class="hljs-comment">// 注释掉的是多重集全排列</span>&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;c[i]=<span class="hljs-built_in">read</span>();tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=c[i];++j) h[j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=c[i];++j) &#123;<span class="hljs-keyword">int</span> p=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(p,j);&#125;<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);cnt+=c[i];(ans*=f[<span class="hljs-number">1</span>]*<span class="hljs-built_in">C</span>(cnt,c[i])%mod)%=mod;        <span class="hljs-comment">// 这也是子树合并</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>组合数学</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#816 (Div 2)</title>
    <link href="/2022/cf1715-solution/"/>
    <url>/2022/cf1715-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1715</strong>.</p><span id="more"></span><h1 id="a.-crossmarket">A. Crossmarket</h1><h2 id="分析">分析</h2><p>钦定 <span class="math inline">\(n \ge m\)</span>。</p><p>不难发现，最优操作方式一定是一个先走完 <spanclass="math inline">\((n-1) + (m-1)\)</span> 的路程，另一个只需要走<span class="math inline">\((m-1)\)</span> 的路程加上 <spanclass="math inline">\(1\)</span> 的传送即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n, m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;&amp;m==<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-built_in">swap</span>(n,m);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(n<span class="hljs-number">-1</span>)+(m<span class="hljs-number">-1</span>)+(m<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-beautiful-array">B. Beautiful Array</h1><h2 id="分析-1">分析</h2><p>既然是构造题，那么我们可以乱搞。</p><p>考虑如果 <span class="math inline">\(a_i &lt;k\)</span>，那么不会对序列的 beauty 产生贡献。</p><p>由于存在向下取整，所以序列的和最小是 <span class="math inline">\(k\cdot b\)</span>，如果 <span class="math inline">\(k \cdot b &gt;s\)</span>，那么无解。</p><p>让 <span class="math inline">\(a_1\)</span> 为 <spanclass="math inline">\(\min(k \cdot (b+1)-1,s)\)</span>，如果 <spanclass="math inline">\(s - a_1\)</span>之后还有剩余，那么就贪心地在后面放上不超过 <spanclass="math inline">\(k\)</span> 的数字就行了。</p><p>如果没有位置可以放的时候，<span class="math inline">\(s\)</span>仍然大于 <span class="math inline">\(0\)</span>，那么无解。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, k, b, s, a[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k*b&gt;s) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> t=k*(b+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(t&gt;s) t-=t-s;a[<span class="hljs-number">1</span>]=t;s-=t;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(s&gt;=k<span class="hljs-number">-1</span>) a[i]=k<span class="hljs-number">-1</span>, s-=(k<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) a[i]=s, s=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(s!=<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-monoblock">C. Monoblock</h1><h2 id="分析-2">分析</h2><p>先求出原序列的值，考虑每个数的贡献。</p><p>不太好想，举个例子。假设 <span class="math inline">\(1,2\)</span>的贡献已经计算完毕，现在要在后面加入一个 <spanclass="math inline">\(3\)</span>。不难发现，所有以 <spanclass="math inline">\(3\)</span> 结尾的前缀，<spanclass="math inline">\(1,2,3\)</span>，<spanclass="math inline">\(2,3\)</span>，<spanclass="math inline">\(3\)</span> 中都存在 <spanclass="math inline">\(3\)</span> 的 <spanclass="math inline">\(1\)</span> 个贡献，所以这部分的贡献是 <spanclass="math inline">\(3\)</span>。而由于这 <spanclass="math inline">\(3\)</span> 段都是新加入的，所以也要计算 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(2\)</span>的贡献。不难发现这就是一个相同的问题，以 <spanclass="math inline">\(2\)</span> 结尾的前缀的个数加上以 <spanclass="math inline">\(1\)</span> 结尾的前缀的个数。</p><p>而如果加入的是 <span class="math inline">\(2\)</span> 呢？则只会让以<span class="math inline">\(2\)</span> 结尾的前缀个数增加 <spanclass="math inline">\(1\)</span>，其他是相同的。</p><p>形式化地，设 <span class="math inline">\(pre\)</span> 为所有 <spanclass="math inline">\(k \in [1,i-1]\)</span>，以 <spanclass="math inline">\(k\)</span> 结尾的前缀的数量，<spanclass="math inline">\(ans\)</span> 为 <spanclass="math inline">\([1,i-1]\)</span> 的贡献。加入 <spanclass="math inline">\(a_i\)</span></p><p>假设 <span class="math inline">\(a_1,\ldots a_{i-1}\)</span>的贡献已经计算完毕，那么插入 <span class="math inline">\(a_i\)</span>时，如果 <span class="math inline">\(a_{i} \neq a_{i-1}\)</span>，那么令<span class="math inline">\(pre + i\)</span>，<spanclass="math inline">\(ans + pre\)</span>。否则令 <spanclass="math inline">\(pre+1\)</span>，<span class="math inline">\(ans +pre\)</span>。</p><p>对于修改操作，如果 <span class="math inline">\(a_i \neqa_{i-1}\)</span> 且 <span class="math inline">\(x =a_{i-1}\)</span>，那么左端点在 <spanclass="math inline">\([1,i-1]\)</span>，右端点在 <spanclass="math inline">\([i,n]\)</span> 中的区间，其贡献都会减少 <spanclass="math inline">\(1\)</span>，所以要减去 <spanclass="math inline">\((i-1) \cdot (n-i+1)\)</span>。同理，如果 <spanclass="math inline">\(a_i \neq a_{i+1}\)</span> 且 <spanclass="math inline">\(x = a_{i+1}\)</span>，那么就要减去 <spanclass="math inline">\(i \cdot (n-i)\)</span>。</p><p>反过来，如果 <span class="math inline">\(a_i = a_{i-1}\)</span> 且<span class="math inline">\(x \neq a_{i-1}\)</span> 或者 <spanclass="math inline">\(a_i = a_{i+1}\)</span> 且 <spanclass="math inline">\(x \neqa_{i+1}\)</span>，那么就要加上对应的值。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, m, cnt, a[N], b[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>, pre=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]!=a[i<span class="hljs-number">-1</span>]) pre+=i, ans+=pre;<span class="hljs-keyword">else</span> ++pre, ans+=pre;&#125;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> i=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]==x) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">if</span>(x==a[i<span class="hljs-number">-1</span>]&amp;&amp;a[i]!=a[i<span class="hljs-number">-1</span>]) ans-=(i<span class="hljs-number">-1</span>)*(n-i+<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=a[i<span class="hljs-number">-1</span>]&amp;&amp;a[i]==a[i<span class="hljs-number">-1</span>]) ans+=(i<span class="hljs-number">-1</span>)*(n-i+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(x==a[i+<span class="hljs-number">1</span>]&amp;&amp;a[i]!=a[i+<span class="hljs-number">1</span>]) ans-=i*(n-i);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=a[i+<span class="hljs-number">1</span>]&amp;&amp;a[i]==a[i+<span class="hljs-number">1</span>]) ans+=i*(n-i);a[i]=x;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-2-doors">D. 2+ doors</h1><h2 id="分析-3">分析</h2><p>设 <span class="math inline">\(g(k,x)\)</span> 为 <spanclass="math inline">\(x\)</span> 二进制中的第 <spanclass="math inline">\(k\)</span> 位。</p><p>如果 <span class="math inline">\(a_i | a_j = x\)</span>，那么如果<span class="math inline">\(g(k,x)=0\)</span>，那么一定有 <spanclass="math inline">\(g(k,a_i) = g(k,a_j) = 0\)</span>。</p><p>考虑反着构造，先将每个 <span class="math inline">\(a_i\)</span>赋值为 <span class="math inline">\(2^{30} - 1\)</span>。</p><p>对于一组 <span class="math inline">\((i,j,x)\)</span>，如果 <spanclass="math inline">\(i \neq j\)</span>，那么就执行上述操作。</p><p>执行完之后，<span class="math inline">\(a_i | a_j\)</span> 必然等于<span class="math inline">\(k\)</span>，下面着手减小它的字典序。</p><p>对于一个 <span class="math inline">\(i\)</span>，枚举其为 <spanclass="math inline">\(1\)</span> 的位 <spanclass="math inline">\(k\)</span>，找到所有与 <spanclass="math inline">\(i\)</span> 有关的 <spanclass="math inline">\((j,x)\)</span>，如果上满足存在一组 <spanclass="math inline">\((j,x)\)</span>，满足 <spanclass="math inline">\(g(k,a_j) = 1\)</span> 且 <spanclass="math inline">\(g(k,x) = 0\)</span>，那么就将 <spanclass="math inline">\(g(k,a_1)\)</span> 改为 <spanclass="math inline">\(0\)</span>。</p><p>这样做会导致其他的 <span class="math inline">\((j,x)\)</span>不满足条件，但为什么是最优解呢？因为数据保证有解，由于枚举 <spanclass="math inline">\(i\)</span>是从前往后，所以减小靠前的数要优于减小靠后的数，且可以通过修改 <spanclass="math inline">\(a_j\)</span> 的方式重新满足条件。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, q, a[N];<span class="hljs-keyword">bool</span> v[N];vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; w[N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> i=<span class="hljs-built_in">read</span>(), j=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(i==j) &#123;a[i]=x, v[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">29</span>;~k;--k) &#123;<span class="hljs-keyword">if</span>(x&gt;&gt;k&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(a[i]&gt;&gt;k&amp;<span class="hljs-number">1</span>) a[i]^=<span class="hljs-number">1</span>&lt;&lt;k;<span class="hljs-keyword">if</span>(a[j]&gt;&gt;k&amp;<span class="hljs-number">1</span>) a[j]^=<span class="hljs-number">1</span>&lt;&lt;k;&#125;w[i].<span class="hljs-built_in">push_back</span>(&#123;j,x&#125;);w[j].<span class="hljs-built_in">push_back</span>(&#123;i,x&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">29</span>;~j;--j) &#123;<span class="hljs-keyword">if</span>(!(a[i]&gt;&gt;j&amp;<span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">bool</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:w[i]) &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><span class="hljs-keyword">if</span>((p.y&gt;&gt;j&amp;<span class="hljs-number">1</span>)&amp;&amp;!(a[p.x]&gt;&gt;j&amp;<span class="hljs-number">1</span>)) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(fg) a[i]^=<span class="hljs-number">1</span>&lt;&lt;j;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div><h1 id="e.-long-way-home">E. Long Way Home</h1><p>咕咕咕。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ#3381 函数调用 题解</title>
    <link href="/2022/loj3381-solution/"/>
    <url>/2022/loj3381-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>函数调用，满足不出现递归，本身就构成了一张 DAG。</p><span id="more"></span><p>由于乘法操作是全局乘法，所以可以提前预处理乘法操作，而加法操作最终的贡献，取决于在它之后乘上多少次。</p><p>设 <span class="math inline">\(pls_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个函数执行的加法的值，如果没有的话则为<span class="math inline">\(0\)</span>，<spanclass="math inline">\(id_i\)</span> 为第 <spanclass="math inline">\(i\)</span>个函数要执行加法的元素的编号，没有的话为 <spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(mul_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个函数对全局的乘法值，如果没有的话则为<span class="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(cnt_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个函数加法操作之后又被乘了多少。</p><p>对于函数 <span class="math inline">\(i\)</span> 要调用的函数 <spanclass="math inline">\(x\)</span>，连边 <span class="math inline">\((i\rightarrow x)\)</span>。用 DFS可以预处理出当运行完任意一个函数时，对全局的乘法操作，而函数 <spanclass="math inline">\(i\)</span> 必然在 <spanclass="math inline">\(x\)</span> 之后操作，因此 <spanclass="math inline">\(x\)</span> 加法操作的最终值依赖于 <spanclass="math inline">\(i\)</span>，因此处理 <spanclass="math inline">\(i\)</span> 要早于处理 <spanclass="math inline">\(x\)</span>，拓扑排序即可。</p><p>但是函数的调用是有序的，依次从左到右。因此必须新建立一个节点 <spanclass="math inline">\(0\)</span>，向所有调用的函数连边，并且在遍历 <spanclass="math inline">\(x\)</span> 能到达的所有点时，必须要按照倒序。</p><p>DFS 之后，<span class="math inline">\(mul_0\)</span>即为全局最终乘上的值，而对于每一个加法函数 <spanclass="math inline">\(i\)</span>，都会对 <spanclass="math inline">\(a_{id_i}\)</span> 产生 <spanclass="math inline">\(pls_i \cdot cnt_i\)</span> 的贡献。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, a[N], id[N], pls[N], mul[N], cnt[N];<span class="hljs-keyword">int</span> in[N], op[N];<span class="hljs-keyword">bool</span> v[N];vector&lt;<span class="hljs-keyword">int</span>&gt; p[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">return</span>;v[x]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 关于为什么这里要用v数组来判环</span>    <span class="hljs-comment">// 因为从0连边之前是DAG，但是连边之后就可能不是了</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-built_in">dfs</span>(y);(mul[x]*=mul[y])%=mod;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">int</span> dlt=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=p[x].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;~i;--i) &#123;        <span class="hljs-comment">// 倒序遍历</span><span class="hljs-keyword">int</span> y=p[x][i];(cnt[y]+=cnt[x]*dlt)%=mod;            <span class="hljs-comment">// 这里的层次一定要分清楚</span>            <span class="hljs-comment">// y的加法操作只会被x影响，要按照拓扑序处理，而不是看全局乘上的值</span>(dlt*=mul[y])%=mod;<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;call.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;call.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;op[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">1</span>) id[i]=<span class="hljs-built_in">read</span>(), pls[i]=<span class="hljs-built_in">read</span>(), mul[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">2</span>) mul[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">read</span>();mul[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();p[i].<span class="hljs-built_in">pb</span>(x), ++in[x];&#125;&#125;&#125;<span class="hljs-keyword">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();p[<span class="hljs-number">0</span>].<span class="hljs-built_in">pb</span>(x), ++in[x];&#125;cnt[<span class="hljs-number">0</span>]=mul[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">toposort</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) (a[i]*=mul[<span class="hljs-number">0</span>])%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">1</span>) (a[id[i]]+=cnt[i]*pls[i]%mod)%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ#3387 字符串匹配 题解</title>
    <link href="/2022/loj3387-solution/"/>
    <url>/2022/loj3387-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>规定以下讨论中，字符串的下标从 <span class="math inline">\(1\)</span>开始。</p><p>注意到 <span class="math inline">\((AB)^K\)</span>一定是一段前缀，<span class="math inline">\(C\)</span>一定是一段后缀，而 <span class="math inline">\(AB\)</span> 又一定是<span class="math inline">\((AB)^k\)</span> 的前缀，且满足连续出现 <spanclass="math inline">\(k\)</span> 次。</p><p>考虑 <span class="math inline">\(S\)</span> 的 <spanclass="math inline">\(z\)</span> 函数。</p><span id="more"></span><p>如果知道了 <span class="math inline">\(AB\)</span> 的长度和 <spanclass="math inline">\(k\)</span>，那么就能计算出对应的 <spanclass="math inline">\(C\)</span>。设当前 <spanclass="math inline">\(AB\)</span> 长度为 <spanclass="math inline">\(i\)</span>，那么最多的循环次数为 <spanclass="math display">\[\lfloor \frac{z_{i+1}}{i} \rfloor + 1\]</span> <del>感性理解一下，显然是对的</del>。</p><p>当然这是“至多”，我们可以规定循环次数为任何一个小于最多次数，大于<span class="math inline">\(0\)</span> 的整数。</p><p>注意到对于奇偶性相同的 <spanclass="math inline">\(k\)</span>，出现次数为奇数的字符个数是相等的，所以只需要分奇偶讨论。当<span class="math inline">\(k\)</span> 为奇数时，个数不变，当 <spanclass="math inline">\(k\)</span>为偶数时，不存在出现次数为奇数的字符。</p><p>设 <span class="math inline">\(g(l,r)\)</span> 为 <spanclass="math inline">\(S[l,r]\)</span>中出现次数为奇数的字符的数量。设当前 <spanclass="math inline">\(AB\)</span> 长度为 <spanclass="math inline">\(i\)</span>，<span class="math inline">\(|A| =j\)</span>。</p><p>首先一定存在 <span class="math inline">\(F(A) \leF(C)\)</span>，<span class="math inline">\(F(A) = g(1,j)\)</span>。</p><ul><li>如果 <span class="math inline">\(k\)</span> 是个奇数，那么就有 <spanclass="math inline">\(g(1,j) \le g(i+1,n)\)</span>。尽管 <spanclass="math inline">\(C\)</span>中具体有多少个出现次数为奇数的字符是未知的，但是 <spanclass="math inline">\((AB)^k\)</span> 在 <spanclass="math inline">\([i+1,n]\)</span>的出现次数一定为偶数次，所以不会产生影响，<spanclass="math inline">\(g(i+1,n)\)</span> 就是 <spanclass="math inline">\(F(C)\)</span>。</li><li>否则，由于 <span class="math inline">\((AB)^k\)</span>不存在这类字符，所以 <span class="math inline">\([1,ki]\)</span>就不存在出现次数为奇数的字符，因此 <span class="math inline">\(F(C) =g(ki+1,n) = g(1,n) \Longrightarrow g(1,j) \le g(1,n)\)</span>。</li></ul><p>如何维护这类信息？使用树状数组。设 <spanclass="math inline">\(C(x)\)</span> 表示长度小于 <spanclass="math inline">\(i\)</span> 且这类字符的个数小于等于 <spanclass="math inline">\(x\)</span> 的前缀的数量。</p><p>同时用变量 <span class="math inline">\(pre\)</span> 表示 <spanclass="math inline">\([1,i]\)</span> 中这类字符的个数，<spanclass="math inline">\(suf\)</span> 表示 <spanclass="math inline">\([i+1,n]\)</span> 中的，<spanclass="math inline">\(all\)</span> 表示 <spanclass="math inline">\(g(1,n)\)</span>。</p><p>对于 <span class="math inline">\(t = \lfloor \frac{z_{i+1}}{i}\rfloor + 1\)</span>，奇数的情况有 <span class="math inline">\(t -\lfloor \frac{t}{2} \rfloor\)</span>，偶数则有 <spanclass="math inline">\(\lfloor \frac{t}{2} \rfloor\)</span>。对于 <spanclass="math inline">\(i\)</span> <span class="math display">\[(t - \lfloor \frac{t}{2} \rfloor) \cdot C(suf) + \lfloor \frac{t}{2}\rfloor \cdot C(all)\]</span> 然后插入 <span class="math inline">\(pre\)</span> 即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)+<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> t, n, z[N], p[<span class="hljs-number">30</span>], q[<span class="hljs-number">30</span>], c[<span class="hljs-number">30</span>];<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">for</span>(;x&lt;=<span class="hljs-number">27</span>;x+=x&amp;-x) c[x]+=y; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;z[<span class="hljs-number">0</span>]=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) z[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;z[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<span class="hljs-keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[z[i]]==s[i+z[i]]) ++z[i];<span class="hljs-keyword">if</span>(r&lt;i+z[i]<span class="hljs-number">-1</span>) l=i, r=i+z[i]<span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(i+z[i]==n) --z[i];    <span class="hljs-comment">// 由于c不是空串，所以i+z[i]必须小于n</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);n=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p));<span class="hljs-built_in">memset</span>(q,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(q));<span class="hljs-built_in">Z</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>, pre=<span class="hljs-number">0</span>, suf=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) ++q[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i) <span class="hljs-keyword">if</span>(q[i]&amp;<span class="hljs-number">1</span>) ++suf;<span class="hljs-keyword">int</span> all=suf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-keyword">int</span> d=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;++p[d], --q[d];<span class="hljs-keyword">if</span>(p[d]&amp;<span class="hljs-number">1</span>) ++pre; <span class="hljs-keyword">else</span> --pre;<span class="hljs-keyword">if</span>(q[d]&amp;<span class="hljs-number">1</span>) ++suf; <span class="hljs-keyword">else</span> --suf;<span class="hljs-keyword">if</span>(i) &#123;<span class="hljs-keyword">int</span> t=z[i+<span class="hljs-number">1</span>]/(i+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;            <span class="hljs-comment">// 由于我的代码中i从0开始，所以要+1表示长度为i，和z[i+1]中的+1无关</span>ans+=(t-t/<span class="hljs-number">2</span>)*<span class="hljs-built_in">query</span>(suf+<span class="hljs-number">1</span>)+(t/<span class="hljs-number">2</span>)*<span class="hljs-built_in">query</span>(all+<span class="hljs-number">1</span>);            <span class="hljs-comment">// 为了防止0下标，这些都要+1</span>&#125;<span class="hljs-built_in">modify</span>(pre+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;string.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;string.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>字符串</tag>
      
      <tag>扩展KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「字符串学习笔记」#2 Z函数（扩展KMP）</title>
    <link href="/2022/notes-string-2/"/>
    <url>/2022/notes-string-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>本来想着，暑假要多学点算法，结果就学了一点点……</p><p>大部分时间拿来写题了。</p><p>有点小遗憾。</p><p>不过无妨。</p><span id="more"></span><h2 id="z-函数扩展-kmp">Z 函数（扩展 KMP）</h2><h3 id="算法流程及实现">算法流程及实现</h3><p>约定：字符串下标以 <span class="math inline">\(0\)</span>为起点。</p><p>对于一个字符串 <span class="math inline">\(S\)</span>，满足 <spanclass="math inline">\(|S| = n\)</span>，它的 <spanclass="math inline">\(z\)</span> 函数定义为：<spanclass="math inline">\(z(i)\)</span> 表示 <spanclass="math inline">\(S\)</span> 和以 <spanclass="math inline">\(i\)</span> 开头的后缀 <spanclass="math inline">\(S[i,n-1]\)</span> 的最长公共前缀 (LCP)的长度。</p><p>显然有 <span class="math inline">\(z(0)=n\)</span>。</p><p>国外一般将计算该数组的算法称为 <strong>ZAlgorithm</strong>，而国内则称其为<strong>扩展 KMP</strong>。</p><p>为啥是扩展 KMP？可能是因为这两段的 LCP，某种意义上也是一个Border。</p><p>根据定义易得 <span class="math inline">\(O(n^2)\)</span> 的实现</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C++ Version</span><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">z_function_trivial</span><span class="hljs-params">(string s)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)s.<span class="hljs-built_in">length</span>();    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;    z[<span class="hljs-number">0</span>] = n;    <span class="hljs-comment">// 这句是我加的</span>    <span class="hljs-comment">// OI-wiki上说z[0]=0，但是z[0]=0不仅说不过去而且板子题也过不了啊</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)    <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-comment">// Code from oi-wiki.org</span></code></pre></div><p>一般情况下，当一个能求出很 NB的东西的算法复杂度过高时，就会有神犇来优化它。</p><blockquote><p>如同大多数字符串主题所介绍的算法，其关键在于，运用自动机的思想寻找限制条件下的状态转移函数，使得可以借助之前的状态来加速计算新的状态。</p></blockquote><p>就像是 KMP 算法中的 <span class="math inline">\(next\)</span>数组一样，这里考虑用 <span class="math inline">\(z(0),z(1),\ldotsz(i-1)\)</span> 来求出 <span class="math inline">\(z(i)\)</span>。</p><p>对于 <span class="math inline">\(i\)</span>，我们称区间 <spanclass="math inline">\([i,i+z(i)-1]\)</span> 是 <spanclass="math inline">\(i\)</span> 的<strong>匹配段</strong>，也可以叫Z-box。</p><p>设 <span class="math inline">\([l,r]\)</span> 为最靠右的 Z-box对应的左右端点，必须保证 <span class="math inline">\(l \lei\)</span>，初始化 <span class="math inline">\(l=r=0\)</span>.</p><p>对于 <span class="math inline">\(z(i)\)</span>，如果 <spanclass="math inline">\(i \le r\)</span>，那么由于 <spanclass="math inline">\([l,r]\)</span> 是一个匹配段，所以 <spanclass="math inline">\(s[i,r] = s[i-l,r-l]\)</span>。</p><p>因此 <span class="math inline">\(z(i) \ge \min \big(z(i-l),r-i+1\big)\)</span>。</p><p>这时候</p><ul><li>如果 <span class="math inline">\(z(i-l) &lt; r-i+1\)</span>，那么<span class="math inline">\(z(i)=z(i-l)\)</span>。</li><li>否则 <span class="math inline">\(z(i-l) \ge r-i+1\)</span>，这时候令<span class="math inline">\(z(i) = \max(0,r-i+1 )\)</span>，然后暴力递增<span class="math inline">\(z(i)\)</span>，知道不能扩展为止。求出 <spanclass="math inline">\(z(i)\)</span> 后，如果 <spanclass="math inline">\(r &lt; i+z(i)-1\)</span>，那么就令 <spanclass="math inline">\(l=i,r=i+z(i)-1\)</span>。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;z[<span class="hljs-number">0</span>]=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) z[i]=z[i-l];<span class="hljs-keyword">else</span> &#123;z[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<span class="hljs-keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[z[i]]==s[i+z[i]]) ++z[i];<span class="hljs-keyword">if</span>(r&lt;i+z[i]<span class="hljs-number">-1</span>) l=i, r=i+z[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;</code></pre></div><h3 id="复杂度分析">复杂度分析</h3><p>对于内层<code>while</code>循环，每次都使得 <spanclass="math inline">\(r\)</span> 向后移动一位，而 <spanclass="math inline">\(r \in [0,n-1]\)</span>，因此复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p>对于外层循环，只有一次遍历，复杂度 <spanclass="math inline">\(O(n)\)</span>。</p><p>因此整个算法的复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><h2 id="应用">应用</h2><h3id="求出模式串与文本串每一个后缀的lcp">求出模式串与文本串每一个后缀的LCP</h3><p>也就是洛谷上的模板题。</p><p>类似于 KMP 算法，求出模式串的 <span class="math inline">\(z\)</span>函数，设文本串 <span class="math inline">\(|T|=m\)</span>，那么设 <spanclass="math inline">\(f(i)\)</span> 为模式串与文本串的后缀 <spanclass="math inline">\(T[i,m-1]\)</span> 的 LCP 长度，在 <spanclass="math inline">\(z\)</span> 函数的基础上处理即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exkmp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">Z</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">-1</span>, r=<span class="hljs-number">-1</span>, ans=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 注意从l=r=-1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i+<span class="hljs-number">1</span>) f[i]=z[i-l];        <span class="hljs-comment">// 这里是z[i-l]</span><span class="hljs-keyword">else</span> &#123;f[i]=<span class="hljs-built_in">max</span>(r-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<span class="hljs-keyword">while</span>(i+f[i]&lt;m&amp;&amp;s[f[i]]==t[i+f[i]]) ++f[i];<span class="hljs-keyword">if</span>(r&lt;i+f[i]<span class="hljs-number">-1</span>) l=i, r=i+f[i]<span class="hljs-number">-1</span>;&#125;&#125;&#125;</code></pre></div><h3 id="匹配所有子串">匹配所有子串</h3><p>寻找模式串 <span class="math inline">\(P\)</span> 在文本串 <spanclass="math inline">\(T\)</span> 中的所有出现 (occurrence)。</p><p>构造字符串 <span class="math inline">\(S = P + \lambda +T\)</span>，其中 <span class="math inline">\(\lambda\)</span>是一个不在二者之中出现的字符。</p><p>首先计算出 <span class="math inline">\(S\)</span> 的 <spanclass="math inline">\(z\)</span> 函数，对于任意 <spanclass="math inline">\(i \in [0,|T|-1]\)</span>，考虑以 <spanclass="math inline">\(T_i\)</span> 开头的后缀在 <spanclass="math inline">\(S\)</span> 中的函数值 <spanclass="math inline">\(k = z(i+|S|+1)\)</span>，如果 <spanclass="math inline">\(k = |S|\)</span>，那么说明有一个 <spanclass="math inline">\(P\)</span> 出现在了 <spanclass="math inline">\(T\)</span> 的第 <spanclass="math inline">\(i\)</span> 个位置。</p><p>不难发现此种方法也可以求解上面的那个问题。</p><h3 id="字符串整周期">字符串整周期</h3><p>找到给定字符串 <span class="math inline">\(|S|=n\)</span>的最小整周期。</p><p>考虑 <span class="math inline">\(S\)</span> 的 <spanclass="math inline">\(z\)</span> 函数，则其最小整周期为满足 <spanclass="math inline">\(i \mid n\)</span> 且 <spanclass="math inline">\(i+z_i = n\)</span>。</p><p>证明？感性理解~</p><p> </p><p>嗯嗯，就写这么点吧。</p><p>由于时间原因，本文没有放很多证明过程。</p><h2 id="参考">参考</h2><ul><li><a href="https://oi-wiki.org/string/z-func/">OI-wiki Z 函数（扩展KMP）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>扩展KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#815 (Div 2)</title>
    <link href="/2022/cf1720-solution/"/>
    <url>/2022/cf1720-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1720</strong>.</p><span id="more"></span><h1 id="a.-burenka-plays-with-fractions">A. Burenka Plays withFractions</h1><h2 id="分析">分析</h2><p><span class="math display">\[\frac{a}{b} = \frac{c}{d}\]</span></p><p><span class="math display">\[ad = cb\]</span></p><p>如果相等，答案为 <span class="math inline">\(0\)</span>。</p><p>如果某一方是 <span class="math inline">\(0\)</span>，答案为 <spanclass="math inline">\(1\)</span>。</p><p>如果两者有倍数关系，答案为 <spanclass="math inline">\(1\)</span>。</p><p>否则为 <span class="math inline">\(2\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a*d==b*c) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!a||!c) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(a*d,b*c)%<span class="hljs-built_in">min</span>(a*d,b*c)==<span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-interesting-sum">B. Interesting Sum</h1><h2 id="分析-1">分析</h2><p>发现无论如何都能选择一个区间，满足区间内最大值是序列最大值或次大值，区间内最小值是序列最小值或次小值。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> ans=a[n]-a[<span class="hljs-number">1</span>]+a[n<span class="hljs-number">-1</span>]-a[<span class="hljs-number">2</span>];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-corners">C. Corners</h1><h2 id="分析-2">分析</h2><p>发现第一次操作后，每次操作一定都能只消耗一个白点。</p><p>如果存在两个 <span class="math inline">\(0\)</span>能被同时操作，那么第 <span class="math inline">\(1\)</span>次操作就会消耗 <span class="math inline">\(1\)</span>个白点，否则，如果存在 <span class="math inline">\(0\)</span>，就会消耗<span class="math inline">\(2\)</span> 个，否则就会消耗 <spanclass="math inline">\(3\)</span> 个。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,j,k) for(int i=j;i&lt;=k;++i)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n, m, a[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%1d&quot;</span>,&amp;a[i][j]);<span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>, dlt=<span class="hljs-number">1</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) cnt1+=a[i][j];<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(!a[i][j]) &#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i<span class="hljs-number">-1</span>][j]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;!a[i+<span class="hljs-number">1</span>][j]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i][j<span class="hljs-number">-1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&lt;m&amp;&amp;!a[i][j+<span class="hljs-number">1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;j&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;j&lt;m&amp;&amp;!a[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&gt;<span class="hljs-number">1</span>&amp;&amp;!a[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&lt;m&amp;&amp;!a[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) dlt=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(!dlt) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(cnt1==n*m) dlt=<span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,cnt1-dlt);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d1.-xor-subsequence-easy-version">D1. Xor-Subsequence (easyversion)</h1><p>这题被 Hack 了，原因是使用<code>memset()</code>。</p><h2 id="分析-3">分析</h2><p>注意到 <span class="math inline">\(a_i \in [0,200]\)</span>。</p><p>设 <span class="math inline">\(f(i)\)</span> 为以 <spanclass="math inline">\(i\)</span> 结尾的 beautiful subsequence的最大长度，以下下标均从 <span class="math inline">\(0\)</span>开始。</p><p>初始值 <span class="math inline">\(f(i)=1\)</span>。 <spanclass="math display">\[f(i) = \max_{j \in [0,i-1]} \{ f(j) + 1 \}\]</span> 其中 <span class="math inline">\(a_j \oplus i &lt; a_i \oplusj\)</span>。</p><p>这样的复杂度是 <span class="math inline">\(O(n^2)\)</span> 的。</p><p>由于 <span class="math inline">\(a_i\)</span> 不超过 <spanclass="math inline">\(2^8\)</span>，所以 <span class="math inline">\(j\in [\max(0,i-2^8),i-1]\)</span>。</p><p>可过。</p><p>答案 <span class="math inline">\(\max_{i=0}^{n-1} f_i\)</span>。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N], f[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) f[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;f[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,i<span class="hljs-number">-256</span>);j&lt;i;++j) &#123;<span class="hljs-keyword">if</span>((a[j]^i)&lt;(a[i]^j)) f[i]=<span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);&#125;ans=<span class="hljs-built_in">max</span>(ans,f[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d2.-xor-subsequence-hard-version">D2. Xor-Subsequence (hardversion)</h1><h2 id="分析-4">分析</h2><p><span class="math inline">\(a_i \in[0,10^9]\)</span>，上面的做法失效了。考虑优化这个 DP。</p><p>如果 <span class="math inline">\(a_j \oplus i &lt; a_i \oplusj\)</span>，那么一定存在一个 <spanclass="math inline">\(k\)</span>，满足前 <spanclass="math inline">\(k\)</span> 位中，<span class="math inline">\(a_j\oplus i = a_i \oplus j\)</span>，<spanclass="math inline">\(k+1\)</span> 位上，前者为 <spanclass="math inline">\(0\)</span>，后者为 <spanclass="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(w(k,x)\)</span> 为 <spanclass="math inline">\(x\)</span> 二进制中第 <spanclass="math inline">\(k\)</span> 位的值。</p><p>不知道为什么下面部分字体出现了问题，但是不影响观看。</p><p>如果 <span class="math inline">\(w(1 \sim k, a_j \oplus i) = w(1 \simk,a_i \oplus j)\)</span>，那么两边同时异或上 <spanclass="math inline">\(i \oplus j\)</span>，即 <spanclass="math inline">\(w(1 \sim k,a_j \oplus j) = w(1 \sim k,a_i \oplusi)\)</span>。这个转化，直接将 <spanclass="math inline">\(O(n^2)\)</span> 级别的数对变成 <spanclass="math inline">\(O(n)\)</span> 级别的了。</p><p>而 <span class="math inline">\(k+1\)</span> 位上，有 <spanclass="math inline">\(a_j \oplus j &lt; a_i \oplus i\)</span>，这表明<span class="math inline">\(w(k+1,a_i \oplus i) \oplus 1 = w(k+1,a_j\oplus j)\)</span>，这是第一个要点。</p><p>由于 <span class="math inline">\(w(k+1,a_j \oplus i) &lt; w(k+1,a_i\oplus j)\)</span>，所以 <span class="math inline">\(w(k+1,a_i \oplus j)= 1\)</span>，即 <span class="math inline">\(w(k+1,a_i) \neqw(k+1,j)\)</span>，这是第二个要点。</p><p>建立一颗 0/1 Trie 来维护这个东西，插入 <spanclass="math inline">\(a_i \oplus i\)</span>。对于每个 <spanclass="math inline">\(f(i)\)</span>，通过上述方法找到满足条件的最大的<span class="math inline">\(f(j)\)</span>。</p><p>设 <span class="math inline">\(g(x,k=0/1)\)</span> 为字典树上经过<span class="math inline">\(x\)</span> 节点，且这一位为 <spanclass="math inline">\(0/1\)</span> 的最大的 <spanclass="math inline">\(f(j)\)</span>。上文两个要点已经说明的求的满足条件的<span class="math inline">\(j\)</span> 的方法，即要过 <spanclass="math inline">\(w(k+1,a_i \oplus i) \oplus 1\)</span>这个节点，且第 <span class="math inline">\(k+1\)</span> 位与 <spanclass="math inline">\(w(k+1,a_i)\)</span> 不同。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, tot, a[N], f[N], trie[<span class="hljs-number">30</span>*N][<span class="hljs-number">2</span>], g[<span class="hljs-number">30</span>*N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-keyword">int</span> a=(s&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];g[x][(id&gt;&gt;i)&amp;<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(g[x][(id&gt;&gt;i)&amp;<span class="hljs-number">1</span>],f[id]);        <span class="hljs-comment">// id为下标</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>, x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">30</span>;~i;--i) &#123;<span class="hljs-keyword">int</span> a=(s&gt;&gt;i)&amp;<span class="hljs-number">1</span>, y=trie[x][a^<span class="hljs-number">1</span>];        <span class="hljs-comment">// y=a[i]^i^1的这一位所在的节点</span>ans=<span class="hljs-built_in">max</span>(ans,g[y][(k&gt;&gt;i)&amp;<span class="hljs-number">1</span>^<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);        <span class="hljs-comment">// k为a[i],(k&gt;&gt;i)&amp;1^1等于在这一位上，y与k不同</span><span class="hljs-keyword">if</span>(!trie[x][a]) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 没有后续的节点了，结束</span>x=trie[x][a];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) a[i]=<span class="hljs-built_in">read</span>(), f[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=tot;++i) trie[i][<span class="hljs-number">0</span>]=trie[i][<span class="hljs-number">1</span>]=g[i][<span class="hljs-number">0</span>]=g[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;f[i]=<span class="hljs-built_in">query</span>(a[i]^i,a[i]);<span class="hljs-built_in">insert</span>(a[i]^i,i);        <span class="hljs-comment">// 注意插入和查询的参数不同</span>&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#805 (Div 3)</title>
    <link href="/2022/cf1702-solution/"/>
    <url>/2022/cf1702-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1702</strong>.</p><span id="more"></span><h1 id="a.-round-down-the-price">A. Round Down the Price</h1><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> pw[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;++i) pw[i]=pw[i<span class="hljs-number">-1</span>]*<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> e=<span class="hljs-built_in">log10</span>(n);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-pw[e]);&#125;&#125;</code></pre></div><h1 id="b.-polycarp-writes-a-string-from-memory">B. Polycarp Writes aString from Memory</h1><h2 id="分析">分析</h2><p>用<code>std::set</code>自动完成去重，随便输出即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n;<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s; cin&gt;&gt;s;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;set&lt;<span class="hljs-keyword">char</span>&gt; ss;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) &#123;ss.<span class="hljs-built_in">insert</span>(x);<span class="hljs-keyword">if</span>(ss.<span class="hljs-built_in">size</span>()==<span class="hljs-number">4</span>) &#123;ss.<span class="hljs-built_in">clear</span>();ss.<span class="hljs-built_in">insert</span>(x);++ans;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-train-and-queries">C. Train and Queries</h1><h2 id="分析-1">分析</h2><p>如果能从站 <span class="math inline">\(i\)</span> 到站 <spanclass="math inline">\(j\)</span>，当且仅当 <spanclass="math inline">\(i\)</span> 第一次出现的位置小于 <spanclass="math inline">\(j\)</span> 最后一次出现的位置。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, k;map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; a, b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();a.<span class="hljs-built_in">clear</span>(), b.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!a[x]) a[x]=i, b[x]=i; <span class="hljs-keyword">else</span> b[x]=i;&#125;<span class="hljs-keyword">while</span>(k--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!a[x]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(a[x]&lt;b[y]? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-not-a-cheap-string">D. Not a Cheap String</h1><h2 id="分析-2">分析</h2><p>贪心地删除字典序较大的字母</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> t, p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s, ss; cin&gt;&gt;s;ss=s;p=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(ss.<span class="hljs-built_in">rbegin</span>(),ss.<span class="hljs-built_in">rend</span>());    <span class="hljs-comment">// 字典序从大到小排序</span><span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) tot+=x-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ss) &#123;<span class="hljs-keyword">if</span>(tot&gt;p) ++m[x], tot-=x-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) &#123;<span class="hljs-keyword">if</span>(!m[x]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x); <span class="hljs-keyword">else</span> --m[x];&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e.-split-into-two-sets">E. Split Into Two Sets</h1><h2 id="分析-3">分析</h2><p>显然，你可以选择是否根据抽屉原理，得到如果存在 <spanclass="math inline">\(a_i = b_i\)</span>或者某个数字出现了两次以上，那么一定无解。</p><p>对于一组 <span class="math inline">\((a_i,b_i)\)</span>，连边 <spanclass="math inline">\((a_i \rightarrow b_i)\)</span>，<spanclass="math inline">\((b_i \rightarrow a_i)\)</span>。</p><p>以下讨论均不讨论环，断环为链即可。</p><p>从一个节点 <span class="math inline">\(x\)</span> 出发到达 <spanclass="math inline">\(y\)</span>，再从 <spanclass="math inline">\(y\)</span> 到达 <spanclass="math inline">\(z\)</span>，这说明 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(z\)</span>不能在同一组。由于没有自环，所以只要取这一条路径上的点，交替加入两个集合。如果从<span class="math inline">\(x\)</span>出发的最长路径经过的节点个数为奇数，那么一定无解。否则，一定有解。</p><p>证明：由于每个节点最多在 dominoes中出现两次，所以每个节点至多存在两条边。因此，如果 <spanclass="math inline">\(x\)</span>只有一个节点，那么显然是对的，否则由于最长路径上，除了 <spanclass="math inline">\(x\)</span>和最后一个点之外，每个点有连接了两条边，所以 <spanclass="math inline">\(x\)</span>的另一条路径一定只连接了一个点——路径末尾的点，显然也是合法的。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n;vector&lt;<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(y)+<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();p[x].<span class="hljs-built_in">push_back</span>(y), p[y].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">if</span>(x==y||p[x].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>||p[y].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>) fg=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]&amp;&amp;<span class="hljs-built_in">dfs</span>(i)%<span class="hljs-number">2</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="f.-equate-multisets">F. Equate Multisets</h1><h2 id="分析-4">分析</h2><p>注意到对于一个奇数，如果把它除以 <spanclass="math inline">\(2\)</span>下取整，那么这个奇数将不复存在。换句话说，对于偶数，两个操作是可逆的，对于奇数则是不可逆的。</p><p>因此，对于 <span class="math inline">\(2 \mid a_i\)</span>，将 <spanclass="math inline">\(a_i\)</span> 不断除以二使得 <spanclass="math inline">\(a_i\)</span> 是个奇数并加入集合。</p><p>这样做之后，如果 <span class="math inline">\(b\)</span> 能够和 <spanclass="math inline">\(a\)</span>完全相同，那么一定也能变成集合内的数。</p><p>对于 <span class="math inline">\(b_i\)</span>，如果 <spanclass="math inline">\(b_i\)</span> 不在集合中，那么不断将 <spanclass="math inline">\(b_i\)</span> 除以 <spanclass="math inline">\(2\)</span> 下取整，如果直到 <spanclass="math inline">\(b_i = 0\)</span>时仍然没有在集合中出现过，那么就无解。否则有解。</p><p>正确性显然。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N], b[N];multiset&lt;<span class="hljs-keyword">int</span>&gt; st;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();st.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(a[i]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) a[i]/=<span class="hljs-number">2</span>;st.<span class="hljs-built_in">insert</span>(a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(b[i]&amp;&amp;!st.<span class="hljs-built_in">count</span>(b[i])) b[i]/=<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(!b[i]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">else</span> st.<span class="hljs-built_in">erase</span>(st.<span class="hljs-built_in">find</span>(b[i]));&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="g.-passable-paths">G. Passable Paths</h1><h2 id="分析-5">分析</h2><p>CF 题面给的图都挺好用的（</p><p><img src="https://s2.loli.net/2022/08/17/lytTnbmQvXoSWzi.png" srcset="/img/loading.gif" lazyload /></p><p>对于一个集合 <spanclass="math inline">\(p\)</span>，如果能够满足条件，那么将 <spanclass="math inline">\(p\)</span>按照深度排序之后，所有节点一定依次分布在一条简单路径上。</p><p>先考虑一条深度单调减的链，举个例子 <spanclass="math inline">\(\{5,4,2,1\}\)</span>，它满足深度最大的节点 <spanclass="math inline">\(5\)</span> 和其他任何一个节点 <spanclass="math inline">\(p_i\)</span> 的 <spanclass="math inline">\(lca\)</span> 为 <spanclass="math inline">\(p_i\)</span>。</p><p>然后是深度不单调减的链，举个例子 <span class="math inline">\(\{5,4,2,3\}\)</span>。</p><p>一个想法是找到直径的两端，然后拆成两条链，满足深度单调，分别判断即可，例中为判断<span class="math inline">\(\{5,4\}\)</span> 和 <spanclass="math inline">\(\{3,2\}\)</span>。 具体做法见代码。</p><p>有一种特殊情况，<span class="math inline">\(lca\)</span>的父亲节点也在其中，那么这个做法就会 fAKe掉。一种简单的办法就是判断一下直径两端 <spanclass="math inline">\(lca\)</span>的深度是否小于等于深度最小的节点的深度。</p><h2 id="code-6">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, q, p[N], dep[N], f[N][<span class="hljs-number">19</span>];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>;f[x][<span class="hljs-number">0</span>]=fa;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">18</span>;++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">18</span>;~i;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];<span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> dep[x]&gt;dep[y]; &#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">addedge</span>(x,y);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) p[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+m+<span class="hljs-number">1</span>,cmp);<span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(m+<span class="hljs-number">5</span>)</span></span>;s[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-keyword">if</span>(<span class="hljs-built_in">lca</span>(p[<span class="hljs-number">1</span>],p[i])==p[i]) s[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 满足这个条件，说明p[i]和p[1]在一条链上</span><span class="hljs-keyword">while</span>(pos&lt;=m&amp;&amp;s[pos]) ++pos;        <span class="hljs-comment">// 为什么出现了lca(p[1],p[i])!=p[i]? 因为到了另一条链上了</span>        <span class="hljs-comment">// 由于深度已经排序，pos就是另一个端点</span><span class="hljs-keyword">if</span>(pos==m+<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-comment">// 如果pos==m+1，说明深度单调</span>s[pos]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos+<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-keyword">if</span>(<span class="hljs-built_in">lca</span>(p[pos],p[i])==p[i]) s[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 从另一个端点开始判断</span><span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) ans&amp;=s[i];ans&amp;=dep[<span class="hljs-built_in">lca</span>(p[<span class="hljs-number">1</span>],p[pos])]&lt;=dep[p[m]];        <span class="hljs-comment">// 特判</span><span class="hljs-keyword">if</span>(ans) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>最近公共祖先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些简单DP题</title>
    <link href="/2022/DP-solution-1/"/>
    <url>/2022/DP-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="luogu2606-排列计数">luogu2606 排列计数</h1><h2 id="分析">分析</h2><p>这个条件相当于，<span class="math inline">\([1,n]\)</span>有多少排列满足小根堆性质。</p><p>设 <span class="math inline">\(sz_i\)</span> 为以 <spanclass="math inline">\(i\)</span> 为根的子树大小。</p><span id="more"></span><p>那么 <span class="math inline">\(1\)</span> 必定填 <spanclass="math inline">\(1\)</span>，而其他节点只需要考虑相对大小，所以对于<spanclass="math inline">\(i\)</span>，只要规定了它的子节点内部到底用哪些数字，就一定存在合法方案。</p><p>设 <span class="math inline">\(f_i\)</span> 为以 <spanclass="math inline">\(i\)</span> 为根的子树的方案数，那么 <spanclass="math display">\[f_i = C_{sz_i - 1} ^{sz_{2i}} \cdot f_{2i} \cdot f_{2i + 1}\]</span> 对于 <span class="math inline">\(i &gt; n\)</span>，规定 <spanclass="math inline">\(f_i = 1\)</span>。</p><p>数据很弱，貌似不必使用 lucas 定理。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">6</span>;ll n, p, sz[N&lt;&lt;<span class="hljs-number">1</span>], fac[N], f[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;    ll z=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%p,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) z=z*x%p;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n,ll m)</span> </span>&#123;    <span class="hljs-keyword">return</span> fac[n]*<span class="hljs-built_in">fp</span>(fac[m],p<span class="hljs-number">-2</span>)%p*<span class="hljs-built_in">fp</span>(fac[n-m],p<span class="hljs-number">-2</span>)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">lucas</span><span class="hljs-params">(ll n,ll m)</span> </span>&#123;    <span class="hljs-keyword">return</span> m? <span class="hljs-built_in">lucas</span>(n/p,m/p)*<span class="hljs-built_in">C</span>(n%p,m%p)%p:<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);    fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%p;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) sz[i]=sz[i*<span class="hljs-number">2</span>]+sz[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) &#123;        f[i]=<span class="hljs-built_in">lucas</span>(sz[i]<span class="hljs-number">-1</span>,sz[i*<span class="hljs-number">2</span>]);        f[i]=f[i]*(i*<span class="hljs-number">2</span>&lt;=n? f[i*<span class="hljs-number">2</span>]:<span class="hljs-number">1</span>)%p*(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=n? f[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]:<span class="hljs-number">1</span>)%p;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>]);&#125;</code></pre></div><h1 id="luogu2467-地精部落">luogu2467 地精部落</h1><h2 id="分析-1">分析</h2><p>山脉高度亮亮不同，而且只关心相对大小，所以问题可以转化为 <spanclass="math inline">\([1,n]\)</span>的排列中，满足波浪形分布的排列的个数。</p><p>考虑“谷”必须要接在”峰“的后面，设 <spanclass="math inline">\(f_{i,j}\)</span> 表示考虑 <spanclass="math inline">\([1,i]\)</span> 的排列中，满足最后一个数为 <spanclass="math inline">\(j\)</span>且是一个”谷“的方案数。可以这样设的原因是只关心相对大小。</p><p>枚举一个 <span class="math inline">\(k \in[1,j-1]\)</span>，那么贡献为 <spanclass="math inline">\(f_{i-1,(i-1)-k+1} =f_{i-1,i-k}\)</span>。这样做的原因是，对于一个以峰结尾的合法排列，对于其中每个元素<span class="math inline">\(p_j\)</span> 都变成 <spanclass="math inline">\((i-1)-p_j+1\)</span>，就能满足以谷结尾，且仍然合法。</p><p>如果 <span class="math inline">\((i-1)-k+1 &gt; k\)</span>，那么将<span class="math inline">\(k\)</span> 接在结尾后，交换 <spanclass="math inline">\((i-1)-k+1\)</span> 和 <spanclass="math inline">\(k\)</span>，此时一定满足结尾的元素是峰，而倒数第二个元素是谷，整个序列合法。使用上述做法之后依然是合法的。否则，直接将<span class="math inline">\(k\)</span>接在结尾就是合法的，直接使用上述做法即可。</p><p>举点例子。假如 <span class="math inline">\(k=2\)</span>，<spanclass="math inline">\(i=5\)</span>。那么 <span class="math inline">\(i-k= 3\)</span>，把 <span class="math inline">\(i-k\)</span>接在后面，假设此时排列为 <spanclass="math inline">\(4,3,2\)</span>，交换 <spanclass="math inline">\(3,2\)</span> 后的 <spanclass="math inline">\(4,2,3\)</span> 使用上述方法变成 <spanclass="math inline">\(1,3,2\)</span>，满足条件。如果 <spanclass="math inline">\(k=3\)</span>，其他条件不变，那么排列为 <spanclass="math inline">\(4,2,3\)</span>，此时使用上述方法转化成 <spanclass="math inline">\(1,3,2\)</span>，也满足条件。</p><p>那么 <span class="math display">\[f_{i,j} = \sum_{k=1}^{j-1} f_{i-1,i-k}\]</span> 复杂度为 <spanclass="math inline">\(O(n^3)\)</span>。这个式子肉眼可见很多冗余。</p><p>发现 <span class="math display">\[\sum_{k=1}^{j-1} f_{i-1,i-k} = f_{i-1,i-j+1} + \sum_{k=1}^{j-2}f_{i-1,i-k} = f_{i-1,i-j+1} + f_{i,j-1}\]</span> 于是优化到 <span class="math inline">\(O(n^2)\)</span>。</p><p>最后乘 <span class="math inline">\(2\)</span>才是总方案数，通过上述做法不难证明。</p><p>答案 <span class="math display">\[\sum_{i=1}^n f_{n,i}\]</span></p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">4205</span>;<span class="hljs-keyword">int</span> n, p, k=<span class="hljs-number">1</span>, ans, f[<span class="hljs-number">2</span>][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i,k^=<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j)        f[k][j]=(f[k][j<span class="hljs-number">-1</span>]+f[k^<span class="hljs-number">1</span>][i-j])%p;    <span class="hljs-comment">// 按理说j不能取i，但是当j=i时正好让第二项为0，第一项就相当于求了前缀和</span>    <span class="hljs-comment">// 所以f[k^1][n]就是答案</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(f[k^<span class="hljs-number">1</span>][n]*<span class="hljs-number">2</span>)%p);&#125;</code></pre></div><h1 id="luogu4644-cleaning-shifts">luogu4644 Cleaning Shifts</h1><p>将区间右端点排序。设 <span class="math inline">\(f_i\)</span> 为打扫<span class="math inline">\([1,i]\)</span> 时间段的最小花费，<spanclass="math inline">\(k\)</span> 为当前考虑到了第 <spanclass="math inline">\(k\)</span>个区间。由于每个区间必须全部打扫完，所以每头奶牛只能更新一个位置，<spanclass="math inline">\(f_{r(k)}\)</span>。 <span class="math display">\[f_{r(k)} = \min_{j \in [l(k)-1,r(k)]} \{ f_j+ c_k \}\]</span> 左右区间并不同时具有单调性，可以用线段树维护 <spanclass="math inline">\(f\)</span>。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, l, r, f[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span> <span class="hljs-keyword">int</span> l, r, z; &#125; a[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(E a,E b) &#123; <span class="hljs-keyword">return</span> a.r!=b.r? a.r&lt;b.r:a.l&lt;b.l; &#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Seg</span> &#123;</span>    <span class="hljs-keyword">int</span> l, r, z;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l(x) t[x].l</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r(x) t[x].r</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> z(x) t[x].z</span>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123; <span class="hljs-built_in">z</span>(p)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">z</span>(p&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">z</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-built_in">l</span>(p)=l, <span class="hljs-built_in">r</span>(p)=r;    <span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">z</span>(p)=f[l]; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(p&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">l</span>(p)==<span class="hljs-built_in">r</span>(p)) &#123;  <span class="hljs-built_in">z</span>(p)=y; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">int</span> mid=<span class="hljs-built_in">l</span>(p)+<span class="hljs-built_in">r</span>(p)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(p&lt;&lt;<span class="hljs-number">1</span>,x,y); <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x,y);    <span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l&lt;=<span class="hljs-built_in">l</span>(p)&amp;&amp;r&gt;=<span class="hljs-built_in">r</span>(p)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">z</span>(p);    <span class="hljs-keyword">int</span> mid=<span class="hljs-built_in">l</span>(p)+<span class="hljs-built_in">r</span>(p)&gt;&gt;<span class="hljs-number">1</span>, ans=inf;    <span class="hljs-keyword">if</span>(l&lt;=mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(p&lt;&lt;<span class="hljs-number">1</span>,l,r));    <span class="hljs-keyword">if</span>(r&gt;mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r,&amp;a[i].z);        a[i].l=<span class="hljs-built_in">max</span>(l,a[i].l), a[i].r=<span class="hljs-built_in">min</span>(r,a[i].r);    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f)), f[l<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">if</span>(a[i].l&gt;a[i].r) <span class="hljs-keyword">continue</span>;        f[a[i].r]=<span class="hljs-built_in">min</span>(f[a[i].r],<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,a[i].l<span class="hljs-number">-1</span>,a[i].r)+a[i].z);        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a[i].r,f[a[i].r]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[r]!=inf? f[r]:<span class="hljs-number">-1</span>);&#125;</code></pre></div><h1 id="luogu2018-消息传递">luogu2018 消息传递</h1><h2 id="分析-2">分析</h2><p>一个小贪心：对于 <span class="math inline">\(x\)</span> 的子节点集合<span class="math inline">\(\{y\}\)</span>，首先传达的一定是最费时间的<span class="math inline">\(y_i\)</span>，其次是次费时间的 <spanclass="math inline">\(y_i\)</span>，否则通过邻项交换一定能证明不优。</p><p>但是传达完毕的时间并不一定是最费时间的 <spanclass="math inline">\(y_i\)</span> 所花费的时间 <spanclass="math inline">\(+1\)</span>。</p><p>设 <span class="math inline">\(f_x\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树，所需要的最小时间。 <spanclass="math display">\[f_x = \max_{(x,y)} \{ f(y) + ord_y \}\]</span> 其中 <span class="math inline">\(ord_y\)</span> 表示 <spanclass="math inline">\(y\)</span> 是第几个被 <spanclass="math inline">\(x\)</span> 传达的点。</p><p>这样做复杂度是 <span class="math inline">\(O(n^2)\)</span> 的。</p><p>可以记忆化搜索。</p><p>还有一个优化空间的 Trick 就是，不是记忆化 <spanclass="math inline">\(f(x,fa_x)\)</span>，而是记忆化 <spanclass="math inline">\((fa_x \rightarrow x)\)</span>的这条边，空间复杂度降为 <span class="math inline">\(O(n)\)</span>。</p><h1 id="luogu1385-密令">luogu1385 密令</h1><h2 id="分析-3">分析</h2><p>注意到字典序总和不变。</p><p>设 <span class="math inline">\(f_{i,k}\)</span> 为长度为 <spanclass="math inline">\(i\)</span>，字典序总和为 <spanclass="math inline">\(k\)</span> 的字符串数量。</p><p>小把戏。</p><h1 id="cf106c-buns">CF106C Buns</h1><h2 id="分析-4">分析</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 种馅料，剩下 <spanclass="math inline">\(j\)</span> 克面粉的最大收益。</p><p>做多重背包即可。</p><p>统计答案时，枚举 <span class="math inline">\(i\)</span>，取 <spanclass="math inline">\(f_{n,i} + \frac{n-i}{c_0} \cdot d_0\)</span>的最大值即可。</p><h1 id="luogu2059-卡牌游戏">luogu2059 卡牌游戏</h1><h2 id="分析-5">分析</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为剩下 <spanclass="math inline">\(i\)</span> 个人，其中编号相对大小排第 <spanclass="math inline">\(j\)</span> 的玩家坐庄的胜率。</p><p><span class="math inline">\(f_{1,1}= 1\)</span>，推就行了。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">60</span>;<span class="hljs-keyword">int</span> n, m, c[N];<span class="hljs-keyword">double</span> f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i]);f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;++k) &#123;<span class="hljs-keyword">int</span> p=c[k]%i? c[k]%i:i;<span class="hljs-keyword">if</span>(p&lt;j) f[i][j]+=f[i<span class="hljs-number">-1</span>][j-p]/m;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&gt;j) f[i][j]+=f[i<span class="hljs-number">-1</span>][i-p+j]/m;            <span class="hljs-comment">// p=j时他自己就死了，贡献为0</span>&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%% &quot;</span>,f[n][i]*<span class="hljs-number">100</span>);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h1 id="luogu3287-方伯伯的玉米田">luogu3287 方伯伯的玉米田</h1><h2 id="分析-6">分析</h2><p>每次拔高的一定是一段后缀，否则一定不优。这句话也变相说明了，对于一次拔高操作<span class="math inline">\([i,n]\)</span>，能对答案产生影响的只有 <spanclass="math inline">\(i\)</span> 能否接在之前的某处。</p><p>如果拔高的是 <spanclass="math inline">\([i,n]\)</span>，那么最终最长不下降子序列中必然包含<span class="math inline">\(i\)</span>，否则这个操作无用。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为中 <spanclass="math inline">\(i\)</span> 已经被拔高了 <spanclass="math inline">\(j\)</span> 次，以 <spanclass="math inline">\(i\)</span> 结尾的最长不下降子序列长度。 <spanclass="math display">\[f_{i,j} = \max_{k \in [1,i-1], l \in[0,j]} \{ f_{k,l} \} + 1\]</span> 其中必须满足 <span class="math inline">\(h_i + j \ge h_k +l\)</span>。</p><p>可以用二维树状数组维护前缀最大值，一维是 <spanclass="math inline">\(h_i + j\)</span>，另一维是 <spanclass="math inline">\(j\)</span>。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">505</span>;<span class="hljs-keyword">int</span> n, m, mx, ans, a[N], f[N][M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=mx+m;i+=(i&amp;-i)) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=y;j&lt;=m+<span class="hljs-number">1</span>;j+=(j&amp;-j))        f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],z);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i;i-=(i&amp;-i)) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=y;j;j-=(j&amp;-j)) ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), mx=<span class="hljs-built_in">max</span>(mx,a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;--j) &#123;        <span class="hljs-comment">// 没有储存阶段的信息，滚动数组</span>        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">query</span>(a[i]+j,j+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;        <span class="hljs-comment">// j+1防止0下标</span>        ans=<span class="hljs-built_in">max</span>(ans,k);        <span class="hljs-built_in">modify</span>(a[i]+j,j+<span class="hljs-number">1</span>,k);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>概率论</tag>
      
      <tag>线段树</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#814 (Div 2)</title>
    <link href="/2022/cf1719-solution/"/>
    <url>/2022/cf1719-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1719</strong>.</p><span id="more"></span><h1 id="a.-chip-game">A. Chip Game</h1><h2 id="分析">分析</h2><p>根据 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(m\)</span> 的奇偶性判断即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n, m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(m%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Burenka&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Tonya&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Tonya&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Burenka&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-mathematical-circus">B. Mathematical Circus</h1><h2 id="分析-1">分析</h2><p>如果 <span class="math inline">\(k\)</span>是奇数，那么奇数加奇数为偶数，最小是 <spanclass="math inline">\(2\)</span>，而最小的偶数也是 <spanclass="math inline">\(2\)</span>，因此只要将奇数 <spanclass="math inline">\(i\)</span> 和偶数 <spanclass="math inline">\(i+1\)</span> 配对即可。</p><p>否则，如果 <span class="math inline">\(k \equiv 2 \pmod4\)</span>，那么只要将一个模 <span class="math inline">\(4\)</span> 为<span class="math inline">\(2\)</span> 的偶数加上 <spanclass="math inline">\(k\)</span>，就一定是 <spanclass="math inline">\(4\)</span> 的倍数，与任意奇数配对即可。</p><p>否则，一定有 <span class="math inline">\(4 \midk\)</span>，因此原来不是 <span class="math inline">\(4\)</span>的倍数的数无法转化成 <span class="math inline">\(4\)</span>的倍数，最终一定存在若干奇数无法配对。无解</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,i,i+<span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k%<span class="hljs-number">4</span>==<span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">bool</span> cur=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(!cur) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,i+<span class="hljs-number">1</span>,i);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,i,i+<span class="hljs-number">1</span>);cur^=<span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-fighting-tournament">C. Fighting Tournament</h1><h2 id="分析-2">分析</h2><p>很容易预处理出前 <span class="math inline">\(n\)</span> 局比赛中，第<span class="math inline">\(i\)</span> 个人赢了的比赛。</p><p>注意到 <span class="math inline">\(\{a\}\)</span>是一个排列，那么比完前 <span class="math inline">\(n\)</span>局后，最终一定是能力为 <span class="math inline">\(n\)</span>的人在队头，且其他人不会再赢任何一场比赛，胜利者只会是他。</p><p>模拟这个过程即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, q, a[N];vector&lt;<span class="hljs-keyword">int</span>&gt; p[N];deque&lt;<span class="hljs-keyword">int</span>&gt; d;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pf push_front</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();d.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), d.<span class="hljs-built_in">pb</span>(i), p[i].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=d.<span class="hljs-built_in">front</span>(); d.<span class="hljs-built_in">pop_front</span>();<span class="hljs-keyword">int</span> y=d.<span class="hljs-built_in">front</span>(); d.<span class="hljs-built_in">pop_front</span>();<span class="hljs-keyword">if</span>(a[x]&lt;a[y]) <span class="hljs-built_in">swap</span>(x,y);d.<span class="hljs-built_in">pf</span>(x), d.<span class="hljs-built_in">pb</span>(y);p[x].<span class="hljs-built_in">pb</span>(i);&#125;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">upper_bound</span>(p[x].<span class="hljs-built_in">begin</span>(),p[x].<span class="hljs-built_in">end</span>(),k)-p[x].<span class="hljs-built_in">begin</span>();        <span class="hljs-comment">// p[x]是有序的，可以二分查找</span><span class="hljs-keyword">if</span>(a[x]==n&amp;&amp;k&gt;n) ans+=k-n;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-burenka-and-traditions">D. Burenka and Traditions</h1><h2 id="分析-3">分析</h2><p>虽然代价式子看起来复杂，但是不难发现，处理区间长度为 <spanclass="math inline">\(1,2\)</span> 时，代价为 <spanclass="math inline">\(1\)</span>，长度为 <spanclass="math inline">\(3,4\)</span> 时，代价为 <spanclass="math inline">\(2\)</span>，以此类推。因此可以看作，花费 <spanclass="math inline">\(1\)</span> 的代价，处理 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span> 个数。</p><p>因此最多操作次数为 <spanclass="math inline">\(n\)</span>，每个数异或上他自己。</p><p>设 <span class="math inline">\(f_i\)</span> 为将 <spanclass="math inline">\([1,i]\)</span> 变成全 <spanclass="math inline">\(0\)</span> 的最小代价。</p><p>什么时候能同时处理两个数？当且仅当在 <spanclass="math inline">\(i\)</span> 时，异或前缀和 <spanclass="math inline">\(S_i\)</span> 已经出现过了，说明存在某个包含 <spanclass="math inline">\(i\)</span> 的区间的异或和为 <spanclass="math inline">\(0\)</span>。</p><p>设 <span class="math inline">\(S_j = S_i\)</span>，那么<spanclass="math inline">\([j+1,i]\)</span>每个数都出现了偶数次，通过改变异或顺序就能得到两个相同的数，消去他们代价为<span class="math inline">\(1\)</span>。 <span class="math display">\[f_{j} + i - (j+1) + 1 - 1 = f_j - j + i - 1\]</span></p><p>用<code>std::map</code>记录 <span class="math inline">\(S_j\)</span>对应的 <span class="math inline">\(f_j - j\)</span> 即可。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N];set&lt;<span class="hljs-keyword">int</span>&gt; st;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> suf=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;st.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!a[i]||st.<span class="hljs-built_in">count</span>(a[i]^suf)) st.<span class="hljs-built_in">clear</span>(), st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>), suf=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> st.<span class="hljs-built_in">insert</span>(suf), suf^=a[i], ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e.-fibonacci-strings">E. Fibonacci Strings</h1><h2 id="分析-4">分析</h2><p>先递推斐波那契数列及其前缀和对应的项数。</p><p>对于字符总数 <spanclass="math inline">\(sum\)</span>，如果它不是斐波那契数列的某项前缀和，那么无解。</p><p>否则找到它的项数 <spanclass="math inline">\(m\)</span>，从大到小依次尝试用某一类字符取填充，如果当前最多的字符也达不到要求的个数，那么无解。使用大根堆维护。</p><p>如何处理相邻的字符不能相同？对于某一类字符的个数 <spanclass="math inline">\(x\)</span>，满足 <span class="math inline">\(x&gt; fib_i\)</span>，那么填充完之后必然剩下 <spanclass="math inline">\(x-fib_i\)</span> 个字符，将其延迟插入堆即可。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n, s, f[<span class="hljs-number">105</span>];map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">1</span>]=f[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;s=<span class="hljs-number">2</span>;p[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, p[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">100</span>;++i) &#123;f[i]=f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>];s+=f[i];p[s]=i;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();sum+=x, q.<span class="hljs-built_in">push</span>(x);&#125;<span class="hljs-keyword">int</span> m=p[sum];<span class="hljs-keyword">if</span>(!m) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i;--i) &#123;<span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(x&lt;f[i]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">if</span>(t!=<span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(t);        <span class="hljs-comment">// 延迟入堆，i=m时使用过的字符，到了i=m-2时才能使用</span>t=x-f[i];&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1334E Divisor Paths 题解</title>
    <link href="/2022/cf1344e-solution/"/>
    <url>/2022/cf1344e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>放一张题面里的图。</p><p><img src="https://s2.loli.net/2022/08/15/HuQbB3C76AJsmWR.png" srcset="/img/loading.gif" lazyload /></p><span id="more"></span><p>注意到对于给定的两个点 <span class="math inline">\((x,y)\)</span>，若<span class="math inline">\(x \nmid y\)</span> 并且 <spanclass="math inline">\(y \nmidx\)</span>，那么二者之间的最短路上节点一定是先减小再增加，换句话说，一定是分别从<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 出发，最终汇于一点。否则</p><p>对于一条节点大小递减的路径 <span class="math inline">\((x_1\rightarrow x_2 \rightarrow \cdots \rightarrow x_n)\)</span>，它的权值为<span class="math inline">\(d(x_1) - d(x_2) + d(x_2) - d(x_3) + \cdots -d(x_n) = d(x_1) -d(x_n)\)</span>。因此两点之间的路径长度，之和两个端点有关。由于 <spanclass="math inline">\((x,y)\)</span>之间的路径要汇于一点，所以这个点一定是 <spanclass="math inline">\((x,y)\)</span> 的公约数 <spanclass="math inline">\(z\)</span>，什么时候 <spanclass="math inline">\(d(x)- d(z) + d(y) - d(z)\)</span> 最小？<spanclass="math inline">\(z = \gcd(x,y)\)</span> 时。</p><p>考虑 <span class="math inline">\((x \rightarrow z)\)</span>的过程，无论怎样的走法，一定恰好消去了 <span class="math inline">\(g =\frac{x}{z}\)</span>。而每一条边只会消去一个质数，所以将 <spanclass="math inline">\(g\)</span> 分解 <span class="math display">\[g = \prod_{i=1}^k p_i^{e_i}\]</span> 每一个方案，等价于 <span class="math inline">\(p_i\)</span>的排列方式。而 <span class="math inline">\(p_i\)</span> 有 <spanclass="math inline">\(e_i\)</span> 个，根据可重集的全排列，得到方案数为<span class="math display">\[f(\frac{x}{z}) = \frac{(\sum_{i=1}^k e_i) !}{\prod_{i=1}^k (e_i!)}\]</span> 对于 <span class="math inline">\((y \rightarrowz)\)</span>，同样处理即可。最终答案为 <span class="math display">\[f(\frac{x}{z}) \cdot  f(\frac{y}{z})\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> D, q, cnt, d[<span class="hljs-number">1000</span>], fac[<span class="hljs-number">100</span>];<span class="hljs-comment">// 虽然D很大，但是质因数个数并不会很多，质因数指数的阶乘就更少了</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>, q=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i) <span class="hljs-keyword">if</span>(x%d[i]==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">int</span> e=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%d[i]==<span class="hljs-number">0</span>) x/=d[i], ++e;p+=e, (q*=fac[e])%=mod;&#125;<span class="hljs-keyword">return</span> fac[p]*<span class="hljs-built_in">fp</span>(q,mod<span class="hljs-number">-2</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;D=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=D;++i) <span class="hljs-keyword">if</span>(D%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span>(D%i==<span class="hljs-number">0</span>) D/=i;d[++cnt]=i;&#125;<span class="hljs-keyword">if</span>(D&gt;<span class="hljs-number">1</span>) d[++cnt]=D;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> z=<span class="hljs-built_in">gcd</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">calc</span>(x/z)*<span class="hljs-built_in">calc</span>(y/z)%mod);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6278 Haircut 题解</title>
    <link href="/2022/lg6278-solution/"/>
    <url>/2022/lg6278-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>一道很有趣，也很有益的题目（雾）。</p><span id="more"></span><h2 id="分析">分析</h2><p>注意到 <span class="math inline">\(a_i \in[0,N]\)</span>，这是很关键的一个点，可以从每个 <spanclass="math inline">\(a_i\)</span> 下手。</p><p>当 <span class="math inline">\(j= a_i\)</span> 时，所有大于 <spanclass="math inline">\(a_i\)</span> 的数都会等于 <spanclass="math inline">\(a_i\)</span>。也就是说，所有 <spanclass="math inline">\(a_i\)</span>作为较小数的逆序对，全部寄了。这样看起来很难下手。</p><p>可是退一步，当 <span class="math inline">\(j=a_i\)</span> 时，小于<span class="math inline">\(a_i\)</span> 的数不变，大于 <spanclass="math inline">\(a_i\)</span> 的数变为 <spanclass="math inline">\(a_i\)</span>，它们的相对大小不变。因此，当 <spanclass="math inline">\(j=a_i\)</span> 时，由大于 <spanclass="math inline">\(a_i\)</span> 的数 <spanclass="math inline">\(a_x\)</span> 和小于 <spanclass="math inline">\(a_i\)</span> 的数 <spanclass="math inline">\(a_y\)</span>，构成的逆序对 <spanclass="math inline">\((x,y)\)</span>，其中 <spanclass="math inline">\((x&lt;y)\)</span>，此时一定仍然成立。而对于由两个小于<span class="math inline">\(a_i\)</span>的数构成的逆序对，显然也成立。</p><p>所以如果以较小数为基准，设 <spanclass="math inline">\(S_{a_i}\)</span> 为 <spanclass="math inline">\([1,i-1]\)</span> 中大于 <spanclass="math inline">\(a_i\)</span> 的数的个数，那么当 <spanclass="math inline">\(j \ge a_i\)</span> 时，这些逆序对仍然成立。</p><p>而由上述讨论知道，其他的逆序对绝对不成立。</p><p>因此，用树状数组求出 <span class="math inline">\(S_{a_i}\)</span>。当<span class="math inline">\(j=t\)</span> 时，答案为 <spanclass="math inline">\(\sum_{k=0}^{t-1} S_k\)</span>。</p><p>由于树状数组下标必须为正整数，所以要平移一位。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, ans, a[N], s[N], c[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">for</span>(;x&lt;=<span class="hljs-number">1e5</span>;x+=x&amp;(-x)) c[x]+=y; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;(-x)) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>; <span class="hljs-comment">// 平移</span><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> d=n-(a[i]<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;s[a[i]]+=<span class="hljs-built_in">query</span>(d<span class="hljs-number">-1</span>);<span class="hljs-built_in">modify</span>(d,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans+=s[i<span class="hljs-number">-1</span>]);    <span class="hljs-comment">// 由于平移了一位，所以是[2,n]</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「AtCoder Beginner Contest」#264</title>
    <link href="/2022/abc264-solution/"/>
    <url>/2022/abc264-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>ABC264</strong>.</p><span id="more"></span><h1 id="a.-atcoder.substr">A. "atcoder".substr()</h1><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;string s=<span class="hljs-string">&quot;atcoder&quot;</span>;<span class="hljs-keyword">int</span> l=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, r=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(;l&lt;=r;++l) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[l]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h1 id="b.-nice-grid">B. Nice Grid</h1><p>不会结论，写了大暴力。把行折半之后大力判断。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> r=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(r&gt;=<span class="hljs-number">8</span>) r=<span class="hljs-number">16</span>-r;<span class="hljs-keyword">if</span>(r==<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">8</span>) <span class="hljs-keyword">if</span>(c&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>);<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(r&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(r==<span class="hljs-number">3</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">2</span>&amp;&amp;c!=<span class="hljs-number">14</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">5</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">2</span>&amp;&amp;c!=<span class="hljs-number">14</span>&amp;&amp;c!=<span class="hljs-number">4</span>&amp;&amp;c!=<span class="hljs-number">12</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">7</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">2</span>&amp;&amp;c!=<span class="hljs-number">14</span>&amp;&amp;c!=<span class="hljs-number">4</span>&amp;&amp;c!=<span class="hljs-number">12</span>&amp;&amp;c!=<span class="hljs-number">6</span>&amp;&amp;c!=<span class="hljs-number">10</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(r==<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">1</span>&amp;&amp;c!=<span class="hljs-number">15</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">4</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">1</span>&amp;&amp;c!=<span class="hljs-number">15</span>&amp;&amp;c!=<span class="hljs-number">3</span>&amp;&amp;c!=<span class="hljs-number">13</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">6</span>) <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">1</span>&amp;&amp;c!=<span class="hljs-number">15</span>&amp;&amp;c!=<span class="hljs-number">3</span>&amp;&amp;c!=<span class="hljs-number">13</span>&amp;&amp;c!=<span class="hljs-number">5</span>&amp;&amp;c!=<span class="hljs-number">11</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;white&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;black&quot;</span>);&#125;&#125;&#125;</code></pre></div><h1 id="c.-matrix-reducing">C. Matrix Reducing</h1><h2 id="分析">分析</h2><p>显然对于任意 <span class="math inline">\(i\)</span>，<spanclass="math inline">\(B_i\)</span> 中每一个元素都要在 <spanclass="math inline">\(A\)</span> 中某一行 <spanclass="math inline">\(j\)</span> 全部出现，且若 <spanclass="math inline">\(i&#39; &gt; i\)</span>，则 <spanclass="math inline">\(j&#39; &gt; j\)</span>。否则无解。</p><p>然后如同</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span>    <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-number">16</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span></code></pre></div><p><span class="math inline">\(B\)</span> 中每一行的元素在 <spanclass="math inline">\(A\)</span>中对应行的位置，必须完全相同。样例中都是<code>1 3 4</code>。</p><p>就这么点东西，实现的时候有亿点细节。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> n1, m1, n2, m2, a[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>], b[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>], c[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> lst;multiset&lt;<span class="hljs-keyword">int</span>&gt; st[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n1=<span class="hljs-built_in">read</span>(), m1=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m1;++j) &#123;a[i][j]=<span class="hljs-built_in">read</span>();st[i].<span class="hljs-built_in">insert</span>(a[i][j]);        <span class="hljs-comment">// multiset维护每一行出现的数字</span>&#125;n2=<span class="hljs-built_in">read</span>(), m2=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n2;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) b[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n2;++i) &#123;<span class="hljs-keyword">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=lst+<span class="hljs-number">1</span>;j&lt;=n1;++j) <span class="hljs-keyword">if</span>(st[j].<span class="hljs-built_in">count</span>(b[i][<span class="hljs-number">1</span>])) &#123;st[j].<span class="hljs-built_in">erase</span>(st[j].<span class="hljs-built_in">find</span>(b[i][<span class="hljs-number">1</span>]));            <span class="hljs-comment">// 存在第一个元素的话就尝试找所有元素</span>            <span class="hljs-comment">// 记得找完之后删除，因为可能有重复的</span><span class="hljs-keyword">bool</span> ok=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">2</span>;k&lt;=m2;++k)<span class="hljs-keyword">if</span>(!st[j].<span class="hljs-built_in">count</span>(b[i][k])) &#123; ok=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;                <span class="hljs-comment">// 有一个数字不存在，直接放弃这行</span><span class="hljs-keyword">else</span> st[j].<span class="hljs-built_in">erase</span>(st[j].<span class="hljs-built_in">find</span>(b[i][k]));<span class="hljs-keyword">if</span>(ok) &#123; fg=j; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=m1;++k) &#123;<span class="hljs-keyword">if</span>(b[i][j]==a[fg][k]) c[i][j]=k;                <span class="hljs-comment">// 记录位置</span>&#125;lst=fg;            <span class="hljs-comment">// 下一行要从fg+1开始找</span>&#125;&#125;    <span class="hljs-comment">// 下面这两块都是判断c[i][j]是否完全相同。</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n2;++i) &#123;<span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) &#123;<span class="hljs-keyword">if</span>(pre&gt;c[i][j]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">else</span> pre=<span class="hljs-built_in">max</span>(pre,c[i][j]);&#125;        <span class="hljs-comment">// 看有没有逆序对，有逆序对也是无解</span>&#125;    <span class="hljs-comment">// 看看对应位置，所有行是否相同</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m2;++j) &#123;<span class="hljs-keyword">int</span> fg=c[<span class="hljs-number">1</span>][j];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n2;++i) <span class="hljs-keyword">if</span>(c[i][j]!=fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125;</code></pre></div><h1 id="d.-redocta.swapii1">D. "redocta".swap(i,i+1)</h1><p>求逆序对个数。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;t&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">114514</span>;&#125;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;string s; cin&gt;&gt;s;s=<span class="hljs-string">&quot; &quot;</span>+s;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">7</span>;++i) a[i]=<span class="hljs-built_in">trans</span>(s[i]);<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">7</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">7</span>;++j) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;a[j]) ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="e.-blackout-2">E. Blackout 2</h1><h2 id="分析-1">分析</h2><p>经典套路，删边转化为倒序加边，于是乎问题变为维护连通性和连通块信息。</p><p>设 <span class="math inline">\(sz_i\)</span> 为连通块 <spanclass="math inline">\(i\)</span> 的大小，<spanclass="math inline">\(d_i\)</span> 为连通块 <spanclass="math inline">\(i\)</span> 包含的 power plants 的数量。</p><p>考虑合并两个连通块 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>，如果 <span class="math inline">\(d_i&gt; 0\)</span> 并且 <span class="math inline">\(d_j &gt;0\)</span>，那么合并之后不会产生任何贡献，因为在合并之前，<spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 之中的城市就已经连接到各自的 powerplants 了。</p><p>否则，如果 <span class="math inline">\(d_i =0\)</span> 且 <spanclass="math inline">\(d_j = 0\)</span>，那么合并之后也没有贡献。</p><p>当 <span class="math inline">\(d_i = 0\)</span> 且 <spanclass="math inline">\(d_j &gt; 0\)</span> 时，贡献为 <spanclass="math inline">\(sz_i\)</span>，否则为 <spanclass="math inline">\(sz_j\)</span>。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, e, Q, dlt, u[N], v[N], q[N], d[N], fa[N], sz[N], ans[N];<span class="hljs-keyword">bool</span> vv[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123;<span class="hljs-keyword">if</span>(!d[x]&amp;&amp;d[y]) dlt+=sz[x];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!d[y]&amp;&amp;d[x]) dlt+=sz[y];fa[x]=y, sz[y]+=sz[x], d[y]+=d[x];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), e=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) d[n+i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) fa[i]=i, sz[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=e;++i) &#123;u[i]=<span class="hljs-built_in">read</span>(), v[i]=<span class="hljs-built_in">read</span>();&#125;Q=<span class="hljs-built_in">read</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;++i) q[i]=<span class="hljs-built_in">read</span>(), vv[q[i]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=e;++i) <span class="hljs-keyword">if</span>(!vv[i]) <span class="hljs-built_in">merge</span>(u[i],v[i]);    <span class="hljs-comment">// 合并没有被删的边</span>ans[Q]=dlt;    <span class="hljs-comment">// ans[i]表示第i次删除之后的信息，所以只需要加边[q[2],q[Q]]即可</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Q;i&gt;<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-built_in">merge</span>(u[q[i]],v[q[i]]);ans[i<span class="hljs-number">-1</span>]=dlt;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;</code></pre></div><h1 id="f.-monochromatic-path">F. Monochromatic Path</h1><h2 id="分析-2">分析</h2><p>显然，对于一行或者一列，修改次数只有 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>。</p><p>设 <span class="math inline">\(f(i,j,p=0/1,q=0/1)\)</span> 表示，从<span class="math inline">\((1,1)\)</span> 到达 <spanclass="math inline">\((i,j)\)</span>，且第 <spanclass="math inline">\(i\)</span> 行的修改次数为 <spanclass="math inline">\(p\)</span>，第 <spanclass="math inline">\(j\)</span> 列的修改次数为 <spanclass="math inline">\(q\)</span>，所需的最小代价。</p><p>通过状态记录的信息就能得出，此时 <spanclass="math inline">\((i,j)\)</span> 的数字为 <spanclass="math inline">\(c1 = a_{i,j} \oplus p \oplusq\)</span>。顺便说一句这是因为异或是异或的逆运算，异或两次等于没异或。</p><p>同时也就得到了 <span class="math inline">\((i+1,j)\)</span> 和 <spanclass="math inline">\((i,j+1)\)</span> 的颜色 <spanclass="math inline">\(c2\)</span>，分别为 <spanclass="math inline">\(a_{i+1,j} \oplus q\)</span>，<spanclass="math inline">\(a_{i,j+1} \oplus p\)</span>。</p>这样就能够转移了。若颜色相同则代价不变，否则加上修改那一行/列的代价。 $$<span class="math display">\[\begin{cases}f(i,j,p,q) \rightarrow f(i+1,j,0,q) &amp; c1 = c2\\f(i,j,p,q) + r_{i+1} \rightarrow f(i+1,j,1,q) &amp; c1 \neq c2\end{cases}\]</span><p>$$</p><p><span class="math display">\[\begin{cases}f(i,j,p,q) \rightarrow f(i,j+1,p,0) &amp; c1=c2\\f(i,j,p,q) \rightarrow f(i,j+1,p,q) &amp; c1 \neq c2\end{cases}\]</span></p><p>最终答案 <span class="math display">\[\min_{i=0}^1 \min_{j=0}^1 \{ f(n,m,i,j) \}\]</span></p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-keyword">int</span> n, m, a[N][N], r[N], c[N];<span class="hljs-keyword">int</span> f[N][N][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,j,k) for(int i=j;i&lt;=k;++i)</span><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) r[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%1d&quot;</span>,&amp;a[i][j]);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=r[<span class="hljs-number">1</span>], f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=c[<span class="hljs-number">1</span>];f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=r[<span class="hljs-number">1</span>]+c[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 初始值</span><span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">rep</span>(p,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(q,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;=n) &#123;<span class="hljs-keyword">int</span> c1=a[i][j]^p^q, c2=a[i+<span class="hljs-number">1</span>][j]^q;<span class="hljs-keyword">if</span>(c1==c2) f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>][q]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>][q],f[i][j][p][q]);<span class="hljs-keyword">else</span> f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>][q]=<span class="hljs-built_in">min</span>(f[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>][q],f[i][j][p][q]+r[i+<span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;=m) &#123;<span class="hljs-keyword">int</span> c1=a[i][j]^p^q, c2=a[i][j+<span class="hljs-number">1</span>]^p;<span class="hljs-keyword">if</span>(c1==c2) f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">0</span>],f[i][j][p][q]);<span class="hljs-keyword">else</span> f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i][j+<span class="hljs-number">1</span>][p][<span class="hljs-number">1</span>],f[i][j][p][q]+c[j+<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">1e15</span>;<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ans=<span class="hljs-built_in">min</span>(ans,f[n][m][i][j]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DP</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#813 (Div 2)</title>
    <link href="/2022/cf1712-solution/"/>
    <url>/2022/cf1712-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1712</strong>.</p><span id="more"></span><h1 id="a.-wonderful-permutation">A. Wonderful Permutation</h1><h2 id="分析">分析</h2><p>考虑到这是个排列，所以最优解一定是把 <span class="math inline">\(1\sim k\)</span> 都放在 <span class="math inline">\([1,k]\)</span>里面，因此答案是 <span class="math inline">\([1,k]\)</span> 中满足 <spanclass="math inline">\(p_i&gt;k\)</span> 的 <spanclass="math inline">\(i\)</span> 的个数。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> t, n, k, a[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-keyword">if</span>(a[i]&gt;k) ++ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-woeful-permutation">B. Woeful Permutation</h1><h2 id="分析-1">分析</h2><p>如果 <span class="math inline">\(a,b\)</span> 互质，那么 <spanclass="math inline">\(\operatorname{lcm}(a,b) = a \timesb\)</span>。</p><p>由于这是个排列，而相邻两数必定互质，所以先令 <spanclass="math inline">\(p_i = i\)</span>，从大到小贪心地两两交换即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i-=<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(a[i],a[i<span class="hljs-number">-1</span>]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-sort-zero">C. Sort Zero</h1><h2 id="分析-2">分析</h2><p>由于最终序列单调不降，所以 <span class="math inline">\(0\)</span>一定是一段前缀。</p><p>考虑如果存在由重复元素围成的峰，例如<code>1 2 1</code>，那么这一段必然全部为<spanclass="math inline">\(0\)</span>；如果存在由重复元素围成的谷，例如<code>2 1 2</code>，那么这一段也必然全部为<span class="math inline">\(0\)</span>。</p><p>以上两种情况，均可以推得那一段前缀全部为 <spanclass="math inline">\(0\)</span>。</p><p>但是，取最靠后的峰或谷的末尾，就一定可行吗？</p><p>考虑</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span></code></pre></div><p>不存在峰和谷，但是由于存在逆序对导致不满足单调不降，所以必须将这个逆序对破坏掉。</p><p>也就是说，假设 <span class="math inline">\(a_{i-1}\)</span> 和 <spanclass="math inline">\(a_i\)</span> 构成了逆序对，那么 <spanclass="math inline">\(a_{i-1}\)</span> 必须为 <spanclass="math inline">\(0\)</span>，进而 <spanclass="math inline">\([1,i-1]\)</span> 必须全为 <spanclass="math inline">\(0\)</span>。</p><p>同理</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span></code></pre></div><p>有峰有谷，但是不满足由重复元素围成。考虑到有峰有谷就一定存在逆序对，那么仍然按照上面的方法就行。</p><p>最后找到全部为 <span class="math inline">\(0\)</span> 的前缀 <spanclass="math inline">\([1,d]\)</span>，答案为 <spanclass="math inline">\([1,d]\)</span> 中不同元素的数量。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N];set&lt;<span class="hljs-keyword">int</span>&gt; s, st;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();s.<span class="hljs-built_in">clear</span>(), st.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> d=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(a[i])&amp;&amp;a[i]!=a[i<span class="hljs-number">-1</span>]) d=i;        <span class="hljs-comment">// 如果s.count(a[i])成立，说明有重复元素</span>        <span class="hljs-comment">// 如果a[i]!=a[i-1]成立，说明这两个重复元素必然构成峰或谷</span>        <span class="hljs-comment">// 重复元素相邻的情况则不用考虑</span>s.<span class="hljs-built_in">insert</span>(a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;d+<span class="hljs-number">1</span>;--i) <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>]) &#123; d=i<span class="hljs-number">-1</span>; <span class="hljs-keyword">break</span>; &#125;    <span class="hljs-comment">// 找到最后一个逆序对的位置</span><span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=d;++i) &#123;<span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(a[i])) <span class="hljs-keyword">continue</span>;++ans, st.<span class="hljs-built_in">insert</span>(a[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-empty-graph">D. Empty Graph</h1><h2 id="分析-3">分析</h2><p>一个结论：这张图的直径一定来自于两个相邻的节点。</p><blockquote><p>证明：假设直径的两个端点 <span class="math inline">\(l\)</span> 与<span class="math inline">\(r\)</span>，不满足 <spanclass="math inline">\(l+1=r\)</span>，那么将 <spanclass="math inline">\(r\)</span> 改为 <spanclass="math inline">\(r-1\)</span> 后，由于 <spanclass="math inline">\(\min_{i=l}^r{\{ a_i \}} \le\min_{i=l}^{r-1}{a_i}\)</span>，所以这时候两点之间的距离不会变小。也就是说，对于一个固定的左端点<spanclass="math inline">\(l\)</span>，不断让左右端点靠近，结果一定不会变差。</p></blockquote><p>因此可以二分直径长度 <spanclass="math inline">\(mid\)</span>，判断能否使用不超过 <spanclass="math inline">\(k\)</span>次操作使得存在某个点对之间的距离大于等于 <spanclass="math inline">\(k\)</span>。</p><p>从 <span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(i+1\)</span> 的最短路有 <spanclass="math inline">\(3\)</span> 种，一是直接走 <spanclass="math inline">\(\min(a_i,a_{i+1})\)</span>，二是从 <spanclass="math inline">\(i\)</span> 走到 <spanclass="math inline">\([i+2,n]\)</span> 中满足 <spanclass="math inline">\(a_j\)</span> 最小的 <spanclass="math inline">\(j\)</span> ，再走回 <spanclass="math inline">\(i+1\)</span>，三是从 <spanclass="math inline">\(i+1\)</span> 走到 <spanclass="math inline">\([1,i-1]\)</span> 中满足 <spanclass="math inline">\(a_j\)</span> 最小的 <spanclass="math inline">\(j\)</span> 再走回 <spanclass="math inline">\(i\)</span>。</p><p>设 <span class="math inline">\(p_i =\min_{j=1}^i{\{a_j\}}\)</span>，<span class="math inline">\(q_i =\min_{j=i}^n {\{ a_j \}}\)</span>，则第二种的长度为 <spanclass="math inline">\(2 \cdot p_{i-1}\)</span>，第三种的长度为 <spanclass="math inline">\(2 \cdot q_{i+2}\)</span>。</p><p>如何安排操作呢？仔细思考发现，操作是牵一发而动全身的。假如 <spanclass="math inline">\(a_i&lt;mid\)</span>，那么修改 <spanclass="math inline">\(a_i\)</span> 之后，必须让其他决策全部不能优于<span class="math inline">\(a_i\)</span>。即如果 <spanclass="math inline">\(a_{i+1} &lt;mid\)</span>，那么不用考虑，否则就要修改它到大于等于 <spanclass="math inline">\(a_i\)</span>。同理如果修改了 <spanclass="math inline">\(p_{i-1}\)</span>，那么还要修改其他 <spanclass="math inline">\([1,i-1]\)</span> 中满足 <spanclass="math inline">\(a_j &lt; mid\)</span> 的 <spanclass="math inline">\(j\)</span>，使得它们不对最短路产生影响。</p><p>更进一步地，所有权值小于 <span class="math inline">\(mid\)</span>的路径都要修改，而无论取哪个决策，操作数量是不会变化的。</p><p>因此设 <span class="math inline">\(c_i\)</span> 为 <spanclass="math inline">\([1,i]\)</span> 中满足 <spanclass="math inline">\(2 \cdot a_j &lt; mid\)</span> 的 <spanclass="math inline">\(j\)</span> 的个数，<spanclass="math inline">\(d_i\)</span> 为 <spanclass="math inline">\([i,n]\)</span> 中满足上述条件的 <spanclass="math inline">\(j\)</span> 的个数。对于一个点对 <spanclass="math inline">\((i,i+1)\)</span>，将这两点之间的距离作为直径的操作数是<span class="math display">\[\Delta + c_{i-1} + d_{i+2}\]</span> 其中 <span class="math inline">\(\Delta\)</span> 为 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(a_{i+1}\)</span> 中，小于 <spanclass="math inline">\(mid\)</span> 的个数。</p><p>每次二分用 <span class="math inline">\(O(n)\)</span>的时间找到最小操作数，判断是否小于等于 <spanclass="math inline">\(k\)</span> 即可。</p><p>复杂度为 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><p>另外还有排序再贪心的方法，可以参考<ahref="https://zhuanlan.zhihu.com/p/553529151">这篇博客</a>。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, k, a[N], c[N], d[N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) c[i]=d[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;c[i]=c[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*a[i]&lt;x) ++c[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) &#123;d[i]=d[i+<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*a[i]&lt;x) ++d[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> q=(a[i]&lt;x)+(a[i+<span class="hljs-number">1</span>]&lt;x);ans=<span class="hljs-built_in">min</span>(ans,q+c[i<span class="hljs-number">-1</span>]+d[i+<span class="hljs-number">2</span>]);&#125;<span class="hljs-keyword">return</span> ans&lt;=k;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1e9</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e1.-lcm-sum-easy-version">E1. LCM Sum (easy version)</h1><h2 id="分析-4">分析</h2><p>正难则反，考虑用三元组的总数减去满足 <spanclass="math inline">\(\operatorname{lcm}(i,j,k) &lt; i+j+k\)</span>的三元组的个数。</p><p>由于 <span class="math inline">\(i,j,k\)</span> 有序，设 <spanclass="math inline">\(len = r-l+1\)</span>，则总数为 <spanclass="math display">\[\frac{len(len-1)(len-2)}{P_3^3} = \frac{len(len-1)(len-2)}{6}\]</span> 考虑到 <span class="math inline">\(i &lt; j &lt;k\)</span>，那么 <span class="math inline">\(i+j+k &lt;3k\)</span>，因此 <span class="math inline">\(\operatorname{lcm}(i,j,k)&lt; 3k\)</span>，所以 <spanclass="math inline">\(\operatorname{lcm}(i,j,k)\)</span> 只能为 <spanclass="math inline">\(k\)</span> 或者 <spanclass="math inline">\(2k\)</span>。</p><p>枚举 <span class="math inline">\(k\)</span>，再枚举 <spanclass="math inline">\(2k\)</span> 的每个约数 <spanclass="math inline">\(j\)</span>，再枚举 <spanclass="math inline">\(i\)</span>，逐一判断即可。时间限制为 <spanclass="math inline">\(3.5s\)</span>，加上剪枝就能过了。</p><p>具体看代码。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, l, r;vector&lt;<span class="hljs-keyword">int</span>&gt; factor[<span class="hljs-number">2</span>*N]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> len=r-l+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> ans=(len*(len<span class="hljs-number">-1</span>)*(len<span class="hljs-number">-2</span>))/<span class="hljs-number">6</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l+<span class="hljs-number">2</span>;k&lt;=r;++k) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:factor[<span class="hljs-number">2</span>*k]) &#123;<span class="hljs-keyword">if</span>(j&lt;l||k%j&amp;&amp;<span class="hljs-number">2</span>*j&lt;=k) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 不在区间内的就不要了</span>            <span class="hljs-comment">// k%j!=0，说明lcm(i,j,k)=2k</span>            <span class="hljs-comment">// 如果2*j&lt;=k，那么由于i&lt;j，所以i+j&lt;k，所以i+j+k&lt;2k，也就是lcm(i,j,k)&gt;i+j+k</span>            <span class="hljs-comment">// 矛盾</span><span class="hljs-keyword">if</span>(j&gt;=k) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:factor[<span class="hljs-number">2</span>*k]) &#123;<span class="hljs-keyword">if</span>(i&lt;l) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(i&gt;=j) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(k%j||k%i) ans-=(<span class="hljs-number">2</span>*k)&lt;(i+j+k);                <span class="hljs-comment">// 任何一个成立，说明lcm(i,j,k)=2k，直接判断</span><span class="hljs-keyword">else</span> --ans;                <span class="hljs-comment">// 否则lcm(i,j,k)=k，一定小于i+j+k</span>&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4e5</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*i;j&lt;=<span class="hljs-number">4e5</span>;j+=i)factor[j].<span class="hljs-built_in">push_back</span>(i);    <span class="hljs-comment">// O(nlogn)的时间里求出[1,n]中每个数的约数</span>t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NowCoderX54F 题解</title>
    <link href="/2022/ncx54f-solution/"/>
    <url>/2022/ncx54f-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>先给一组官方题解的数据。</p><span id="more"></span><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">10</span> <span class="hljs-number">10</span><span class="hljs-number">10</span> <span class="hljs-number">19</span> <span class="hljs-number">18</span> <span class="hljs-number">17</span> <span class="hljs-number">16</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span> <span class="hljs-number">13</span> <span class="hljs-number">12</span> <span class="hljs-number">10</span></code></pre></div><p>先考虑特殊情况，对于每个 <spanclass="math inline">\(i\)</span>，要求从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(i\)</span> 再到 <spanclass="math inline">\(n\)</span> 的最短路长度为 <spanclass="math inline">\(d_i\)</span>。那么当 <spanclass="math inline">\(i=1\)</span> 或者 <spanclass="math inline">\(i=n\)</span> 时，都相当于 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的最短路。于是 <spanclass="math inline">\(d_1\)</span> 必须等于 <spanclass="math inline">\(d_n\)</span>，且二者必须为 <spanclass="math inline">\(\min_{i=1}^n{\{d_i\}}\)</span>，否则一定无解。</p><p>于是乎我们就能搞出第一条边。</p><p><img src="https://s2.loli.net/2022/08/14/DXKlfk1MjiPTYOa.png" srcset="/img/loading.gif" lazyload /></p><p>从 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(i\)</span> 再到 <spanclass="math inline">\(n\)</span>，一种做法是将 <spanclass="math inline">\(i\)</span> 作为一个中转点，单纯地 <spanclass="math inline">\(1 \rightarrow i \rightarrown\)</span>，另一种做法是 <span class="math inline">\(1 \rightarrow i\rightarrow 1 \rightarrow n\)</span>。后者的好处就是，<spanclass="math inline">\((1 \rightarrow i)\)</span> 走了两遍，如果 <spanclass="math inline">\(d_i - d_1\)</span>是个偶数，那么这就很好构造了。直接连接 <spanclass="math inline">\((1,i)\)</span>，权值为 <spanclass="math inline">\(\frac{d_i-d_1}{2}\)</span>。</p><p>形成一个大菊花。</p><p><img src="https://s2.loli.net/2022/08/14/G9xnosaItbSVvk6.png" srcset="/img/loading.gif" lazyload /></p><p>那么剩下的只有 <span class="math inline">\(2 \nmid d_i - d_1\)</span>的情况了，我们可以尝试上述第一种做法，把 <spanclass="math inline">\(i\)</span> 作为一个中转点，连边 <spanclass="math inline">\((1,i)\)</span>，<spanclass="math inline">\((i,n)\)</span>。这时候突然发现，如果 <spanclass="math inline">\((1,i)\)</span> 的权值 <spanclass="math inline">\(\Delta\)</span> 为奇数，剩下的点 <spanclass="math inline">\(j\)</span> 一定有 <span class="math inline">\(2\mid d_j - d_1 - \Delta\)</span>，于是就能将剩下的点连到 <spanclass="math inline">\(i\)</span>上，再用上面的方法了。为了防止负权，这个 <spanclass="math inline">\(i\)</span> 一定满足 <spanclass="math inline">\(d_i - d_1\)</span> 最小。</p><p><img src="https://s2.loli.net/2022/08/14/wOqJLPbCK8ym6tS.png" srcset="/img/loading.gif" lazyload /></p><p>那么如何取值最优呢？首先从 <span class="math inline">\(1\)</span>经过 <span class="math inline">\(i\)</span>的道路不止一条，就比如图中还有 <span class="math inline">\(1 \rightarrow8 \rightarrow 1 \rightarrow 10\)</span>，<span class="math inline">\(1\rightarrow 10 \rightarrow 8 \rightarrow 10\)</span>。如果 <spanclass="math inline">\(1 \rightarrow 8 \rightarrow 10\)</span>不是最优的话，那么这个方法就死掉了。</p><p>可是构造题只关注可行性，所以要想办法让 <span class="math inline">\(1\rightarrow i \rightarrow n\)</span>最优。注意到其他两种方法，本质上就是走了一遍 <spanclass="math inline">\(d_1\)</span>，走了两遍 <spanclass="math inline">\(1 \rightarrow i\)</span> 或者 <spanclass="math inline">\(i \rightarrow n\)</span>。</p><p>由于 <span class="math inline">\(d_i\)</span> 是个大于等于 <spanclass="math inline">\(d_1\)</span> 且与 <spanclass="math inline">\(d_1\)</span> 奇偶性不同的数，所以 <spanclass="math inline">\(d_i &gt; d_1\)</span>，当边权取 <spanclass="math inline">\(\lfloor \frac{d_i}{2} \rfloor\)</span> 和 <spanclass="math inline">\(\lfloor \frac{d_i}{2} \rfloor + 1\)</span>时，走两遍后，最短也是 <span class="math inline">\(d_i -1\)</span>。因此，这种情况下，只要满足 <span class="math inline">\(d_1 +d_i -1 \ge d_i\)</span>，就能保证 <span class="math inline">\(1\rightarrow i \rightarrow n\)</span> 的走法是最优的。上式解得 <spanclass="math inline">\(d_1 \ge 1\)</span>。</p><p><img src="https://s2.loli.net/2022/08/14/a9Lpl61cZOmbVnK.png" srcset="/img/loading.gif" lazyload /></p><p>如果 <span class="math inline">\(d_1 = 0\)</span> 且存在满足 <spanclass="math inline">\(2 \nmid d_i - d_1\)</span> 的 <spanclass="math inline">\(i\)</span>，这种构造思路就失效了。</p><p>设满足 <span class="math inline">\(2 \nmid d_i - i\)</span>的点为奇点 <span class="math inline">\(odd\)</span>，其余为偶点 <spanclass="math inline">\(even\)</span>，这样使用的边数为 <spanclass="math inline">\(1+even + (1 + odd) =n\)</span>，如果不存在奇点，那么就是 <spanclass="math inline">\(1+even\)</span>。</p><p>剩下的边权用 <span class="math inline">\(10^9\)</span>即可，因为这样不会影响到最短路。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, mn=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, d[N];vector&lt;<span class="hljs-keyword">int</span>&gt; odd, even;set&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; s;<span class="hljs-comment">// 用set判断是否存在</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> d[x]&lt;d[y]; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,x,y,z);s.<span class="hljs-built_in">insert</span>(&#123;x,y&#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;mn=<span class="hljs-built_in">min</span>(d[i]=<span class="hljs-built_in">read</span>(),mn);<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;i&lt;n) &#123;<span class="hljs-keyword">if</span>((d[i]-d[<span class="hljs-number">1</span>])&amp;<span class="hljs-number">1</span>) odd.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">else</span> even.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;<span class="hljs-keyword">int</span> nd=<span class="hljs-number">1</span>+even.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span>(odd.<span class="hljs-built_in">size</span>()) nd+=odd.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(m&gt;n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>||nd&gt;m||d[<span class="hljs-number">1</span>]!=d[n]||d[<span class="hljs-number">1</span>]!=mn||d[n]!=mn||(!mn&amp;&amp;odd.<span class="hljs-built_in">size</span>()))    <span class="hljs-comment">// 如果m超过了完全图的边数，显然也无解</span>&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,n,d[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:even) <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,x,(d[x]-d[<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>);<span class="hljs-keyword">if</span>(odd.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-built_in">sort</span>(odd.<span class="hljs-built_in">begin</span>(),odd.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-keyword">int</span> a=odd[<span class="hljs-number">0</span>];<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,a,d[a]/<span class="hljs-number">2</span>+d[a]%<span class="hljs-number">2</span>);<span class="hljs-built_in">add</span>(a,n,d[a]/<span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;odd.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">int</span> b=odd[i];<span class="hljs-built_in">add</span>(a,b,(d[b]-d[a])/<span class="hljs-number">2</span>);&#125;&#125;m-=nd;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n&amp;&amp;m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) &#123;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(&#123;j,i&#125;)) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 注意是&#123;j,i&#125;</span><span class="hljs-built_in">add</span>(j,i,<span class="hljs-number">1e9</span>);<span class="hljs-keyword">if</span>(--m==<span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> end;&#125;end:;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NowCoder Round X」#54 题解</title>
    <link href="/2022/ncx54-solution/"/>
    <url>/2022/ncx54-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>NowCoderX54</strong>.</p><span id="more"></span><h1 id="a.-sum">A. Sum</h1><h2 id="分析">分析</h2><p>引理：在最优解中，每次操作的 <spanclass="math inline">\(k=2\)</span>。</p><blockquote><p>证明：反证法。假设最优解中，存在一次操作 <spanclass="math inline">\(k \neq 2\)</span>。那么 <spanclass="math inline">\(k \ge 3\)</span>，当 <spanclass="math inline">\(k=3\)</span> 时，设选择的数为 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<spanclass="math inline">\(c\)</span>，那么会得到 <spanclass="math inline">\(a+b+c\)</span>，收益为 <spanclass="math inline">\(a+b+c\)</span>。如果先选择 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 得到 <spanclass="math inline">\(a+b\)</span>，再选择 <spanclass="math inline">\(a+b\)</span> 与 <spanclass="math inline">\(c\)</span>，那么会得到 <spanclass="math inline">\(a+b+c\)</span>，收益为 <spanclass="math inline">\((a+b)+(a+b+c)\)</span>。这与最优解矛盾。由于操作次数没有限制，所以引理显然成立。</p></blockquote><p>引理：在最优解中，一定先选择较大的数，再选择较小的数。</p><blockquote><p>证明：感性理解。如果选择了最大的数和一个正数，那么它被删去之后会在另一个更大数之内，此后只要选这个更大的数，原先最大的数就会不断产生贡献。如果一开始选的数不是最大的数，显然不优。</p></blockquote><p>将数列递减排序，维护前缀和 <spanclass="math inline">\(pre\)</span>，对于 <span class="math inline">\(i&gt; 1\)</span>，先令 <span class="math inline">\(pre +a_i\)</span>，如果此时 <span class="math inline">\(pre &gt;0\)</span>，那么累加答案即可。</p><p><span class="math inline">\(pre\)</span>其实是此时数列里最大的数。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> t, n, a[N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x&gt;y; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<span class="hljs-keyword">int</span> pre=a[<span class="hljs-number">1</span>], ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;pre+=a[i];<span class="hljs-keyword">if</span>(pre&gt;<span class="hljs-number">0</span>) (ans+=pre)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-gaming">B. Gaming</h1><h2 id="分析-1">分析</h2><p>将 <span class="math inline">\((l_i,r_i,s_i)\)</span> 看作是让 <spanclass="math inline">\([l_i,r_i]\)</span> 都加上 <spanclass="math inline">\(s_i\)</span>，那么对于每一个位置 <spanclass="math inline">\(i\)</span>，表示的就是必须带着第 <spanclass="math inline">\(i\)</span> 个 debuff 才能拿到的总分数，设为 <spanclass="math inline">\(c_i\)</span>。</p><p>设总分数为 <span class="math inline">\(S\)</span>，那么没有带着所有debuff 获得的最大的分，相当于带着 <spanclass="math inline">\(m-1\)</span> 个 debuff 的最大得分。</p><p>于是乎答案为 <span class="math inline">\(\max_{i=1}^m \{ S - c_i\}\)</span>。</p><p>差分维护即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, ans, sum, c[N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> l=<span class="hljs-built_in">read</span>(), r=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();c[l]+=s, c[r+<span class="hljs-number">1</span>]-=s;sum+=s;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;c[i]+=c[i<span class="hljs-number">-1</span>];ans=<span class="hljs-built_in">max</span>(ans,sum-c[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="c.-school">C. School</h1><h2 id="分析-2">分析</h2><p>这个也可以差分，可是值域很大，一种方法是离散化。</p><p>将几时几分转化为分钟，对于每一个禁止通话的时间段 <spanclass="math inline">\([l_i,r_i]\)</span>，在 <spanclass="math inline">\(l_i\)</span> 处 <spanclass="math inline">\(+1\)</span>，在 <spanclass="math inline">\(r_i+1\)</span> 处 <spanclass="math inline">\(-1\)</span>。某个时间能够通话，那么这个时间的位置必须是<span class="math inline">\(0\)</span>，否则一定被某个区间包含。</p><p>直接查 <span class="math inline">\(x\)</span> 的位置是否为 <spanclass="math inline">\(0\)</span>，这是差分做法。</p><p>但是还有一个更简单的方法。</p><p>不被任何区间包含，也就是说，<span class="math inline">\(x\)</span>经过起点 <span class="math inline">\(l_i\)</span> 的个数必须等于经过终点<span class="math inline">\(r_i\)</span> 的个数。</p><p>将起点和终点分别排序，二分查找 <span class="math inline">\(x\)</span>严格大于的起点个数和严格大于的终点个数，判断是否相等即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">int</span> n, h, m, q;vector&lt;<span class="hljs-keyword">int</span>&gt; st, ed;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), h=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> x=a*m+b, y=c*m+d;st.<span class="hljs-built_in">push_back</span>(x), ed.<span class="hljs-built_in">push_back</span>(y);&#125;<span class="hljs-built_in">sort</span>(st.<span class="hljs-built_in">begin</span>(),st.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">sort</span>(ed.<span class="hljs-built_in">begin</span>(),ed.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();x=x*m+y;<span class="hljs-keyword">auto</span> d1=<span class="hljs-built_in">lower_bound</span>(st.<span class="hljs-built_in">begin</span>(),st.<span class="hljs-built_in">end</span>(),x)-st.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">auto</span> d2=<span class="hljs-built_in">lower_bound</span>(ed.<span class="hljs-built_in">begin</span>(),ed.<span class="hljs-built_in">end</span>(),x)-ed.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">if</span>(d1!=d2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125;&#125;</code></pre></div><h1 id="d.-word">D. Word</h1><h2 id="分析-3">分析</h2><p>将差异小于等于 <span class="math inline">\(1\)</span>的字符串互相连边。设 <span class="math inline">\(s\)</span> 为 <spanclass="math inline">\(0\)</span>，<span class="math inline">\(t\)</span>为 <span class="math inline">\(n+1\)</span>，等价于求出 <spanclass="math inline">\(0 \sim n+1\)</span> 的最短路。</p><p>BFS 即可，过程中记录方案。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">20005</span>;<span class="hljs-keyword">int</span> n, m, d[N], pre[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">char</span> s[N][<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diff</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s1,<span class="hljs-keyword">char</span>* s2)</span> </span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cnt+=(s1[i]!=s2[i]);<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(~d[y]) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;pre[y]=x;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(!x) &#123; <span class="hljs-built_in">puts</span>(s[x]+<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">print</span>(pre[x]);<span class="hljs-built_in">puts</span>(s[x]+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,s[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>,s[n+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">diff</span>(s[i],s[j])&lt;=<span class="hljs-number">1</span>) <span class="hljs-built_in">addedge</span>(i,j);&#125;<span class="hljs-built_in">bfs</span>();<span class="hljs-keyword">if</span>(!d[n+<span class="hljs-number">1</span>]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(~d[n+<span class="hljs-number">1</span>]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,d[n+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">goto</span> end; &#125;<span class="hljs-built_in">print</span>(n+<span class="hljs-number">1</span>);end:;&#125;</code></pre></div><h1 id="d.-slash">D. Slash</h1><h2 id="分析-4">分析</h2><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为当前在矩阵的 <spanclass="math inline">\((i,j)\)</span>，匹配到了 <spanclass="math inline">\(s_k\)</span>，这个字符串含有 <spanclass="math inline">\(s\)</span> 的最大值。</p><p>当 <span class="math inline">\(a_{i,j} = s_k\)</span> 时 <spanclass="math display">\[f(i,j,k) = \max_{k \in [1,|s|]}{\{ f(i-1,j,k-1),f(i,j-1,k) \}}\]</span> 如果 <span class="math inline">\(a_{i,j}\)</span> 匹配到了<span class="math inline">\(s\)</span> 的最后一位，那么下一步就要从<span class="math inline">\(0\)</span> 开始匹配 <spanclass="math display">\[f(i,j,0) = f(i,j,|s|) + 1\]</span> 之前状态的任何局面都有可能从 <spanclass="math inline">\(0\)</span> 重新开始匹配，所以 <spanclass="math display">\[f(i,j,0) = \max_{k \in [0,|s|]} {\{ f(i-1,j,k),f(i,j-1,k) \}}\]</span> 初始值乱搞就行了。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-keyword">int</span> n, m, l, f[N][N][N];<span class="hljs-keyword">char</span> s[N], a[N][N];<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>), l=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a[i]+<span class="hljs-number">1</span>);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=l;++k) &#123;<span class="hljs-keyword">if</span>(a[i][j]==s[k])f[i][j][k]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][k<span class="hljs-number">-1</span>],f[i][j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>]);&#125;f[i][j][<span class="hljs-number">0</span>]=f[i][j][l]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=l;++k)f[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">0</span>],<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][k],f[i][j<span class="hljs-number">-1</span>][k]));&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=l;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][m][i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="f.-traveling">F. Traveling</h1><p>单独写了<ahref="https://yozora0908.github.io//ncx54f-solution">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>最短路</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6569 &amp; luogu6772 题解</title>
    <link href="/2022/lg6569-6772-solution/"/>
    <url>/2022/lg6569-6772-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="luogu6569-魔法值">luogu6569 魔法值</h1><h2 id="分析">分析</h2><p>天数异常大，但是节点数很小，由于异或运算满足结合律，直接考虑矩阵优化。</p><span id="more"></span><p>将初始魔法值搞成一个向量，<span class="math inline">\(n\)</span> 行<span class="math inline">\(1\)</span> 列。 <spanclass="math display">\[\begin{bmatrix}w_1\\w_2\\\vdots\\w_n\end{bmatrix}\]</span> 考虑转移矩阵 <span class="math inline">\(A\)</span>。</p><p>要达到的目的是，如果 <span class="math inline">\((i,k)\)</span>之间有边才进行运算。那么设 <span class="math inline">\(A_{i,k}\)</span>表示 <span class="math inline">\((i,k)\)</span> 是否相连。所以 <spanclass="math display">\[w&#39;_i = \bigoplus_{k=1}^n A_{i,k} \cdot w_k\]</span> 所以 <span class="math inline">\(A_{x,y} = A_{y,x} =1\)</span>。</p><p>好像就没有然后了。</p><p>因为有多次询问，直接做的话复杂度是 <span class="math inline">\(O(qn^3\log_2 k)\)</span> 的，较高。但是由于不仅做 <spanclass="math inline">\(O(n^3)\)</span> 的矩阵乘法，还要做上面那种 <spanclass="math inline">\(O(n^2)\)</span>的矩阵向量乘法，所以可以预处理矩阵次幂，对询问进行二进制拆分优化。</p><p>复杂度 <span class="math inline">\(O(n^3 + qn^2 \log_2k)\)</span>，其中 <span class="math inline">\(n^3\)</span> 带着一个<span class="math inline">\(31\)</span> 的常数。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, q, w[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mat</span> &#123;</span><span class="hljs-keyword">int</span> m[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(m)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; f, rec[<span class="hljs-number">35</span>];Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)c.m[i][j]^=a.m[i][k]*b.m[k][j];    <span class="hljs-comment">// 相较于其他矩阵优化的题目来说，n还是比较大的。</span>    <span class="hljs-comment">// 所以本人在这里没有使用惯用的 for(int i=0;i&lt;100;++i) 的方法来降低常数</span><span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">mul</span><span class="hljs-params">(Mat a,Mat b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)c.m[i][<span class="hljs-number">0</span>]^=a.m[i][k]*b.m[k][<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> c;    <span class="hljs-comment">// 这是矩阵向量乘法</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;f.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) f.m[i][<span class="hljs-number">0</span>]=w[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>;~i;--i) <span class="hljs-keyword">if</span>((x&gt;&gt;i)&amp;<span class="hljs-number">1</span>) f=<span class="hljs-built_in">mul</span>(rec[i],f);<span class="hljs-keyword">return</span> f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;        <span class="hljs-comment">// 编号为0~n-1</span>rec[<span class="hljs-number">0</span>].m[x][y]=rec[<span class="hljs-number">0</span>].m[y][x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">32</span>;++i) rec[i]=rec[i<span class="hljs-number">-1</span>]*rec[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">query</span>(x));&#125;&#125;</code></pre></div><h1 id="luogu6772-美食家">luogu6772 美食家</h1><h2 id="分析-1">分析</h2><p>先不考虑美食节的影响。</p><p>考虑到节点数和边权都很小，不妨拆点。将每个点拆为 <spanclass="math inline">\(5\)</span> 个点，其中第 <spanclass="math inline">\(5\)</span> 个点是起始点，第 <spanclass="math inline">\(1\)</span>个点是终点。这样边权就变化为了经过的节点数。也就是说，到达节点 <spanclass="math inline">\(x\)</span> 转化为到达 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(5\)</span> 个节点，而从 <spanclass="math inline">\(x\)</span> 到达 <spanclass="math inline">\(y\)</span> 权值为 <spanclass="math inline">\(z\)</span>，转化为从 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(6-z\)</span> 个节点到达 <spanclass="math inline">\(y\)</span> 的第 <spanclass="math inline">\(5\)</span> 个节点，权值全部为 <spanclass="math inline">\(1\)</span>。同时，五个节点之间边权全部为 <spanclass="math inline">\(0\)</span>。</p><p>这样做的好处就是，所谓代价，也就是天数，就转化为了阶段。</p><p>设 <span class="math inline">\(f(i,x)\)</span> 表示第 <spanclass="math inline">\(i\)</span> 天在第 <spanclass="math inline">\(x\)</span> 个城市，所能获得的最大收益。 <spanclass="math display">\[f(i+1,x) = \max_{(x,y) \in E} \{ f(i,y) + c_x \}\]</span> 边界是 <spanclass="math inline">\(f(0,1)=c_1\)</span>，其余为负无穷。</p><p>其中 <span class="math inline">\(c_x\)</span> 表示到达节点 <spanclass="math inline">\(x\)</span> 的收益。转化过来就是到达 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(5\)</span> 个节点的收益。</p><p>设 <span class="math inline">\(id(i,x)\)</span> 为 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(i\)</span> 个节点，答案为 <spanclass="math inline">\(f \big( T,id(5,1) \big)\)</span>。</p><p>但是 <span class="math inline">\(T\)</span> 太大了，又因为 <spanclass="math inline">\((\max,+)\)</span>的运算满足结合律，考虑矩阵加速。常规操作是把要转移的这个东西搞成一个向量，做<span class="math inline">\(O(n^2)\)</span> 的矩阵向量乘法，但是由于<span class="math inline">\(T\)</span>的存在，数组是开不下的，只能用滚动数组优化，这样就不能封装成向量，必须手写一个广义矩阵向量乘法了。</p><p>考虑转移矩阵 <span class="math inline">\(A\)</span>，要满足 <spanclass="math display">\[f(i+1,x) = \max_{}\{ f(i,y) + A_{y,x}  \}\]</span> 所以 <span class="math inline">\(A_{y,x}\)</span> 必须表示从<span class="math inline">\(y\)</span> 到达 <spanclass="math inline">\(x\)</span> 的收益。</p><p>所以跑个 <span class="math inline">\(A\)</span> 的 <spanclass="math inline">\(T\)</span> 次幂再乘起来就行了。</p><p>这时候考虑存在美食节，不难发现美食节 <spanclass="math inline">\(i\)</span> 仅仅对 <spanclass="math inline">\(t_i\)</span> 天的 <spanclass="math inline">\(x_i\)</span> 有效。所以可以求出 <spanclass="math inline">\(i-1\)</span> 天的状态之后，手动给 <spanclass="math inline">\(f \big(t_i,id(5,x_i) \big)\)</span> 加上 <spanclass="math inline">\(y_i\)</span>，显然不会有更优的方案了。</p><p>于是将 <span class="math inline">\(t_i\)</span>递增排序，分段处理即可。和上题处理询问相同，预处理倍增次幂，对每一段进行二进制拆分优化，做复杂度为<span class="math inline">\(O(n^2)\)</span> 的矩阵向量乘法。</p><p>如果最后答案小于 <spanclass="math inline">\(0\)</span>，那么无解。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> n, m, T, k, lim, cur, ans, w[<span class="hljs-number">256</span>], f[<span class="hljs-number">2</span>][<span class="hljs-number">256</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Festival</span> &#123;</span> <span class="hljs-keyword">int</span> t, x, y; &#125; fs[<span class="hljs-number">205</span>];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Festival a,Festival b) &#123; <span class="hljs-keyword">return</span> a.t&lt;b.t; &#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mat</span> &#123;</span><span class="hljs-keyword">int</span> m[<span class="hljs-number">256</span>][<span class="hljs-number">256</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(m)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lim;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; rec[<span class="hljs-number">35</span>];Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lim;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;lim;++k)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;lim;++j)c.m[i][j]=<span class="hljs-built_in">max</span>(c.m[i][j],a.m[i][k]+b.m[k][j]);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">30</span>;~i;--i) <span class="hljs-keyword">if</span>((x&gt;&gt;i)&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">memset</span>(f[cur^<span class="hljs-number">1</span>],<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f[cur^<span class="hljs-number">1</span>]));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;lim;++k) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;lim;++j)f[cur^<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">max</span>(f[cur^<span class="hljs-number">1</span>][j],f[cur][k]+rec[i].m[k][j]);        <span class="hljs-comment">// 广义矩阵向量乘法</span>cur^=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (i<span class="hljs-number">-1</span>)*n+j; &#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), T=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();lim=<span class="hljs-number">5</span>*n;rec[<span class="hljs-number">0</span>].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, y=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, z=<span class="hljs-built_in">read</span>();rec[<span class="hljs-number">0</span>].m[<span class="hljs-built_in">id</span>(<span class="hljs-number">6</span>-z,x)][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,y)]=w[y];        <span class="hljs-comment">// 一定要记清楚，自己的转移矩阵表示的是什么</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) fs[i].t=<span class="hljs-built_in">read</span>(), fs[i].x=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, fs[i].y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(fs+<span class="hljs-number">1</span>,fs+k+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) rec[<span class="hljs-number">0</span>].m[<span class="hljs-built_in">id</span>(i+<span class="hljs-number">1</span>,j)][<span class="hljs-built_in">id</span>(i,j)]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 拆开的点相互到达不计代价</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">30</span>;++i) rec[i]=rec[i<span class="hljs-number">-1</span>]*rec[i<span class="hljs-number">-1</span>];<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[cur][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)]=w[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-keyword">int</span> dlt=fs[i].t-fs[i<span class="hljs-number">-1</span>].t;<span class="hljs-built_in">trans</span>(dlt);f[cur][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,fs[i].x)]+=fs[i].y;&#125;<span class="hljs-keyword">if</span>(fs[k].t&lt;T) <span class="hljs-built_in">trans</span>(T-fs[k].t);    <span class="hljs-comment">// 如果还有时间就再变换</span>ans=f[cur][<span class="hljs-built_in">id</span>(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans&gt;=<span class="hljs-number">0</span>? ans:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC256G Black and White Stones 题解</title>
    <link href="/2022/abc256g-solution/"/>
    <url>/2022/abc256g-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>下面定义白色黑色石头为染白色黑色。</p><p>套路性地断环为链。如图中，把顶点拆成两个点，<spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(i&#39;\)</span>，显然 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i&#39;\)</span>的颜色必定相同，即上一条链的尾等于下一条链的首，所以每条链首尾的颜色都要记录。</p><span id="more"></span><p><img src="https://s2.loli.net/2022/08/13/2lFo64mduNpKWEI.png" srcset="/img/loading.gif" lazyload /></p><p><img src="https://s2.loli.net/2022/08/13/ulvDh5mFIis2Tet.png" srcset="/img/loading.gif" lazyload /></p><p>枚举每条链防放置石头的个数 <span class="math inline">\(k\)</span>，设<span class="math inline">\(f_{i,0/1,0/1}\)</span> 为考虑前 <spanclass="math inline">\(i\)</span>条链，它们按顺序首尾相连后形成一个长链，其中这个长链的头是黑/白色，尾是黑/白色的方案数。</p><p>只有 <span class="math inline">\(1\)</span> 条链时没有限制，相当于<span class="math inline">\(d-1\)</span>个位置（去掉首尾）染成白色，所以有 <span class="math display">\[\begin{cases}f_{1,0,0} = C_{d-1}^k\\f_{1,0,1} = f_{1,1,0} = C_{d-1}^{k-1}\\f_{1,1,1} = C_{d-1}^{k-2}\end{cases}\]</span> 考虑将 <span class="math inline">\(i-1\)</span>条链相连后，扩展成 <span class="math inline">\(i\)</span>条链的过程。一个很重要的思想是，所有的单链，本质上是相同的。</p><p>首先，对于 <span class="math inline">\(f_{i,0,0}\)</span>，必须用<span class="math inline">\(i-1\)</span> 条链相连且首是 <spanclass="math inline">\(0\)</span>的长链，接上一条首和长链的尾相同，且尾是 <spanclass="math inline">\(0\)</span> 的单链。 <span class="math display">\[f_{i,0,0} = \sum_{k=0}^1 f_{i-1,0,k} \cdot f_{1,k,0}\]</span> 对于 <spanclass="math inline">\(f_{i,1,1}\)</span>，也是差不多的。 <spanclass="math display">\[f_{i,1,1} = \sum_{k=0}^1 f_{i-1,1,k} \cdot f_{1,k,1}\]</span> 其他两种就很显然了，不再赘述。</p><p>不难发现，这个式子就是矩阵乘法的形式，正好 <spanclass="math inline">\(N\)</span> 特别大，所以可以用矩阵加速递推。</p><p>建立矩阵 <span class="math inline">\(A\)</span>。 <spanclass="math display">\[A  =\begin{bmatrix}f_{1,0,0} &amp; f_{1,0,1}\\f_{1,1,0} &amp; f_{1,1,1}\end{bmatrix}\]</span> 通过观察不难得出，求 <span class="math inline">\(i=N\)</span>时的答案，等于求 <span class="math inline">\(A^n\)</span>。</p><p>矩阵快速幂就行了。</p><p>最后，由于整个链还要接成一个环，所以首尾必须相同，即答案累加 <spanclass="math inline">\(f_{n,0,0} + f_{n,1,1}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, d, ans, c[<span class="hljs-number">10005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mat</span> &#123;</span><span class="hljs-keyword">int</span> m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(m)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; f;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;++j)(c.m[i][j]+=a.m[i][k]*b.m[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c=<span class="hljs-number">1</span>; a%=mod;<span class="hljs-keyword">for</span>(;b;a=a*a%mod,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;(d<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> c[x];&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();c[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;d;++i) c[i]=c[i<span class="hljs-number">-1</span>]*(d-i)%mod*<span class="hljs-built_in">power</span>(i,mod<span class="hljs-number">-2</span>)%mod;    <span class="hljs-comment">// 递推c[d-1][i]</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=d+<span class="hljs-number">1</span>;++i) &#123;f.<span class="hljs-built_in">clear</span>();f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">C</span>(i), f.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">C</span>(i<span class="hljs-number">-1</span>);f.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">C</span>(i<span class="hljs-number">-1</span>), f.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">C</span>(i<span class="hljs-number">-2</span>);f=<span class="hljs-built_in">fp</span>(f,n);(ans+=(f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+f.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC258Ex Odd Steps 题解</title>
    <link href="/2022/abc258-solution/"/>
    <url>/2022/abc258-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>问题可以转化为，在一个 <span class="math inline">\(1 \sim S\)</span>的数轴上，把数轴划分成段若干段，每一段的长度必须是奇数，且对于 <spanclass="math inline">\(i \in [1,n]\)</span>，不能在 <spanclass="math inline">\(a_i\)</span> 处划分。</p><span id="more"></span><p>先不考虑限制条件。</p><p>设 <span class="math inline">\(f_i\)</span> 表示划分 <spanclass="math inline">\([1,i]\)</span>，且最后一段是奇数的方案数，设 <spanclass="math inline">\(g_i\)</span> 表示划分 <spanclass="math inline">\([1,i]\)</span>，且最后一段是偶数的方案数。</p><p>考虑 <span class="math inline">\(i-1 \rightarrow i\)</span>，<spanclass="math inline">\(i\)</span> 既可以单独作为一个奇数段，又可以加入<span class="math inline">\(i-1\)</span>所在的这一段，改变这一段的奇偶性，所以 <span class="math display">\[\begin{cases}f_i = f_{i-1} + g_{i-1}\\g_i = f_{i-1}\end{cases}\]</span> 答案是 <span class="math inline">\(f_{S}\)</span>。</p><p><span class="math inline">\(S\)</span> 过大，考虑矩阵加速递推。</p><p>构造向量 <span class="math inline">\(\begin{bmatrix} f_i \\ g_i\end{bmatrix}\)</span>，初始为 <spanclass="math inline">\(\begin{bmatrix} f_1 = 1 \\ g_1 = 0\end{bmatrix}\)</span>。 设转移矩阵为 <spanclass="math inline">\(A\)</span>。 <span class="math display">\[A \begin{bmatrix} f_{i-1} \\ g_{i-1} \end{bmatrix} = \begin{bmatrix} f_i\\ g_i \end{bmatrix}\]</span> 手算不难发现 <span class="math inline">\(A = \begin{bmatrix} 1&amp; 1 \\ 1 &amp; 0\end{bmatrix}\)</span>，也就是斐波那契数列的转移矩阵。</p><p>递推第 <span class="math inline">\(n\)</span> 项，转化为用 <spanclass="math inline">\(A\)</span> 的 <spanclass="math inline">\(n-1\)</span> 次幂去变化初始向量。</p><p>如果有限制，那么 <span class="math inline">\(i-1 \rightarrowi\)</span> 的这个 <span class="math inline">\(1\)</span>就必须接在前一段，所以 <span class="math display">\[\begin{cases}f_i = g_{i-1}\\g_i = f_{i-1}\end{cases}\LongrightarrowB \begin{bmatrix} f_{i-1} \\ g_{i-1} \end{bmatrix} =  \begin{bmatrix}f_i \\ g_i \end{bmatrix}\]</span> 这个转移矩阵 <span class="math inline">\(B = \begin{bmatrix} 0&amp; 1 \\ 1 &amp; 0 \end{bmatrix}\)</span>，也就是把两项交换一下。</p><p>可以对没有限制的地方分段处理。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, s, pre;<span class="hljs-comment">// pre表示上一次递推完的那一项</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mat</span> &#123;</span><span class="hljs-keyword">int</span> m[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(m)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; rec1, rec2, f;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;++j)(c.m[i][j]+=a.m[i][k]*b.m[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">mul</span><span class="hljs-params">(Mat a,Mat b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;++k)(c.m[i][<span class="hljs-number">0</span>]+=a.m[i][k]*b.m[k][<span class="hljs-number">0</span>]%mod)%=mod;<span class="hljs-keyword">return</span> c;    <span class="hljs-comment">// 矩阵向量乘法</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>();rec1.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=rec1.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=rec1.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, rec1.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;rec2.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=rec2.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, rec2.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=rec2.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, f.m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 第1项</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> lim=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(lim&lt;=pre) <span class="hljs-keyword">continue</span>;f=<span class="hljs-built_in">mul</span>(<span class="hljs-built_in">fp</span>(rec1,lim<span class="hljs-number">-1</span>-pre),f);        <span class="hljs-comment">// 第lim项要单独处理</span>f=<span class="hljs-built_in">mul</span>(rec2,f);pre=lim;&#125;f=<span class="hljs-built_in">mul</span>(<span class="hljs-built_in">fp</span>(rec1,s-pre<span class="hljs-number">-1</span>),f);    <span class="hljs-comment">// 此时第pre项已经递推完毕，f存的是第pre+1项</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4591 碱基序列 题解</title>
    <link href="/2022/lg4591-solution/"/>
    <url>/2022/lg4591-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为使用了 <spanclass="math inline">\(i\)</span> 个串，匹配到了 <spanclass="math inline">\(S\)</span> 的前 <spanclass="math inline">\(j\)</span> 位的方案数。 <spanclass="math display">\[f_{i,j} = \sum_{S[i-m,i] = S_0} f_{i-1,i-m}\]</span> <span id="more"></span></p><p>其中 <span class="math inline">\(S_0\)</span> 表示一个匹配串，<spanclass="math inline">\(S[i-m,i]\)</span> 是这个长度为 <spanclass="math inline">\(m\)</span> 的匹配串的长度。</p><p>可以用 KMP 算法快速求出匹配串 <spanclass="math inline">\(S_0\)</span> 在 <spanclass="math inline">\(S\)</span> 中出现的所有位置，最终答案为 <spanclass="math inline">\(\sum_{i=0}^n f_{k,i}\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, m, k, ans, cur, nxt[N], f[<span class="hljs-number">105</span>][N];<span class="hljs-keyword">char</span> s[N], p[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) ++j;nxt[i]=j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) ++j;<span class="hljs-keyword">if</span>(j==m) (f[k][i]+=f[k<span class="hljs-number">-1</span>][i-m])%=mod, j=nxt[j];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;k=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>), n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-keyword">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,p+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">strlen</span>(p+<span class="hljs-number">1</span>);<span class="hljs-built_in">kmp</span>(i);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (ans+=f[k][i])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>既是交错，又是回响</title>
    <link href="/2022/memory/"/>
    <url>/2022/memory/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ebde17c3198a078f3bf88b5db461d599d22048b63f9a6496d6ac5cf4b0535856">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e133b8c40d73a2a7bcc4a1f233304a918b6be2477dcaf040c012c44fc38c39a86c76270a64455fd007e7dd9f6c937f56076cc7cfed31854eb74e6d1abcd98ac00dfa3a8f4c5ff93a40d48b41eca481dac53e82f7e4b9652a2d9b88d26ad080613b02afe01a84e53aacc27e984bd109cabb6abc57d7d0488e9753f7acad561f31eef1b34a07eb0dff02a706f973a2a9f3fb4aa1a31698953b406abbe6e31c78dc78e223ba9e7aa270fa38a22c198cbb80f095fa17e921b97a67ed431fcda7dbf6a2b71ef9ec766c3e1a9c0af0efb1c59f97d3e799f7585eb74192c27b8a31bf80bc64a5489c27411e0e3363779c52a9af78a092eb9ccc69c50263a649b143ca7514e235bb1a4ac5aa46c5d80c08cc8f80027b2905e1665bd84eb411e7a41ee2a03a52b5741ba87c48383624b64ff41a70bd0de0954cfd39da526f8b60b093547a7ea446358f841f1a2d36c4409a309b77867e008db26995e14616c04678fbef52ed0e48e0ed8b7ee22b3fe714e0fcf3ae8781a27fe81c11cc413fa1551a7bdb203c10eb41ce8dd058084e8b9e8930f3c6462e0abc3a4c1690caaf98ad9aac28e1c395c25928cec77c5ceaf3cf11efc0c5d81b2d3d17fb839116636be8c5135f99aa55761193ee7708d210ef9953a5764c870d90c90132711447edb31d8677bb5efd93a107e72a74bf36b72b0cd3a503c49ec2a5b8bbbb52a935d6a4063d20e87657ceae37e34e155e167a2731ec1768db1948540d4528c5fe6d971be71ce4dc37b3a51febf68b3c8efd5bccce2a0da39f8611d3fe54fe0734aa383734f8d1625f0b91a3422b01a03d277a414993487a1f7993898e8226aa43860583b1f29b5d988b796a71756b9301fedce177d9e9c71fd0eddedbe1438122acb3b462d5a70f9772cdb1f1a385c7ba08518616b40f89307cdf8c4229e8e4570800615a4364834d44971c5ccdbd5dbe3c147a1bad8111178891d5aa919fe806448406e91b40bca590986bedee0c7f1cb4a6470a7c5d171e4c71693aa59f280690550ac0223d954b02ddf07b1c6c7451f950fe75c9c05e12c0febac2efd3c1a37dfb2db3980465983033098b46fefb1cd5c50ee96495f67dbf68c6e8ff08e59526f03d2bf82a2404f9dc6652106bc16ef9019168c62e6ed58817ecb8fd5700ef70b37550d652a8cafc28c82426b2565a68a85b31afc72207477ea1965d2f84b102ed8be158efc40eebb41c356da401b9e5f0231547dda298697dce5af31ee26140d9dcd66b9b8ff3466e56fc946895b4b752b0dd40068edd4a22afb386571539cb9098df0a4f03c56df35143d429d8341f2b363cdf505ec74df90bff1a2f1cfe7ab50b54f8022579b93b1ed5c3a5af4b67ab86151f6d9a62da15129b108c97e8b5531132fa0306968ea05241ca441528cd6fc44d6be6474018cb16a3529e5376411623ec00364a91af8642349ca25a8feeb1d7eb33f1120261c138521369af06d90605acb6a642fcfebfe0c201f29644331865d749ad07ef77815bb371f5816d9c175fd308fba7b1a3aa7c0a79dcb3252e1dcf0c12b94b843e8cab5478a40dbaa7bf3a93ccc4f18d6ee53839abd0371cf1d6b16e36a4c40623af93637c428999bd10970cd59b9c14385d4fee0bbb59197b4fc6eb02adc35cca55ec0cb9f0fe30165e7aad0fbb24d516ab91d65b04b4683449fdfbdf886d95753a405a5abd776c60d6dc6e090a0fc0d5c5fca375882556047de8d4dc8dfcd314f8a7a571afe0ce48f4658b6c9d4640be1acf0f1665dc061371b8958ed386d10375647270ae9bc8df941f37374162032d93a6e24bc4a3590ff8f6ca60cef00cb948785e33064dad42b206260ccd6dfe39de02266b4ddca6628b3c30078827af7e7aa8c4e23cf80be4a9ada435c77515f7a1924d6bd4f8dcfd6f755d6557452f281add4c9264f0cb89a87cd5ed0101ac873a633b6ce9704262c985e64fe790d16eb9fff6ab9ca7eb5f447e454a37dcdb07e09586b1feb39db53348f0538e5125ca04d5fb288223273ed180283364125748a4285323bbe0b3545475bb6a57493cea2e5fc0b0e14584d0999dd12df9051f1014a376f37bd880568002e1d851a25b800e96f21ae874e266b39d492e166d7370ab241aa9eebcaf869e50d89fef4f9660f03fd3b72dfa964a71a9206b6c2582b53e6ee9e05ffacd15941e4ec29e1c36cc477a3a5c63b0ffcacea67b71125453163c251293727dc47570604f2fe80f4bdb1ffd5835289abc4fd10cf82d3a24ead00936852fe1d0614466c861c40163a492f163b705741980d5b2ce4a88b11d18bc37060c38584e2c37961abf6609fd919475656aba1ba41831e7a8fdf758136029fedcabe7206ce0364bda6852142aeb204ca2261a8fdc89bef5d297765fc8c6835fb1276debf3ed0fd7909f376560bde636aabc7a726c3f3a71a2e168e69751603d0b0692b94188aba127d54f600ef2a9d88a9599bad23f008d0ee2547361259ad664c66bf2ace0618d970713e849d60cc5536e0ae0d4f5d9d0e4f5d9dceed097cae1dbea8544862c4a254989430ae235a3b00f80b4b02738aabe4974ace216d1cfa67b4ac08abca41e5a847e6fe9270e04e71626375e1b342d4169e886f4c85e114fff2a33441d3df2dc193f5f150fc49145363e97f12143ec1cafdca4082c28e88e8a27157d84954dcdd387de8b0c6687b9f830f96fc0f3e26dc5a3e2185f15ea1c6bc9e40b15c4d5ab618f52c458d3208abd3762b27bc9edc8be81e3d074a3b991d4b00427fbd9e0d5d75e522be76dc9184ac7a25d70e84cb523a8cf40eeafeaac0663cbb748734361c9421492fa80fd2a5a09c7cb4c59071ad2fcd6fd064d227cdc14950ab5379dd6cae1eacf54953cc62e91f734ee0ee6207f90021d721a2fd6ab0ecb0b952039a4007e071367e49b0ad73b373f13c5c828181245f6498d5d791e706de98562a3fc0f40591c4f28acee2a907a04801f5a2464fec6c2554de220df35d1dab59ea917e2ed933655f5729479db1c07d0219f92bd4b4781bd9f4cf27cc38556b3887ab35d1ae0cd88e5f47cafa7c8e7ede92d61e6ad1f25c063322f371f6d2dcc3135f8fb4e83f2b9d79dbc4ffaf42a1a38a4a5d23c3013c1a56ecb80bbb6e6f27da1874e364c6231509af92ff9b3ecd3303c0dc0d6f3ab51a5ac69813d768e0317893e4b415b42a76fe60a85ea413e10f18918e2c76e74ffcf4654ef058361efea524819363481106c402ef53244aaae744292d0debf32686a7fd69a2e4c153253aaef3aa6838550a899aa0e001e5ff89979acec7af3dcac3928d72414094e6dd193e59586b244184411e4912deddfdabaee3273d6fa0f0a9891c2bd8e117efe2ddd96a462eb84222a4a288d0ba348677ebc14594cfb76cd24a60cad5def4176261f2c155376d8437185ec22abf3664398d7f7cd5a4359e03dcb455c125aed9f59d076d2fe2d4fee95820d8209a53f1f9f551570bf54b38fcc74bdfeaca9427715f309596da0ad76aef38cfc7203efca719e9cc87ca53dd60295b31d07982308cd55d90a32d372b3356c559515578aba04a4d3264e0f03fcbc8605cf48ecec13ff661985e08ec11c39d914d8eb857cca0d5fbdb9fecf9b06b014b665de24ce7d9c6a82e4fa44d3eab7512432000827d6e1f86c6d4ee3b790bfa080602103707d88c19a365c9419a15090493d0bd3bc1ba456a8d620663b26b7a3a935b809bd76f397d20669da3f7eaaa3fda11ca01715706472e653e124343ad88a59ebe7a2eb43f5b09886cc0ecf4fcdb786169430f74cf632e1c3012ac3aaed228697a046ae6626aa682fe09cd74b9090736bf219c9046b1a3e283156fdff3c35c13f51e85b491f456d76fa876c1bc620a15fabe66f0f0013b6c38fc914a8499c25c298f40e3b05ba19faa18c1b2d08ad5a96e1ee25fdc41eaa1cdf262e5527ab6d263fcea0595df9bcd8f02043d22e1a667b371cf8d056055a54d7bddddd233549cc03fedfe515ec9fd713b59d1b711a944b0eb41859dd89f76b86b8e17509c48de560ca6c7fc0c241379d40e21d9a9037fb4a7c417968a221ff6f160fe98836d1af8c0de0e0c255a28db48474c15dbfed3009fbb2ffeebf82dc1ef26011998dd04418c0532beb37298ecba383fba63cdde324fd880b91a4dbcceb16b6a48a00db7a0a27a0443289f4703adb4a8d659c41d9b7f4575e9990c21dafc6d654cccbe757e57b70f4d3b0b5451082e495da9f577ada37d612069ccb4e23564523d21296dd41fc34616c75affe2027ca9560ee4e661eb40865cd0b7dfb174bf95f05058f4e661ea17690defd25f08118bf73d38416d86949be83fa44c7dd98aa9fd3ebbfa76b81c844686b5b87064347a5acd41d1269fed91e2b5ccb0c8f475e18a2effc24b8fd7fd2210926a07ff93f89f4f433b27686807b82b6da054d119c65ac789df3c79441cc532a9cf95355975e67e36f1665c6d2534e8087d9e6b232690797c8c72f336cb164501eb93c00a91390ff86faa822fe776de2cf55cc9ded81f9b15af92332e614e503126014900a12dea552cad9dc0356d91d9bf2bcf7d630a0c46caacfeebdbdb9fe73193e5e28a884f34d9f444a4cda8e8fd63b7677b28546b0fbf8683c266572329a37e37c14b25ba95d4314e8d27360f6ece5b382534776fd2d6a21ea83f941b92a3c6d9856c2f992c691f5b2a3ad4db98c5c17caae7a408b608f7e88c3ead72f3d0d0df5a324ed00306403d485421aaafc8cf9b79f817dc25023ee84e1c8b1451fbb3ed1b416ba92538261d0bd6cc837da72324dec3c1ad8633928bdfaca6d5990a0b007b0de9d33a6fa5aab208f3382fee355e5a31d23d0babfc9bb49c9eebde75efa131c4068ad9054dc39dd33175899929c53b0e34fda405fbf87f4922fe08d1f26190bbe636c9b06e20e2d29ca12074420a32d26fd3d2300af506990d2eadfa65c2f21be0c8f0f5ef2c08f41eede260be2f0ec9484fdc10cdb756d24a2d5fd2132ab145fc3382b541e6f9f74761cda8b5de5af04adfa0a9de9ea33275bf9f97b4e838662156a02e38afb6823a20e995a12ed45e3d167055acc873382c8fd7636ee8323c1107b3775ac0cf2189bc74f119591b71c6d257573dba5787a0b7beac9b51bc034b6cff80dd80f15d087f6679c9f5c32f952defdbdcd2f05d70228120beb720e16c03da0d248973c308d28feaf654b339dabf70d74ec8e5541632aa5403de654f2e519b0ec44fc26d9294bf890bb148818f1d09af8a7a0d97db98c0435035da526826296a36d58f5fbbed61e67eccafbd728db10a0aa8ec94549199a877ef62bb538ba4954eac464a0cb5b109ee7f38a313138245241222439d7ac1695e8678c1f74aea886c31da5a135f867e897a13915f4dacbbe7201842563ab2026c3aed4e1e0c2100c9fd59a5b71c60ef899191c11893cad190fad85d7c68476ffe69ab802a3da3b22109cc3fa93bccf14b9f1c8b51d719af541de60dd7af8a848ffbf2dbcdbe8dc8bbd6ac316e271badc1fe9e03b0420273c810f18c105475ec609a491a2a701ae5a3b711fcadb45835a814c40fdc89ec811f98df47fa953ec815f0c7110ae64092bdf98fc095038976f43fc65844de30f669a82f10b01230b4ffdcc768b1a7e89714daff638b6ab3826d274f697f9f2f1956197ee7bee81bee46af4bb5d540b4a9033a2018cdf15d4a102208fa7f8568392f712e3cf143233e79a72933913367c3b84efebe7d2027f9a777655b300445acb334ac5f864064eaccfc129fa1f46fb3223abbab62db84b0733ed662e6be50c0d207d6f95d1ba67a2077c3e69f024ba4ccec09a080953da68e2ea7ea27650d8fd169efc9f03ae8d9d8721630fd54c2678e64e5fd8be4a3b7d4093569ec5370b9fb3fc94db12c5edce27f089983fdaebbd627c77c3fad1a4e1a2d98a7acac0592cc3a6495295b30e6cb5a18caa6ae4cbc440444d5f61f01edb48d27d2331ce2a0601f33176ab558cb2d91cf7d3af2a8e240a4ea974515317d0232a7239c64d2e32276945f9149103aeeabd2e1d5a969dcb2e9faab730090dc5038ef537ce411728fb52e93dfea31e09321c4bc1eb0f30dbdf2b3aaf0d6b9dac27f90faaa5eae7e7c84b8ae4d1efda479b332746f5682d6718d56378453e8d82a517278f36d50397692c61f9bfaa67063606a7da07d6f7fecfdba83aa8d0b431ca4763c9cd55570780d02a7911bb914383e3a08c055e77da1045be9937050dff947005bb398d60f25f020cf9f6cf8536b683bad0a3d99ecb010b4925bc7cc54f296a610e6444c996fe5598cea56346e3823746ecf6081810e9fe03adcf0d294b049240296a521d9f39a56049411dc7eb6fb0c55af4491d0aba1377f4e5d8a029a41a6c22fcede5326a2d25dc2919a6b8f745e999cade0c688e1ebb117b073f89a32fe2038ea82d4cd21d8170c5fef1b37b6be2d338bf41d410c4dcd87aee82eccd68ede2623872b0a45d2b882883f4812c7cac99627657f52ceda51ce65ce7f17ab4c8e651b0faa58dd32f5128304794ea9eb4cf9114137810944a48fd52fe398c4c785b32417c7398b0891797571bdfbb8b7f24ee22658e6422e6ca3a2d6b010dcc8473444694d59d7d5c3167d6eb9d768eb13c4dce7590dbd88695867f4b087a80a17757269c24d30a4586aecde74ea13f9a5a118e062e50d13a9bfe68c18de6dd50fab45652bae43ec655a1802663782c98bdfbec9e9f3c75ddc81e9fa9935488a6820ce27565467e37858284f3d87d3ef4a9f9238c4c3953a4b03b950b36e8752aa077bd25017c9f2561cdacd916b16ab7852f4f2a3bd503a8ff1c49a672b53c5c3a30b8528c4f4573f5b94dcd706e3d7d16eb734545b5f4df2a287b4a1de6eed410b41e94b2a266b2d593c3ce78a0f281e6fe46dcd2637aeb61563d2fb8a01bef1055ebf06e444f7886bcae128ecfb91693bf3538b985001b5670f1f1f6a4e2d7172c4968136462107dc771dae52bbab4a1ffcf0f9e1a6f26e9e4fa0688d2df64f71532f65faa47e9407f884f19c68e470e694752595ceddd107f924bab45b4b76f85dc5d3980c6d2e3ffb8b1eb70fbf0a7b568b85c6131a983d1d4b46a75c2865604ebe8a393e57c6d798a1c1a1fd9ac19ab0f3e5a9b3e8a72437aea2af6b6a47015ed7a1d09d03fc0552f1c9485ce56d58af3e2f203a09f41d11488d5e3ccbd8a1d5123954878f7ca2f48d7a686c28a7e807681fc53b6d64539f25e02b57c0a4bc756b885bfeb23709b4a781614368a9b73b1c94acd32e71a5837e2bc6d6942ef8fd6a0c27a41206f367b98d93ea0f77785d31ed15db5d388b5048b10f010c95619a7a03b62000c2786cf46a2249e0951dccddd6489e16a8f577cca51720545da556f8fd4c041deb196181c7b6c1c33d645fadba91935ab89cf3dcf2b0f04589f0dadbf6d91027bdd81b1a1ce869ea44097ca0f8a663d7e479a54bd14500f56788d17bb692f4f53e11af8158248413c99651bd10e023c551550bf42483b18684ced3a5d0abf54c5ba5efa54035d19c3541c96772176f4c267c29e0f900f183c02670705fe8eded6508c90ace4f46f2095e953a4d213c733139e442062b848d0cb0b5e7e6fc47de87d81b2ba851a9260bfae4858f704a6b73ce652886f1e6a98b8bc1d2cfab115a62ae111aadc55b4cd33990b2847429da0aedb8c5743861544e256847d0deb457d8174beb204883677f5c20daa53d2ba8193e71f54ad6d781ba46e73668c4e8dfe06596a707c3f78ce520631f93d8736c49ff25aaf5da37c30e50c010f49618ac289bf8413e610488f4bcdec82fd48d3ddb0b36533fd90a56df7e3e6eee06be7fd2fe12b2ebdd5e9a612d637636179a0e821c7e1a629f81712b5efea2210ac34fdf3d898dfcdd3ca0050e70da63c801a76e41dfaba33dabb1e674577b9b1d75f62fa6de937288f6798d78adc5f75ac6c1c416e63c6992a4dcdcb0f430718dc7da102d61ebcfc0708248318f16d19ec6b780462002f696c4d06625446b70abf78da57463019cf28e09cb68c0a188c55d04bfd2deb047bcb051868619a083eb5d4e55a159a8b97e09f2b7b045bda11505d2a627f02a8b2b3c7da4690d12e705fde3a3719295afa2635a5458afe244d560473c54794cd305bd644fb2209ab39616e68fe6ab3e9e4ea8ce6fab1163b95e9f112790c1bcde5d3df325110dbf459689749fa254aa8dfa01ec63bd81054eb31bf5ebf87a37df5700a6284ca05d4852f05d534af4a09d17aa022d3d6c703c51c3dba6de0eb249a99329de8cb6e7eb0f6850143727220d05bbd85a97af19b4044764fe2c0be1e1cb719d2ecab9d0d6b044f985d90366bea9157a4fed8b90f7aefdd113bd83ef06f0ece128dac3b71330f12e9e3f2697b0fcf894ae46e1651493afb1279282a938176b99e523f69ff15dffa58013cec396de37d9accf248c99e7314ced77f7f61c4f6038cf3c2aac7ddd817ee4edb80e8a48c45128b0303d6bd433deb0fdddae1af74397fc2a5cd904d4b4646211aca2b5fac3d209bea55f76cf04e53d319384e62ff3ed9cd54e3cf5aa93ef44aed9d1d67e3de59319eda8b70b25e5dd2dfea2cc9cca1974a13e9fb120f5896d059718430ce373516ee95f78b102e29993ed0db9e52815dcdfe5df45e7c0129e5bb20041dc97d54b973ba1bc435b901ffa5090c3bc25a35e0ddcdb80bdaca766fad0e6b6d3a6ee576eb62f642029da0e75370d4f609717ddf0c4085ae18efbeb9dd7c2c0d6d9afa6d41f6eb1f51fab26f8f203c871b515157196b0591d1a9f28a7b62f9c0f68056a4c6c2af19334f8969231c616003adf65b2aaafda0f67aa7465cb08658908c142cd05e4e153fde11f62d2d124ca62278ee02efe1d57faad1062526d0cc1ce4aba6f8d22cbee89dd4e9f124a544c456b2080b82407eb46b492f9c79697f8b674c3b89207e3077e74c23f006ee77b68ccbc3fec8967818b415ae375b089bd5a4790be11082dfce233f6dfea07acf7cd60c0454a005f21959a8fe7db9e7f3bab34867c8698a78a8d543be7b6e7a8f2b1ceefa1d32ed64dbdc1d6d8ab79003aa183a360ae164625d494d36d7e98164ce4025dbb42afb576a33b362feadee7798669763327873756c9e667917a32665e237f503b82fdd6f0a23aae648fae4cea259922af1b1e429c6f1e922ae43682f646865603768c050c2091cc165e7879e1ee7015a282959b985d54b31bb47a8036f3ff9aa704d0499dfbc3e1e9d875afe8f25163f31b7f37ad736269214c9783d62b54199ec440e93fe0805aecb3ab6d780a2006fc94ee23171f435ef067606ffae37430a38668be6ddbbf23bf83aa69035219c3227e841223ba0b602f2fbbc3a2d26c3e2474a5a8a3b2fd0a2fb51e49ac63624588ad05566d223a15b889bc2851fb8a40d18eded581010e5101e9b0eb7e62d93827e636ffe25ce01f6600ef309a9038575670e6c76d9484828f24193865339abb03f836d2885f257446a61961b4cc19baf5ed0b7a8a9e4d98f6284b9293c6964a5d53d0f57eeb93197cc0cb231ac99faa3215601c84495e846bbbd2b2b51c319f91e90d767cb949eacbbb0340d86cd5fd07d05d9fc38fbf88a2e44137440beea5a2d53d83d90aa3c53d016b086465ca05d99778461c6b3b32ea880c7d0abbc4c5eb9025d329891be605699597d73e8391b92a418df66016680f62a8460fb896fcc215169b645a053e299be3fb4b8296cddbb09ebcf5f66f03299ca6be9999ea188cd5e0faf95f8106e8caca6381047c3c4e97fb6691d18b768299dfa70483010aa523348e6a66d8bdb4ccb2f7888f6b4fdb2a59174e5e2e3eb9c531840c657c26384f7dd3a03777da98971082b9696e824b9beeb998b4023336b6eda61b532ad4b4fb332f744aba11ab4d0dcdadc28a2bb007272c1949f86e2169970d4b3008f929e9f9bf961c5d9a4f2ce2c82ac1be731cf04a788cb5461c98143b70581e53974a7003166846f5ab05813f5a32d5b76cd2ed669c6ee51fd4995cbbfe5496512816a6febb05ad8a075235a9d4951db7762a992bf25a7dde2dd31b5c01fccc2d3d357c7babcfc0d7e843676712489523e8789d8a48886ad24a8c76d56687a534792a81e85e1858e0870ce9669afcbf1fb5c5b3326cc3374606ac8b02dc9151d0bd389d5f4d911e030cca82e0e08790a945b76f785302704d06a718050565c53591ea9f21bc06a554cfd98add7efdab88854dc86d53b8a94175d1c36201c4174dae147a3dab3023b7ef1a0138871becf56bc7e1c2157c37cebd5a3496671724165a60032cf6c9ebc7c4df6d76a4afc9649410e0ca69aeef1d366bfb10fac7933e5eb6b440f7e0a690e56fd7f405d52a096e7f8afb1aa58a30b605aac529b07adbcb15b5aa19f823b391f86f1af0afd5ac90ed6ba5389bb448db09ce4a34cbd3ff5cf0801f1ffe14a1592f7e2532205734665ebfee6cbffc8065f35e1ee2c279946ccd0289a9354bc890eaaf5baae65bb3b80d629b9b7b6757618d6c6d5392a2a99dc4452ac37254ff7bedfbe301042dff8c2d0f65af296a71c8096c13eaa27a4b3bdcdb1873fe69ce1fc85cf07964d2ad9e8800510b83775b619429cfe3b5c7ba151b5282a04b3a8b50b7cd69d7783ff48f7191136dd47d68a5d45e67fa21e21857bb10823c3596a4ad9dc0c0febb9373ae12ebc7e8f6567b90a4d4e510b2997ccfef57c6310fa0e424e1929d0d428be6b12d558426c31781414bf15dd50c93148102265b28be7e65b76e5bc594064eccbc7ac8e00324d403697af66efbfe21f253ad71a9be6335f9b27dd4fe64ad0dbd8927c8e9cb39401837db7f803799ae6393f6a1eca8160b0915d678987e6bc9c8d4582b02349cba11b7b4982db882e5871b3175e831814eb9e6787decbffa92310f7497821eb048c34826e8dcdbef51fb09a0fb5906aa156415926de198e39f2dcfc84b2c87c7175116bd53e1073ebbda65587f466351dbc7100f1b8fe3f27f39e17d715559735f52387e34e3003fdf01370c2dfc2efee9ab35c4c07810ae92556d4b98df49bb5e34c24d18cbdde9d1529d887bb8b316f2e2ce9c0eae14a52a6bf7ed39cb81e961708a7eec0cc66e01fa45d68bb91e5c6379e104a98b48fa4c0f6bdb7ac420374e56497110a356b92ec123f0d974aa6460d2f938581ed1dca237834e1842a0e7449e1a76d10c9450e4ccd8967b1cc6da14e1ae3c4bda208db9df6a00b6a047dd857db9ebeea774adeb7f73e0117eb0fd46ff965b665f31cba84ce292c7fb2f9f68b0710cd0c5378866e913bc67da468516c13623d4c54a701b6cb84506c917094e4997476a9d37d25bfdebd49d36ab941d4b36f796ac8bca688233b5a162aea95a963a64664e51b94b98e0dbbab6a5fc3c42563bc8525be0a56a3fcb026b240bba70bb6438834971581feec67ab1375683bea4b06a6a474f9def24a57261726167ba28aac6670cac8b0fcc88cd5df27f891dd39e0e4cd999519367c55483d2308d272adb632ab64897190538a032ba0476d3a5d1e1d28bf9dbb705b8c54edd6e18ea0d98cd3a4fe1f49555fba8f810ecfcf70295f6034a223cbfd4219142e268fb88bd24216b5ed55d0644b986204cf8bd6925d866f025a5c18cfe95bab7a4d1ca510b4f2da3ee8b718d423ef90ffd63ab1473541d58696aaf2ec22496eff660a8b2984ad5bda129a771c8dc93bbad69fe317b97e886e9ba79f2041fc53e05d2c0f5b0ffb258d9be0ee798cec3b1aea1395ea9815667c28671af9c85c06f0c8a6dd16e3d386935be3b29eb9475eed1bca3b19e71754c76a18535b3c02dc9197debdca10d78668e4f40f1b73089fbcb830281d8c854b360a94c7ffea84a19313f059e0c468d771402278d6b21011ec558c4637e1f132259a5efc9fbdd90ba133610509be1b7e50d812f6a854ba1e8c8ebe99ddb7ba0686b63b247ec5aac7d1d10b3d30591b86207952199a92fd6f7184381afdba245483a2ac759bc7491aecab879a27fc423621f291cfec95d0c91164a7150accbc8dbb5dfff9604eac83d14bde9d0b642feb58937d3a54f7e0d846e72410d1d65dac8a7148856a92997ed3cabb0a07a4d9e773f201e3430ed7b35a6650ef6019e4108b15fcb419f2f3c1f9893f19bd3f8058d25fa3ea11344661953663fc3aefcfaa68188859faea49a0d00ac31b192c21d4026bbcd672368d90ca9f92ac2f48ed57e12e94873e2a6e34456e613c78e69824c3cd6ae571652b1388c0a07e7cfbf8009ee6232876abceed84e218153127aa3f2338fa9b003203d0f0b7c515a985ae233f8ad9d2258891ef2f73a661f1e0014dbd0cd232074b8913e136b2bb99c20c0979b64b567be1f65e60a3bd180f0ff4bdb25d3e39f91607d5a4b7d16f9da3ff7befe2e432661444c57428b0053689bbe4cfe95e6b41c1ed8b6a7542cdf9e8c78534f736730e3c8726f497f9a41cbf761d7783daac267363ae9322dba5405212405269aad53cf228da20b1af3ed8f85c91180a5e559616d024d66dffdc8676dc1c3452f2de49e50e8a0ebe7d45df284d551b90101daf28462c39a45bc84252ace9b259e83fff4a7ba0aa840d1e3420736c19072e36c4392800c5e4bf185a3fa6d779d7c3f461f5a8581babffa444c6a4b5facb53f344f10ec9ea0f263c1c354342163f1d70be992983c70b34a6f82715fb544c9955a2ff9ec0d5b961a2a264cbcf7e5f324cef837d7d1392d479dfdec9a000a3ab9c7d810a22a257c15dc90e1cbd22ea16bb773411e4cfe7778d1e54d0554940cd76c162cf21c8133ee6bbfd8d923513528d13d485b9873a188d1d60ce040d95f27378eb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵乘法简单题 1</title>
    <link href="/2022/matrix-solution-1/"/>
    <url>/2022/matrix-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>以下是简单矩阵乘法题目大赏。</p><p>注意我这时候的矩阵乘法还没有形成固定的码风，所以代码看起来差异较大且比较别扭，见谅。</p><span id="more"></span><h1 id="luogu5343-分块">luogu5343 分块</h1><h2 id="分析">分析</h2><p>分的块长必须同时满足二人的要求，所以必然是二者的交集。</p><p>设 <span class="math inline">\(f_i\)</span> 为长度为 <spanclass="math inline">\(i\)</span> 序列的分块方案数，有 <spanclass="math inline">\(f_0 = 1\)</span>。 <span class="math display">\[f_i = \sum_{j=1}^m f_{i-a_j}\]</span> 其中 <span class="math inline">\(a_i\)</span> 是第 <spanclass="math inline">\(i\)</span> 种合法分块长度，<spanclass="math inline">\(m\)</span> 是序列 <spanclass="math inline">\(a\)</span> 的长度。</p><p>数据范围明显要用矩阵加速递推。下面放图是因为我对我当时的写法实在是无语了，与我现在的习惯大相径庭，为了便于理解就用这张图了。</p><figure><img src="https://s2.ax1x.com/2019/05/05/Ewtapd.png" srcset="/img/loading.gif" lazyloadalt="借用洛谷题解的图片，侵删" /><figcaption aria-hidden="true">借用洛谷题解的图片，侵删</figcaption></figure><p>先把 <span class="math inline">\(f\)</span> 搞成一个向量。</p><p>考虑从 <span class="math inline">\(f_{i-1}\)</span> 推得 <spanclass="math inline">\(f_i\)</span>的过程，不难发现首先要整体平移一下，也就是在转移矩阵 <spanclass="math inline">\(A\)</span> 中，有 <spanclass="math inline">\(A_{i+1,i}=1\)</span>，表示 从 <spanclass="math inline">\(f_{i-1}\)</span> 数第 <spanclass="math inline">\(i+1\)</span> 个要转移到第 <spanclass="math inline">\(i\)</span> 个的位置，于是乎 <spanclass="math inline">\(1\)</span>，也就是要求的 <spanclass="math inline">\(f_i\)</span> 空了出来。此时，表示如果 <spanclass="math inline">\(a_j\)</span> 合法，那么就让 <spanclass="math inline">\(A_{1,a_j}=1\)</span>，表示从 <spanclass="math inline">\(f_{i-1}\)</span> 数第 <spanclass="math inline">\(a_j\)</span> 个，也就是 <spanclass="math inline">\(f_{i-a_j}\)</span> 要转移到 <spanclass="math inline">\(1\)</span>，也就是 <spanclass="math inline">\(f_i\)</span> 的地方。</p><p>初始 <span class="math inline">\(f_0 = 1\)</span>，求 <spanclass="math inline">\(n\)</span> 次幂即可，注意要预处理 <spanclass="math inline">\(1 \sim 100\)</span> 的 <spanclass="math inline">\(f\)</span> 值，因为块最大是 <spanclass="math inline">\(100\)</span>，这样做不会漏掉信息。</p><p>好了，我已经受不了这奇葩的写法了。上代码，看得懂的就看，看不懂尽量别死磕这个SB 写法。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, p, q, c[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>], f[<span class="hljs-number">105</span>];bitset&lt;105&gt; a, b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mul</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ans[<span class="hljs-number">105</span>]; <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100</span>;j++)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)ans[i]=(ans[i]+f[j]*c[j][i]%mod)%mod;<span class="hljs-built_in">memcpy</span>(f,ans,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mulself</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ans[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>]; <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">100</span>;k++)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100</span>;j++)ans[i][j]=(ans[i][j]+c[i][k]*c[k][j]%mod)%mod;<span class="hljs-built_in">memcpy</span>(c,ans,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">100</span>;++i) c[i+<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;p=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(p--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();a[x]=<span class="hljs-number">1</span>;&#125;q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();b[x]=<span class="hljs-number">1</span>;&#125;a&amp;=b;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;++i) <span class="hljs-keyword">if</span>(a[i]) c[<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// f[1]-f[100]的信息都在c里面</span>    <span class="hljs-comment">// 注意用的是bitset，a[i]是上述的下标j，i才是a[j]</span><span class="hljs-keyword">for</span>(;n;<span class="hljs-built_in">mulself</span>(),n&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">mul</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>]);&#125;</code></pre></div><h1 id="luogu3758-可乐">luogu3758 可乐</h1><h2 id="分析-1">分析</h2><p>设 <span class="math inline">\(f(i,x)\)</span> 为时刻 <spanclass="math inline">\(i\)</span>，在城市 <spanclass="math inline">\(x\)</span> 的方案数。增加一个节点 <spanclass="math inline">\(n+1\)</span> 表示自爆。 <spanclass="math display">\[f(i,x) = \sum_{(x,y) \in E} f(i-1,y)\]</span> 每次处理完一个时间，都让答案累计已经自爆的 <spanclass="math inline">\(f(i,n+1)\)</span>，最后加上 <spanclass="math inline">\(f(t,x)\)</span>，其中 <spanclass="math inline">\(x \in [1,n]\)</span>。</p><p>这样能水过原题，但是复杂度实在太高，考虑矩阵加速。</p><p>和上题相同，只不过还更简单了，<span class="math inline">\(x\)</span>与 <span class="math inline">\(y\)</span> 互相转移，<spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>和 <span class="math inline">\(n+1\)</span> 都能转移。预处理 <spanclass="math inline">\(i=0\)</span> 时的初始矩阵，求 <spanclass="math inline">\(t\)</span> 次幂即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">2017</span>;<span class="hljs-keyword">int</span> n, m, t, ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mat</span> &#123;</span><span class="hljs-keyword">int</span> m[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">31</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(m)); &#125;&#125; a;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">31</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">31</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">31</span>;++j)c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();a.m[x][y]=a.m[y][x]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a.m[i][i]=a.m[i][n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;a.m[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 尽管没有实际意义，但是为了能够做矩阵乘法，需要让m[n+1][n+1]=1</span>t=<span class="hljs-built_in">read</span>();a=<span class="hljs-built_in">fp</span>(a,t);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) ans=(ans+a.m[<span class="hljs-number">1</span>][i])%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="luogu5337-甲苯先生的字符串">luogu5337 甲苯先生的字符串</h1><h2 id="分析-2">分析</h2><p>设 <span class="math inline">\(f(i,j)\)</span> 为写完了 <spanclass="math inline">\(s_2\)</span> 的前 <spanclass="math inline">\(i\)</span> 个字符，其中最后一个字符为 <spanclass="math inline">\(j\)</span> 的方案数。 <spanclass="math display">\[f(i,j) = \sum_{k=1}^{26} f(i-1,k) \cdot b(k,j)\]</span> 其中 <span class="math inline">\(b(k,j)\)</span>表示能不能先出现 <span class="math inline">\(k\)</span>，再出现 <spanclass="math inline">\(j\)</span>。</p><p>标准的矩阵乘法。矩阵乘法本质是对相同转移方式的处理，所以设 <spanclass="math inline">\(A_{i,j}\)</span> 为当前阶段，倒数第二个字符为<span class="math inline">\(i\)</span>，最后一个字符为 <spanclass="math inline">\(j\)</span> 的方案数。当 <spanclass="math inline">\(i=1\)</span> 时，很容易写出。不相邻的为 <spanclass="math inline">\(1\)</span>，否则为 <spanclass="math inline">\(0\)</span>。</p><p>求它的 <span class="math inline">\(n-1\)</span> 次幂就行了。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, f[<span class="hljs-number">30</span>];<span class="hljs-keyword">char</span> s[<span class="hljs-number">100005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mat</span> &#123;</span><span class="hljs-keyword">int</span> m[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(m,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(m)); &#125;&#125; a;Mat <span class="hljs-keyword">operator</span>*(Mat a,Mat b) &#123;Mat c; c.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">26</span>;++k)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;++j)c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">Mat <span class="hljs-title">fp</span><span class="hljs-params">(Mat a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;Mat c; c.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">id</span>();<span class="hljs-keyword">for</span>(;b;a=a*a,b&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) c=c*a;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;++j) a.m[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;++i) a.m[s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>][s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;a=<span class="hljs-built_in">fp</span>(a,n<span class="hljs-number">-1</span>);<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">26</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;++j) (ans+=a.m[i][j])%=mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4774 屠龙勇士 题解</title>
    <link href="/2022/lg4774-solution/"/>
    <url>/2022/lg4774-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先预处理出杀死每条龙时要使用哪一把剑，设杀死第 <spanclass="math inline">\(i\)</span> 条龙用的剑的攻击力为 <spanclass="math inline">\(atk_i\)</span>。</p><span id="more"></span><p>那么问题转化为求解 <span class="math display">\[\left\{\begin{array}{l}atk_1 \cdot x &amp;\equiv a_1 \pmod{p_1}\\atk_2 \cdot x &amp;\equiv a_2 \pmod{p_2}\\&amp;\vdots\\atk_n \cdot x &amp;\equiv a_n \pmod{p_2}\end{array}\right.\]</span> 由于 <span class="math inline">\(p_i\)</span>不一定两两互质，所以如果没有 <span class="math inline">\(atk_i\)</span>的话，就可以直接上 exCRT。这里需要多预处理几步。</p><p>数论中有一个结论：如果 <span class="math display">\[ax \equiv ay \pmod p\]</span> 那么 <span class="math display">\[x \equiv y \pmod{\frac{p}{\gcd(a,p)}}\]</span> 其实这里的能这么做是因为 <spanclass="math inline">\(\gcd(a,a)=a\)</span>，所以我们只要求出 <spanclass="math inline">\(d_i = \gcd(atk_i,a_i)\)</span>，就能化成 <spanclass="math display">\[\frac{atk_i}{d_i} x \equiv \frac{a_i}{d_i} \pmod{\frac{p_i}{\gcd(d_i,p_i)}}\]</span> 由于此时 <spanclass="math inline">\(\frac{atk_i}{d_i}\)</span> 与 <spanclass="math inline">\(\frac{p_i}{\gcd(d_i,p_i)}\)</span>必然互质，所以一定存在模 <spanclass="math inline">\(\frac{p_i}{\gcd(d_i,p_i)}\)</span> 意义下 <spanclass="math inline">\(\frac{atk_i}{d_i}\)</span> 的逆元。于是乎再次转化<span class="math display">\[x \equiv \frac{a_i}{atk_i} \pmod{\frac{p_i}{\gcd(d_i,p_i)}}\]</span> 这样就能用 exCRT 求解了。</p><p>注意到数据范围中有不少点都满足 <span class="math inline">\(p_i=1\)</span>，而模 <span class="math inline">\(1\)</span>的情况十分简单，那么就可以特判一下。</p><p>不同推式子，直接考虑实际意义。当巨龙的生命为负时，它就会一直回复一滴血直到血量为<span class="math inline">\(0\)</span>，然后去世。也就是说，只要 <spanclass="math inline">\(atk_i \cdot x \ge a_i\)</span> 就行，所以答案就是<span class="math inline">\(x = \lceil \frac{a_i}{atk_i} \rceil\)</span>取个最大值。</p><p>注意为了防止乘法溢出，要用光速乘。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> uint unsigned long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> T, n, m, fg, a[N], p[N], sw[N], rec[N], atk[N];<span class="hljs-keyword">int</span> M, R, ans, t[N];multiset&lt;<span class="hljs-keyword">int</span>&gt; st;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span>&amp; y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<span class="hljs-keyword">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);y-=a/b*x;<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> mod)</span> </span>&#123;<span class="hljs-keyword">int</span> x, y;<span class="hljs-built_in">exgcd</span>(a,mod,x,y);<span class="hljs-keyword">return</span> (x+mod)%mod;    <span class="hljs-comment">// 返回a在模mod意义下的逆元</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x+y<span class="hljs-number">-1</span>)/y; &#125;<span class="hljs-comment">// 向上取整函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> p)</span> </span>&#123;<span class="hljs-keyword">int</span> z=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>)x/p*y;<span class="hljs-keyword">int</span> res=(uint)x*y-(uint)z*p;<span class="hljs-keyword">return</span> (res+p)%p;    <span class="hljs-comment">// 非常玄学的O(1)光速乘</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exCRT</span><span class="hljs-params">()</span> </span>&#123;R=t[<span class="hljs-number">1</span>], M=p[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> d=t[i]-R, g, mod, x, y;g=<span class="hljs-built_in">exgcd</span>(M,p[i],x,y);<span class="hljs-keyword">if</span>(d%g) &#123; ans=<span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>; &#125;mod=p[i]/g;x=(<span class="hljs-built_in">mul</span>(x,d/g,mod))%mod;<span class="hljs-keyword">int</span> P=M/g*p[i];R=(<span class="hljs-built_in">mul</span>(x,M,P)+R)%P; M=M/g*p[i]; &#125;ans=R;    <span class="hljs-comment">// 板子</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;st.<span class="hljs-built_in">clear</span>();fg=ans=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) fg+=(p[i]=<span class="hljs-built_in">read</span>())==<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) rec[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) sw[i]=<span class="hljs-built_in">read</span>(), st.<span class="hljs-built_in">insert</span>(sw[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">auto</span> p=st.<span class="hljs-built_in">upper_bound</span>(a[i]);<span class="hljs-keyword">if</span>(p!=st.<span class="hljs-built_in">begin</span>()) --p;atk[i]=*p;st.<span class="hljs-built_in">erase</span>(p), st.<span class="hljs-built_in">insert</span>(rec[i]);&#125;<span class="hljs-keyword">if</span>(fg==n) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">cil</span>(a[i],atk[i]));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> _d=<span class="hljs-built_in">gcd</span>(atk[i],p[i]), d=<span class="hljs-built_in">gcd</span>(_d,a[i]);atk[i]/=_d, a[i]/=_d, p[i]/=d;t[i]=<span class="hljs-built_in">mul</span>(a[i],<span class="hljs-built_in">inv</span>(atk[i],p[i]),p[i]);&#125;<span class="hljs-built_in">exCRT</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>扩展中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串简单题目 1</title>
    <link href="/2022/string-solution-1/"/>
    <url>/2022/string-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>KMP 算法和 Trie 的一点入门题目。</p><span id="more"></span><h1 id="luogu4391-无线传输">luogu4391 无线传输</h1><h2 id="分析">分析</h2><p>题目说的很别扭，实际上是求一个最短的 <spanclass="math inline">\(S\)</span> 的子串，满足这个子串自我拼接之后，<spanclass="math inline">\(S\)</span> 是这个拼接串的子串。也就是 <spanclass="math inline">\(S\)</span> 的最小周期。</p><p>若 <span class="math inline">\(|S|=n\)</span>，则答案为 <spanclass="math inline">\(n-next_n\)</span>。证明如下：</p><p>如下图表示 <span class="math inline">\(S\)</span> 的最大 Border相交的情况，黑色部分是字符串 <spanclass="math inline">\(S\)</span>，蓝色部分是和红色部分是 <spanclass="math inline">\(next_n\)</span>，绿色部分 <spanclass="math inline">\(T=S[1,n-next_n]\)</span>。</p><p>显然 <span class="math inline">\(T\)</span> 是 <spanclass="math inline">\(S[1,next_n]\)</span> 的一个前缀，又因为 <spanclass="math inline">\(S[1,next_n] = S[n-next_n+1,n]\)</span>，所以 <spanclass="math inline">\(T\)</span> 后面又能再拼接上一块 <spanclass="math inline">\(T\)</span>。而前面的黄色部分 <spanclass="math inline">\(S[n-next_n+1,next_n]\)</span> 是前缀 Border 的最后$next_n - (n-next_n+1) + 1 = 2 next_n - n $ 个字符，后面的黄色部分是后缀Border 的最后 <span class="math inline">\(n - 2(n-next_n) = 2next_n -n\)</span> 个字符，所以黄色这这两块是等价的。由于左边的黄色部分是 <spanclass="math inline">\(T\)</span> 的一个前缀，所有右边的黄色部分也是<span class="math inline">\(T\)</span> 的前缀，于是在第二个 <spanclass="math inline">\(T\)</span> 后面再接一个 <spanclass="math inline">\(T\)</span>，此时 <spanclass="math inline">\(S\)</span> 必然为它的子串。</p><p><img src="https://s2.loli.net/2022/08/09/TbkpgLeVFNfhUjr.png" srcset="/img/loading.gif" lazyload /></p><p>那么最大 Border不重叠呢？看下图，颜色所代表的信息与上图相同。不难发现红色部分就是等价于蓝色部分，蓝色部分是<span class="math inline">\(T\)</span> 的前缀。所以再接一个 <spanclass="math inline">\(T\)</span> 就能覆盖整个串了。</p><p><img src="https://s2.loli.net/2022/08/09/PdxqIWCZnHD4vOF.png" srcset="/img/loading.gif" lazyload /></p><p>综上，<span class="math inline">\(n-next_n\)</span> 一定是 <spanclass="math inline">\(S\)</span> 的一个周期。</p><p>而 <span class="math inline">\(next_n\)</span> 是 <spanclass="math inline">\(S\)</span> 的最大 Border，对应的 <spanclass="math inline">\(n-next_n\)</span> 就是 <spanclass="math inline">\(S\)</span> 的最小周期。</p><h1 id="luogu3435-periods-of-words">luogu3435 Periods of Words</h1><h2 id="分析-1">分析</h2><p>上题证明了，<span class="math inline">\(n-next_n\)</span> 是 <spanclass="math inline">\(S\)</span> 的最小周期，同理 <spanclass="math inline">\(i-next_i\)</span> 是前缀 <spanclass="math inline">\(S[1,i]\)</span> 的最小周期。由于 <spanclass="math inline">\(next_{next_i}\)</span> 是 <spanclass="math inline">\(S[1,i]\)</span> 的次小Border，所以只要对于一个前缀 <spanclass="math inline">\(S[1,i]\)</span>，只要找到最小的非 <spanclass="math inline">\(0\)</span> border <spanclass="math inline">\(t\)</span>，最大周期即为 <spanclass="math inline">\(i-t\)</span>。方法是令 <spanclass="math inline">\(t=i\)</span>，如果 <spanclass="math inline">\(next_t &gt; 0\)</span>，那么就不断让 <spanclass="math inline">\(t=next_t\)</span>。这个过程也是可以记忆化的。</p><h1 id="luogu4824-censoring">luogu4824 Censoring</h1><h2 id="分析-2">分析</h2><p>套路性的维护一个栈，然后如果匹配到一个 <spanclass="math inline">\(T\)</span> 串，那么那么就让栈顶减小 <spanclass="math inline">\(|T|\)</span> 即可。最后留在栈里的即为答案。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, top, nxt[N], f[N], stk[N];<span class="hljs-keyword">char</span> a[N], b[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;a[i]!=a[j+<span class="hljs-number">1</span>]) j=nxt[j];j+=a[i]==a[j+<span class="hljs-number">1</span>];nxt[i]=j;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,b+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(a+<span class="hljs-number">1</span>), m=<span class="hljs-built_in">strlen</span>(b+<span class="hljs-number">1</span>);<span class="hljs-built_in">pre</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;b[i]!=a[j+<span class="hljs-number">1</span>]) j=nxt[j];j+=b[i]==a[j+<span class="hljs-number">1</span>];f[i]=j;stk[++top]=i;<span class="hljs-keyword">if</span>(f[i]==n) top-=n, j=f[stk[top]];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=top;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,b[stk[i]]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h1 id="luogu2375-动物园">luogu2375 动物园</h1><h2 id="分析-3">分析</h2><p>要求前缀和后缀不重叠还要计数。</p><p>设 <span class="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(S[1,i]\)</span> 的 Border 的个数，也就是如果 <spanclass="math inline">\(next_i = j\)</span>，那么有 <spanclass="math inline">\(f_i = f_j +1\)</span>。</p><p>对于每一个 <span class="math inline">\(i\)</span>，找到最大的满足<span class="math inline">\(i \ge 2j\)</span> 的 Border <spanclass="math inline">\(j\)</span>，此时 <span class="math inline">\(num_i= f_j\)</span>。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> t, n, ans, nxt[N], f[N];<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;nxt[i]=j;f[i]=f[j]+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;ans=<span class="hljs-number">1</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>), n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">pre</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">2</span>*j) j=nxt[j];(ans*=f[j]+<span class="hljs-number">1</span>)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="luogu3426-template">luogu3426 Template</h1><h2 id="分析-4">分析</h2><p>首先印章上的字符串一定是原串的一个 Border，但是原串的 Border不一定合法。</p><p>而如果一个 Border 合法，那么所有 Border为它的下标之间的间隔绝对小于它的长度。这样就可以完成整个串的覆盖。观察样例就能得到这两个结论。</p><p>所以答案就要从原串 <span class="math inline">\(S\)</span> 的 Border里面选择，优先考虑最小的。</p><p>设 <span class="math inline">\(ans_i\)</span> 为候选答案中第 <spanclass="math inline">\(i\)</span> 小的答案。考虑 <spanclass="math inline">\(ans_{i-1}\)</span> 不合法，但是 <spanclass="math inline">\(ans_i\)</span> 合法的情况。</p><p>由于 <span class="math inline">\(ans_{i-1}\)</span>不合法，所以要排除所有 Border 为 <spanclass="math inline">\(ans_{i-1}\)</span> 且不为 <spanclass="math inline">\(ans_i\)</span> 的下标（<spanclass="math inline">\(ans_{i-1}\)</span> 一定是 <spanclass="math inline">\(ans_i\)</span> 的 Border）。排除之后，又要再次统计Border 为 <span class="math inline">\(ans_i\)</span>的下标的间隔。可以用链表来实现快速查询和删除。</p><p>如何快速实现排除下标呢？引入一种数据结构，名为——失配树。也叫 <spanclass="math inline">\(fail\)</span> 树和 <spanclass="math inline">\(next\)</span> 树。简而言之，就是把 <spanclass="math inline">\(next_i\)</span> 向 <spanclass="math inline">\(i\)</span> 连一条边。</p><p>它的主要性质是：点 <span class="math inline">\(x\)</span> 如果是点<span class="math inline">\(y\)</span> 的祖先，那么 <spanclass="math inline">\(S[1,x]\)</span> 是 <spanclass="math inline">\(S[1,y]\)</span> 的一个 Border。如果 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>之间没有祖孙关系，那么绝不满足上述性质。</p><p>也就是说，删去所有 Border 为 <spanclass="math inline">\(ans_{i-1}\)</span> 且 Border 不为 <spanclass="math inline">\(ans_i\)</span> 的下标，只要在失配树中删去 <spanclass="math inline">\(ans_{i-1}\)</span> 子树内所有非 <spanclass="math inline">\(ans_i\)</span> 的节点即可。</p><p>从小到大枚举答案，如果某个 <span class="math inline">\(ans_i\)</span>满足了，答案就是 <span class="math inline">\(ans_i\)</span>。</p><p>参考：<ahref="https://www.cnblogs.com/dedicatus545/p/8903324.html">[POI2005][luogu3462]SZA-Template [fail树]</a></p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, gap, rec, fail[N], pre[N], suf[N], ans[N];<span class="hljs-keyword">int</span> tot, h[N], to[N], nxt[N];<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepre</span><span class="hljs-params">()</span> </span>&#123;fail[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=fail[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;fail[i]=j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(fail[i],i);    <span class="hljs-comment">// 每一个点都要加入失配树</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;i=fail[i]) ans[++m]=i;    <span class="hljs-comment">// 这里是从大到小存的</span><span class="hljs-comment">// for(int i=1;i&lt;=m;++i) printf(&quot;%lld\n&quot;,ans[i]);</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pre[i]=i<span class="hljs-number">-1</span>, suf[i]=i+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;suf[pre[x]]=suf[x], pre[suf[x]]=pre[x];gap=<span class="hljs-built_in">max</span>(gap,suf[x]-pre[x]);pre[x]=suf[x]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> zero)</span> </span>&#123;<span class="hljs-built_in">del</span>(x);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==zero) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">del</span>(y);<span class="hljs-built_in">dfs</span>(y,zero);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-built_in">prepre</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i;--i) &#123;<span class="hljs-built_in">dfs</span>(ans[i+<span class="hljs-number">1</span>],ans[i]);        <span class="hljs-comment">// 这个可以模拟一下，注意第一次先删去了所有根节点0所有Border不是ans[m]的节点</span><span class="hljs-keyword">if</span>(gap&lt;=ans[i]) &#123; rec=ans[i]; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,rec);&#125;</code></pre></div><h1 id="cf126b-password">CF126B Password</h1><h2 id="分析-5">分析</h2><p>既是前缀，又是后缀，又在中间出现过。</p><p>不难想到，既是前缀又是后缀，说明一定是 <spanclass="math inline">\(S\)</span> 的一个 Border，所以答案最大为 <spanclass="math inline">\(next_n\)</span>。在中间也出现过，假设出现的位置是<span class="math inline">\(i_0\)</span>，那么答案也是 <spanclass="math inline">\(S[1,i_0]\)</span> 的一个Border。因此只要从大到小寻找满足</p><ol type="1"><li>是 <span class="math inline">\(S\)</span> 的 Border。</li><li>存在至少一个 <span class="math inline">\(i \in[1,n-1]\)</span>，满足 <span class="math inline">\(next_j =i\)</span>，</li></ol><p>的最大的 <span class="math inline">\(j\)</span> 即可。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, nxt[N], v[N];<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];<span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;nxt[i]=j;<span class="hljs-keyword">if</span>(i!=n) v[j]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> ans=nxt[n], fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(ans) &#123;<span class="hljs-keyword">if</span>(v[ans]) &#123; fg=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;ans=nxt[ans];&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Just a legend&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=ans;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h1 id="cf858d-polycarps-phone-book">CF858D Polycarp's phone book</h1><h2 id="分析-6">分析</h2><p>对于每个字符串 <spanclass="math inline">\(S_i\)</span>，找到一个最短的子串，满足这个子串是且只是<span class="math inline">\(S_i\)</span> 的子串。</p><p>一个想法把所有字符串的所有子串插入集合，对于每个字符串 <spanclass="math inline">\(S_i\)</span>，从小到大枚举所有子串，在不考虑 <spanclass="math inline">\(S_i\)</span>的所有子串的情况下查看是否存在这个子串。</p><p>这个显然是不行的，考虑优化。注意到，只要把所有后缀都插入集合，枚举的时候只枚举起点，就能找到所有<span class="math inline">\(S_i\)</span> 的子串。</p><p>既然是和字符串相关，那么这个集合可以用 Trie来在一个比较优的复杂度内实现。</p><p>考虑什么时候可行。设 <span class="math inline">\(cnt_x\)</span>表示字符 <span class="math inline">\(x\)</span> 在集合中的出现次数，如果<span class="math inline">\(S_i\)</span> 的某个子串的结尾字符的 <spanclass="math inline">\(cnt\)</span> 为 <spanclass="math inline">\(0\)</span>，由于之前已经删掉了 <spanclass="math inline">\(S_i\)</span>的所有后缀，所以此时这个子串一定是唯一的，输出即可。然后再把所有后缀插入回去。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, tot, d, cnt[N], trie[N][<span class="hljs-number">15</span>];<span class="hljs-keyword">char</span> a[N][<span class="hljs-number">15</span>], ans[<span class="hljs-number">15</span>], t[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-keyword">int</span> a=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a], ++cnt[x];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-keyword">int</span> a=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;x=trie[x][a], --cnt[x];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;t[i]=s[i];<span class="hljs-keyword">int</span> a=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;x=trie[x][a];<span class="hljs-keyword">if</span>(cnt[x]==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;d) &#123;d=i+<span class="hljs-number">1</span>;                <span class="hljs-comment">//此时答案长度为i+1</span>t[i+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;                <span class="hljs-comment">// 截取t[0,i]这一段，因为puts()遇到&#x27;\0&#x27;会停止</span><span class="hljs-built_in">strcpy</span>(ans,t);<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">insert</span>(a[i]+j);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;d=<span class="hljs-number">10</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">del</span>(a[i]+j);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">find</span>(a[i]+j);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j) <span class="hljs-built_in">insert</span>(a[i]+j);<span class="hljs-built_in">puts</span>(ans);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP算法</tag>
      
      <tag>失配树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「字符串学习笔记」#1 KMP算法、Trie和自动机概念</title>
    <link href="/2022/notes-string-1/"/>
    <url>/2022/notes-string-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>本人第一次系统学习字符串相关知识。</p><p>这段时间也是比较的迷茫吧，颓了好久。目前的目标是拿到省一，但是又不想整天看比赛题。字符串又是我的一大盲区，所以就用两个半天，粗略地学习了一些字符串的入门知识。</p><span id="more"></span><h2 id="基础概念">基础概念</h2><p>定义 <span class="math inline">\(S\)</span> 为一个字符串，其长度为<span class="math inline">\(n=|S|\)</span>，不特殊说明的情况下，下标从<span class="math inline">\(1\)</span> 开始，<spanclass="math inline">\(S_i\)</span> 为 <spanclass="math inline">\(S\)</span> 中从左往右第 <spanclass="math inline">\(i\)</span> 个字符。</p><p><span class="math inline">\(S[l,r]\)</span> 为 <spanclass="math inline">\(S_l,S_{l+1} , \ldots S_{r}\)</span>，称为 <spanclass="math inline">\(S\)</span> 的一个子串。<spanclass="math inline">\(S[1,i]\)</span> 称为 <spanclass="math inline">\(S\)</span> 的一个前缀 (prefix)，<spanclass="math inline">\(S[i,n]\)</span> 为 <spanclass="math inline">\(S\)</span> 的一个后缀 (suffix)。</p><p>对于 <span class="math inline">\(S\)</span> 的一个子串 <spanclass="math inline">\(S_0\)</span>，满足 <spanclass="math inline">\(S_0\)</span> 不仅是 <spanclass="math inline">\(S\)</span> 的一个前缀，还是 <spanclass="math inline">\(S\)</span> 的一个后缀，那么称 <spanclass="math inline">\(S_0\)</span> 或其长度为 <spanclass="math inline">\(S\)</span> 的一个 Border。Border 不能是 <spanclass="math inline">\(S\)</span> 本身。</p><p><imgsrc="https://pic2.zhimg.com/80/v2-c3cd7adda369b334a8065b7eadf8e2cd_720w.jpg" srcset="/img/loading.gif" lazyload /></p><p>举个例子，对于一个字符串<code>s=QwQorzQwQ</code>，其中<code>QwQ</code>就是<code>s</code>的一个Border。</p><h2 id="kmp-算法">KMP 算法</h2><p>KMP算法主要来解决两个字符串的匹配问题，能够在线性时间内判断一个字符串是否为另一个字符串的子串并求出其出现位置。</p><p>对于字符串 <span class="math inline">\(S\)</span>，设 <spanclass="math inline">\(next_i\)</span> 为 <spanclass="math inline">\(S[1,i]\)</span> 中最长的 Border 的长度。</p><p>如何求出 <span class="math inline">\(next_i\)</span>？</p><p>朴素的做法是，枚举 <span class="math inline">\(j \in[1,i-1]\)</span>，判断 <span class="math inline">\(S[1,j]\)</span> 与<span class="math inline">\(S[i-j+1,i]\)</span> 是否相同，如果相同，那么<span class="math inline">\(j\)</span> 就是 <spanclass="math inline">\(next_i\)</span> 的一个“候选项”。取最大的 <spanclass="math inline">\(j\)</span> 即可。</p><p>但是复杂度奇高，不够。</p><p>引理：若 <span class="math inline">\(j_0\)</span> 是 <spanclass="math inline">\(next_i\)</span> 的一个“候选项”，那么小于 <spanclass="math inline">\(j_0\)</span> 的最大的 <spanclass="math inline">\(next_i\)</span> 的“候选项”是 <spanclass="math inline">\(next_{j_0}\)</span>。</p><blockquote><p>证明：反证法。假设存在 <span class="math inline">\(next_{j_0} &lt;j_1 &lt; j_0\)</span>，且 <span class="math inline">\(j_1\)</span> 是<span class="math inline">\(next_i\)</span> 的一个“候选项”，那么一定有<span class="math inline">\(S[1,j_1]=S[i-j_1+1,i]\)</span>。由于 <spanclass="math inline">\(S[1,j_0]=S[i-j_0+1,i]\)</span>，所以分别取 <spanclass="math inline">\(S[1,j_0]\)</span> 和 <spanclass="math inline">\(S[i-j_0+1,i]\)</span> 的后 <spanclass="math inline">\(j_1\)</span> 个字符，显然也相等，也就是 <spanclass="math inline">\(S[j_0-j_1+1,j_0] = S[1,j_1]\)</span>，从而 <spanclass="math inline">\(j_1\)</span> 是 <spanclass="math inline">\(S[1,j_0]\)</span> 的一个 Border，这与 <spanclass="math inline">\(next_{j_0}\)</span> 是 <spanclass="math inline">\(j_0\)</span> 的最大的 Border 相矛盾。由于 <spanclass="math inline">\(next_{j_0}\)</span> 是 <spanclass="math inline">\(j_0\)</span> 的前后缀，所以显然也是 <spanclass="math inline">\(next_i\)</span> 的一个 Border。</p><p>综上，命题得证。</p></blockquote><p>考虑如何求解。根据引理，当 <spanclass="math inline">\(next_{i-1}\)</span> 被计算完毕之后，就能够得到所有<span class="math inline">\(next_{i-1}\)</span> 的“候选项”。如果 <spanclass="math inline">\(j\)</span> 是 <spanclass="math inline">\(next_i\)</span> 的“候选项”，那么 <spanclass="math inline">\(j-1\)</span> 必然是 <spanclass="math inline">\(next_{i-1}\)</span>的“候选项”。这个通过手动模拟一下就能知道。</p><p>也就是说，我们可以用 <span class="math inline">\(next_{i-1}\)</span>的最大候选项 <span class="math inline">\(j\)</span> 来得到 <spanclass="math inline">\(next_i\)</span> 的最大候选项。如果 <spanclass="math inline">\(next_{i-1}=j\)</span> 且 <spanclass="math inline">\(S_i = S_{j+1}\)</span>，那么很显然，<spanclass="math inline">\(j+1\)</span> 就能够称为 <spanclass="math inline">\(next_i\)</span>的候选项，且一定是最大的。否则，对于任何 <spanclass="math inline">\(next_{i-1}\)</span>非最大的候选项，如果满足上述条件，也能变成 <spanclass="math inline">\(next_i\)</span> 的候选项。因此，只要枚举 <spanclass="math inline">\(next_{i-1}\)</span>的所有候选项，取满足条件且最大的即可。</p><p>流程。</p><p>首先有 <span class="math inline">\(next_1 = 0\)</span>，详见 Border的定义。</p><p>初始化 <spanclass="math inline">\(j=0\)</span>，表示当前匹配的长度，假设 <spanclass="math inline">\(next_{1 \sim i-1}\)</span> 都已经求解完成。如果<span class="math inline">\(j \neq 0\)</span> 且 <spanclass="math inline">\(S_i \neq S_{j+1}\)</span>，那就不断令 <spanclass="math inline">\(j=next_j\)</span>。如果 <spanclass="math inline">\(S_i = S_{j+1}\)</span> 了，那就让 <spanclass="math inline">\(j+1\)</span>。此时 <spanclass="math inline">\(next_i = j\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp">nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;    <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="hljs-number">1</span>]) j=nxt[j];    <span class="hljs-keyword">if</span>(s[i]==s[j+<span class="hljs-number">1</span>]) ++j;    nxt[i]=j;&#125;</code></pre></div><p>此外，如果要得到字符串 <span class="math inline">\(A\)</span> 与<span class="math inline">\(B\)</span> ($|B| |A| $) 匹配的结果，还要求出<span class="math inline">\(f\)</span>，表示一个 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 之间的广义 Border 的长度。<spanclass="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(A[1,i]\)</span> 与 <spanclass="math inline">\(B\)</span> 中以 <spanclass="math inline">\(i\)</span> 结尾的子串的最长匹配长度。形式化地<span class="math display">\[f_i = \max{\{j\}}\]</span> 其中 <span class="math inline">\(j \le i\)</span> 并且 <spanclass="math inline">\(A[1,j] = B[i-j+1,i]\)</span>。注意 <spanclass="math inline">\(next_i\)</span> 不能为 <spanclass="math inline">\(i\)</span>，但是 <spanclass="math inline">\(f_i\)</span> 能为 <spanclass="math inline">\(i\)</span>。</p><p>方法也是类似的。</p><div class="code-wrapper"><pre><code class="hljs cpp">nxt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;    <span class="hljs-keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="hljs-number">1</span>]) j=nxt[j];    <span class="hljs-keyword">if</span>(b[i]==b[j+<span class="hljs-number">1</span>]) ++j;    nxt[i]=j;&#125;<span class="hljs-comment">// 先求出较小串的next</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;    <span class="hljs-comment">// 这里i从1开始</span>    <span class="hljs-keyword">while</span>(j&amp;&amp;b[j+<span class="hljs-number">1</span>]!=a[i]) j=nxt[j];    <span class="hljs-keyword">if</span>(b[j+<span class="hljs-number">1</span>]==a[i]) ++j;    f[i]=j;    <span class="hljs-comment">// f[i]==m 表示b在a中出现了</span>    <span class="hljs-keyword">if</span>(j==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-m+<span class="hljs-number">1</span>), j=nxt[j];&#125;</code></pre></div><p>KMP 算法的复杂度是 <span class="math inline">\(O(N+M)\)</span>的，如果只用来求 <span class="math inline">\(next\)</span> 则是 <spanclass="math inline">\(O(N)\)</span> 的。证明略。</p><h3 id="失配树">失配树</h3><p>见 <a href="https://miku01ck.xyz//string-solution-1">这篇博客</a>的倒数第三题。</p><p>早晚会补上的。</p><h2 id="trie">Trie</h2><p>像字典那样把字符串串在一棵树上哦~</p><p>没啥可写的，直接上板子好了。</p><p>这东西念作<code>Tree</code>……</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> tot, trie[N][<span class="hljs-number">26</span>];<span class="hljs-comment">// N要大于字符串个数*字符串长度</span><span class="hljs-comment">// 26是字符集</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-keyword">int</span> a=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;        <span class="hljs-comment">// 建立新结点</span>x=trie[x][a];&#125;    <span class="hljs-comment">// 插入一个字符串</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i) &#123;<span class="hljs-keyword">int</span> a=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 找不到节点</span>x=trie[x][a];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">114514</span>; <span class="hljs-comment">// 返回你想要的信息</span>&#125;</code></pre></div><p>这玩意是典型的空间换时间……</p><h3 id="一个简单应用-0-1-trie">一个简单应用 0-1 Trie</h3><p>把<code>int</code>当作长度为 <span class="math inline">\(31\)</span>的字符串插入 Trie 中。</p><p>下面放板子，可以快速处理最大异或和的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> tot, trie[N*<span class="hljs-number">31</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">// [数字个数*数位][每一位不是0就是1]</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> S)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!trie[x][a]) trie[x][a]=++tot;x=trie[x][a];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> S)</span> </span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">int</span> a=(S&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(trie[x][a^<span class="hljs-number">1</span>]) ans+=(<span class="hljs-number">1</span>&lt;&lt;i), x=trie[x][a^<span class="hljs-number">1</span>];        <span class="hljs-comment">// 尽量往数字相反的地方走，这样异或值为1</span><span class="hljs-keyword">else</span> x=trie[x][a];&#125;<span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><h2 id="dfa-是个啥">DFA 是个啥？</h2><p>有限自动机 (FA)，确定有限状态自动机 (DFA)。</p><p>下面都是一些概念，<del>我甚至还没有完全理解</del>，还是太菜了。</p><p>我们通常用确定有限状态自动机 (DFA) 解决大部分字符串的问题。</p><p>DFA 可以用一个 <span class="math inline">\(5\)</span> 元组 <spanclass="math inline">\((Q,\Sigma,\delta,q_0,F)\)</span> 表示，其中 <spanclass="math inline">\(Q\)</span> 为状态集, <spanclass="math inline">\(\Sigma\)</span> 为字符集，<spanclass="math inline">\(\delta\)</span> 为转移函数，<spanclass="math inline">\(q_0\)</span> 为起始状态，<spanclass="math inline">\(F\)</span> 为终态集。</p><p>如何判断一个字符串是否能被一个 DFA 接受呢？一开始时，自动机在起始状态<span class="math inline">\(q_0\)</span> ，每读入一个字符 <spanclass="math inline">\(c\)</span> 后，状态转移到 <spanclass="math inline">\(\delta(q,c)\)</span> ，其中 <spanclass="math inline">\(q\)</span> 为当前状态。当整个字符串读完之后,当且仅当 <span class="math inline">\(q\)</span> 在终态集 <spanclass="math inline">\(F\)</span> 中时，DFA 接受这个字符串。</p><p><span class="math inline">\(Trie\)</span> 是一种最简单的 DFA。</p><p>插入每个模式串的时候，从前往后依次考虑每一位 <spanclass="math inline">\(c\)</span> ，然后记当前所在的状态 <spanclass="math inline">\(q\)</span> ，如果不存在 <spanclass="math inline">\(\delta(q,c)\)</span> 那么添加一个 <spanclass="math inline">\(\delta(q,c)\)</span> 的转移。接下来 <spanclass="math inline">\(q \rightarrow \delta(q,c)\)</span>。终态的 <spanclass="math inline">\(q\)</span> 作为 DFA 的一个 <spanclass="math inline">\(F\)</span> 的一个元素。</p><p><span class="math inline">\(Trie\)</span>能接受的所有字符串就是插入的所有的串。</p><p>至于 AC 自动机啥的，目前不会……😥</p><p>为啥你的学习笔记里面一道题都没有呢？</p><p>一是因为懒，而是因为想加进来的题目有点多……</p><h2 id="参考">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/545135464">字符串学习笔记(1)基础概念与kmp前置</a></li><li><a href="https://zhuanlan.zhihu.com/p/546135224">字符串学习笔记(2)字典树与Border树</a></li><li><ahref="https://www.cnblogs.com/Y25t/p/12459152.html">从0开始的字符串学习--KMP与失配树</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#812 (Div 2)</title>
    <link href="/2022/cf1713-solution/"/>
    <url>/2022/cf1713-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1713</strong>.</p><span id="more"></span><h1 id="a.-traveling-salesman-problem">A. Traveling SalesmanProblem</h1><h2 id="分析">分析</h2><p>注意到答案为 <span class="math inline">\(2 \cdot(Rx-Lx+Ry-Ly)\)</span>，其中 <span class="math inline">\(Rx\)</span>为最大的横坐标，<span class="math inline">\(Lx\)</span>为最小的横坐标，<span class="math inline">\(Ry\)</span> 与 <spanclass="math inline">\(Ly\)</span> 同理。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> t, n, x[<span class="hljs-number">105</span>], y[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> Lx=<span class="hljs-number">0</span>, Rx=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> Ly=<span class="hljs-number">0</span>, Ry=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;x[i]=<span class="hljs-built_in">read</span>(), y[i]=<span class="hljs-built_in">read</span>();Lx=<span class="hljs-built_in">min</span>(Lx,x[i]), Rx=<span class="hljs-built_in">max</span>(Rx,x[i]);Ly=<span class="hljs-built_in">min</span>(Ly,y[i]), Ry=<span class="hljs-built_in">max</span>(Ry,y[i]);&#125;<span class="hljs-keyword">int</span> d1=Rx-Lx;<span class="hljs-keyword">int</span> d2=Ry-Ly;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(d1+d2)&lt;&lt;<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-optimal-reduction">B. Optimal Reduction</h1><h2 id="分析-1">分析</h2><p>最优策略是不断“削平”，<span class="math inline">\(1,2,3 \rightarrow0,1,2, \rightarrow 0,0,1 \rightarrow 0 , 0 ,0\)</span>。</p><p>注意到如果存在一个「谷」，那么在操作中必然存在 <spanclass="math inline">\(0\)</span>把两边元素隔开，从而让操作次数增加。<span class="math inline">\(2 ,1, 3\rightarrow 1 , 0 ,2 \rightarrow 0 , 0 , 2 \rightarrow 0 , 0 ,1\rightarrow 0 , 0 ,0\)</span>。</p><p>而这个「谷」不一定非要是与相邻的两个数，比如 <spanclass="math inline">\(5 , 2 ,2 ,5\)</span> 这样的。</p><p>所以设前缀 <span class="math inline">\(\max\)</span> 为 <spanclass="math inline">\(p_i\)</span>，后缀 $$ 为 <spanclass="math inline">\(q_i\)</span>。判断是否存在一个 <spanclass="math inline">\(i\)</span>，满足 <spanclass="math inline">\(p_{i-1} &gt; a_i\)</span> 且 <spanclass="math inline">\(a_i &lt; q_{i+1}\)</span>。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N], p[N], q[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">bool</span> fg=<span class="hljs-number">1</span>;p[<span class="hljs-number">0</span>]=q[n+<span class="hljs-number">1</span>]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), p[i]=<span class="hljs-built_in">max</span>(p[i<span class="hljs-number">-1</span>],a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) q[i]=<span class="hljs-built_in">max</span>(q[i+<span class="hljs-number">1</span>],a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&lt;p[i<span class="hljs-number">-1</span>]&amp;&amp;a[i]&lt;q[i+<span class="hljs-number">1</span>]) fg=<span class="hljs-number">0</span>;&#125;<span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-build-permutation">C. Build Permutation</h1><h2 id="分析-2">分析</h2><p>考虑一个事实，对于任意正整数 <spanclass="math inline">\(n\)</span>，在 <spanclass="math inline">\([n,2n]\)</span> 区间内一定存在一个完全平方数。</p><p>那么从 <span class="math inline">\(x=n-1\)</span> 开始，找到大于<span class="math inline">\(x\)</span> 的最小的完全平方数 <spanclass="math inline">\(t\)</span>，对于 <span class="math inline">\(i \in[t-x,x]\)</span>，令 <span class="math inline">\(ans_i = t-i\)</span>即可，之后让 <span class="math inline">\(x= t-x-1\)</span>。</p><p>直到 <span class="math inline">\(x=-1\)</span> 为止。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, ans[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> x=n<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(~x) &#123;<span class="hljs-keyword">int</span> t=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*x);t*=t;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=t-x;i&lt;=x;++i) ans[i]=t-i;x=t-x<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n<span class="hljs-number">-1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-tournament-countdown">D. Tournament Countdown</h1><h2 id="分析-3">分析</h2><p>这是一道交互题，也是我的第一道交互题。</p><p>先来考虑，两个人获胜场数相同意味着什么？由于胜利者会晋级，淘汰者再也不能参加比赛，所以两个人获胜场数相同，意味着这两人必定晋级到了同一轮。</p><p>那么如果 <span class="math inline">\(a\)</span> 的获胜次数大于 <spanclass="math inline">\(b\)</span>，说明 <spanclass="math inline">\(a\)</span> 晋级到了更高的一轮，否则就反过来。</p><p>由于询问次数最多为 <span class="math inline">\(\frac{2}{3}2^n\)</span>，设 <span class="math inline">\(m= 2^n\)</span>所以有一个我想不到的结论，只要每次对 <spanclass="math inline">\(4\)</span>个人进行两次询问，就能直到哪个人晋级，从而询问数量为 <spanclass="math display">\[2 \times ( \frac{1}{4}m + \frac{1}{16}m + \frac{1}{64}m +\cdots) =\frac{2}{3}m\]</span> 等比数列求和公式——我从来都背不过的东西。</p><p>那么怎么样对 <span class="math inline">\(4\)</span>个人进行两次询问，就能得到最终晋级者呢？</p><p>对于第 <span class="math inline">\(i\)</span> 个人，其中 <spanclass="math inline">\(i\)</span> 是 <spanclass="math inline">\(4\)</span> 人中的第一个，<spanclass="math inline">\(i\)</span> 要和 <spanclass="math inline">\(i+1\)</span> 对抗，<spanclass="math inline">\(i+2\)</span> 和 <spanclass="math inline">\(i+3\)</span> 对抗。</p><p>询问 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(i+2\)</span>，如果胜利场数相同，说明二人都输给了与自己对抗的人。如果都打败了与自己对抗的人，虽然此时也相同，但是最后<span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(i+2\)</span>必然要分出胜负，所以这种情况不会发生。此时只要询问 <spanclass="math inline">\(i+1\)</span> 和 <spanclass="math inline">\(i+3\)</span> 就能找到胜利者。</p><p>否则如果 <span class="math inline">\(i\)</span> 的获胜次数大于 <spanclass="math inline">\(i+2\)</span>，就询问 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(i+3\)</span>。如果 <spanclass="math inline">\(i\)</span> 的获胜次数小于 <spanclass="math inline">\(i+2\)</span>，就询问 <spanclass="math inline">\(i+1\)</span> 和 <spanclass="math inline">\(i+2\)</span>。</p><p>综上，必然能够满足条件。</p><p>特别地，当只剩下 <span class="math inline">\(2\)</span>人时，只要询问 <span class="math inline">\(1\)</span> 次就可以了。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, ans[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;? &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;<span class="hljs-keyword">int</span> x; cin&gt;&gt;x;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;cin&gt;&gt;n;n=<span class="hljs-number">1</span>&lt;&lt;n;vector&lt;<span class="hljs-keyword">int</span>&gt; a, b;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a.<span class="hljs-built_in">pb</span>(i);<span class="hljs-keyword">while</span>(a.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>) &#123;b.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i+=<span class="hljs-number">4</span>) &#123;<span class="hljs-keyword">int</span> res=<span class="hljs-built_in">ask</span>(a[i],a[i+<span class="hljs-number">2</span>]);<span class="hljs-keyword">if</span>(!res) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask</span>(a[i+<span class="hljs-number">1</span>],a[i+<span class="hljs-number">3</span>])==<span class="hljs-number">1</span>) b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">3</span>]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask</span>(a[i],a[i+<span class="hljs-number">3</span>])==<span class="hljs-number">1</span>) b.<span class="hljs-built_in">pb</span>(a[i]);<span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">3</span>]);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask</span>(a[i+<span class="hljs-number">2</span>],a[i+<span class="hljs-number">1</span>])==<span class="hljs-number">1</span>) b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">2</span>]);<span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pb</span>(a[i+<span class="hljs-number">1</span>]);&#125;&#125;a=b;&#125;<span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()==<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">int</span> res=<span class="hljs-built_in">ask</span>(a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span>(res==<span class="hljs-number">2</span>) a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>];&#125;cout&lt;&lt;<span class="hljs-string">&quot;! &quot;</span>&lt;&lt;a[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e.-cross-swapping">E. Cross Swapping</h1><p>太菜了不会。</p><h1 id="f.-lost-array">F. Lost Array</h1><p>太菜了不会。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>交互题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「AtCoder Beginner Contest」#263</title>
    <link href="/2022/abc263-solution/"/>
    <url>/2022/abc263-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>ABC263</strong>.</p><span id="more"></span><h1 id="a.-full-house">A. Full House</h1><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> h[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;++i) ++h[<span class="hljs-built_in">read</span>()];<span class="hljs-keyword">int</span> f1=<span class="hljs-number">0</span>, f2=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">13</span>;++i) &#123;<span class="hljs-keyword">if</span>(h[i]==<span class="hljs-number">3</span>) f1=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h[i]==<span class="hljs-number">2</span>) f2=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(f1&amp;&amp;f2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;</code></pre></div><h1 id="b.-ancestor">B. Ancestor</h1><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">500</span>;<span class="hljs-keyword">int</span> n, dep[N];vector&lt;<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;dep[x]=dep[fa]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> pp=<span class="hljs-built_in">read</span>();p[i].<span class="hljs-built_in">push_back</span>(pp), p[pp].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dep[n]<span class="hljs-number">-1</span>);&#125;</code></pre></div><h1 id="c.-monotonically-increasing">C. Monotonically Increasing</h1><h2 id="分析">分析</h2><p>搜</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">50</span>;<span class="hljs-keyword">int</span> n, m, len, ans[N], c[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> now)</span> </span>&#123;<span class="hljs-keyword">if</span>(now==n) &#123; <span class="hljs-built_in">print</span>(ans); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos+<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;ans[now+<span class="hljs-number">1</span>]=i;<span class="hljs-built_in">dfs</span>(i,now+<span class="hljs-number">1</span>);ans[now+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div><h1 id="d.-left-right-operation">D. Left Right Operation</h1><h2 id="分析-1">分析</h2><p>不难发现，让修改的前缀和后缀交错是没有任何意义的，所以可以认为 <spanclass="math inline">\(x\)</span> 严格小于 <spanclass="math inline">\(n-y+1\)</span>。</p><p>仿照 <span class="math inline">\(DP\)</span>的套路，注意到可以直接维护 <span class="math inline">\(p_i\)</span> 表示<span class="math inline">\([1,i]\)</span> 的最小值，<spanclass="math inline">\(q_i\)</span> 表示 <spanclass="math inline">\([i,n]\)</span> 的最小值。 <spanclass="math display">\[p_i = \min\{ p_{i-1}+a_i,L \cdot i \}\]</span></p><p><span class="math display">\[q_i = \min\{ q_{i+1}+a_i,R \cdot (n-i+1) \}\]</span></p><p>找到最小的 <span class="math inline">\(p_i + q_{i+1}\)</span>即可。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, L, R, ans, a[N], p[N], q[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), L=<span class="hljs-built_in">read</span>(), R=<span class="hljs-built_in">read</span>();p[<span class="hljs-number">0</span>]=p[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=a[i]=<span class="hljs-built_in">read</span>(), p[i]=<span class="hljs-built_in">min</span>(p[i<span class="hljs-number">-1</span>]+a[i],L*i);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) q[i]=<span class="hljs-built_in">min</span>(q[i+<span class="hljs-number">1</span>]+a[i],R*(n-i+<span class="hljs-number">1</span>));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;ans=<span class="hljs-built_in">min</span>(ans,p[i]+q[i+<span class="hljs-number">1</span>]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="e.-sugoroku-3">E. Sugoroku 3</h1><h2 id="分析-2">分析</h2><p>设 <span class="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(n\)</span> 的期望步数，有 <spanclass="math inline">\(f_n =0\)</span>。 <span class="math display">\[f_i = 1 + \frac{\sum_{j=1}^{a_i} f(i+j) }{a_i +1} + \frac{f_i}{a_i+1}\]</span> 含义：<span class="math inline">\(1\)</span>是投掷骰子这一步，结果是正数的总期望值是第二项，结果是 <spanclass="math inline">\(0\)</span> 意味着还要再 <spanclass="math inline">\(i\)</span> 呆一次，期望值是第三项。</p><p>简单化简 <span class="math display">\[f_i = \frac{\sum_{j=1}^{a_i}f(i+j) + a_i + 1}{a_i}\]</span> 那个和式可以用后缀和 <span class="math inline">\(O(1)\)</span>得到。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, a[N], s[N], f[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) a[i]=<span class="hljs-built_in">read</span>();f[n]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i;--i) &#123;<span class="hljs-keyword">int</span> S=((s[i+<span class="hljs-number">1</span>]-s[i+a[i]+<span class="hljs-number">1</span>])%mod+a[i]+<span class="hljs-number">1</span>)%mod;f[i]=S*<span class="hljs-built_in">fp</span>(a[i],mod<span class="hljs-number">-2</span>)%mod;s[i]=(s[i+<span class="hljs-number">1</span>]+f[i])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>]+mod)%mod);&#125;</code></pre></div><h1 id="f.-tournament">F. Tournament</h1><h2 id="分析-3">分析</h2><p>人数是 <span class="math inline">\(2\)</span>的整数次幂，考虑一个类似分治的做法。</p><p>由于最终一定会留下一个获胜的人，设 <spanclass="math inline">\(f_i\)</span> 为 <spanclass="math inline">\(i\)</span> 获胜的最大收益。注意 <spanclass="math inline">\(C_{i,j}\)</span> 是第 <spanclass="math inline">\(i\)</span> 个人恰好赢了 <spanclass="math inline">\(j\)</span> 场得到的收益，如果 <spanclass="math inline">\(i\)</span> 多赢了一场，那么就要获得 <spanclass="math inline">\(C_{i,j+1}\)</span>，去掉 <spanclass="math inline">\(C_{i,j}\)</span>。</p><p>考虑一个自底向上的过程 <spanclass="math inline">\(solve(l,r,d)\)</span>，表示编号在 <spanclass="math inline">\([l,r]\)</span> 中的人，此时是第 <spanclass="math inline">\(d\)</span> 场。令 <span class="math inline">\(mid= \frac{l+r}{2}\)</span>。</p><p>在更新信息之前，设 <span class="math inline">\(p =\max_{i=l}^{mid}{\{ f_i \}}\)</span>，<span class="math inline">\(q =\max_{i=mid+1}^r{\{ f_i \}}\)</span>。</p><p>由于能够自由安排比赛，假设 <spanclass="math inline">\([l,mid]\)</span> 中的人全部胜出，那么有 <spanclass="math inline">\(C_{i,d} - C_{i,d-1} \rightarrow f_i\)</span>。由于<span class="math inline">\(i\)</span>胜利之后必然有一个人告负，所以对于每个胜利者，都让打败的人在第 <spanclass="math inline">\(d-1\)</span> 层得到的收益最大即可，所以 <spanclass="math inline">\(C_{i,d} - C_{i,d-1} + q \rightarrowf_i\)</span></p><p>反过来，若 <span class="math inline">\(i \in[mid+1,r]\)</span>，<span class="math inline">\(C_{i,d} - C_{i,d-1} + p\rightarrow f_i\)</span>。</p><p>答案为 <span class="math inline">\(\max{\{f_i \}}\)</span>。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">16</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, c[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)+<span class="hljs-number">5</span>][N+<span class="hljs-number">5</span>], f[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)+<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> d)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">solve</span>(l,mid,d<span class="hljs-number">-1</span>), <span class="hljs-built_in">solve</span>(mid+<span class="hljs-number">1</span>,r,d<span class="hljs-number">-1</span>);<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>, q=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=mid;++i) p=<span class="hljs-built_in">max</span>(p,f[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i) q=<span class="hljs-built_in">max</span>(q,f[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=mid;++i) f[i]+=c[i][d]-c[i][d<span class="hljs-number">-1</span>]+q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i) f[i]+=c[i][d]-c[i][d<span class="hljs-number">-1</span>]+p;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1</span>&lt;&lt;n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) c[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;n,n);<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1</span>&lt;&lt;n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="g.-erasing-prime-pairs">G. Erasing Prime Pairs</h1><h2 id="分析-4">分析</h2><p>注意到，如果把奇数作为左部点，偶数作为右部点。如果一个左部点和一个右部点相加是个质数，那么在他们之间连边，这样就能形成一张二分图。而奇数与奇数，偶数与偶数的和必然不是质数，每个数能够使用多次，求它的最大多重匹配即可。</p><p>但是存在一个特例，数字 <span class="math inline">\(1\)</span>。<spanclass="math inline">\(1\)</span> 可以和自身匹配，也可以和偶数匹配。</p><p>一个错误的想法是直接将 <span class="math inline">\(1\)</span>加入图中，用最大流算法求出最大多重匹配之后，找到 <spanclass="math inline">\(1\)</span> 在残量网络中对应的边，设其容量为 <spanclass="math inline">\(w\)</span>，则让答案加上 <spanclass="math inline">\(\lfloor \frac{w}{2}\rfloor\)</span>，含义是让剩下的 <span class="math inline">\(1\)</span>两两配对。</p><p>这个想法错在可能会有剩下的 <spanclass="math inline">\(1\)</span>，这个 <spanclass="math inline">\(1\)</span>可能和没有在最大多重匹配之中的点匹配。</p><p>正确的做法是先不将 <span class="math inline">\(1\)</span>加入图中，跑出最大匹配。然后将 <span class="math inline">\(1\)</span>有关的边加入残量网络中，再跑一次最大匹配（因为 <spanclass="math inline">\(1\)</span> 自己匹配和与别的点匹配，贡献都是 <spanclass="math inline">\(1\)</span>），最后加上 <spanclass="math inline">\(\lfloor \frac{w}{2} \rfloor\)</span>即可。此时如果还有剩下的 <spanclass="math inline">\(1\)</span>，那么这个 <spanclass="math inline">\(1\)</span>既不能和其他数匹配，又不能自己匹配，只能扔掉了。</p><h2 id="code-6">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-keyword">int</span> n, s, t, one, ans, a[N], b[N], d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[<span class="hljs-number">6</span>*N], w[<span class="hljs-number">6</span>*N], nxt[<span class="hljs-number">6</span>*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>); &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) d[i]=<span class="hljs-number">0</span>;d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-keyword">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) ans+=<span class="hljs-built_in">dfs</span>(s,inf);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();s=<span class="hljs-number">0</span>, t=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">addedge</span>(s,i,b[i]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">addedge</span>(i,t,b[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(a[i]&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(!(a[j]&amp;<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-built_in">isprime</span>(a[i]+a[j])) <span class="hljs-built_in">addedge</span>(i,j,inf);&#125;ans=<span class="hljs-built_in">dinic</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">addedge</span>(s,i,b[i]), one=tot;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!(a[j]&amp;<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-built_in">isprime</span>(<span class="hljs-number">1</span>+a[j])) <span class="hljs-built_in">add</span>(i,j,inf);&#125;ans+=<span class="hljs-built_in">dinic</span>();<span class="hljs-keyword">if</span>(one) ans+=w[one<span class="hljs-number">-1</span>]/<span class="hljs-number">2</span>;    <span class="hljs-comment">// 边的编号从1开始</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="ex">Ex</h1><p>太菜了没看。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>数学期望</tag>
      
      <tag>分治</tag>
      
      <tag>网络流</tag>
      
      <tag>最大流</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Edu Codeforces Round」#133 (Div 2)</title>
    <link href="/2022/cf1716-solution/"/>
    <url>/2022/cf1716-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1716</strong>.</p><span id="more"></span><h1 id="a.-2-3-moves">A. 2-3 Moves</h1><h2 id="分析">分析</h2><p>注意到 <span class="math inline">\(n=1\)</span> 的时候要使用 <spanclass="math inline">\(+3\)</span>，<spanclass="math inline">\(-2\)</span> 两次操作。</p><p>如果 <span class="math inline">\(3 \mid n\)</span>，那么全部用 <spanclass="math inline">\(3\)</span> 就好，操作数 <spanclass="math inline">\(\frac{n}{3}\)</span>。</p><p>否则当 <span class="math inline">\(n \equiv 2 \pmod 3\)</span>时，先用一次 <span class="math inline">\(2\)</span> 然后全部用 <spanclass="math inline">\(3\)</span> 即可，操作数 <spanclass="math inline">\(\lfloor \frac{n}{3} \rfloor + 1\)</span>。</p><p>否则一定有 <span class="math inline">\(n \equiv 1 \pmod3\)</span>，那么由于 <span class="math inline">\(n \neq1\)</span>，所以必定存在一个 <spanclass="math inline">\(4\)</span>，用两次 <spanclass="math inline">\(2\)</span>，剩下的一定是 <spanclass="math inline">\(3\)</span> 的倍数。不难发现操作数仍然是 <spanclass="math inline">\(\lfloor \frac{n}{3} \rfloor + 1\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) ans=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) ans=n/<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> ans=n/<span class="hljs-number">3</span>+<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-permutation-chain">B. Permutation Chain</h1><h2 id="分析-1">分析</h2><p>注意最优解中第一次肯定是从 <span class="math inline">\(1\)</span> 到<span class="math inline">\(n\)</span>，fixedness 为 <spanclass="math inline">\(n\)</span>。经过一次交换后 fixedness 必定为 <spanclass="math inline">\(n-2\)</span>，之后每一次交换都一定有办法让fixedness 减少 <span class="math inline">\(1\)</span>，最终为 <spanclass="math inline">\(0\)</span>。</p><p>直接输出 <span class="math inline">\(n\)</span>然后随便乱搞即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-keyword">int</span> t, n, ans[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,a[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n);<span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans[i]=i;<span class="hljs-built_in">print</span>(ans);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-2</span>;~i;--i) &#123;<span class="hljs-built_in">swap</span>(ans[p],ans[p+<span class="hljs-number">1</span>]);<span class="hljs-built_in">print</span>(ans);++p;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-robot-in-a-hallway">C. Robot in a Hallway</h1><h2 id="分析-2">分析</h2><p>由于本人比较懒，所以直接用网图了 awa。侵删。</p><p>由于要经过每一个格子，所以走法必定是先走蛇形然后「コ」形。<del>实在是无法形容所以直接用这个片假名orz</del>。当然也可以全部走蛇形或者全部走「コ」形，其中蛇形必然是先向下走。</p><p><imgsrc="https://pic3.zhimg.com/80/v2-a10661f2b15524cc218cb738acb3c86a_720w.jpg" srcset="/img/loading.gif" lazyload /></p><p>这张图也就说明了「コ」形路线必然确定了终点的位置。</p><p>设 <span class="math inline">\(f(i=0/1,j)\)</span> 为从起点到达 <spanclass="math inline">\((i,j)\)</span>，再向右走「コ」形最终到达 <spanclass="math inline">\((i \operatorname{xor} 1,j)\)</span>的时间。转移如下</p><ol type="1"><li>能到达 <span class="math inline">\((i,j)\)</span> 的最早时间为 <spanclass="math inline">\(a_{i,j} +1\)</span>，如果路上所有格子都能够经过，那么走到 <spanclass="math inline">\((i \operatorname{xor} 1,j)\)</span>的最早时间为还要加上 <span class="math inline">\(2 \cdot (n-j+1)-1\)</span>。</li><li><span class="math inline">\(f(i,j+1)\)</span> 差一步就走到 <spanclass="math inline">\((i \operatorname{xor} 1,j)\)</span> 了，如果此时<span class="math inline">\((i \operatorname{xor} 1,j)\)</span>可以经过，时间就要加上 <span class="math inline">\(1\)</span>。</li><li><span class="math inline">\(a_{i \operatorname{xor} 1,j} +1\)</span>，题目规定的最早时间。</li></ol><p>三种情况取最大值。</p><p>但是此时最小的 <span class="math inline">\(f(i,j)\)</span>仍然不一定是答案。就比如</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">3</span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>手算易得答案为 <span class="math inline">\(10\)</span>，但是最小的<span class="math inline">\(f(i,j)\)</span> 答案为 <spanclass="math inline">\(3\)</span>。</p><p>这是因为我们默认了从起点到 <span class="math inline">\((i,j)\)</span>的过程中畅通无阻。此时只要设当前时间为 <spanclass="math inline">\(cur\)</span>，假设后面所有点都畅通无阻就行了，时间为<span class="math inline">\(cur + 2 \cdot (n-j+1) -1\)</span>。</p><p>那么下面这组数据呢？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">4</span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">100</span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">100</span></code></pre></div><p>上面的那种解决方案失效了，可是又被 <spanclass="math inline">\(f(i,j)\)</span> 的第二种转移覆盖了。</p><p>模拟走蛇形路线，计算将每个 <span class="math inline">\(i\)</span>作为终点的时间即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[<span class="hljs-number">2</span>][N], f[<span class="hljs-number">2</span>][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) a[i][j]=<span class="hljs-built_in">read</span>();a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">-1</span>;f[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>]=f[<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n;j;--j) &#123;f[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(a[i][j]+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*(n-j+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>,f[i][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>),a[i^<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>, ans=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">int</span> i=(j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>;ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">max</span>(f[i][j],cur+<span class="hljs-number">2</span>*(n-j+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>));cur=<span class="hljs-built_in">max</span>(cur,a[i][j]+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;cur=<span class="hljs-built_in">max</span>(cur,a[i^<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><p>这不比 D 难？</p><h1 id="d.-chip-move">D. Chip Move</h1><h2 id="分析-3">分析</h2><p>问题转化一下。有一个 <span class="math inline">\(0 \rightarrown\)</span> 的数轴，从 <span class="math inline">\(0\)</span>开始跳跃任意次，第 <span class="math inline">\(i\)</span> 次跳跃的距离是<span class="math inline">\(k+i-1\)</span> 的倍数。</p><p>对于 <span class="math inline">\(x \in [1,n]\)</span>，求出跳到 <spanclass="math inline">\(x\)</span> 的方案数。</p><p>设 <span class="math inline">\(\Delta_i = k+i-1\)</span>，<spanclass="math inline">\(f(j)\)</span> 为跳到 <spanclass="math inline">\(j\)</span> 的方案数。注意到将 <spanclass="math inline">\(i\)</span> 作为阶段的话，计算 <spanclass="math inline">\(f\)</span> 的过程相当于完全背包问题。背包容量为<span class="math inline">\(j\)</span>，物品体积则为 <spanclass="math inline">\(\Delta_i\)</span>，选择 <spanclass="math inline">\(\Delta_i\)</span> 的 <spanclass="math inline">\(n\)</span> 倍就是 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(\Delta_i\)</span>。</p><p>对于每个阶段，分别累加答案即可。</p><p>注意完全背包问题是每个物品可以选择任意次，但是本题至少选择 <spanclass="math inline">\(1\)</span> 次。所以可以使用「平移」的办法，令<span class="math inline">\(i\)</span> 阶段的 <spanclass="math inline">\(f(j)\)</span> 的值等于 <spanclass="math inline">\(i-1\)</span> 阶段 <spanclass="math inline">\(f(j-\Delta_i)\)</span>的值，这样就相当于强制选择一个 <spanclass="math inline">\(\Delta_i\)</span>。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> t, n, k, f[N], ans[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) ans[i]=<span class="hljs-number">0</span>;f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> dlt=k+i<span class="hljs-number">-1</span>;cur+=dlt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n;j&gt;=dlt;--j) f[j]=f[j-dlt];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;dlt;++j) f[j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=dlt;j&lt;=n;++j) (f[j]+=f[j-dlt])%=mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=dlt;j&lt;=n;++j) (ans[j]+=f[j])%=mod;<span class="hljs-keyword">if</span>(cur&gt;n) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e.-swap-and-maximum-block">E. Swap and Maximum Block</h1><p>不会</p><h1 id="f.-bags-with-balls">F. Bags with Balls</h1><p>不会</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「杂题选讲」#2</title>
    <link href="/2022/tititi-solution-2/"/>
    <url>/2022/tititi-solution-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>菜死了啊。</p><p>都是些比较简单的题目，<del>可惜我做不出来</del></p><span id="more"></span><h1 id="abc261d-flipping-and-bonus">ABC261D Flipping and Bonus</h1><h2 id="分析">分析</h2><p>称正面朝上为获胜，反面朝上为失败。</p><p>一开始认为，输掉一局相当于把计数器置 <spanclass="math inline">\(0\)</span>，所以应该加入状态，设 <spanclass="math inline">\(f(i,j)\)</span> 为前 <spanclass="math inline">\(i\)</span> 局，输掉 <spanclass="math inline">\(j\)</span>局，所能得到的最大收益。这个状态最大的问题是信息缺失。你怎么知道你赢下第<span class="math inline">\(i\)</span> 局是几连胜？无法转移。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为前 <spanclass="math inline">\(i\)</span> 局，其中第 <spanclass="math inline">\(i\)</span> 局为 <spanclass="math inline">\(j\)</span> 连胜。特别地，当 <spanclass="math inline">\(j=0\)</span> 时表示输掉第 <spanclass="math inline">\(i\)</span>局。相比于上一个状态，这个状态是能够进行转移的，且没有荣誉信息，是正确的状态。</p><p>转移就比较简单了 <span class="math display">\[f(i,j) =\begin{cases}f(i-1,j-1) + x_i + b_j &amp; j &gt; 0\\\max_{k \in [0,i-1]}{\{ f(i-1,k) \}} &amp; j=0\end{cases}\]</span> 最终答案 <span class="math display">\[\max_{i \in [1,n]} {\{ f(n,i) \}}\]</span> 最后一局输掉显然不划算啊。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> n, m, x[N], b[N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) x[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> c=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();b[c]=y;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+x[i]+b[j];f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][j]);&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="abc261d-sorting-color-balls">ABC261D Sorting Color Balls</h1><h2 id="分析-1">分析</h2><p>首先明确冒泡排序的交换次数就是逆序对的个数。</p><p>注意到相同颜色的球，交换它们是不耗费代价的。</p><p>很容易想到答案即为总的逆序对个数减去同种颜色的逆序对个数。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, ans, a[N], c[N];vector&lt;<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">for</span>(;x&lt;=<span class="hljs-number">3e5</span>;x+=x&amp;-x) c[x]+=y; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) ans+=c[x];<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();p[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(x);p[a[i]].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> sz=p[i].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) &#123;<span class="hljs-keyword">int</span> dlt=<span class="hljs-built_in">query</span>(n)-<span class="hljs-built_in">query</span>(x);            <span class="hljs-comment">// 逆序对</span><span class="hljs-keyword">if</span>(!i) ans+=dlt; <span class="hljs-keyword">else</span> ans-=dlt;            <span class="hljs-comment">// i=0为原序列，否则为颜色i</span><span class="hljs-built_in">modify</span>(x,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:p[i]) <span class="hljs-built_in">modify</span>(x,<span class="hljs-number">-1</span>);        <span class="hljs-comment">// 删除</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="abc262c-min-max-pair">ABC262C Min Max Pair</h1><h2 id="分析-2">分析</h2><p>注意到当 <span class="math inline">\(a_i = i\)</span> 与任何 <spanclass="math inline">\(a_j = j\)</span>，其中 <spanclass="math inline">\(i &lt; j\)</span>，配对时都满足条件。设满足 <spanclass="math inline">\(a_i = i\)</span> 的 <spanclass="math inline">\(i\)</span> 的个数为 <spanclass="math inline">\(t\)</span>，则答案一定含有 <spanclass="math inline">\(\frac{t(t+1)}{2}\)</span>。</p><p>否则若 <span class="math inline">\(a_i = j\)</span> 且 <spanclass="math inline">\(j &gt; i\)</span>，那么 <spanclass="math inline">\(a_j\)</span> 必须为 <spanclass="math inline">\(i\)</span> 才能满足条件。扫一遍即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> n, ans, t, a[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]==i) ++t;&#125;ans=t*(t<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;i&amp;&amp;a[a[i]]==i) ++ans;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="abc262d-i-hate-non-integer-number">ABC262D I Hate Non-integerNumber</h1><h2 id="分析-3">分析</h2><p>平均数是个整数，说明分子模分母为 <spanclass="math inline">\(0\)</span>。既然是个计数问题，考虑 DP。</p><p>这类问题的一个技巧就是，将分子模分母的结果加入状态。这样要求的问题变为了DP求出的一个子问题，在面对某些有特殊条件限制问题时有奇效，这也是为什么很多时候都要“考虑问题的简化版”。一开始我根本无法理解这种做法，后来才慢慢明白，为了DP 而去 DP，在很多时候时行不通的。</p><p>设 <span class="math inline">\(r\)</span> 为选出 <spanclass="math inline">\(r\)</span> 个数的阶段。当 <spanclass="math inline">\(r=1\)</span> 时，贡献显然为 <spanclass="math inline">\(n\)</span>。这东西加不加进状态都无所谓，反正就当个模数。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为考虑前 <spanclass="math inline">\(i\)</span> 个数，选出了 <spanclass="math inline">\(j\)</span> 个数，这 <spanclass="math inline">\(j\)</span> 个数之和模 <spanclass="math inline">\(r\)</span> 为 <spanclass="math inline">\(k\)</span> 的方案数。注意如果是模 <spanclass="math inline">\(j\)</span> 为 <spanclass="math inline">\(k\)</span> 的话，无后效性就没了。</p><p>由于存在取模，所以这类状态还是使用刷表法比较好。 <spanclass="math display">\[f(i-1,j-1,k) \rightarrow f(i,j,k+a_i \bmod r )\]</span> 答案为 <span class="math display">\[n + \sum_{r=2}^n f(n,r,0)\]</span> 注意到对于每一个阶段 <spanclass="math inline">\(r\)</span>，相当于一个 0/1 背包问题，优化掉 <spanclass="math inline">\(i\)</span> 这一维即可。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, ans, a[N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=<span class="hljs-number">2</span>;r&lt;=n;++r) &#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-built_in">min</span>(i,r);j;--j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;r;++k)(f[j][(k+a[i])%r]+=f[j<span class="hljs-number">-1</span>][k])%=mod;&#125;(ans+=f[r][<span class="hljs-number">0</span>])%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="abc262e-red-and-blue-graph">ABC262E Red and Blue Graph</h1><h2 id="分析-4">分析</h2><p>提神醒脑数学题。</p><p>要求是</p><ol type="1"><li>恰好有 <span class="math inline">\(k\)</span> 个红点。</li><li>连接不同颜色点的边的数量为偶数。</li></ol><p>设这 <span class="math inline">\(k\)</span> 个红点的度数和为 <spanclass="math inline">\(Deg_k\)</span>，连接红点的边的数量为 <spanclass="math inline">\(Red\)</span>，连接不同颜色点的数量为 <spanclass="math inline">\(RedBlue\)</span>，那么由于每条连接红点的边在度数中被统计了两次，则<span class="math display">\[Deg_k = 2 Red + RedBlue\]</span> 注意到 <span class="math inline">\(Deg_k\)</span> 和 <spanclass="math inline">\(RedBlue\)</span> 同奇偶。</p><p>题目要求 <span class="math inline">\(RedBlue\)</span> 为偶数，可知<span class="math inline">\(Deg_k\)</span>是偶数。于是乎求出每个节点的度数 <spanclass="math inline">\(deg_x\)</span>，数量为 <spanclass="math inline">\(odds\)</span>。</p><p>从 <span class="math inline">\(odds\)</span> 中选出偶数 <spanclass="math inline">\(t\)</span> 个点作为红点，在其他点中任选 <spanclass="math inline">\(k-t\)</span>个点作为蓝点，组合数求方案就行了。由于红点是计数的基准，所以蓝点的选择对答案没有贡献。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, k, odd, ans, deg[N], fac[N], inv[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();++deg[x], ++deg[y];&#125;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[n]=<span class="hljs-built_in">fp</span>(fac[n],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;~i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) ++odd;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i+=<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span>(i&lt;=odd&amp;&amp;k-i&lt;=n-odd)(ans+=<span class="hljs-built_in">C</span>(odd,i)*<span class="hljs-built_in">C</span>(n-odd,k-i)%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="nowcodert62c-莫娜与阿贝多">NowCoderT62C 莫娜与阿贝多</h1><h2 id="分析-5">分析</h2><blockquote><p>注：你的最优策略是依赖于每一步的掉落结果的。</p></blockquote><p>……</p><p>很好，和博弈论没有关系。</p><p>随机应变啊。</p><p>等等！这不就是 DP 中的最优子结构性质？</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为 <spanclass="math inline">\(i\)</span> 级物品剩下 <spanclass="math inline">\(j\)</span> 个，<spanclass="math inline">\(i+1\)</span> 级物品剩下 <spanclass="math inline">\(k\)</span> 个，能达到目标的概率。</p><p>边界是 <span class="math inline">\(f(m,i,0) = 1\)</span>，其中 <spanclass="math inline">\(i \ge n\)</span>。</p><p>当 <span class="math inline">\(j \in [0,2]\)</span> 时，无法进行合成<span class="math display">\[f(i,j,k) = f(i+1,k,a_{i+2})\]</span> 否则 <span class="math display">\[f(i,j,k) = \max\begin{cases}p \cdot f(i,j-2,k+1) + (1-p) \cdot f(i,j-3,k+1)\\q \cdot f(i,j-3,k+2) + (1-p) \cdot f(i,j-3,k+1)\end{cases}\]</span> 答案 <span class="math inline">\(f(1,a_1,a_2)\)</span>。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-keyword">int</span> n, m, a[N];<span class="hljs-keyword">double</span> p, q, f[<span class="hljs-number">10</span>][N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;p,&amp;q);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&lt;=<span class="hljs-number">1e3</span>;++i) f[m][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1.0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;i;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">1e3</span>;++k) f[i][j][k]=f[i+<span class="hljs-number">1</span>][k][a[i+<span class="hljs-number">2</span>]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;j&lt;=<span class="hljs-number">1e3</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">1e3</span>;++k) &#123;<span class="hljs-keyword">double</span> k1=p*f[i][j<span class="hljs-number">-2</span>][k+<span class="hljs-number">1</span>]+(<span class="hljs-number">1</span>-p)*f[i][j<span class="hljs-number">-3</span>][k+<span class="hljs-number">1</span>];<span class="hljs-keyword">double</span> k2=q*f[i][j<span class="hljs-number">-3</span>][k+<span class="hljs-number">2</span>]+(<span class="hljs-number">1</span>-q)*f[i][j<span class="hljs-number">-3</span>][k+<span class="hljs-number">1</span>];f[i][j][k]=<span class="hljs-built_in">max</span>(k1,k2);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,f[<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>]][a[<span class="hljs-number">2</span>]]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>组合数学</tag>
      
      <tag>概率论</tag>
      
      <tag>杂题选讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NowCoderL101E 水没都市 题解</title>
    <link href="/2022/nc11247e-solution/"/>
    <url>/2022/nc11247e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p><span class="math inline">\(t\)</span> 时刻还有城镇没有被淹没，<spanclass="math inline">\(t+1\)</span> 时刻所有城镇将要被淹没。</p><p>一个思路是求出最后一个城镇被淹没的时刻 <spanclass="math inline">\(D\)</span>，然后通过魔法调整使得所有城镇至少会在<span class="math inline">\(D\)</span> 时刻被淹没。显然 <spanclass="math inline">\(D\)</span> 就是 <spanclass="math inline">\(1\)</span>到每一个点所有的路径中的最大边权取最小值，猜都能猜到是最小生成树中的最大边权，证明略。</p><span id="more"></span><p>求出 <span class="math inline">\(D\)</span> 后，我们的目标是使得<span class="math inline">\(1 \rightarrow n\)</span>所有路径中最大边权最小为 <spanclass="math inline">\(D\)</span>，否则如果比 <spanclass="math inline">\(D\)</span> 小则不满足条件，比 <spanclass="math inline">\(D\)</span> 大则显然不优。</p><p>对于一条权值为 <span class="math inline">\(w\)</span> 的边，代价为<span class="math inline">\(D - w\)</span>，其中 <spanclass="math inline">\(w &lt; D\)</span>。考虑把 <spanclass="math inline">\((x,y,D-w)\)</span>加入图中，那么问题就变成了选择权值和最小的边，使得 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(n\)</span> 不连通。原因是如果 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(n\)</span> 不连通，那么 <spanclass="math inline">\(1 \rightarrow n\)</span> 的所有路径中不存在 <spanclass="math inline">\(w &lt; D\)</span> 的边，这就达到了目的。</p><p>以 <span class="math inline">\(1\)</span> 为源点，<spanclass="math inline">\(n\)</span> 为汇点，求出图中的最小割即可。</p><p>注意这是一张无向图，加边的时候有一些细节。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">30005</span>, M=<span class="hljs-number">2e4</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e15</span>;<span class="hljs-keyword">int</span> n, m, D, fa[N], d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> u, v, w; &#125; e[M];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(edge a,edge b) &#123; <span class="hljs-keyword">return</span> a.w&lt;b.w; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) fa[i]=i;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">get</span>(e[i].u), y=<span class="hljs-built_in">get</span>(e[i].v);<span class="hljs-keyword">if</span>(x!=y) &#123;fa[x]=y;D=<span class="hljs-built_in">max</span>(D,e[i].w);<span class="hljs-keyword">if</span>(++cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==n||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-keyword">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) ans+=<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,inf);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;e[i].u=<span class="hljs-built_in">read</span>(), e[i].v=<span class="hljs-built_in">read</span>(), e[i].w=<span class="hljs-built_in">read</span>();&#125; <span class="hljs-built_in">kruskal</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> u=e[i].u, v=e[i].v;<span class="hljs-keyword">if</span>(D&gt;e[i].w) <span class="hljs-built_in">addedge</span>(u,v,D-e[i].w);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dinic</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#811 (Div 3)</title>
    <link href="/2022/cf1714-solution/"/>
    <url>/2022/cf1714-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1714</strong>.</p><p>最近摸得有点厉害，主要是被自己菜到了，心态有点差……</p><p>老年人也就看看 Div 3 了。</p><span id="more"></span><h1 id="a.-everyone-loves-to-sleep">A. Everyone Loves to Sleep</h1><h2 id="分析">分析</h2><p>转化成分钟乱搞即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> t, n, H, M, D, ans, h[<span class="hljs-number">15</span>], m[<span class="hljs-number">15</span>], d[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), H=<span class="hljs-built_in">read</span>(), M=<span class="hljs-built_in">read</span>();D=H*<span class="hljs-number">60</span>+M;ans=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;h[i]=<span class="hljs-built_in">read</span>(), m[i]=<span class="hljs-built_in">read</span>();d[i]=h[i]*<span class="hljs-number">60</span>+m[i];<span class="hljs-keyword">if</span>(d[i]&lt;D) d[i]+=<span class="hljs-number">24</span>*<span class="hljs-number">60</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,d[i]-D);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,ans/<span class="hljs-number">60</span>,ans%<span class="hljs-number">60</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="b.-remove-prefix">B. Remove Prefix</h1><h2 id="分析-1">分析</h2><p>从后往前寻找第一个重复数字出现的位置即可。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, ans, a[N];map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>(), ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) &#123;++p[a[i]];<span class="hljs-keyword">if</span>(p[a[i]]&gt;<span class="hljs-number">1</span>) &#123; ans=i; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="c.-minimum-varied-number">C. Minimum Varied Number</h1><h2 id="分析-2">分析</h2><p>注意到 <span class="math inline">\(t \in[1,45]\)</span>，说明答案最大就是 <spanclass="math inline">\(123456789\)</span>，那么要求数字最小只要贪心从后往前依次放置即可。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> t, n, ans[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">9</span>;i;--i) <span class="hljs-keyword">if</span>(n&gt;i) &#123;n-=i; ans[i]=i;&#125; <span class="hljs-keyword">else</span> &#123; ans[i]=n; <span class="hljs-keyword">break</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;++i) <span class="hljs-keyword">if</span>(ans[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans[i]);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="d.-color-with-occurrences">D. Color with Occurrences</h1><h2 id="分析-3">分析</h2><p>注意到颜色是可以覆盖的，所以也可以理解为“无后效性吧”。</p><p>那么设 <span class="math inline">\(f(i)\)</span> 为将 <spanclass="math inline">\([1,i]\)</span>染色用的最小次数，那么对于一个字符串 <spanclass="math inline">\(j\)</span> <span class="math display">\[f(i) = \min_{k \in [i-l_j,i-1]}{ \{ f_k + 1} \}\]</span> 其中 <span class="math inline">\(l_j\)</span> 是 <spanclass="math inline">\(j\)</span> 的长度，且必须满足 <spanclass="math inline">\(i \ge l_j\)</span> 且 <spanclass="math inline">\(t[i-l_j+1,i] = a_j\)</span>。</p><p>为啥不把 <span class="math inline">\(j\)</span>加入状态呢？复杂度是不会变化的，是冗余信息。</p><p>考虑输出方案。一开始我竟然用了一个 SB二维数组乱搞，结果还真的过了样例和第一个点，但是会 WA#2。仔细一想，输出方案实际上是把 DP的过程重现一遍，那么输出方案时需要的信息应当与状态相同，但是由于不仅要输出决策点，还要输出所用的字符串编号，所以要用两个数组。<del>我一开始就是把这两个合一了</del>。</p><p>设 <span class="math inline">\(g1(i)\)</span> 表示决策点，<spanclass="math inline">\(g2(i)\)</span> 表示将 <spanclass="math inline">\(i\)</span> 染色用的字符串编号。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">15</span>;<span class="hljs-keyword">int</span> t, n, m, f[N], l[M], g1[N], g2[N];string s, a[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-comment">// i表示染色的位置</span><span class="hljs-keyword">if</span>(!i) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">print</span>(g1[i]);    <span class="hljs-comment">// i的决策点，也就是上一个染色的位置</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,g2[i],i-l[g2[i]]+<span class="hljs-number">1</span>);    <span class="hljs-comment">// 用的字符串编号的染色的位置</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<span class="hljs-built_in">memset</span>(l,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(l));<span class="hljs-built_in">memset</span>(g1,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g1));<span class="hljs-built_in">memset</span>(g2,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g2));cin&gt;&gt;s; n=<span class="hljs-built_in">read</span>();m=s.<span class="hljs-built_in">length</span>(), s=<span class="hljs-string">&quot; &quot;</span>+s;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i], l[i]=a[i].<span class="hljs-built_in">length</span>();f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(i&gt;=l[j]) &#123;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">substr</span>(i-l[j]+<span class="hljs-number">1</span>,l[j])==a[j]) &#123;<span class="hljs-keyword">int</span> p=m+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i-l[j];k&lt;i;++k) <span class="hljs-keyword">if</span>(f[p]&gt;f[k]) p=k;<span class="hljs-keyword">if</span>(f[i]&gt;f[p]+<span class="hljs-number">1</span>) f[i]=f[p]+<span class="hljs-number">1</span>, g1[i]=p, g2[i]=j;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[m]&lt;=m? f[m]:<span class="hljs-number">-1</span>);    <span class="hljs-comment">// 不难发现只要能够全部染色，次数绝不会超过m</span><span class="hljs-keyword">if</span>(f[m]&lt;=m) <span class="hljs-built_in">print</span>(m);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="e.-add-modulo-10">E. Add Modulo 10</h1><h2 id="分析-4">分析</h2><p>注意到如果某个数模 <span class="math inline">\(10\)</span> 为 <spanclass="math inline">\(0\)</span>，那么它就不会变化，如果模 <spanclass="math inline">\(10\)</span> 为 <spanclass="math inline">\(5\)</span>，那么它只会改变一次。</p><p>它们可以归为一类——因为它们的终态都能计算出来，姑且称之为 <spanclass="math inline">\(\alpha\)</span> 类，其他称之为 <spanclass="math inline">\(\beta\)</span> 类。如果既有 <spanclass="math inline">\(\alpha\)</span> 类又有 <spanclass="math inline">\(\beta\)</span> 类，那么绝对不可能全部相等。</p><p>否则如果只有 <span class="math inline">\(\alpha\)</span>类，那么直接算出来判断是否全部相等即可。</p><p>未经特殊声明，下面的数都是模 <span class="math inline">\(10\)</span>之后的结果。</p><p>考虑这样一条路径，<span class="math inline">\(1 \rightarrow 2\rightarrow 4 \rightarrow 8\)</span>。</p><p><span class="math inline">\(3 \rightarrow 6 \rightarrow2\)</span>，<span class="math inline">\(7 \rightarrow 4\)</span>，<spanclass="math inline">\(9 \rightarrow8\)</span>，这些操作都能让本不属于这条路径的数字加入路径，且最终都会达到<spanclass="math inline">\(8\)</span>，那么可以知道一定能做到让所有的数模<span class="math inline">\(10\)</span> 相同，但是一定能全部相等吗？</p><p>注意到 <span class="math inline">\(8\)</span> 和 <spanclass="math inline">\(28\)</span>，将 <spanclass="math inline">\(8\)</span> 进行变成 <spanclass="math inline">\(28\)</span> 需要 <spanclass="math inline">\(4\)</span> 次操作，但是根本无法让 <spanclass="math inline">\(28\)</span> 变成 <spanclass="math inline">\(38\)</span>。这是因为路径中 <spanclass="math inline">\(8\)</span> 变成 <spanclass="math inline">\(8\)</span> 要进位两次，所以只有个位是 <spanclass="math inline">\(8\)</span> 的两个数的差是 <spanclass="math inline">\(10\)</span> 的偶数倍才能满足条件。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N], f1, f2;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> d=<span class="hljs-built_in">abs</span>(a-b);<span class="hljs-keyword">return</span> (d/<span class="hljs-number">10</span>)%<span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();f1=f2=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">5</span>) f1=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> f2=<span class="hljs-number">1</span>; &#125;<span class="hljs-keyword">if</span>(f1&amp;&amp;f2) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f1) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">5</span>) a[i]+=<span class="hljs-number">5</span>;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;a[i]!=a[i<span class="hljs-number">-1</span>]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">return</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">1</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">2</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">4</span>) &#123;a[i]-=a[i]%<span class="hljs-number">10</span>, a[i]+=<span class="hljs-number">8</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">3</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">6</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>||a[i]%<span class="hljs-number">10</span>==<span class="hljs-number">9</span>) &#123;a[i]-=a[i]%<span class="hljs-number">10</span>, a[i]+=<span class="hljs-number">18</span>;&#125;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">pd</span>(a[i],a[i<span class="hljs-number">-1</span>])) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">return</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h1 id="f.-build-a-tree-and-that-is-it">F. Build a Tree and That IsIt</h1><p>没看，不会。😢</p><h1 id="g.-path-prefixes">G. Path Prefixes</h1><h2 id="分析-5">分析</h2><p>维护树上前缀和，记为 <span class="math inline">\(sa\)</span>，<spanclass="math inline">\(sb\)</span>。</p><p>在一条路径上，找到第一个严格大于 <spanclass="math inline">\(sa_x\)</span> 的 <spanclass="math inline">\(sb_y\)</span>，那么 <spanclass="math inline">\(sa_x\)</span> 一定严格大于之前的每一个 <spanclass="math inline">\(sb\)</span>，于是 <spanclass="math inline">\(y-1\)</span> 即为答案。<spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 都是路径上节点的编号。由于 <spanclass="math inline">\(sb\)</span> 显然是单调增的，可以二分查找。</p><p>在更新更新完 <span class="math inline">\(x\)</span>的所有子节点之后还原 <span class="math inline">\(sa_x\)</span>，<spanclass="math inline">\(sb_x\)</span> 即可。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n,  sa, sb, a[N], b[N], ans[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];vector&lt;<span class="hljs-keyword">int</span>&gt; ssb;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;sa+=a[x], sb+=b[x];ssb.<span class="hljs-built_in">push_back</span>(sb);ans[x]=<span class="hljs-built_in">upper_bound</span>(ssb.<span class="hljs-built_in">begin</span>(),ssb.<span class="hljs-built_in">end</span>(),sa)-ssb.<span class="hljs-built_in">begin</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);&#125;sa-=a[x], sb-=b[x];ssb.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();tot=sa=sb=<span class="hljs-number">0</span>;ssb.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> p=<span class="hljs-built_in">read</span>();a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(p,i), <span class="hljs-built_in">add</span>(i,p);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NowCoderT62B 置换 题解</title>
    <link href="/2022/nc11202b-solution/"/>
    <url>/2022/nc11202b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="关于置换">关于置换</h2><p>根据《数学奥林匹克小丛书·组合数学》上关于置换的定义：</p><p>给定集合 <span class="math inline">\(X = \{1,2,3,\ldots ,n\}\)</span>，置换 <span class="math inline">\(\varphi\)</span> 是从<span class="math inline">\(X\)</span> 到 <spanclass="math inline">\(X\)</span> 上的一一映射，通常记为 <spanclass="math display">\[\varphi =\begin{Bmatrix}1 &amp; 2 &amp;  \ldots &amp; n\\\varphi(1) &amp; \varphi(2) &amp; \ldots &amp; \varphi(n)\end{Bmatrix}\]</span> <span id="more"></span></p><p>由于是一一映射，所以这实际上是 <spanclass="math inline">\([1,n]\)</span> 的一个排列，满足 <spanclass="math inline">\(\varphi(i) = i\)</span> 的 <spanclass="math inline">\(i\)</span> 成为 <spanclass="math inline">\(\varphi\)</span> 的一个不动点。</p><p>直接感受就是，加了一堆概念得到的还只是一个排列，这么吃力不讨好的事情有啥用？但是看到这题题面之后就应该明白，「置换」本质上是一一映射，所以你可以用置换<span class="math inline">\(\varphi\)</span> 再把 <spanclass="math inline">\(\varphi\)</span> 映射一遍……</p><p>而对于「不动点」，无论如何用 <spanclass="math inline">\(\varphi\)</span>去映射，都不会改变这些元素的值。（知道这个说不定能骗点分）。</p><p>关于置换的一些性质、题目和解题方法，刘汝佳的《入门经典训练指南》上还有所涉及。</p><h2 id="分析">分析</h2><p>题意很简单，<del>然而我一开始完全没有思路</del>。注意到如果 <spanclass="math inline">\(A\)</span> 中存在不动点，那么只要检查是否与 <spanclass="math inline">\(B\)</span> 的对应位置相同即可。</p><p>手算不难发现对于一个 <span class="math inline">\(i\)</span>，从 <spanclass="math inline">\(a_i\)</span> 不断映射直到 <spanclass="math inline">\(a_i&#39; =i\)</span>，经过的数字构成了一个环，含义是无论怎么置换都会如此循环。把环中数组当作下标，把<span class="math inline">\(A\)</span> 中对应的以元素列出来，记为 <spanclass="math inline">\(p\)</span>。能够发现正好相差一位（因为 <spanclass="math inline">\(A\)</span> 把 <spanclass="math inline">\([1,n]\)</span> 映射了一次了）。如果其中不包含<span class="math inline">\(b_i\)</span>，那么必然无解。同时也把 <spanclass="math inline">\(B\)</span> 中对应的元素列出来，记为 <spanclass="math inline">\(q\)</span>。判断从 <spanclass="math inline">\(p_{x} = b_i\)</span> 的 <spanclass="math inline">\(x\)</span> 开始检查 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(q\)</span> 是否完全相同，否则无解。</p><p>假设从 <span class="math inline">\(i\)</span> 开始置换 <spanclass="math inline">\(r_i\)</span> 次才能让 <spanclass="math inline">\(a_i\)</span> 变成 <spanclass="math inline">\(b_i\)</span>，其环长为 <spanclass="math inline">\(m_i\)</span>。由于循环节的存在，最终的 <spanclass="math inline">\(k\)</span> 必定满足 <span class="math display">\[\begin{cases}k &amp;\equiv r_1 \pmod {m_1}\\k &amp;\equiv r_2 \pmod {m_2}\\&amp; \vdots\\k &amp; \equiv r_n \pmod {m_n}\end{cases}\]</span> 此时的 <span class="math inline">\(n\)</span> 为环的个数。</p><p>用扩展中国剩余定理判断是否有解即可。</p><p>注意爆 <code>long long</code>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int __int128</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, R, M, a[N], b[N];<span class="hljs-keyword">bool</span> v[N];vector&lt;<span class="hljs-keyword">int</span>&gt; r, m, c;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span>&amp; y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<span class="hljs-keyword">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);y-=a/b*x;<span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exCRT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// n为环的个数</span>R=r[<span class="hljs-number">0</span>], M=m[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> d=r[i]-R, g, mod, x, y;g=<span class="hljs-built_in">exgcd</span>(M,m[i],x,y);<span class="hljs-keyword">if</span>(d%g) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;mod=m[i]/g;x=((x*d/g)%mod+mod)%mod;R=x*M+R;M=M/g*m[i];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();r.<span class="hljs-built_in">clear</span>(), m.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) a[i]=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) b[i]=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]==i&amp;&amp;b[i]!=i) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(v[i]) <span class="hljs-keyword">continue</span>;v[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> cur=a[i];c.<span class="hljs-built_in">clear</span>();c.<span class="hljs-built_in">pb</span>(i);        <span class="hljs-comment">// 起点</span><span class="hljs-keyword">while</span>(cur!=i) &#123;c.<span class="hljs-built_in">pb</span>(cur);v[cur]=<span class="hljs-number">1</span>;cur=a[cur];&#125;vector&lt;<span class="hljs-keyword">int</span>&gt; p, q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:c) p.<span class="hljs-built_in">pb</span>(a[x]), q.<span class="hljs-built_in">pb</span>(b[x]);<span class="hljs-keyword">bool</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> sz=p.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;sz;++j) &#123;<span class="hljs-keyword">if</span>(p[j]==q[<span class="hljs-number">0</span>]) &#123;                <span class="hljs-comment">// q[0]=b[i]，置换j次才成为b[i]</span>fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j,pos=<span class="hljs-number">0</span>;k&lt;j+sz;++k,++pos) &#123;<span class="hljs-keyword">if</span>(p[k%sz]!=q[pos]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;r.<span class="hljs-built_in">pb</span>(j), m.<span class="hljs-built_in">pb</span>(sz);                <span class="hljs-comment">// sz是环长</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!fg) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exCRT</span>(r.<span class="hljs-built_in">size</span>())) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数学</tag>
      
      <tag>扩展中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1493D GCD of an Array 题解</title>
    <link href="/2022/cf1493d-solution/"/>
    <url>/2022/cf1493d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>本题的关键是</p><p>对于一个序列 <span class="math inline">\(\{a\}\)</span>，将 <spanclass="math inline">\(a_i\)</span> 分解为 <spanclass="math inline">\(a_i = \prod_{j=1}^k p_{i,j}^{a_{i,j}}\)</span>的形式，那么 $({a}) $ 为所有出现过的质因数 <spanclass="math inline">\(p_i\)</span> 的 <spanclass="math inline">\(\alpha_i\)</span> 次幂的乘积。 其中 <spanclass="math inline">\(\alpha_i\)</span> 表示出现过的 <spanclass="math inline">\(p_i\)</span> 的最小幂次。</p><span id="more"></span><p>原序列可以看作依次插入。将 <span class="math inline">\(a_x\)</span>修改为 <span class="math inline">\(y\)</span>，本质上是除去所有在 <spanclass="math inline">\(a_x\)</span> 分解中的质因数的幂次，然后再将 <spanclass="math inline">\(y\)</span> 插入并更新。</p><p>所以用<code>std::map</code>来维护某个 <spanclass="math inline">\(a_i\)</span>中所有质因数的幂次，用<code>std::set</code>来维护某个质因数的所有幂次（目的是快速插入，快速查找最小值）。</p><p>记录 <span class="math inline">\(rec_i\)</span> 表示序列中含有质因数<span class="math inline">\(i\)</span> 的数字的个数，一旦存在 <spanclass="math inline">\(rec_i=n\)</span>，那么答案要累乘 <spanclass="math inline">\(i\)</span> 的最小次幂。</p><p>具体看代码。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, m, cnt, ans=<span class="hljs-number">1</span>, p[N], pr[N], rec[N];map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp[N];multiset&lt;<span class="hljs-keyword">int</span>&gt; st[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!p[i]) p[i]=i, pr[++cnt]=i;        <span class="hljs-comment">// p[i]表示i的最小质因子</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=<span class="hljs-number">2e5</span>;++j) &#123;p[i*pr[j]]=pr[j];<span class="hljs-keyword">if</span>(i%pr[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;x%=mod;<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getinv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">fp</span>(x,mod<span class="hljs-number">-2</span>); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; t;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, d=p[y];<span class="hljs-keyword">while</span>(y%d==<span class="hljs-number">0</span>) y/=d, ++a;t.<span class="hljs-built_in">push_back</span>(&#123;d,a&#125;);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tt:t) &#123;<span class="hljs-keyword">int</span> _p=tt.fr, _a=tt.sc;<span class="hljs-keyword">if</span>(mp[x][_p]==<span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果a[x]中没有出现过p这个因子</span>++rec[_p], st[_p].<span class="hljs-built_in">insert</span>(_a), mp[x][_p]=_a;            <span class="hljs-comment">// 维护</span><span class="hljs-keyword">if</span>(rec[_p]==n) &#123;(ans*=<span class="hljs-built_in">fp</span>(_p,*st[_p].<span class="hljs-built_in">begin</span>()))%=mod;                <span class="hljs-comment">// 这个因子是所有数的公因子，取最小幂次</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(rec[_p]==n) &#123;<span class="hljs-keyword">int</span> inv=<span class="hljs-built_in">getinv</span>(<span class="hljs-built_in">fp</span>(_p,*st[_p].<span class="hljs-built_in">begin</span>()));(ans*=inv)%=mod;                <span class="hljs-comment">// p已经出现过了，如果p是所有数公因子，就要先让gcd除以p的最小次幂</span>&#125;st[_p].<span class="hljs-built_in">erase</span>(st[_p].<span class="hljs-built_in">find</span>(mp[x][_p]));mp[x][_p]+=_a;st[_p].<span class="hljs-built_in">insert</span>(mp[x][_p]);            <span class="hljs-comment">// 删除原信息，维护新信息</span><span class="hljs-keyword">if</span>(rec[_p]==n) &#123;(ans*=<span class="hljs-built_in">fp</span>(_p,*st[_p].<span class="hljs-built_in">begin</span>()))%=mod;                <span class="hljs-comment">// 如果p是公因子，就要更新答案</span>&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">ora</span>();n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve</span>(i,x);&#125;<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">solve</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1389E Calendar Ambiguity 题解</title>
    <link href="/2022/cf1389e-solution/"/>
    <url>/2022/cf1389e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>即求 <span class="math display">\[(x-1)d + y \equiv (y-1)d + x \pmod w\]</span> 满足 <span class="math inline">\(x &lt; y\)</span> 的解 <spanclass="math inline">\((x,y)\)</span> 的个数。</p><span id="more"></span><p>化简 <span class="math display">\[xd + y \equiv yd + x \pmod w\]</span></p><p><span class="math display">\[yd - xd - x -y \equiv 0 \pmod w\]</span></p><p><span class="math display">\[(y-x)(d-1) \equiv 0 \pmod w\]</span></p><p>设 <span class="math inline">\(w&#39; =\frac{w}{\gcd(w,d-1)}\)</span>，那么有 <span class="math display">\[y-x \equiv 0  \pmod {w&#39;}\]</span> 考虑 <span class="math inline">\(y-x = k w&#39;\)</span>。当<span class="math inline">\(k\)</span> 为定值时，由于 <spanclass="math inline">\(y-x \in [1,\min(d,m)]\)</span>，所以数量为 <spanclass="math inline">\(\min(d,m) - kw&#39;\)</span>。</p><p>答案即为 <span class="math display">\[\sum_{k=1}^{\lfloor \frac{\min(d,m)}{w&#39;} \rfloor} \min(d,m) -kw&#39;\]</span> 发现这是个等差数列，直接求和即可。</p><p>首项 <span class="math inline">\(\min(d,m) - kw&#39;\)</span>，末项<span class="math inline">\(\min(d,m) - \lfloor \frac{\min(d,m)}{w&#39;}\rfloor w&#39;\)</span>，公差 <span class="math inline">\(\lfloor\frac{\min(d,m)}{w&#39;} \rfloor\)</span>。</p><p>答案 <span class="math display">\[\frac{\big(2 \min(d,m) - \lfloor \frac{\min(d,m)}{w&#39;} \rfloor w&#39;- w&#39;\big) \cdot \lfloor \frac{\min(d,m)}{w&#39;} \rfloor }{2}\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, m, d, w;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;m=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>(), w=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;w/=(<span class="hljs-built_in">gcd</span>(d<span class="hljs-number">-1</span>,w));<span class="hljs-keyword">int</span> mn=<span class="hljs-built_in">min</span>(m,d), cnt=mn/w;ans=(<span class="hljs-number">2</span>*(mn-w)-w*(cnt<span class="hljs-number">-1</span>))*cnt/<span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF893E Counting Arrays</title>
    <link href="/2022/cf893e-solution/"/>
    <url>/2022/cf893e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>为了方便起见，用 <span class="math inline">\(n\)</span> 代替 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(m\)</span>代替 <span class="math inline">\(y\)</span>。</p><span id="more"></span><p>不难发现无论 <span class="math inline">\([1,m-1]\)</span>这些数字的符号是什么样的，只要恰当安排最后一位就一定能使结果是正数。由于每一位正负都可以选，所以这部分的方案数为<span class="math inline">\(2^{m-1}\)</span>。</p><p>根据唯一分解定理，这个长度为 <span class="math inline">\(m\)</span>的序列中一定直接或间接包含了 <span class="math inline">\(n\)</span>的所有质因子。所以可以预处理出每一个质数。</p><p>对于质数 <span class="math inline">\(p_i\)</span>，如果它是 <spanclass="math inline">\(n\)</span> 的质因子，求出它在 <spanclass="math inline">\(n\)</span> 的分解中的指数 <spanclass="math inline">\(a_i\)</span>。问题转化为在 <spanclass="math inline">\([1,m]\)</span> 这 <spanclass="math inline">\(m\)</span>个位置中，每个位置分配一个数，满足分配的数之和等于 <spanclass="math inline">\(a_i\)</span>，求方案数。形式化地，求不定方程 <spanclass="math display">\[\sum_{i=1}^m x_i = a_i\]</span> 的非负整数解的个数，显然是 <spanclass="math inline">\(C_{m+a_i-1}^{a_i-1}\)</span>。累乘即可。</p><p>特别地，当 <span class="math inline">\(n\)</span> 含有大于 <spanclass="math inline">\(\sqrt n\)</span> 的质因子时，令答案 <spanclass="math inline">\(\times m\)</span>，因为至多只有 <spanclass="math inline">\(1\)</span> 个,否则就大于 <spanclass="math inline">\(n\)</span> 了。</p><p>线性筛预处理质数，分解质因数时只枚举质数会快不少。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> t, n, m, cnt, ans, fac[N], inv[N], p2[N], p[N], v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> n&lt;=m? <span class="hljs-number">1</span>:fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ora</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2e6</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=<span class="hljs-number">2e6</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, p2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, p2[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2e6</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod, p2[i]=p2[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>%mod;inv[N<span class="hljs-number">-5</span>]=<span class="hljs-built_in">fp</span>(fac[N<span class="hljs-number">-5</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=(<span class="hljs-number">2e6</span>)<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<span class="hljs-built_in">ora</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();ans=p2[m<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;p[i]*p[i]&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(n%p[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!(n%p[i])) ++a, n/=p[i];(ans*=<span class="hljs-built_in">C</span>(m+a<span class="hljs-number">-1</span>,m<span class="hljs-number">-1</span>))%=mod;&#125;<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) (ans*=m)%=mod; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF615D Multipliers 题解</title>
    <link href="/2022/cf615ds-solution/"/>
    <url>/2022/cf615ds-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先将 <span class="math inline">\(n\)</span> 分解为 <spanclass="math inline">\(n= \prod_{i=1}^m p_i^{a_i}\)</span>。那么 <spanclass="math inline">\(n\)</span> 的约数个数为 <spanclass="math inline">\(d(n) = \prod_{i=1}^m (a_i +1)\)</span>。</p><p>考虑每个质因子的贡献。</p><span id="more"></span><p>首先对于 <spanclass="math inline">\(p_i\)</span>，它的整数次幂作为独立的一个约数时，一定有<span class="math inline">\(p_i^1 p_i^2 \ldots p_i ^{a_i} =p_i^{\frac{a_i(a_i+1)}{2}}\)</span>。</p><p>其次，<span class="math inline">\(p_i\)</span>还可以和其他约数组合，方案数为 <spanclass="math inline">\(\frac{d(n)}{a_i +1}\)</span>。</p><p>那么 <span class="math inline">\(p_i\)</span> 能够产生的贡献为 <spanclass="math inline">\((p_i^{\frac{a_i(a_i+1)}{2}})^{\frac{d(n)}{a_i+1}}= p_i^{\frac{a_i d(n)}{2}}\)</span>，其含义为 <spanclass="math inline">\(p_i\)</span>作为一个独立的约数时，也可以和其他约数相乘成为新的约数，且在其中 <spanclass="math inline">\(p_i\)</span> 的贡献是相同的。</p><p>指数可能很大，咋办？欧拉降幂公式，由于 <spanclass="math inline">\(p_i\)</span> 和模数 <spanclass="math inline">\(10^9 +7\)</span>都是质数，这里只写出底数与模数互质的形式 <span class="math display">\[a^b \equiv a^{b \, \bmod \, \varphi(p)} \pmod p\]</span> 在本题里面，<span class="math inline">\(\varphi(10^9 +7) =10^9 +6\)</span>。</p><p>当 <span class="math inline">\(d(n)\)</span> 为奇数时，说明所有 <spanclass="math inline">\(a_i\)</span> 都是偶数，那么可以直接将所有 <spanclass="math inline">\(a_i\)</span> 除以 <spanclass="math inline">\(2\)</span>。</p><p>否则重新计算 <spanclass="math inline">\(\frac{d(n)}{2}\)</span>，方法是找到一个奇数指数<span class="math inline">\(a_i\)</span>，然后乘上 <spanclass="math inline">\(\frac{a_i+1}{2}\)</span>，剩下的正常算即可。乱搞逆元什么会在 #21 WA 掉。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _p first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _a second</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, m, d=<span class="hljs-number">1</span>, ans=<span class="hljs-number">1</span>, a[N], p[N], v[N];vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; vec;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ++v[<span class="hljs-built_in">read</span>()];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200000</span>;++i) d=d*(v[i]+<span class="hljs-number">1</span>)%(mod<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200000</span>;++i) <span class="hljs-keyword">if</span>(v[i]) vec.<span class="hljs-built_in">push_back</span>(&#123;i,v[i]&#125;);<span class="hljs-keyword">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) &#123;<span class="hljs-keyword">if</span>(x._a&amp;<span class="hljs-number">1</span>) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(fg) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x:vec) x._a/=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) (ans*=<span class="hljs-built_in">fp</span>(x._p,d*x._a%(mod<span class="hljs-number">-1</span>)))%=mod; &#125; <span class="hljs-keyword">else</span> &#123;d=<span class="hljs-number">1</span>;<span class="hljs-keyword">bool</span> t=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) &#123;<span class="hljs-keyword">if</span>(x._a&amp;<span class="hljs-number">1</span>&amp;&amp;t) t=<span class="hljs-number">0</span>, d=d*(x._a+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>%(mod<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> d=d*(x._a+<span class="hljs-number">1</span>)%(mod<span class="hljs-number">-1</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:vec) (ans*=<span class="hljs-built_in">fp</span>(x._p,d*x._a%(mod<span class="hljs-number">-1</span>)))%=mod; &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数论学习笔记」#1 扩展中国剩余定理</title>
    <link href="/2022/notes-number-theory-1/"/>
    <url>/2022/notes-number-theory-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="中国剩余定理crt">中国剩余定理（CRT）</h2><p>由于扩展中国剩余定理和中国剩余定理没啥关系，所以我们先来复习一下中国剩余定理。</p><span id="more"></span><p>同余方程组 <span class="math display">\[\begin{cases}x \equiv a_1 \pmod {m_1}\\x \equiv a_2 \pmod {m_2}\\\quad \vdots\\x \equiv a_n \pmod {m_n}\end{cases}\]</span> 当 <span class="math inline">\(m_1,m_2,\cdots ,m_n\)</span>两两互质时，对于任意正整数 <spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>，此方程组有解，如下。</p><p>设 <span class="math inline">\(M = \prod_{i=1}^n m_i\)</span>，<spanclass="math inline">\(M_i = \frac{M_i}{m_i}\)</span>。</p><p>设 <span class="math inline">\(t_i = M_i^{-1}\)</span>，在 <spanclass="math inline">\(\bmod m_i\)</span> 的意义下。</p><p>那么方程组的通解为 <span class="math inline">\(x = kM + \sum_{i=1}^na_i t_i M_i\)</span>，其中 <span class="math inline">\(k \in\mathbb{Z}\)</span>。</p><p>最小正整数解只要令 <spanclass="math inline">\(k=0\)</span>，后面那一块对 <spanclass="math inline">\(M\)</span> 取模即可。</p><p>代码</p><div class="code-wrapper"><pre><code class="hljs cpp">MM=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) MM*=m[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;    M[i]=MM/m[i];    <span class="hljs-keyword">int</span> x, y;    <span class="hljs-built_in">exgcd</span>(M[i],m[i],x,y);    t[i]=x;    ans=(ans+a[i]*M[i]*t[i]%MM)%MM&#125;ans=(ans%MM+MM)%MM;</code></pre></div><p>证明略。</p><h2 id="扩展中国剩余定理excrt">扩展中国剩余定理（exCRT）</h2><p>当 <span class="math inline">\(m_1,m_2,\cdots m_n\)</span>不满足两两互质时，就要用到扩展中国剩余定理了。</p><p>考虑 <span class="math display">\[\begin{cases}x \equiv a_1 \pmod {m_1}\\x \equiv a_2 \pmod {m_2}\end{cases}\]</span> 转化一下 <span class="math display">\[\begin{cases}x = k_1 m_1 + a_1\\x = k_2 m_2 + a_2\end{cases}\]</span></p><p><span class="math display">\[k_1 m_1 - k_2 m_2 = a_1 - a_2\]</span></p><p>注意到此方程有解，当且仅当 <span class="math inline">\(\gcd(m_1,m_2)\mid a_1-a_2\)</span>。</p><p>设 <span class="math inline">\(g=\gcd(m_1,m_2)\)</span>，<spanclass="math inline">\(p_1 = \frac{m_1}{g}\)</span>，<spanclass="math inline">\(p_2 = \frac{m_2}{g}\)</span>，代入得 <spanclass="math display">\[k_1 p_1 - k_2 p_2 = \frac{a_1-a_2}{g}\]</span> 由于 <spanclass="math inline">\(\gcd(p_1,p_2)=1\)</span>，此方程有解当且仅当 <spanclass="math inline">\(1 \mid \frac{a_1 - a_2}{g}\)</span>。那么一定有<span class="math inline">\(g \mid a_1 - a_2\)</span>，否则无解。</p><p>那么先求出一组特解 <span class="math display">\[p_1 x_1  + p_2 x_2  = 1\]</span> 得到 <span class="math display">\[\begin{cases}k_1 = \frac{a_2-a_1}{g} x_1\\k_2 = \frac{a_2-a_1}{g} x_2\end{cases}\]</span> 代入原式 <span class="math display">\[x = k_1 m_1 + a_1 = \frac{a_2 - a_1}{g}x_1 m_1 + a_1\]</span> 至此，得到一个解。</p><p>不妨称同余号右边的数为“同余数”。</p><p>考虑数论里一个结论，若 <span class="math inline">\(a \equiv b \pmod{m_i}\)</span>，其中 <span class="math inline">\(i \in[1,n]\)</span>，则 <span class="math display">\[a \equiv b \pmod {\operatorname{lcm}\{m_1,m_2,\cdots ,m_n\}}\]</span>因此，求出两个方程的解时，只要模数取原来两个模数的最小公倍数，就能将原来两个方程合并成一个方程。</p><p>且慢，不是还要求同余数相等吗？令他为 <span class="math inline">\(xm_1+ a_1\)</span> 即可，<del>虽然我也不知道为什么</del>。</p><p>设当前同余数为 <span class="math inline">\(R\)</span>，<spanclass="math inline">\(M\)</span> 为 <spanclass="math inline">\(m_1,m_2,\cdots,m_{i-1}\)</span>的最小公倍数，则对于一个新的方程组 <span class="math display">\[\begin{cases}x \equiv R  \pmod M\\x \equiv a_i \pmod {m_i}\end{cases}\]</span> 再次求解即可。</p><p>代码</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exCRT</span><span class="hljs-params">()</span> </span>&#123;M=m[<span class="hljs-number">1</span>], R=r[<span class="hljs-number">1</span>];    <span class="hljs-comment">// m[]是模数，r[]是同余数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> d=r[i]-R, g, mod, x, y;g=<span class="hljs-built_in">exgcd</span>(M,m[i],x,y);        <span class="hljs-comment">// 这里求解的是 Mx+m[i]y=gcd(M,m[i])</span>        <span class="hljs-comment">// 根据等式的性质，易得等价于上文中的 p1x1+p2x2=1</span><span class="hljs-keyword">if</span>(d%g) &#123; ans=<span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>; &#125;        <span class="hljs-comment">// 无解</span>mod=m[i]/g;        <span class="hljs-comment">// 取模是因为要求最小正整数解，mod为什么这样算详见exgcd</span>x=((x*d/g)%mod+mod)%mod;        <span class="hljs-comment">// 解</span>R=x*M+R;        <span class="hljs-comment">// 更新R</span>M=(M*m[i])/g;        <span class="hljs-comment">// M取lcm</span>&#125;ans=R;    <span class="hljs-comment">// 答案</span>&#125;</code></pre></div><p> </p><p>参考：</p><ul><li><a href="https://oi-wiki.org/math/number-theory/crt/">OI Wiki中国剩余定理</a></li><li><a href="https://luckyglass.github.io/2019/OldVer5/">学习笔记 -扩展中国剩余定理</a></li><li><ahref="https://xixike.github.io/%E3%80%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/">『学习笔记』中国剩余定理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>中国剩余定理</tag>
      
      <tag>扩展中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1265E &amp; luogu6835 题解</title>
    <link href="/2022/cf1265e-lg6835-solution/"/>
    <url>/2022/cf1265e-lg6835-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="cf1265e-beautiful-mirrors">CF1265E Beautiful Mirrors</h1><h2 id="solution-1">solution 1</h2><p>套路地设 <span class="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(1\)</span> 问到第 <spanclass="math inline">\(i\)</span> 个镜子，且通过了第 <spanclass="math inline">\(i\)</span> 个镜子的期望天数。</p><span id="more"></span><p><span class="math inline">\(f_0 = 0\)</span></p><p>设 <span class="math inline">\(P_i = \frac{p_i}{100}\)</span> <spanclass="math display">\[f_i = f_{i-1} + P_i  \cdot 1 + (1-P_i) \cdot (1 + f_i )\]</span></p><p><span class="math display">\[f_i = \frac{f_{i-1}+ 1}{P_i}\]</span></p><p><span class="math display">\[f_i = \frac{f_{i-1}+1}{\frac{p_i}{100}} =  \frac{(f_{i-1}+1) \cdot100}{p_i}\]</span></p><p>预处理 <span class="math inline">\(p_i\)</span> 的逆元即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, P=<span class="hljs-number">100</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> t, n, m, p[N], inv[N], f[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">read</span>();inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)%mod*P%mod*inv[p[i]]%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);&#125;</code></pre></div><h2 id="solution-2">solution 2</h2><p>根据期望的线性性，设 <span class="math inline">\(f_i\)</span> 表示<span class="math inline">\((i-1 \rightarrow i)\)</span>的期望步数。</p><p>设 <span class="math inline">\(S_i = \sum_{j=1}^{i-1} f_j\)</span><span class="math display">\[f_i =  P_i \cdot 1 + (1-P_i) \cdot ( 1 + \sum_{j=1}^{i-1} f_j +f_i)\]</span></p><p><span class="math display">\[f_i =  P_i + (1-P_i) \cdot (1 + S_i + f_i)\]</span></p><p><span class="math display">\[f_i = \frac{(1-P_i) \cdot S_i + 1}{P_i}\]</span></p><p><span class="math display">\[f_i = \frac{(1-\frac{p_i}{100}) \cdot S_i + 1}{\frac{p_i}{100}} =\frac{(100-p_i) \cdot S_i + 100}{p_i}\]</span></p><p>简单维护 <span class="math inline">\(S\)</span>，最后答案为 <spanclass="math inline">\(\sum_{i=1}^n f_i\)</span></p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>, P=<span class="hljs-number">100</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> t, n, m, p[N], inv[N], f[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">read</span>();inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;<span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;f[i]=(<span class="hljs-number">100</span>+(<span class="hljs-number">100</span>-p[i])*s)*inv[p[i]]%mod;(s+=f[i])%=mod;&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s);&#125;</code></pre></div><h1 id="luogu6835-线形生物">luogu6835 线形生物</h1><h2 id="分析">分析</h2><p>是上一题的加强版。</p><p>由于每个台阶都多了若干出边，所以不能采用上题第一种状态了。</p><p>参考了洛谷第一篇题解的推式子方式。</p><p>设 <span class="math inline">\(E(x,y)\)</span> 为线性生物从 <spanclass="math inline">\(x\)</span> 爬到 <spanclass="math inline">\(y\)</span> 的期望步数，<spanclass="math inline">\(deg_x\)</span> 表示 <spanclass="math inline">\(x\)</span> 节点的入度，不包含 <spanclass="math inline">\((x-1 \rightarrow x)\)</span>。</p><p>此时有 <span class="math display">\[E(x,x+1) = \frac{1}{deg_x+1} \cdot 1 + \frac{1}{deg_x +1} \sum_{(x\rightarrow y)} 1 +E(y,x+1)\]</span> 含义：在 <span class="math inline">\(deg_x+1\)</span>种走法中，有一条正好是 <span class="math inline">\((x \rightarrowx+1)\)</span>，权值为 <spanclass="math inline">\(1\)</span>。对于其他每一条 <spanclass="math inline">\((x,y)\)</span>，都要从 <spanclass="math inline">\(y\)</span> 走到 <spanclass="math inline">\(x+1\)</span>，且还要加上走到 <spanclass="math inline">\(y\)</span> 的 <spanclass="math inline">\(1\)</span>。</p><p>化简原式。根据期望的线性性，有 <span class="math inline">\(E(y,x+1) =\sum_{i=y}^x E(i,i+1)\)</span>，带进去得到 <span class="math display">\[E(x,x+1) = 1 + \frac{1}{deg_x+1} \cdot \sum_{(x \rightarrow y)}\sum_{i=y}^x E(i,i+1)\]</span>含义：不管走到哪里，肯定要走一步。后面的部分就是走到不同的点的不同权值。</p><p>此时所有代表状态都是从一个点到编号 <spanclass="math inline">\(+1\)</span> 的点。不妨设 <spanclass="math inline">\(f_x = E(x,x+1)\)</span>，<spanclass="math inline">\(g_x= \sum_{i=0}^x f_i\)</span> 则 <spanclass="math display">\[f_x = 1 + \frac{1}{deg_x + 1} \cdot \sum_{(x \rightarrow y)} g_x -g_{y-1}\]</span> 注意到右边含有一个 <spanclass="math inline">\(\frac{deg_x}{deg_x+1} \cdot f_x\)</span>，化简得到<span class="math display">\[f_x = \frac{deg_x}{deg_x +1} \cdot f_x + 1 + \frac{1}{deg_x + 1} \cdot\sum_{(x \rightarrow y)} g_{x-1} - g_{y-1}\]</span></p><p><span class="math display">\[\frac{f_x}{deg_x+1} = 1 + \frac{1}{deg_x + 1} \cdot \sum_{(x \rightarrowy)} g_{x-1} - g_{y-1}\]</span></p><p><span class="math display">\[f_x = deg_x + 1 + \sum_{(x \rightarrow y)} g_{x-1} - g_{y-1}\]</span></p><p>由于 <span class="math inline">\(y=x+1\)</span> 时没有贡献，<spanclass="math inline">\(y \neq x+1\)</span> 时一定有 <spanclass="math inline">\(y \lex\)</span>，所以很容易按照编号从小到大的拓扑序求出 <spanclass="math inline">\(f_x\)</span> 和 <spanclass="math inline">\(g_x\)</span>。</p><p>最终答案为 <span class="math inline">\(g_n\)</span>。</p><p>尽管要建图，但是显然不是图上动态规划 awa。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> id, n, m, f[N], g[N], deg[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;id=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), ++deg[x];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;f[x]=deg[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];(f[x]+=(g[x<span class="hljs-number">-1</span>]-g[y<span class="hljs-number">-1</span>]+mod)%mod)%=mod;&#125;g[x]=(g[x<span class="hljs-number">-1</span>]+f[x])%mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,g[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「杂题选讲」#1</title>
    <link href="/2022/tititi-solution-1/"/>
    <url>/2022/tititi-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>杂题选讲。</p><span id="more"></span><h1 id="cf1548a-web-of-lies">CF1548A Web of Lies</h1><h2 id="分析">分析</h2><p>发现编号为 <span class="math inline">\(i\)</span>的节点只会对编号大于 <span class="math inline">\(i\)</span>的节点造成影响。</p><p>设 <span class="math inline">\(cnt_x\)</span> 为与 <spanclass="math inline">\(x\)</span> 相连且编号大于 <spanclass="math inline">\(x\)</span> 的点的数量。如果 <spanclass="math inline">\(x\)</span> 是所在连通块编号最小的节点，那么只要<span class="math inline">\(cnt_x\neq 0\)</span>，<spanclass="math inline">\(x\)</span> 就一定被删除。发现最终剩下的一定是满足<span class="math inline">\(cnt_x = 0\)</span> 的点。维护即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>;<span class="hljs-keyword">int</span> n, m, cnt[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">int</span> ans=n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);        <span class="hljs-keyword">if</span>(++cnt[x]==<span class="hljs-number">1</span>) --ans;    &#125;    <span class="hljs-keyword">int</span> q; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--) &#123;        <span class="hljs-keyword">int</span> op, x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%&quot;</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);            <span class="hljs-keyword">if</span>(++cnt[x]==<span class="hljs-number">1</span>) --ans;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-built_in">swap</span>(x,y);            <span class="hljs-keyword">if</span>(--cnt[x]==<span class="hljs-number">0</span>) ++ans;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    &#125;&#125;</code></pre></div><h1 id="luogu3545-hur-warehouse-store">luogu3545 HUR-WarehouseStore</h1><h2 id="分析-1">分析</h2><p>一个错误的贪心就是，只要能卖出就尽可能卖出。反例是 <spanclass="math inline">\(b_1 = a_1 = 10^9\)</span>，<spanclass="math inline">\(a_{2 \sim n} = 0\)</span> 且 <spanclass="math inline">\(b_{2 \sim n} = 1\)</span>，其中 <spanclass="math inline">\(n &gt;2\)</span>。第一天把所有的货物都卖了，可是收益最大为 <spanclass="math inline">\(1\)</span>，显然不对。</p><p>尝试修正这个贪心。设第 <span class="math inline">\(i\)</span>天上午货物量为 <span class="math inline">\(t\)</span>，如果 <spanclass="math inline">\(t &lt; b_i\)</span> 且 <spanclass="math inline">\(b_i\)</span> 小于已经之前的最大需求量 <spanclass="math inline">\(b_j\)</span>，由于卖给谁收益都是 <spanclass="math inline">\(1\)</span> 且卖给 <spanclass="math inline">\(j\)</span> 的一定多于卖给 <spanclass="math inline">\(i\)</span> 的，所以直接令 <spanclass="math inline">\(t + (b_j - b_i)\)</span>。这样做一定不劣。</p><p>否则就遵循能买则买的原则。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">250005</span>;<span class="hljs-keyword">int</span> n, a[N], b[N];<span class="hljs-keyword">bool</span> v[N];priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t+=a[i];<span class="hljs-keyword">if</span>(t&lt;b[i]&amp;&amp;q.<span class="hljs-built_in">size</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>().first&gt;b[i]) &#123;<span class="hljs-keyword">int</span> d=q.<span class="hljs-built_in">top</span>().first, id=q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();v[id]=<span class="hljs-number">0</span>, t+=d, --ans;            <span class="hljs-comment">// 反悔贪心</span>&#125; <span class="hljs-keyword">if</span>(t&gt;=b[i]) &#123;            <span class="hljs-comment">// 如果反悔了，那么一定有t&gt;=b[i]</span>            <span class="hljs-comment">// 否则就直接贪心</span> t-=b[i], v[i]=<span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(b[i],i)), ++ans; &#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(v[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h1 id="luogu2034-选择数字">luogu2034 选择数字</h1><h2 id="分析-2">分析</h2><p>正难则反。<del>虽然正着也能做</del>。</p><p>先认为每个数字都被选择，不能有连续超过 <spanclass="math inline">\(k\)</span> 个数字被选择说明在一个长度为 <spanclass="math inline">\(k+1\)</span> 的窗口中，至少有 <spanclass="math inline">\(2\)</span> 个不被选择的数字。</p><p>选出的数字总和最大，说明不被选出的数字总和最小。</p><p>设 <span class="math inline">\(f_i\)</span> 表示在 <spanclass="math inline">\([1,i]\)</span> 中且满足条件的前提下，不选择 <spanclass="math inline">\(i\)</span> 的最小和。 <spanclass="math display">\[f_i = \min_{j \in [i-k-1,i)} {\{ f_j + a_i \}}\]</span> 单调队列优化即可。答案为 <span class="math inline">\(\max_{i\in [n-k,n]}{\{ S - f_i \}}\)</span>，其中 <spanclass="math inline">\(S=\sum_{i=1}^n a_i\)</span>。这是因为如果 <spanclass="math inline">\([n-k,n]\)</span> 这个长度为 <spanclass="math inline">\(k+1\)</span>区间内，所有数字都没选择，那么显然是不满足条件的。</p><h2 id="code-2">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;<span class="hljs-keyword">int</span> n, k, sum, a[N], f[N], q[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum+=a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;i-k<span class="hljs-number">-1</span>&gt;q[l]) ++l;f[i]=f[q[l]]+a[i];<span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[i]&lt;=f[q[r]]) --r;q[++r]=i;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-k;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,sum-f[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="cf1415e-new-game-plus">CF1415E New Game Plus!</h1><h2 id="分析-3">分析</h2><p><span class="math inline">\(k\)</span> 次机会把计数器变为 <spanclass="math inline">\(0\)</span>，相当于 <spanclass="math inline">\(k+1\)</span> 个初始为 <spanclass="math inline">\(0\)</span> 的局面。</p><p>贪心地将 <span class="math inline">\(\{ a\}\)</span> 递减排序。对于<span class="math inline">\(i\)</span>，找到价值最大的局面 <spanclass="math inline">\(x\)</span>，让 <spanclass="math inline">\(ans+x\)</span>，<spanclass="math inline">\(x+a_i\)</span>。最终 <spanclass="math inline">\(ans\)</span> 即为答案。</p><p>正确性？</p><p>假设所有 <span class="math inline">\(a_i\)</span> 都是正数，那么<span class="math inline">\(k+1\)</span>个局面都不会减小，那么只要不断累加一个局面即可，这样做是对的。</p><p>假设存在负数 <span class="math inline">\(a_i\)</span>，使得最大局面<span class="math inline">\(x\)</span> 会减小，那么由于答案要累加 <spanclass="math inline">\(x\)</span>，所以取出不是最大局面显然不优。由于本题明显存在的一点是“局部最优解可以推得全局最优解”，所以即便<span class="math inline">\(x\)</span>减小，如果他还是最大局面，仍然不会产生错误；否则它也不会产生贡献。这种情况下也是对的。</p><h2 id="code-3">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, k, ans, a[N];priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x&gt;y; &#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;++i) q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();ans+=x, x+=a[i];q.<span class="hljs-built_in">push</span>(x);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><h1 id="cf1385d-a-good-string">CF1385D a-Good String</h1><h2 id="分析-4">分析</h2><p><span class="math inline">\(n\)</span> 为 <spanclass="math inline">\(2\)</span> 的整数次幂，显然是分治啊。</p><p>这是我除了归并排序外，第一道分治题。</p><p>设 <span class="math inline">\(solve(l,r,c)\)</span> 表示将 <spanclass="math inline">\(S_{l,r}\)</span> 变成一个 <spanclass="math inline">\(c\)</span> 好串的最小操作次数。</p><p>具体方法是从 <span class="math inline">\(mid=\frac{l+r}{2}\)</span>作为临界点，考虑两种情况。一种是将 <spanclass="math inline">\(S_{l,mid}\)</span> 全部改为 <spanclass="math inline">\(c\)</span>，<spanclass="math inline">\(S_{mid+1,r}\)</span> 改为 <spanclass="math inline">\(c+1\)</span>，另一种是反过来。</p><p>这一层的答案即为 <span class="math display">\[\sum_{i=l}^{mid} [S_i \neq c] + solve(mid+1,r,c+1)\]</span> 和 <span class="math display">\[\sum_{i=mid+1}^r [S_i \neq c] + solve(l,mid,c+1)\]</span> 取较小值即可。</p><p><span class="math inline">\(T(n) = 2 T(\frac{n}{2}) +O(n)\)</span>，带入主定理得到复杂度为 <span class="math inline">\(O(n\log_2 n)\)</span>。</p><h2 id="code-4">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> t, n;<span class="hljs-keyword">char</span> s[<span class="hljs-number">150000</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">char</span> c)</span> </span>&#123;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> s[l]!=c;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> cl=<span class="hljs-number">0</span>, cr=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=mid;++i) cl+=s[i]!=c;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i) cr+=s[i]!=c;cl+=<span class="hljs-built_in">solve</span>(mid+<span class="hljs-number">1</span>,r,c+<span class="hljs-number">1</span>), cr+=<span class="hljs-built_in">solve</span>(l,mid,c+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cl,cr);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-string">&#x27;a&#x27;</span>));&#125;&#125;</code></pre></div><h1 id="cf1545b-aquamoon-and-chess">CF1545B AquaMoon and Chess</h1><h2 id="分析-5">分析</h2><p><span class="math inline">\(110 \rightarrow 011\)</span>。</p><p><span class="math inline">\(011 \rightarrow 110\)</span>。</p><p>设 <span class="math inline">\(c0\)</span> 为 <spanclass="math inline">\(0\)</span> 的数量，<spanclass="math inline">\(c11\)</span> 为两个连续的 <spanclass="math inline">\(1\)</span> 的数量。注意 <spanclass="math inline">\(111\)</span> 中 <spanclass="math inline">\(c11=1\)</span>。</p><p>那么答案即为 <spanclass="math inline">\(C_{c0+c11}^{c11}\)</span>。</p><p>一共 <span class="math inline">\(c_0+c11\)</span> 个位置，填进去<span class="math inline">\(c11\)</span> 个 <spanclass="math inline">\(11\)</span> 的方案数。</p><p>不难发现，空出来的单个 <span class="math inline">\(1\)</span>是没有任何影响的，因为只要 <span class="math inline">\(11\)</span>交换过来，就能用右边的 <span class="math inline">\(1\)</span>和这个单独的 <span class="math inline">\(1\)</span> 组合成新的 <spanclass="math inline">\(11\)</span>，且 <spanclass="math inline">\(11\)</span> 的总量不变。所以，<spanclass="math inline">\(11\)</span> 可以到达任何一个 <spanclass="math inline">\(0\)</span> 的位置，加上本身的 <spanclass="math inline">\(c11\)</span> 个位置，就有了这个式子。</p><h2 id="code-5">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> t, n, m, cnt, ans, fac[N], inv[N];<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>; x%=mod;<span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%mod;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> n&lt;=m? <span class="hljs-number">1</span>:fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, inv[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e5</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;inv[N<span class="hljs-number">-5</span>]=<span class="hljs-built_in">fp</span>(fac[N<span class="hljs-number">-5</span>],mod<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=(<span class="hljs-number">1e5</span>)<span class="hljs-number">-1</span>;i;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> c0=<span class="hljs-number">0</span>, c11=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>) ++c0;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;=n&amp;&amp;s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>) ++c11, ++i;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">C</span>(c0+c11,c11));&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>分治</tag>
      
      <tag>单调队列</tag>
      
      <tag>杂题选讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5894 robots 题解</title>
    <link href="/2022/lg5894-solution/"/>
    <url>/2022/lg5894-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>二分答案，设 <span class="math inline">\(check(x)\)</span> 为能否在<span class="math inline">\(x\)</span> 的时间之内完成。</p><span id="more"></span><p>一个很显然的贪心策略就是，对于每个弱机器人，从 <spanclass="math inline">\(X_i\)</span>最小的开始，在不超时的前提下，尽可能拿走重量小于 <spanclass="math inline">\(X_i\)</span>且没有被拿走的玩具，优先选择体积最大的。而小机器人则用来收拾烂摊子，从<span class="math inline">\(Y_i\)</span>最大的开始，在不超时的前提下，尽可能拿走能够拿走且没有被拿走的玩具，优先选择体积最大的。</p><p>简单堆贪心。</p><p>正确性？感性理解，弱机器人不考虑体积，那么就在不考虑体积的情况下尽可能多拿，且从<span class="math inline">\(X_i\)</span>小的开始保证了“物尽其用”。由于有时间（拿的个数）限制，所以贪心选择体积更大的为小机器人分担压力。而小机器人则不考虑重量，负责收拾烂摊子（时间不够拿不走的，重量太大拿不走的）就好了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> T, n, m, a[N], b[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">toy</span> &#123;</span> <span class="hljs-keyword">int</span> w, s; &#125; c[M];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(toy a,toy b) &#123; <span class="hljs-keyword">return</span> a.w&lt;b.w; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-comment">// 优先队列存放没有被拿走的玩具的体积</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(pos&lt;=T&amp;&amp;c[pos].w&lt;a[i]) q.<span class="hljs-built_in">push</span>(c[pos++].s);        <span class="hljs-comment">// 把能够拿走的玩具入堆</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=x&amp;&amp;q.<span class="hljs-built_in">size</span>();++j) q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">// x的时间最多拿走x个玩具，贪心选择体积最大的</span>&#125;<span class="hljs-keyword">while</span>(pos&lt;=T) q.<span class="hljs-built_in">push</span>(c[pos++].s);    <span class="hljs-comment">// 这部分就是任何弱机器人都拿不走的</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i;--i) &#123;<span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=x&amp;&amp;q.<span class="hljs-built_in">size</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>()&lt;b[i];++j) q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">// 在x的时间内，优先选择最大的能够拿走的玩具</span>&#125;<span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 优先队列为空，说明能够完成</span>&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=T;++i) c[i].w=<span class="hljs-built_in">read</span>(), c[i].s=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+m+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+T+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=T;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">check</span>(l)? l:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>夏令营的一些图论题 题解</title>
    <link href="/2022/graph-solution-2/"/>
    <url>/2022/graph-solution-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>这篇文章收录了一些夏令营期间写的不是那么复杂的图论题目。</p><span id="more"></span><h2 id="cf715b-complete-the-graph">CF715B Complete The Graph</h2><h3 id="分析">分析</h3><p>注意到如果改权值为 <span class="math inline">\(0\)</span>的边，那么把它改成 <span class="math inline">\(1\)</span>一定收益最大。</p><p>于是乎用 Dijkstra 算法求出以 <span class="math inline">\(s\)</span>为起点，不含 <span class="math inline">\(0\)</span> 边情况的最短路。</p><p>如果此时 <span class="math inline">\(dis(t) &lt;L\)</span>，那么由于改边不会让这时候的最短路更大，所以一定无解。</p><p>如果 <span class="math inline">\(dis(t) =L\)</span>，那么最优解就是让改动后的边不会改变 <spanclass="math inline">\(dis(t)\)</span> 的值，将他们改为 <spanclass="math inline">\(10^{18}\)</span> 即可。</p><p>如果 <span class="math inline">\(dis(t) &gt;L\)</span>，那么就依次把一条 <span class="math inline">\(0\)</span>边改为 <span class="math inline">\(1\)</span>且加入图中，再跑最短路。如果此时 <span class="math inline">\(dis(t) \leL\)</span>，那么就让某一条边的权值加上 <spanclass="math inline">\(L-dis(t)\)</span>，此时 <spanclass="math inline">\((s \rightarrow t)\)</span> 的最短路长度为 <spanclass="math inline">\(L\)</span>。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">10005</span>, inf=<span class="hljs-number">1e18</span>;<span class="hljs-keyword">int</span> n, m, L, s, t, cnt, fg, d[N], a[N], b[N], c[N];<span class="hljs-keyword">int</span> tot, h[N], to[<span class="hljs-number">200010</span>], nxt[<span class="hljs-number">200010</span>], w[<span class="hljs-number">200010</span>];<span class="hljs-keyword">bool</span> v[N];vector&lt;<span class="hljs-keyword">int</span>&gt; e; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) d[i]=inf, v[i]=<span class="hljs-number">0</span>;d[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>().sc; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;); &#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sdasdsad</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;    <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span>(i&lt;fg) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],<span class="hljs-number">1ll</span>);<span class="hljs-keyword">if</span>(i==fg) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],L-d[t]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(i&gt;fg) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],inf);&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],c[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), L=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) &#123; e.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-built_in">add</span>(a[i],b[i],c[i]), <span class="hljs-built_in">add</span>(b[i],a[i],c[i]);&#125;<span class="hljs-built_in">dijkstra</span>(s);<span class="hljs-keyword">if</span>(d[t]&lt;L) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">if</span>(d[t]==L) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],inf);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>,a[i],b[i],c[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(d[t]&gt;L) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;e.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-built_in">add</span>(a[e[i]],b[e[i]],<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(b[e[i]],a[e[i]],<span class="hljs-number">1</span>);<span class="hljs-built_in">dijkstra</span>(s);<span class="hljs-keyword">if</span>(d[t]&gt;L) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(d[t]&lt;=L) &#123;fg=e[i];<span class="hljs-built_in">sdasdsad</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);&#125;</code></pre></div><h2 id="cf1076d-edge-deletion">CF1076D Edge Deletion</h2><h3 id="分析-1">分析</h3><p>最短路树。</p><p>起点到所有点以及对应的最短路径构成一棵树，称为最短路树。其他的边全部删去也不会影响到达任何点的最短路。那我们可以贪心选择最短路树之外的边，如果全都删完了，那么只能从最短路树里删。</p><p>由于不包含 <span class="math inline">\(1\)</span>号节点，所以答案即为 <span class="math inline">\(\min{\{ k,n-1\}}\)</span>。</p><p>至于输出方案，遍历最短树，优先输出前 <spanclass="math inline">\(\min{\{ k,n-1 \}}\)</span>个就好了。由于建立双向边，所以对于边 <spanclass="math inline">\(i\)</span> 的边，其真实编号为 <spanclass="math inline">\(\lfloor \frac{i}{2} \rfloor\)</span>。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e18</span>;<span class="hljs-keyword">int</span> n, m, k, cnt, d[N], ans[N], pre[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> x, y, to; &#125;;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>().sc; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, pre[y]=i, q.<span class="hljs-built_in">push</span>(&#123;-d[y],y&#125;); &#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(pre[y]==i) &#123;++cnt;<span class="hljs-keyword">if</span>(cnt&gt;k||cnt==n) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<span class="hljs-built_in">dfs</span>(y,x);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">min</span>(k,n<span class="hljs-number">-1</span>));<span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>); <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div><h2 id="cf1343e-weights-distributing">CF1343E Weights Distributing</h2><h3 id="分析-2">分析</h3><p>自然是将边权排序。</p><p>分别以 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>为起点进行 BFS 求出到每个节点的距离，设他们为 <spanclass="math inline">\(da(i)\)</span>，<spanclass="math inline">\(db(i)\)</span>，<spanclass="math inline">\(dc(i)\)</span>。枚举一个点 <spanclass="math inline">\(i\)</span>，前 <spanclass="math inline">\(da(i)+db(i)+dc(i)\)</span> 小的边权加上前 <spanclass="math inline">\(db(i)\)</span>小的边权即为这部分的答案，取最小值即可。</p><p>下面证明可以取到所有情况。</p><p>如果 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>在同一条简单路径上，那么最优解一定是取 <spanclass="math inline">\(i=b\)</span>，此时 <spanclass="math inline">\(db(i)=0\)</span>，将最小的边权放到这条路径上即可。</p><p>如果不在同一条简单路径上，由于树上两点之间有且仅有一条简单路径，而路径是<span class="math inline">\((a \rightarrow b)\)</span> 和 <spanclass="math inline">\((b \rightarrow c)\)</span>，所以取 <spanclass="math inline">\(i=lca(a,c)\)</span>，此时保留了 <spanclass="math inline">\((a \rightarrow c)\)</span> 的简单路径且 <spanclass="math inline">\(db(lca(a,b))\)</span> 被计算了 <spanclass="math inline">\(2\)</span>次，贪心地让这一块取最小的几个权值即可。</p><p>这题最好自己画图。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">1e18</span>;<span class="hljs-keyword">int</span> n, m, a, b, c, d[N], da[N], db[N], dc[N], w[N], sum[N];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) da[i]=<span class="hljs-number">-1</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;da[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(s); <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(da[y]==<span class="hljs-number">-1</span>) da[y]=da[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) db[i]=<span class="hljs-number">-1</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;db[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(s); <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(db[y]==<span class="hljs-number">-1</span>) db[y]=db[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) dc[i]=<span class="hljs-number">-1</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;dc[s]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(s); <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(dc[y]==<span class="hljs-number">-1</span>) dc[y]=dc[x]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-number">0</span>;tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), a=<span class="hljs-built_in">read</span>(), b=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) w[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">bfs1</span>(a), <span class="hljs-built_in">bfs2</span>(b), <span class="hljs-built_in">bfs3</span>(c);<span class="hljs-built_in">sort</span>(w+<span class="hljs-number">1</span>,w+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+w[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(da[i]+db[i]+dc[i]&gt;m) <span class="hljs-keyword">continue</span>;ans=<span class="hljs-built_in">min</span>(ans,sum[da[i]+db[i]+dc[i]]+sum[db[i]]);&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="cf832d-misha-grisha-and-underground">CF832D Misha, Grisha andUnderground</h2><h3 id="分析-3">分析</h3><p>不会证明，纯属找规律。</p><p>假设 <span class="math inline">\(a,b\)</span> 是起点，<spanclass="math inline">\(c\)</span> 是终点，答案为 <spanclass="math display">\[\frac{dis(a,b)+dis(a,c)-dis(a,b)}{2} +1\]</span> 枚举三种情况取最大值即可。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, q, fa[N], sz[N], dep[N], son[N];<span class="hljs-keyword">int</span> num, top[N];<span class="hljs-keyword">int</span> tot, h[N], w[N], to[<span class="hljs-number">2</span>*N], nxt[<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y==fa[x]) <span class="hljs-keyword">continue</span>;fa[y]=x, dep[y]=dep[x]+<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs1</span>(y);sz[x]+=sz[y];<span class="hljs-keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> tp)</span> </span>&#123;top[x]=tp;<span class="hljs-keyword">if</span>(!son[x]) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">dfs2</span>(son[x],tp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];<span class="hljs-keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x]) <span class="hljs-built_in">dfs2</span>(y,y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="hljs-built_in">swap</span>(x,y);x=fa[top[x]];&#125;<span class="hljs-keyword">if</span>(dep[x]&gt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">int</span> z=<span class="hljs-built_in">lca</span>(x,y);<span class="hljs-keyword">return</span> dep[x]+dep[y]<span class="hljs-number">-2</span>*dep[z];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;<span class="hljs-keyword">int</span> ans1=(<span class="hljs-built_in">dis</span>(x,z)+<span class="hljs-built_in">dis</span>(y,z)-<span class="hljs-built_in">dis</span>(x,y))/<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> ans2=(<span class="hljs-built_in">dis</span>(x,y)+<span class="hljs-built_in">dis</span>(y,z)-<span class="hljs-built_in">dis</span>(x,z))/<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> ans3=(<span class="hljs-built_in">dis</span>(x,y)+<span class="hljs-built_in">dis</span>(x,z)-<span class="hljs-built_in">dis</span>(y,z))/<span class="hljs-number">2</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans1,<span class="hljs-built_in">max</span>(ans2,ans3))+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,i), <span class="hljs-built_in">add</span>(i,x);&#125;<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">solve</span>(x,y,z));&#125;&#125;</code></pre></div><h2 id="d.-toss-a-coin-to-your-graph...">D. Toss a Coin to YourGraph...</h2><h3 id="分析-4">分析</h3><p>最大值最小，二分答案。设 <spanclass="math inline">\(check(x)\)</span> 表示只经过权值小于等于 <spanclass="math inline">\(x\)</span> 的节点，能不能满足条件。</p><p>具体实现时可以只将满足 <span class="math inline">\((x \rightarrowy)\)</span>，其中 <span class="math inline">\(a_x,a_y \le x\)</span>的边加入图中。</p><p>如果此时有环，那么在这个环上走就行了，显然是能够经过 <spanclass="math inline">\(k\)</span> 个节点的。</p><p>如果没有环，那么此时图是一个 DAG。设 <spanclass="math inline">\(f_i\)</span> 为从 <spanclass="math inline">\(i\)</span> 出发，最多能经过的节点个数。起初 <spanclass="math inline">\(f_i =1\)</span>，然后拓扑排序。 <spanclass="math display">\[f_y= \max_{(x \rightarrow y)}\{ f_x +1\}\]</span> 转移即可。如果存在 <span class="math inline">\(f_i \gek\)</span>，那么就能满足条件。</p><p>可以直接利用拓扑排序判断是否存在环。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> n, m, k, a[N], b[N], f[N], deg[N];<span class="hljs-keyword">int</span> tot, h[N], to[N], nxt[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> u, v; &#125; e[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>(); &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=v[i]=deg[i]=<span class="hljs-number">0</span>, f[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> u=e[i].u, v=e[i].v;<span class="hljs-keyword">if</span>(a[u]&lt;=x&amp;&amp;a[v]&lt;=x) &#123;<span class="hljs-built_in">add</span>(u,v), ++deg[v];&#125;&#125;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!deg[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();ans=<span class="hljs-built_in">max</span>(ans,f[x]);++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--deg[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">if</span>(cnt!=n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">// 存在环</span><span class="hljs-keyword">if</span>(ans&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;e[i].u=<span class="hljs-built_in">read</span>(), e[i].v=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=n;<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(b[mid])) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">check</span>(b[l])? b[l]:<span class="hljs-number">-1</span>);&#125;</code></pre></div><h2 id="cf1131d-gourmet-choice">CF1131D Gourmet choice</h2><h3 id="分析-5">分析</h3><p>差分约束板子题……</p><p>如果 <span class="math inline">\(a_i = b_j\)</span>，合并 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j+n\)</span>。如果 <span class="math inline">\(a_i&lt; b_j\)</span>，连边 <span class="math inline">\((i \rightarrowj+n,1)\)</span>。否则反过来。</p><p>由于要最小化每个数，所以边权均为 <spanclass="math inline">\(1\)</span>。而这样建出来的图如果不是DAG，那么一定无解。</p><p>所以设 <span class="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 最小是多少。初始值和转移同上题。</p><p>用并查集实现合并操作，具体有些细节看代码。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2005</span>;<span class="hljs-keyword">int</span> n, m, fa[N], deg[N], f[N], op[N][N];<span class="hljs-keyword">int</span> tot, h[N], to[N*N], nxt[N*N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) fa[x]=y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) <span class="hljs-keyword">if</span>(!deg[i]) f[i]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-comment">// 把所有没有入度的节点入队即可，不会影响答案</span>    <span class="hljs-comment">// 只把合并后的节点入队一次，是一件吃力不讨好的事</span>    <span class="hljs-comment">// 主要是因为节点数不再是n+m了，不好判断是否存在环</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i];f[y]=<span class="hljs-built_in">max</span>(f[y],f[x]+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(--deg[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">if</span>(cnt!=n+m) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,f[<span class="hljs-built_in">get</span>(i)],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,f[<span class="hljs-built_in">get</span>(i+n)],<span class="hljs-string">&quot; \n&quot;</span>[i==m]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) fa[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-keyword">char</span> c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;c);<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-built_in">merge</span>(i,j+n);<span class="hljs-keyword">else</span> op[i][j]=c==<span class="hljs-string">&#x27;&lt;&#x27;</span>? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>;        <span class="hljs-comment">// 一定要先合并</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">get</span>(i), y=<span class="hljs-built_in">get</span>(j+n);<span class="hljs-keyword">if</span>(op[i][j]&amp;&amp;x==y) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;        <span class="hljs-comment">// 已经合并的节点之间又出现了大小关系，矛盾</span><span class="hljs-keyword">if</span>(op[i][j]==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(x,y), ++deg[y];<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[i][j]==<span class="hljs-number">2</span>) <span class="hljs-built_in">add</span>(y,x), ++deg[x];&#125;<span class="hljs-built_in">toposort</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最近公共祖先</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4678 全排列 题解</title>
    <link href="/2022/lg4678-solution/"/>
    <url>/2022/lg4678-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>显然统计贡献。</p><p>题面有个描述不清楚的地方，“相似”的不一定是一个完整的“排列”，否则这题就没法做了。不过这个笔误也启发我们思考这个东西的本质，注意到<span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 相似，当且仅当对于任意 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(A_i\)</span> 在 <spanclass="math inline">\(A\)</span> 中的相对大小与 <spanclass="math inline">\(B_i\)</span> 在 <spanclass="math inline">\(B\)</span> 中的相对大小相同。 说人话就是，<spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 离散化后是相同的。</p><span id="more"></span><p>那么最终答案一定是通过 <span class="math inline">\([1,d]\)</span>所有包含不超过 <span class="math inline">\(E\)</span>个逆序对的排列的数量来进行计算的，其中 <span class="math inline">\(d \in[1,n]\)</span>。</p><p>这是一个经典问题。设 <span class="math inline">\(f(i,j)\)</span>为包含 <span class="math inline">\(j\)</span> 个逆序对的 <spanclass="math inline">\([1,i]\)</span>的排列的个数。一个显然<del>但我不会证明</del>的结论就是把 <spanclass="math inline">\(i\)</span> 插入 <spanclass="math inline">\([1,i-1]\)</span>的任意排列中，能够增加的逆序对数量取遍 <spanclass="math inline">\([0,i-1]\)</span>，所以转移很显然 <spanclass="math display">\[f(i,j) = \sum_{k= \max(0,j-i+1)}^j f(i-1,k)\]</span> 前缀和优化即可。设 <span class="math inline">\(g(i,j)\)</span>为包含不超过<span class="math inline">\(j\)</span> 个逆序对的 <spanclass="math inline">\([1,i]\)</span> 的排列的个数，可以表示为 <spanclass="math display">\[g(i,j) = \sum_{k=0}^j f(i,k)\]</span> 得到 <span class="math display">\[f(i,j) = g(i-1,j) - \Delta\]</span> 其中当 <span class="math inline">\(j \ge i\)</span> 时，<spanclass="math inline">\(\Delta = g(i-1,j-i)\)</span>，否则 <spanclass="math inline">\(\Delta = 0\)</span>。实现的时候直接把 <spanclass="math inline">\(f\)</span> 当作 <spanclass="math inline">\(g\)</span>，求两遍即可。</p><p>对于每一个询问，不难想到等价于规定区间长度为 <spanclass="math inline">\(i\)</span>，询问离散化后为逆序对个数不超过 <spanclass="math inline">\(E\)</span> 的 <spanclass="math inline">\([1,i]\)</span> 的排列的产生方案，其中 <spanclass="math inline">\(i \in [1,n]\)</span>。</p><p>设 <span class="math inline">\(m_i = \min{( E,\frac{i \cdot (i-1)}{2})}\)</span>。</p><p>首先确定 <span class="math inline">\([1,i]\)</span> 方案数为 <spanclass="math inline">\(n-i+1\)</span>，因为要离散化，只要相对大小相同就行。比如<span class="math inline">\([2,3,4]\)</span> 和 <spanclass="math inline">\([1,2,3]\)</span>。这些方案每一种都有 <spanclass="math inline">\(g(i,m_i)\)</span> 确定满足条件的排列。</p><p>接着考虑从 <span class="math inline">\([1,n]\)</span>中构造这样的排列的方案数。在 <span class="math inline">\([1,n]\)</span>中选出 <span class="math inline">\(i\)</span> 个数，它们离散化后一定是<span class="math inline">\([1,i]\)</span>的一个排列，并且每一种选择方法对应着唯一排列方案，方案数 <spanclass="math inline">\(C^i_n\)</span>。由于乘上了 <spanclass="math inline">\(n-i+1\)</span>，所以相当于这 <spanclass="math inline">\(i\)</span> 个数的位置被固定了，所以剩下的 <spanclass="math inline">\(n-i\)</span> 个数字在 <spanclass="math inline">\(n-i\)</span> 个位置中自由排列，方案数 <spanclass="math inline">\((n-i)!\)</span>。要确定两个排列，所以要乘两边。</p><p>综上所述，对于一组 <span class="math inline">\((n,E)\)</span>，答案为<span class="math display">\[\sum_{i=1}^n f(i,m_i) \cdot (n-i+1) \cdot (C_n^i) ^2 \cdot\big((n-i)!\big)^2\]</span> 这个还是感性理解一下比较好（）。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> t, n, E, f[N][N*N/<span class="hljs-number">2</span>], fac[N], c[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">500</span>;++i) f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">500</span>;++i) &#123;<span class="hljs-keyword">int</span> k=i*(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+(j&gt;=i? mod-f[i<span class="hljs-number">-1</span>][j-i]:<span class="hljs-number">0</span>))%mod;k=i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;++j) f[i][j]=(f[i][j]+f[i][j<span class="hljs-number">-1</span>])%mod;&#125;c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">500</span>;++i) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">500</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), E=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">min</span>(E,i*(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);(ans+=f[i][k]*(n-i+<span class="hljs-number">1</span>)%mod*<span class="hljs-built_in">squ</span>(c[n][i])%mod*<span class="hljs-built_in">squ</span>(fac[n-i])%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDSC2022 游记</title>
    <link href="/2022/SDSC2022/"/>
    <url>/2022/SDSC2022/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="day-0">Day 0</h2><p>坐车去日照。</p><p>和来自烟台的 ZYC 交换了名额，来到了高级算法班。</p><p>晚上不让出去，等着派送晚餐。和来自烟台的选手们分到一个宿舍，不得不感慨自己实在是太弱了，orz。</p><span id="more"></span><p>看了一些课件，贪心啥的。</p><p>天气并不好就是了。</p><p><img src="https://s2.loli.net/2022/07/25/PdCQRTxwqJN4Zhs.jpg" srcset="/img/loading.gif" lazyload /></p><h2 id="day-1">Day 1</h2><p>上午去高级算法班上课，讲师是 hywn。分块数据结构、数论分块、莫队啥都不会，全程掉线qwq。课后与朋友交流发现这个夏令营貌似不是让我们去学新东西，而是去强化的。下午还要模拟赛，果断转去提高班了。</p><p>中午找不到回宿舍的路，frj 和 qjc 认为营员手册上的地图错了。</p><figure><img src="https://s2.loli.net/2022/07/25/TfLS9URYmnI4jDO.jpg" srcset="/img/loading.gif" lazyloadalt="手机摄像头上沾到了一点油" /><figcaption aria-hidden="true">手机摄像头上沾到了一点油</figcaption></figure><figure><img src="https://s2.loli.net/2022/07/25/yzj35OFnkKU4v8N.jpg" srcset="/img/loading.gif" lazyloadalt="小路上" /><figcaption aria-hidden="true">小路上</figcaption></figure><figure><img src="https://s2.loli.net/2022/07/25/nKvSLBiwyo6Vqrh.jpg" srcset="/img/loading.gif" lazyloadalt="qjc在撸猫" /><figcaption aria-hidden="true">qjc在撸猫</figcaption></figure><p>到达宿舍之后，我才发现自己把包忘在餐厅里了，于是飞速和 qjc回去拿。</p><figure><img src="https://s1.ax1x.com/2022/07/25/jvMkLt.jpg" srcset="/img/loading.gif" lazyload alt="再次回宿舍" /><figcaption aria-hidden="true">再次回宿舍</figcaption></figure><p>下午提高班，讲师是chz。一年后还是在这个班，这个进步速度可以垫底了吧。</p><p>90% 的内容都是栈和队列，开始是一些常规题目，觉得还可以接受，但是从 <ahref="https://luogu.com.cn/problems/P3200">luogu3200 有趣的数列</a>开始就觉得不太对劲。虽然这道是卡特兰数板子，但是明显不太好推理啊。然后<a href="https://luogu.com.cn/problems/P5698">luogu5698 算法复杂度</a>和 <a href="https://luogu.com.cn/problems/P7234">luogu7324表达式求值</a> 这两题给我整懵了，掉线。</p><p>然后讲了几道栈匹配的问题，不太懂。</p><p>接下来的内容更是重量级，「维护右链辅助建树的栈」，等等什么是右链啊！笛卡尔树和虚树？什么叫NOIP 很可能考笛卡尔树？CSP-S1 算吗？再次掉线。</p><p>维护决策单调性的栈和队列，还行，但例题 1 是 <ahref="https://luogu.com.cn/problems/P1912">luogu1912 诗人小G</a>……chz认为太难于是不讲了。后面两道题也不是就不放链接了，总之就是很难。</p><p>然后讲了左偏树的例题，但是我连左偏树都不会啊。还有可并堆以及 <ahref="https://luogu.com.cn/problems/P7476">luogu7476 苦涩</a>，<ahref="https://luogu.com.cn/problems/P7078">luogu7078 贪吃蛇</a>，二维 ST表以及<code>STL rope</code>。 Day 1 自闭了……貌似高算那边模拟赛也不是全考上午的内容？有点小后悔，不过我写到这里的时候就不后悔了。晚上去胶州一中的宿舍颓废，玩了会邦邦。见到了 frj等人，结识了一些新朋友。</p><h2 id="day-2">Day 2</h2><p>上午上机。好家伙 A 题到 L 题。</p><p>A 题貌似是 UVa 的，直接跳。B 题 <ahref="https://www.luogu.com.cn/problem/P1993">小 K 的农场</a>，C 题 <ahref="https://www.luogu.com.cn/problem/P3275">糖果</a>，D 题 <ahref="https://www.luogu.com.cn/problem/P4180">次小生成树</a>，E 题……<ahref="https://www.luogu.com.cn/problem/P5109">归程</a>？这就是提高班吗？后面都是CF 的英文题。</p><p>随便写了写，CF 的图论题还真不好调。</p><p><a href="https://www.luogu.com.cn/problem/P3275">糖果</a>在前几天增加了 Hack 数据，卡掉了 SPFA。orz</p><p>由于各种不可抗力，我们暂时还不被允许进入超商，于是就过着三点一线的生活。</p><p>下午又是 hywn讲图论，我并不怎么喜欢她讲课，在高算班也是，总感觉她啥都没讲出来，我这种原本就没学过这些的根本听不懂。不过这次讲的东西比较简单，并查集生成树LCA等，但是中途讲 魔法树的时候不免提了好几嘴树剖，我现在还不会树剖啊啊啊。/(ㄒoㄒ)/~~</p><p>竟然又讲了虚树……</p><p>后面是一些图论算法，但是莫名其妙地开始普及 bitset？</p><p>最后是差分约束系统，这个我还是比较熟悉的，我觉得她讲的不如去年的smy。</p><p>吐槽归吐槽，hywn能当两次女队也是有实力的。只不过不那么善于讲解罢了。</p><p>晚上是 hywn 的讲座，没去。由于机房停电，也没去机房。</p><p>到 ssfz 的宿舍颓废。</p><h2 id="day-3">Day 3</h2><p>上午模拟赛，三道原题。</p><p>T1 最小生成树板子。</p><p>T2问一张无向图，画最少多少笔能经过所有的边一遍。一开始误认为一笔可以重复经过边，等价于连通块个数。后来一想不对，口胡了个关于欧拉路径的做法。</p><p>T3 <a href="https://www.luogu.com.cn/problem/P7113">排水系统</a>原题，不会分数运算爆零。</p><p>T4 <a href="https://www.luogu.com.cn/problem/P2024">食物链</a>原题，扩展域并查集调了一个多小时宣告失败，爆零。</p><p>最总得分 200pts。</p><p>呜哇哭了。</p><figure><img src="https://s1.ax1x.com/2022/07/25/jvMqfg.jpg" srcset="/img/loading.gif" lazyloadalt="qjc再次撸猫" /><figcaption aria-hidden="true">qjc再次撸猫</figcaption></figure><p>下午是 sxw 讲图论，前 1h都在讲并查集，我也发现了自己的一些问题，体验还不错。</p><p>插入了 Kruskal 重构树，不太会……</p><p><img src="https://s2.loli.net/2022/07/25/Eem57nwSMbY1yKl.jpg" srcset="/img/loading.gif" lazyload /></p><p>然后简单讲解了二分图以及判定，欧拉路，Tarjan 算法。</p><p>就结束了。</p><p>晚上去了会机房，写了一道小题后发现自己写不动了，于是乎回宿舍。在 ssfz的宿舍里讨论音乐和虚拟歌姬。</p><p>没有注意晚上的讲座。</p><h2 id="day-4">Day 4</h2><p>宿舍里的卷王这几天熬夜打 CF 和Atcoder，正好我的床位就在他旁边，因此睡眠质量不是多好。每次到宿舍后都很疲惫，因此我没有打比赛。事实上全宿舍只有卷王看OI，而卷王开学上七年级……</p><p>上机。除了一道 小凯的疑惑 之外，全部都是 CF的数论题，写起来自然是十分痛苦。</p><p>下面是三道“NOIP T1/T2 难度”的题目。</p><p><a href="https://www.luogu.com.cn/problem/CF893E">CF615DMultipliers</a></p><p><a href="https://www.luogu.com.cn/problem/CF893E">CF893E CountingArrays</a></p><p><a href="https://www.luogu.com.cn/problem/CF1493D">CF1493D GCD of anArray</a></p><p>下午则是 zhq 的数论课。发现自己有很多知识点特别是同余的一些性质和Trick都没有掌握，最后浅谈一下积性函数与狄利克雷卷积，还可以，但是没完全搞懂。</p><p>饭后和 ssfz 的诸位去了超商，我选择了 1L 装的冰红茶以及若干饼干。</p><figure><img src="https://s1.ax1x.com/2022/07/25/jvMZo8.jpg" srcset="/img/loading.gif" lazyload alt="ssfz" /><figcaption aria-hidden="true">ssfz</figcaption></figure><p>没去机房，而是在 ssfz 的宿舍里写课上 <ahref="https://www.luogu.com.cn/problem/CF1389E">讲过的一道数论题</a>。今晚是唐爷爷讲金牌之路，那报告厅必然爆满，因此开通了腾讯会议转播。</p><p>宿舍里竟然有两个人同时放着转播……</p><p>为啥我老是在 ssfz 的宿舍？因为我去找qjc，顺便和其他人聊得熟络了。而我市今年只有我一个人来夏令营，实在是没有归属感、、、awa</p><p>那道题目并不难想，但是最后化简一个式子不太容易，我看题解才明白，还是太菜了。</p><h2 id="day-5">Day 5</h2><p>上午没有事，自己瞎写了两道很像的期望DP，以及一道完全没有思路的题目，<del>抄题解</del>。</p><p>中午去买了 1L 装的冰红茶诶！</p><p>下雨了，由于山外就在半山腰上且地形崎岖，导致积水比较多，因此我的鞋湿了qwq。下午干脆加入“拖鞋教”，直接穿拖鞋去上课。竟然有奇效。</p><p>下午是来自 SUSTech 的 smy 讲 DP。他比去年胖了一圈的同时还留起了和 lxl一样的秀发，导致我竟然没认出他来。</p><p><img src="https://s2.loli.net/2022/07/25/uoskzHiTrRpgf6y.jpg" srcset="/img/loading.gif" lazyload /></p><p>smy 讲课还是很不错的，DP的阶段、状态、决策、无后效性、转移成环、最优子结构性和子问题重叠性、复杂度计算、简单优化技巧都听得很舒服。好评。</p><p>smy很喜欢拿“简化版”的题目当作例题，他的说法是“既然是简化版的，你在心里就自动把它降级就好了。如果原题是紫的，那么简化之后可能是蓝的，绿的”。比如把<a href="https://luogu.com.cn/problems/P4042">luogu4042 骑士游戏</a>物理攻击杀死每个怪物后只会分裂出一类怪物，<ahref="https://www.luogu.com.cn/problem/CF626F">CF626F Group Projects</a>改为求最大价值而不是计数。</p><p>其中有一道例题，是洛谷月赛的题目。“啊这，洛谷月赛的题目风格和这道题不太一样吧”，回宿舍一看果然，他讲的是 50pts 做法，正解感觉完全不可做啊。</p><p>这天高算班 zhq 出的模拟赛难度极其变态，rk1 和 rk2 只有某一题的90pts，但道题是原题，rk2 是贺的……</p><p>然而我们的 frj 成功凭借实力拿下rk3，85pts！其中某题由于题面少打了一个 0，导致 frj 少了 20pts，痛失rk1。orz，%%%。</p><h2 id="day-6">Day 6</h2><p>上午 smy 出的比赛。</p><p>T1。给你一个数，有两种操作，如果它是奇数就让他乘 3 然后加 1，否则除以2。问你多少次操作能把它变为 1，多组询问。一开始打暴力，AC 了，但是是 OI赛制，看不到。后来记忆化搜索，40pts，再后来为了过群里流出的“hack数据”，讲数组改为<code>std::map</code>，爆零qwq。某位也用了<code>std::map</code>，但是却有 40pts，不知道为什么。</p><p>T2。贪心。2 min想了一个错误贪心，想不到过了样例（smy：“数据是随的，可能很多错误做法都能骗到部分分”），但是只拿了10pts。</p><p>T3。迅速打完，忘记两种情况取 <spanclass="math inline">\(\min\)</span>，爆零。</p><p>T4。简单 DP。我的顺序是 T1 <spanclass="math inline">\(\rightarrow\)</span> T3 <spanclass="math inline">\(\rightarrow\)</span> T4 <spanclass="math inline">\(\rightarrow\)</span> T2，写完 T3 一直在刚T4，觉得比 T2 可做。写完但是考场上被莫名降智，爆零。</p><p>于是我的成绩为 10pts。</p><p>啊啊啊啊啊啊啊啊啊要疯了啊！ w(ﾟДﾟ)w</p><p>尽管很多人都会这种情况，比如宿舍卷王同学昨天比赛硬刚 T1结果全场爆零（那题全场最高分是 15 还是20），但是我从心底是很焦虑的。因为去年的考场上，我也遇到了类似的情况，我承认我一年来进步很小，但是如果重蹈覆辙的话……</p><p>我开始重审自己，重新思考一些问题，通过现有的一点点资源全力提高自己的水平，那些自问自答的话就没必要说出来了。……尽管没有人能保证最后的结果。</p><p><ahref="https://yozora0908.github.io/2022/before-failed/">「作战，可能要失败了」</a>，其实真的失败了，测试的成绩非常差。</p><p>可不知是因为什么，他们还是给了我一个机会。尽管，那不是什么强校，尽管，它存在着一些难以言说的现状和问题。</p><p>但是，我会珍惜的，我会吸取经验，继续下去的。</p><p>因为去年离别时的那首歌。</p><p> </p>    <div id="aplayer-RPxZdtSC" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="454966322" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><p> </p><p>下午还是 smy 讲DP，但貌似大半的时间都在讲斜率优化了。哎，当年我看懂斜率优化的时候还以为自己真的能够做到些什么，实际上，至今我都是一个“理论知识强于做题能力”的人。</p><p>“正视自己的实力，享受 OI 的乐趣”。——<ahref="https://www.luogu.com.cn/user/385093">uniqueharry</a>.。</p><p>失天时——起步太晚，失地利——资源太差。即便是有卧龙轻语道“将军可占人和”，在如今的OI环境下仅凭个人努力也很难有好的成绩。但退一步，现实是大部分人都进不了队，没有什么耀眼的成绩。而且，从一开始就不是为了功利而学习OI 的吧。</p><p>我已经不怎么纠结于这些问题了。</p><p>下午是 smy 讲 DP 优化。但是仅仅斜率优化（例题是玩具装箱）就花了2h+，还应要求现场写了代码。后面简单讲了树形 DP、状压 DP的一点东西，最后讲上午的题目。心态不太好，把上午题目搞懂了之后一直在打<span class="math inline">\(Arcaea\)</span>。</p><p>晚上朋友们都去听了 zhq 的《OI与文化课杂谈》，我独自在宿舍里，望着灰蒙蒙透着深沉蓝色的天空，彷徨着，像个被欺负的小孩子那样自责又坚信着自己的歪理邪说。我害怕重蹈覆辙，我害怕又一次陷入自己编织的梦里。</p><p>眼中只有空荡荡的宿舍与明晃晃的灯，不知为何，又握紧了破旧不堪还缺了封面的《进阶指南》。去年夏令营，尽管也有些许不快，但是我永远记住了最后夕阳下的不舍；是否在某一天，我也能回忆起这个月亮尚未来临的夜晚呢？</p><p>“就要结束了啊！”</p><h2 id="day-7">day 7</h2><p>我只能自己回家。</p><p>早饭后，和朋友们简单告了别，便到宿舍收拾东西。</p><p>九点的时候，从容离开了这段憧憬着的日子。</p><p><img src="https://s2.loli.net/2022/07/25/Wo4YGgPZQuLNREh.jpg" srcset="/img/loading.gif" lazyload /></p><p><img src="https://s2.loli.net/2022/07/25/rcCo3aGMUmRnSyI.jpg" srcset="/img/loading.gif" lazyload /></p><p><img src="https://s2.loli.net/2022/07/25/fs4QNhlrguJzdG6.jpg" srcset="/img/loading.gif" lazyload /></p><p>坐着公交车到车站去，再坐长途汽车到我市。中午没吃饭，又因为赶时间进了候车大厅，所以只能从里面的超市买了些零食。还有夏令营剩下的一包膜片。</p><p>4h的长途汽车，无聊到极点，我理了一遍提高班数论的课件，顺便学了狄利克雷卷积，之后看了高算班的数论和图论。但是大部分时间在睡觉。</p><p>车上遇到了我市某区某小学的一位老师，他自己来的夏令营，听他说我市一共来了2 个人（不知道包不包括我）。</p><p>到站，又是一个傍晚。</p><p>迈开酸痛的双腿，径直走向夏空中的荧光。那由我追想出的蓝色记忆，不知为何，每当仰望它时，它总是竟义无反顾地流向遥远的天际，仿佛竭力演绎着CSP-S 2021 前一晚洇着群青色的地平线。</p><p>我一定，一定会在下一个故事，再次与各位相遇，在我所期待的未来中。</p><p> </p><p>The END.</p><p><img src="https://s2.loli.net/2022/07/25/hGfiESX8lavcKVn.png" srcset="/img/loading.gif" lazyload /></p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022的暑假</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#806 (Div 4)</title>
    <link href="/2022/cf1703-solution/"/>
    <url>/2022/cf1703-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1703</strong>.</p><p>自从前几天开始，我就一直用 <code>#define int long long</code>了。</p><span id="more"></span><h2 id="a.-yes-or-yes">A. YES or YES?</h2><h3 id="分析">分析</h3><p>直接判断即可。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> t;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">char</span> s[<span class="hljs-number">5</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-keyword">int</span> fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;y&#x27;</span>&amp;&amp;s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;Y&#x27;</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;s[<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;E&#x27;</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(s[<span class="hljs-number">2</span>]!=<span class="hljs-string">&#x27;s&#x27;</span>&amp;&amp;s[<span class="hljs-number">2</span>]!=<span class="hljs-string">&#x27;S&#x27;</span>) fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-icpc-balloons">B. ICPC Balloons</h2><h3 id="分析-1">分析</h3><p>对于一个字母，第一次出现就让答案 <spanclass="math inline">\(+2\)</span>，否则 <spanclass="math inline">\(+1\)</span>。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> t, n;map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>();string s; cin&gt;&gt;s;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s) &#123;<span class="hljs-keyword">if</span>(++p[x]==<span class="hljs-number">1</span>) ans+=<span class="hljs-number">2</span>; <span class="hljs-keyword">else</span> ans+=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-cypher">C. Cypher</h2><h3 id="分析-2">分析</h3><p>暴力还原即可。<span class="math inline">\(Up\)</span> 记为 <spanclass="math inline">\(-1\)</span>，<spanclass="math inline">\(Down\)</span> 记为 <spanclass="math inline">\(+1\)</span>，求出操作和 <spanclass="math inline">\(s\)</span>。用原来的数字加上 <spanclass="math inline">\(s\)</span>，取模即可。</p><h3 id="coed">COED</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">int</span> t, n, a[<span class="hljs-number">105</span>], c[<span class="hljs-number">105</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span> <span class="hljs-keyword">int</span> t; <span class="hljs-keyword">char</span> moves[<span class="hljs-number">20</span>]; &#125; b[<span class="hljs-number">105</span>];map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i].t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,b[i].moves);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;b[i].t;++j)<span class="hljs-keyword">if</span>(b[i].moves[j]==<span class="hljs-string">&#x27;U&#x27;</span>) --s; <span class="hljs-keyword">else</span> ++s;c[i]=(a[i]+s)%<span class="hljs-number">10</span>;<span class="hljs-keyword">if</span>(c[i]&lt;<span class="hljs-number">0</span>) c[i]=(c[i]+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld%c&quot;</span>,c[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-double-strings">D. Double Strings</h2><h3 id="分析-3">分析</h3><p>由于每个字符串长度不超过 <spanclass="math inline">\(8\)</span>，可以看作常数。所以对于字符串 <spanclass="math inline">\(S\)</span>，枚举断点 <spanclass="math inline">\(p\)</span>，判断两个字符串是否存在即可，注意边界。</p><p>用 <code>std::map</code> 实现，复杂度 <span class="math inline">\(O(n\log_2 n)\)</span>。</p><p>一开始竟然想出了，开一颗 Trie，对于字符串 <spanclass="math inline">\(s\)</span>，快速查找有没有它的前缀单词，有的话就从那个位置截取字符串，查找是否存在。没实现好，打挂之后就睡觉了。睡前才发现字符串最大长度为<spanclass="math inline">\(8\)</span>，而且貌似快不了多少。菜死了qwq。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, tot;string s[N];map&lt;string,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();p.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;s[i], p[s[i]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> fg=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;s[i].<span class="hljs-built_in">length</span>();++j) &#123;string t1=s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,j), t2=s[i].<span class="hljs-built_in">substr</span>(j,s[i].<span class="hljs-built_in">size</span>()-j);<span class="hljs-keyword">if</span>(p[t1]&amp;&amp;p[t2]) fg=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,fg);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-mirror-grid">E. Mirror Grid</h2><h3 id="分析-4">分析</h3><p>定义一个位置 <spanclass="math inline">\((x,y)\)</span>“被要求修改”，当且仅当存在一个位置旋转任意度后落在<span class="math inline">\((x,y)\)</span>，且与它本身数字不同。</p><p>不难发现，对于一个被要求修改位置 <spanclass="math inline">\((x,y)\)</span>，早修改和晚修改是等价的。</p><p><span class="math inline">\((x,y)\)</span> 顺时针旋转 90° 后的位置是<span class="math inline">\((y,n-x+1)\)</span>。对于一个 <spanclass="math inline">\((x,y)\)</span>，我们只需要枚举包括它在内的 <spanclass="math inline">\(4\)</span> 个位置，看有哪些是被要求修改的。</p><p>设 <span class="math inline">\(cnt_0\)</span> 为这四个位置中 <spanclass="math inline">\(0\)</span> 的个数，如果 <spanclass="math inline">\(cnt_0 = 0\)</span> 或 <spanclass="math inline">\(cnt_0 = 4\)</span>，没有位置被要求修改。如果 <spanclass="math inline">\(cnt_0 = 1\)</span>，那么最优决策是将这个 <spanclass="math inline">\(0\)</span> 改成 <spanclass="math inline">\(1\)</span>，需要一次操作，同理若 <spanclass="math inline">\(cnt_0 = 3\)</span>，也只需要一次操作将那个 <spanclass="math inline">\(1\)</span> 改为 <spanclass="math inline">\(0\)</span> 即可。若 <spanclass="math inline">\(cnt_0 = 2\)</span>，需要两次操作，随便改。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-keyword">int</span> t, n, ans;<span class="hljs-keyword">char</span> s[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">int</span> x=i, y=j, cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>;++k) &#123;cnt+=s[x][y]==<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">int</span> tx=x, ty=y;x=ty, y=n-tx+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(!cnt||cnt==<span class="hljs-number">4</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">char</span> o;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>) o=<span class="hljs-string">&#x27;1&#x27;</span>, ++ans;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">3</span>) o=<span class="hljs-string">&#x27;0&#x27;</span>, ++ans;<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">2</span>) o=<span class="hljs-string">&#x27;0&#x27;</span>, ans+=<span class="hljs-number">2</span>;x=i, y=j;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>;++k) &#123;s[x][y]=o;<span class="hljs-keyword">int</span> tx=x, ty=y;x=ty, y=n-tx+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="f.-yet-another-problem-about-pairs-satisfying-an-inequality">F.Yet Another Problem About Pairs Satisfying an Inequality</h2><h3 id="分析-5">分析</h3><p>有一个我自己总结出来的小结论：在一个序列问题中，对于下标 <spanclass="math inline">\(i\)</span>，更容易统计 <spanclass="math inline">\([1,i-1]\)</span> 这部分的信息。</p><p>考虑维护一个序列，对于下标 <spanclass="math inline">\(x\)</span>，只有满足 <spanclass="math inline">\(a_x &lt; x\)</span> 才将 <spanclass="math inline">\(x\)</span> 加入。那么如果手里有一个 <spanclass="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i&lt; i\)</span>，只要在这个序列中统计小于 <spanclass="math inline">\(a_i\)</span> 的元素的数量，就是 <spanclass="math inline">\([1,i-1]\)</span> 和 <spanclass="math inline">\(i\)</span> 对答案产生的贡献。</p><p>具体地，使用<code>std::lower_bound()</code>，查找序列内第一个大于等于 <spanclass="math inline">\(a_i\)</span> 的数，设它的下标为 <spanclass="math inline">\(k\)</span>，那么贡献即为 <spanclass="math inline">\(k-1\)</span>。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, a[N];vector&lt;<span class="hljs-keyword">int</span>&gt; v;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();v.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;=i) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),a[i])-v.<span class="hljs-built_in">begin</span>();        <span class="hljs-comment">// vector下标从0开始，所以不用-1</span>ans+=k;v.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="g.-good-key-bad-key">G. Good Key, Bad Key</h2><h3 id="分析-6">分析</h3><p>大胆猜想一个结论：在最优解中使用坏钥匙的，一定是一段后缀。</p><blockquote><p>证明：</p><p>邻项交换法。假设 <span class="math inline">\(i\)</span>使用了坏钥匙，<span class="math inline">\(i+1\)</span>使用了好钥匙，那么收益为 <span class="math inline">\(\lfloor\frac{a_i}{2} \rfloor + \lfloor \frac{a_{i+1}}{2} \rfloor -k\)</span>；反过来，假设 <span class="math inline">\(i\)</span>使用了好钥匙，<span class="math inline">\(i+1\)</span>使用了坏钥匙，那么收益为 <span class="math inline">\(a_i + \lfloor\frac{a_{i+1}}{2} \rfloor -k\)</span>。后者显然小于前者，所以最优解中，使用坏钥匙的一定是一段后缀，命题成立。</p></blockquote><p>从 <span class="math inline">\(0\)</span> 到 <spanclass="math inline">\(n\)</span>枚举使用坏钥匙的数量，同时也是倒序枚举好钥匙的数量。</p><p>由于每多用一把坏钥匙，后面的收益都要减半，所以使用<code>std::set</code> 来维护这个「减半集合」。设 <spanclass="math inline">\(s_i = \sum_{j=1}^i a_j\)</span>，则使用 <spanclass="math inline">\(i\)</span> 把好钥匙的收益为 $ = s_i - ik$。此时集合里维护了在 <span class="math inline">\([i+1,n]\)</span>每个箱子都使用坏钥匙后，每个箱子的收益。将 <spanclass="math inline">\(\Delta\)</span>加上所有集合里的数，就得到了总收益，取最大值即可。</p><p>如何维护？当求出使用 <span class="math inline">\(i\)</span>把好钥匙的收益后，将 <span class="math inline">\(\lfloor \frac{a_i}{2}\rfloor\)</span> 加入集合，同时将集合内所有元素都除以 <spanclass="math inline">\(2\)</span> 并下取整。由于 <code>std::set</code>不便于直接修改，可以新开一个 <code>std::set</code>来储存修改后的元素，然后交换两个集合。</p><p>由于最大的元素不超过 <span class="math inline">\(10^9\)</span>，<spanclass="math inline">\(\lfloor \log_2(10^9) \rfloor =29\)</span>，所以可以认为每个元素进出集合常数次，复杂度 <spanclass="math inline">\(O(n \log_2 n)\)</span>。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, k, a[N], s[N];multiset&lt;<span class="hljs-keyword">int</span>&gt; st, tmp;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;st.<span class="hljs-built_in">clear</span>();n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>(), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;~i;--i) &#123;<span class="hljs-keyword">int</span> dlt=s[i]-i*k;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:st) dlt+=x;ans=<span class="hljs-built_in">max</span>(ans,dlt);tmp.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">if</span>(a[i]/<span class="hljs-number">2</span>&gt;<span class="hljs-number">0</span>) tmp.<span class="hljs-built_in">insert</span>(a[i]/<span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:st) <span class="hljs-keyword">if</span>(x/<span class="hljs-number">2</span>) tmp.<span class="hljs-built_in">insert</span>(x/<span class="hljs-number">2</span>);<span class="hljs-built_in">swap</span>(st,tmp);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC259G Grid Card Game 题解</title>
    <link href="/2022/abs259g-solution/"/>
    <url>/2022/abs259g-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>既然可以不选择任何一行和任何一列，那么最大收益的最小值为 <spanclass="math inline">\(0\)</span>。</p><span id="more"></span><p>设 <span class="math inline">\(r_i = \sum_{j=1}^ma_{i,j}\)</span>，<span class="math inline">\(c_{j} = \sum_{i=1}^na_{i,j}\)</span>。如果 <span class="math inline">\(r_i &lt;0\)</span>或者 <span class="math inline">\(c_j &lt; 0\)</span>，那么选择 <spanclass="math inline">\(i\)</span> 行或 <spanclass="math inline">\(j\)</span> 列一定不优，可以直接无视。</p><p>选择 <span class="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的收益为 <spanclass="math inline">\(r_i + c_j -a_{i,j}\)</span>。由于可以选择任意多行和列，那么一个思路就是先选择所有大于等于<span class="math inline">\(0\)</span> 的 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span>，再减去重复的 <spanclass="math inline">\(a_{i,j}\)</span>。但是如果 <spanclass="math inline">\(a_{i,j} &lt; 0\)</span>，就不能选择 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span>。</p><p>考虑最小割。</p><p>将行作为左部点，列作为右部点。若 <span class="math inline">\(r_i \ge0\)</span>。从源点向左部点 <span class="math inline">\(i\)</span>连容量为 <span class="math inline">\(r_i\)</span> 边；若 <spanclass="math inline">\(c_j \ge 0\)</span>，从右部点 <spanclass="math inline">\(j\)</span> 向汇点连容量为 <spanclass="math inline">\(c_j\)</span> 的边。</p><p>对于 <span class="math inline">\(a_{i,j} \ge 0\)</span>，从 <spanclass="math inline">\(i\)</span> 向 <spanclass="math inline">\(j\)</span> 连容量为 <spanclass="math inline">\(a_{i,j}\)</span> 的边。对于 <spanclass="math inline">\(a_{i,j} &lt; 0\)</span>，从 <spanclass="math inline">\(i\)</span> 向 <spanclass="math inline">\(j\)</span> 连容量为 <spanclass="math inline">\(\infty\)</span> 的边。</p><p>在删去最小割的网络中，<span class="math inline">\(S\)</span> 与 <spanclass="math inline">\(T\)</span> 不连通，且容量为 <spanclass="math inline">\(\infty\)</span>的边一定仍然存在。也就是说，对于容量为 <spanclass="math inline">\(a_{i,j}\)</span> 的边 <spanclass="math inline">\((i,j)\)</span>，由于 <spanclass="math inline">\(r_i\)</span> 与 <spanclass="math inline">\(c_j\)</span> 都大于等于 <spanclass="math inline">\(0\)</span>，要么是 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span> 其中一个被删去，要么是 <spanclass="math inline">\(a_{i,j}\)</span> 被删去。对于容量为 <spanclass="math inline">\(\infty\)</span> 的边 <spanclass="math inline">\((i,j)\)</span>，一定是 <spanclass="math inline">\(r_i\)</span> 或者 <spanclass="math inline">\(c_j\)</span> 其中一个或者两个都被删去。</p><p>用所有大于等于 <span class="math inline">\(0\)</span> 的 <spanclass="math inline">\(r_i\)</span> 和 <spanclass="math inline">\(c_j\)</span>的和减去最小割，就得到了最大收益。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">50005</span>, inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, s, t, a[N][N], d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[M], w[M], nxt[M];<span class="hljs-keyword">int</span> ans, r[N], c[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;d[y]=d[x]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-keyword">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> maxflow=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);<span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();s=<span class="hljs-number">0</span>, t=n+m+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;a[i][j]=<span class="hljs-built_in">read</span>();r[i]+=a[i][j], c[j]+=a[i][j];<span class="hljs-keyword">if</span>(a[i][j]&gt;=<span class="hljs-number">0</span>) <span class="hljs-built_in">addedge</span>(i,j+n,a[i][j]); <span class="hljs-keyword">else</span> <span class="hljs-built_in">addedge</span>(i,j+n,inf);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(r[i]&gt;=<span class="hljs-number">0</span>) &#123;ans+=r[i];<span class="hljs-built_in">addedge</span>(s,i,r[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(c[i]&gt;=<span class="hljs-number">0</span>) &#123;ans+=c[i];<span class="hljs-built_in">addedge</span>(i+n,t,c[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans-<span class="hljs-built_in">dinic</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「网络流 24 题」#1</title>
    <link href="/2022/netflow-24t-1/"/>
    <url>/2022/netflow-24t-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>网络流 24题，很多都是与二分图相关，「能用网络流算法求解」的题目，所以下文叙述时会更多地讨论题目的本质。</p><p>只能说，24 题毕竟也仅仅是比板子要复杂一些，就将就着看个乐呵吧。</p><span id="more"></span><h2 id="luogu2756-飞行员配对方案问题">luogu2756 飞行员配对方案问题</h2><h3 id="分析">分析</h3><p>显然，将英国飞行员和外籍飞行员分别作为二分图的左右节点，一个英国飞行员只能和一个外籍飞行员配合，满足「每个集合内部有<span class="math inline">\(0\)</span> 条边」的 0 要素和「每个点最多与<span class="math inline">\(1\)</span> 条匹配边相连」的 1 要素。</p><p>派出最多的飞机，转化为求这张二分图的最大匹配。</p><p>至于输出方案，最大流算法结束后，有流经过的点和边就是匹配点、匹配边。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, s, t, maxflow, d[N], hh[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;        c=<span class="hljs-built_in">getchar</span>();    &#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dinic</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();    s=n+<span class="hljs-number">1</span>, t=n+<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span>(x!=<span class="hljs-number">-1</span>&amp;&amp;y!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(i,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,i,<span class="hljs-number">0</span>);    n+=<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dinic</span>(s,n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,maxflow);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=m;++x) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(y==s||z) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 由于边容量为 1，所以z!=0绝对没有流经过</span>        <span class="hljs-comment">// 不能是到源点的边</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,x,y);    &#125;&#125;</code></pre></div><h2 id="luogu3254-圆桌问题">luogu3254 圆桌问题</h2><h3 id="分析-1">分析</h3><p>将单位看作左部点，餐桌看作右部点，显然这是一张二分图。</p><p>考虑转化成二分图模型。同一个单位来的代表不能在同一个餐桌就餐，那么餐桌与代表之间两两有一条边。而单位<span class="math inline">\(i\)</span> 派出 <spanclass="math inline">\(r_i\)</span> 个代表，说明它最多与 <spanclass="math inline">\(r_i\)</span> 条匹配边相连，第 <spanclass="math inline">\(j\)</span> 个餐桌能容纳 <spanclass="math inline">\(c_j\)</span> 个代表，说明它最多和 <spanclass="math inline">\(c_j\)</span>条匹配边相连。二分图多重匹配板子。</p><p>解决这个问题，只需要将源点到左部点 <spanclass="math inline">\(i\)</span> 的容量设置成 <spanclass="math inline">\(r_i\)</span>，右部点 <spanclass="math inline">\(j\)</span> 到汇点的容量设置成 <spanclass="math inline">\(c_j\)</span>，跑最大流即可。求出多重匹配后，如果匹配书不等于人数，那么无解。</p><p>输出方案时记得将编号搞到 <span class="math inline">\([1,n]\)</span>之间。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">500</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, s, t, sum, maxflow, d[N], hh[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;        c=<span class="hljs-built_in">getchar</span>();    &#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dinic</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();    s=n+m+<span class="hljs-number">1</span>, t=n+m+<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(s,i,x), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>);        sum+=x;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(i+m,t,x), <span class="hljs-built_in">add</span>(t,i+m,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>+m;j&lt;=n+m;++j)        <span class="hljs-built_in">add</span>(i,j,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(j,i,<span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dinic</span>(s,inf);    <span class="hljs-keyword">if</span>(maxflow!=sum) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=m;++x) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(y!=s&amp;&amp;!z) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,y-m);        &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="luogu2763-试题库问题">luogu2763 试题库问题</h2><h3 id="分析-2">分析</h3><p>类型作为左部点，题目作为右部点。</p><p>要选出 <span class="math inline">\(c_i\)</span> 道类型的题，就是<span class="math inline">\(i\)</span> 最多与 <spanclass="math inline">\(c_i\)</span> 条匹配边相连。</p><p>如果第 <span class="math inline">\(j\)</span> 道题可以属于 <spanclass="math inline">\(p\)</span> 类，对应的点之间连容量为 <spanclass="math inline">\(1\)</span> 的边。</p><p>对于每道题 <span class="math inline">\(j\)</span>，它最多与 <spanclass="math inline">\(1\)</span> 条匹配边相连。</p><p>仍然是多重给匹配，除了建模，其他与上题完全相同。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, k, m, s, t, cnt[N], d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> maxflow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);    <span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    k=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=n+k+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;        m+=cnt[i]=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(s,i,cnt[i]), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">int</span> num=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">while</span>(num--) &#123;            <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();            <span class="hljs-built_in">add</span>(x,i+k,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(i+k,x,<span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(i+k,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,i+k,<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">dinic</span>();    <span class="hljs-keyword">if</span>(ans!=m) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No Solution!&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=k;++x) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: &quot;</span>,x);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(y==s||z) <span class="hljs-keyword">continue</span>;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,y-k);        &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="luogu2764-最小路径覆盖问题">luogu2764 最小路径覆盖问题</h2><p>DAG 最小路径覆盖板子题，具体做法不再赘述，看代码就能懂。</p><p>更大的问题是输出方案。由于在拆点二分图上，路径必定是一个左部点和右部点交替出现。设<span class="math inline">\(p(x)=y-n\)</span>为在最大流（的分层图）中与左部点 <span class="math inline">\(x\)</span>相连的右部点，<span class="math inline">\(q(y-n)=x\)</span> 为与右部点<span class="math inline">\(y\)</span> 相连的左部点。方向都是 <spanclass="math inline">\((x \rightarrowy)\)</span>。由于右部点是左部点拆过去的，平移了 <spanclass="math inline">\(n\)</span> 位，所以要减去 <spanclass="math inline">\(n\)</span>。</p><p>初始的时候，<span class="math inline">\(p(x)=q(x)=i\)</span>。</p><p>对于一个 <span class="math inline">\(x\)</span>，如果 <spanclass="math inline">\(p(x)=x\)</span> 且没有被标记，那么说明 <spanclass="math inline">\(x\)</span> 是一条路径的尽头，直接从 <spanclass="math inline">\(x\)</span> 往前递归输出即可。具体流程如下：</p><ol type="1"><li><span class="math inline">\(x=0\)</span>，结束递归。</li><li><span class="math inline">\(x \neq 0\)</span>，如果 <spanclass="math inline">\(q(x) \neq x\)</span>，那么递归 <spanclass="math inline">\(q(x)\)</span>。</li><li>递归结束后标记 <spanclass="math inline">\(x\)</span>，不再使用。</li><li>输出 <span class="math inline">\(x\)</span>，确保是按照顺序。</li></ol><p>这么做的根据是，对于一张拆点二分图的最大匹配中，其匹配边 <spanclass="math inline">\((x,y+n)\)</span> 对应了原图中的 <spanclass="math inline">\((x,y)\)</span>。如果存在 <spanclass="math inline">\(p(x)=x\)</span>，那么说明 <spanclass="math inline">\((x \rightarrow x+n)\)</span>，即 <spanclass="math inline">\((x \rightarrow x)\)</span>，自环是不被允许的。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000</span>, M=<span class="hljs-number">6666</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, s, t, d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[N*N], nxt[N*N], w[N*N];<span class="hljs-keyword">int</span> p[N], q[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(k&amp;&amp;x!=s&amp;&amp;y!=t) p[x]=y-n, q[y-n]=x;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> maxflow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);    <span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(q[x]!=x) <span class="hljs-built_in">print</span>(q[x]);    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=q[i]=i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(x,y+n,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(y+n,x,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(i+n,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,i+n,<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">dinic</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) <span class="hljs-keyword">if</span>(p[x]==x&amp;&amp;!v[x]) &#123;        <span class="hljs-built_in">print</span>(x), <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-ans);&#125;</code></pre></div><p>输出方案也可以如下（网上复制来的，不做解释）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];~j;j=e[j].next)&#123;        <span class="hljs-keyword">int</span> v=e[j].to;        <span class="hljs-keyword">if</span>(e[j].cap-e[j].flow==<span class="hljs-number">0</span>&amp;&amp;e[j].flow==<span class="hljs-number">1</span>)&#123;            pre[v-n]=i;            lst[i]=v-n;        &#125;        &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;    <span class="hljs-keyword">if</span>(!pre[i])&#123;        <span class="hljs-keyword">int</span> u=i;        <span class="hljs-keyword">while</span>(lst[u]!=<span class="hljs-number">0</span>)&#123;            cout&lt;&lt;u&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;            u=lst[u];        &#125;        cout&lt;&lt;u&lt;&lt;endl;    &#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;</code></pre></div><h2 id="luogu2765-魔术球问题">luogu2765 魔术球问题</h2><h3 id="分析-3">分析</h3><p>要求相邻两个数之和是完全平方数，而数据范围极小，考虑枚举。</p><p>如果将 <span class="math inline">\(x\)</span> 在 <spanclass="math inline">\(y\)</span> 上面，看作 <spanclass="math inline">\((y \rightarrow x)\)</span>的一条边，那么最终一定是一个 DAG。</p><figure><img src="https://cdn.luogu.com.cn/upload/pic/45422.png" srcset="/img/loading.gif" lazyloadalt="图源洛谷，侵删" /><figcaption aria-hidden="true">图源洛谷，侵删</figcaption></figure><p>这样每个柱子实际上代表了一条路径，这些路径两两不相交，要求球数尽可能多，变相地说明对于一定量的球，路径要尽可能少。转化为DAG 的最小路径覆盖问题。</p><p>先预处理平方。从 <span class="math inline">\(1\)</span>开始枚举最大编号，寻找能够放置的球的最大编号。把每个球的编号 <spanclass="math inline">\(x\)</span> 拆成两个点 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(x&#39;\)</span>，分为左部右部两个集合。</p><p>为了避免重复，规定只能从较小点连到较大点。对于一个数 <spanclass="math inline">\(i^2\)</span>，满足 <span class="math inline">\(i^2&gt; j\)</span> 且 <span class="math inline">\(i^2 - j &lt;j\)</span>，才连边 <span class="math inline">\((i^2 -j,j&#39;)\)</span>，容量为 <span class="math inline">\(1\)</span>。对应DAG 中 <span class="math inline">\((i^2 -j,j)\)</span> 的边。</p><p>然后和源点汇点的边容量也为 <spanclass="math inline">\(1\)</span>，跑最大流。如果最大编号 <spanclass="math inline">\(T - maxflow &gt; n\)</span>，说明需要超过 <spanclass="math inline">\(n\)</span> 个柱子，此时 <spanclass="math inline">\(T-1\)</span> 即为答案。</p><p>然后找最大流经过的路径就行了。</p><h3 id="code-4">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, s, t, ans, d[N], squ[<span class="hljs-number">1145</span>], p[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], hh[N], to[M], nxt[M], w[M];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i];            <span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;            d[y]=d[x]+<span class="hljs-number">1</span>;            q.<span class="hljs-built_in">push</span>(y);            <span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        <span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> maxflow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dfs</span>(s,inf);    <span class="hljs-keyword">return</span> maxflow;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    s=<span class="hljs-number">0</span>, t=<span class="hljs-number">5e4</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;++i) squ[i]=i*i;    <span class="hljs-keyword">int</span> T=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">lower_bound</span>(squ+<span class="hljs-number">1</span>,squ+<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>,T)-squ;        <span class="hljs-comment">// 最小的大于等于T的完全平方数</span>        <span class="hljs-built_in">add</span>(s,T,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(T,s,<span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(T+<span class="hljs-number">1e4</span>,t,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(t,T+<span class="hljs-number">1e4</span>,<span class="hljs-number">0</span>);        <span class="hljs-comment">// n不是点数，不能平移n位</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*k;++i) &#123;            <span class="hljs-keyword">int</span> j=squ[i]-T;            <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;T&gt;j) <span class="hljs-built_in">add</span>(j,T+<span class="hljs-number">1e4</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(T+<span class="hljs-number">1e4</span>,j,<span class="hljs-number">0</span>);        &#125;        ans+=<span class="hljs-built_in">dinic</span>();        <span class="hljs-keyword">if</span>(T-ans&gt;n) <span class="hljs-keyword">break</span>;        ++T;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,--T);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=T;++x) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i];        <span class="hljs-keyword">if</span>(y==s||z) <span class="hljs-keyword">continue</span>;        p[x]=y<span class="hljs-number">-1e4</span>; <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 标记</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=T;++x) &#123;        <span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=x;k;k=p[k]) &#123;            v[k]=<span class="hljs-number">1</span>;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,k);        &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="luogu4014-分配问题">luogu4014 分配问题</h2><h3 id="分析-4">分析</h3><p>跑一边最小费用最大流，再跑一边最大费用最大流。</p><h3 id="code-5">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">4</span>*N*N;<span class="hljs-keyword">const</span> ll inf=<span class="hljs-number">0x7fffffff</span>;<span class="hljs-keyword">int</span> n, m, s, t, a[N][N], hh[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M], nxt[M], w[M], cst[M];ll maxcost, mincost, d[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z,<span class="hljs-keyword">int</span> cost)</span> </span>&#123;    to[++tot]=y, w[tot]=z, cst[tot]=cost, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SPFA1</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;++i) d[i]=inf, v[i]=<span class="hljs-number">0</span>;    d[s]=<span class="hljs-number">0</span>, v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        v[x]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i], cost=cst[i];            <span class="hljs-keyword">if</span>(!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(d[y]&gt;d[x]+cost) &#123;                d[y]=d[x]+cost;                <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> d[t]!=inf;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SPFA2</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;++i) d[i]=-inf, v[i]=<span class="hljs-number">0</span>;    d[s]=<span class="hljs-number">0</span>, v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        v[x]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i], cost=cst[i];            <span class="hljs-keyword">if</span>(!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(d[y]&lt;d[x]+cost) &#123;                d[y]=d[x]+cost;                <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> d[t]!=-inf;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;     v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i], cost=cst[i];        <span class="hljs-keyword">if</span>(v[y]||!z||d[y]!=d[x]+cost) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    v[x]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fg)</span> </span>&#123;    <span class="hljs-keyword">while</span>(fg? <span class="hljs-built_in">SPFA1</span>():<span class="hljs-built_in">SPFA2</span>()) &#123;        <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));        <span class="hljs-comment">// mincost+=dfs(s,inf)*d[t];</span>        fg? mincost+=<span class="hljs-built_in">dfs</span>(s,inf)*d[t]:maxcost+=<span class="hljs-built_in">dfs</span>(s,inf)*d[t];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(h));    tot=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i+n,t,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(t,i+n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)        <span class="hljs-built_in">add</span>(i,j+n,<span class="hljs-number">1</span>,a[i][j]), <span class="hljs-built_in">add</span>(j+n,i,<span class="hljs-number">0</span>,-a[i][j]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;        <span class="hljs-keyword">int</span> x=a[i][j]=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(i,j+n,<span class="hljs-number">1</span>,x), <span class="hljs-built_in">add</span>(j+n,i,<span class="hljs-number">0</span>,-x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">add</span>(s,i,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i,s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(i+n,t,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">add</span>(t,i+n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">dinic</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mincost);    <span class="hljs-built_in">rebuild</span>();    <span class="hljs-built_in">dinic</span>(<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,maxcost);&#125;</code></pre></div><h2 id="luogu2774-方格取数问题">luogu2774 方格取数问题</h2><h3 id="分析-5">分析</h3><p>按照格点横纵坐标相加的奇偶性，构造二分图。由于所有格子中的数都是正数，任意两个取出的数所在的格子没有公共边，等价于先强制选择所有格子，然后删去最小的一批有冲突的格子。</p><p>最小割。</p><p>源点连向所有奇数点，容量为这个格点的数字，表示删去这个格子的代价。所有偶数点连向汇点，容量为这个格点的数字，表示删去这个格子的代价。</p><p>对于一个奇数格点，与它冲突的格点为它上下左右的偶数格点。将奇数个点与偶数个点之间连容量为<span class="math inline">\(\infty\)</span>的边。表示这两个节点互斥。</p><p>在最小割中，一定不包含边权为 <spanclass="math inline">\(\infty\)</span>的边，也就是一定没有从互斥格点取数。删掉最小割之后，网络就不连通了，说明删去的都是格点，从而一定不包含所有有冲突的格点。否则由于这两个互斥的点之间的权值为<span class="math inline">\(\infty\)</span>的边仍然存在，图是连通的。矛盾。</p><h3 id="code-6">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> n, m, s, t, d[N*N], hh[<span class="hljs-number">2</span>*N*N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[<span class="hljs-number">2</span>*N*N], to[<span class="hljs-number">4</span>*N*N], nxt[<span class="hljs-number">4</span>*N*N], w[<span class="hljs-number">4</span>*N*N];ll sum;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;q.<span class="hljs-built_in">push</span>(y);d[y]=d[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;<span class="hljs-keyword">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));<span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;<span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x<span class="hljs-number">-1</span>)*m+y; &#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;    ll maxflow=<span class="hljs-number">0</span>, flow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">dfs</span>(s,inf)) maxflow+=flow;    <span class="hljs-keyword">return</span> maxflow;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    s=<span class="hljs-number">0</span>, t=n*m+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;        <span class="hljs-keyword">int</span> awa=<span class="hljs-built_in">read</span>();        sum+=awa;        <span class="hljs-keyword">if</span>((i+j)&amp;<span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">add</span>(s,<span class="hljs-built_in">id</span>(i,j),awa), <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j),s,<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k) &#123;                <span class="hljs-keyword">int</span> x=i+dx[k], y=j+dy[k];                <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="hljs-number">0</span>&amp;&amp;y&lt;=m) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j),<span class="hljs-built_in">id</span>(x,y),inf), <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(x,y),<span class="hljs-built_in">id</span>(i,j),<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j),t,awa), <span class="hljs-built_in">add</span>(t,<span class="hljs-built_in">id</span>(i,j),<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sum-<span class="hljs-built_in">dinic</span>());    <span class="hljs-comment">// 总量-最小割=最大收益</span>&#125;</code></pre></div><h2 id="luogu2045-方格取数加强版k-方格取数">luogu2045 方格取数加强版（K方格取数）</h2><h3 id="分析-6">分析</h3><p>其实这题不属于网络流 24 题，但是也挺有启发意义的，顺带讲了吧。</p><p>看起来和上题很像，实际上很多性质都不同。比如本题中就无法直接构造出一张二分图，也不能用上题的删点方法。</p><p>当 <span class="math inline">\(k=1\)</span> 时，那么将 <spanclass="math inline">\((i,j)\)</span> 作为节点，有一个点权 <spanclass="math inline">\(a_{i,j}\)</span>，向 <spanclass="math inline">\((i+1,j)\)</span> 和 <spanclass="math inline">\((i,j+1)\)</span> 连边。答案为 <spanclass="math inline">\((1,1)\)</span> 到 <spanclass="math inline">\((n,n)\)</span> 的点权最长路。</p><p>当 <span class="math inline">\(k&gt;0\)</span> 时，一共走 <spanclass="math inline">\(k\)</span> 次，那么对于节点 <spanclass="math inline">\((i,j)\)</span>，只有第一次走过时有收益，剩下 <spanclass="math inline">\(k-1\)</span> 次收益均为 <spanclass="math inline">\(0\)</span>。从 <spanclass="math inline">\((i,j)\)</span> 出发，最多可以向 <spanclass="math inline">\((i+1,j)\)</span> 和 <spanclass="math inline">\((i,j+1)\)</span> 分别走 <spanclass="math inline">\(k\)</span> 次。为了保证路径数量是 <spanclass="math inline">\(k\)</span>，可以把“走过的次数”看作容量，收益看作费用，这样就有了一个费用流模型的雏形。</p><p>但是，权值是点权，无法直接做。这就要使用一种名为「点转化边」的Trick。</p><p>将 <span class="math inline">\((i,j)\)</span> 拆成入点 <spanclass="math inline">\((i,j,0)\)</span> 和出点 <spanclass="math inline">\((i,j,1)\)</span>，连边，入点和出点之间的权值（费用）等于原来的点权，容量为能够经过的次数。具体地，费用为<span class="math inline">\(a_{i,j}\)</span>，容量为 <spanclass="math inline">\(1\)</span>；费用为 <spanclass="math inline">\(0\)</span>，容量为 <spanclass="math inline">\(k-1\)</span>。</p><p>然后从出点 <span class="math inline">\((i,j,1)\)</span> 向 <spanclass="math inline">\((i+1,j,0)\)</span> 和 <spanclass="math inline">\((i,j+1,0)\)</span> 连边，权值（费用）为 <spanclass="math inline">\(0\)</span>，容量为 <spanclass="math inline">\(k\)</span>。</p><p>下图描述了 <span class="math inline">\((x \rightarrow y \rightarrowz)\)</span>，点权分别为 <span class="math inline">\(1\)</span>，<spanclass="math inline">\(2\)</span>，<span class="math inline">\(3\)</span>的情况。</p><p><img src="https://s2.loli.net/2022/07/11/KIC3xAbdmnRL95H.png" srcset="/img/loading.gif" lazyload /></p><p>最大化权值和（总费用），最大费用最大流。</p><p>注意给节点编号，并且点转化边之后节点总量为 <spanclass="math inline">\(2 n^2\)</span>。</p><h3 id="code-7">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>, M=<span class="hljs-number">200005</span>, inf=<span class="hljs-number">0x7fffffff</span>;<span class="hljs-keyword">int</span> n, k, s, t, hh[N], d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M], nxt[M], w[M], cst[M];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">return</span> (i<span class="hljs-number">-1</span>)*n+j+k*n*n;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z,<span class="hljs-keyword">int</span> cost)</span> </span>&#123;to[++tot]=y, w[tot]=z, cst[tot]=cost, nxt[tot]=h[x], h[x]=tot;to[++tot]=x, w[tot]=<span class="hljs-number">0</span>, cst[tot]=-cost, nxt[tot]=h[y], h[y]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n*n;++i) d[i]=-inf/<span class="hljs-number">2</span>, v[i]=<span class="hljs-number">0</span>;    d[s]=<span class="hljs-number">0</span>, v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        hh[x]=h[x];        v[x]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=to[i], z=w[i], cost=cst[i];            <span class="hljs-keyword">if</span>(!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(d[y]&lt;d[x]+cost) &#123;                d[y]=d[x]+cost;                <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> d[t]!=-inf/<span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-keyword">int</span> res=flow;    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i], z=w[i], cost=cst[i];        <span class="hljs-keyword">if</span>(v[y]||!z||d[y]!=d[x]+cost) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dfs</span>(y,<span class="hljs-built_in">min</span>(res,z));        w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;    &#125;    v[x]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> flow-res;&#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v)), ans+=<span class="hljs-built_in">dfs</span>(s,inf)*d[t];<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();s=<span class="hljs-number">1</span>, t=<span class="hljs-number">2</span>*n*n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">0</span>),<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,x);<span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">0</span>),<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),k<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(i&lt;n) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-built_in">id</span>(i+<span class="hljs-number">1</span>,j,<span class="hljs-number">0</span>),k,<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(j&lt;n) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-built_in">id</span>(i,j+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),k,<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dinic</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最大流</tag>
      
      <tag>最小割</tag>
      
      <tag>二分图</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1542D Priority Queue</title>
    <link href="/2022/cf1542d-solution/"/>
    <url>/2022/cf1542d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>大佬们都说是显然题，套路题，可是我一开始连这是个 DP 都想不到qwq。</p><p>状态数量太多，要求的值是所有状态的和，那么可以尝试统计贡献。</p><span id="more"></span><p><span class="math inline">\(b\)</span> 是 <spanclass="math inline">\(a\)</span>的子序列，说白了就是，对于每一个操作，都能选，或者不选。那么可以对于每一个元素计算能够让它保留到最后的方案数，从而统计贡献。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为在当前基准的一个下标<span class="math inline">\(p\)</span> 之下，考虑了前 <spanclass="math inline">\(i\)</span> 个操作，其中有 <spanclass="math inline">\(j\)</span> 个元素小于 <spanclass="math inline">\(a_p\)</span> 的方案数。</p><p>如果第 <span class="math inline">\(i\)</span>个操作是删除，那么由于选不选都可以，转移为 <span class="math display">\[f(i,j) = f(i-1,j) + f(i-1,j+1)\]</span> 前者为不选，后者为选。</p><p>特别地，当 <span class="math inline">\(i &lt; p\)</span> 并且 <spanclass="math inline">\(j=0\)</span> 时，要再加上 <spanclass="math inline">\(f(i-1,j)\)</span>，一种表示一直过来都没选，这次选但是什么也不做。另一种是选了但是删没了。</p><p>当第 <span class="math inline">\(i\)</span>个操作是加入，那么也可以选或不选。</p><p>当 <span class="math inline">\(a_i &lt; a_p\)</span> 时 <spanclass="math display">\[f(i,j) = f(i-1,j) + f(i-1,j-1)\]</span> 当 <span class="math inline">\(a_i &gt; a_p\)</span>时，选不选都不会改变 <span class="math display">\[f(i,j)= f(i-1,j) + f(i-1,j)\]</span> 特别的，如果 <span class="math inline">\(a_i =a_p\)</span>，那么当 <span class="math inline">\(i&lt; p\)</span>时，放到第一种转移，当 <span class="math inline">\(i&gt;p\)</span>时，放到第二种转移。</p><p>特别地，当 <span class="math inline">\(i=p\)</span> 时，直接将 <spanclass="math inline">\(i-1\)</span> 的状态转移到 <spanclass="math inline">\(i\)</span>，因为必须选择。</p><p>最后累加 <span class="math display">\[\sum_{i=0}^n f(n,i)\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, a[N];<span class="hljs-keyword">char</span> s[N];ll f[N][N], ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;s[i]);<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>) a[i]=<span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;p&lt;=n;++p) &#123;<span class="hljs-keyword">int</span> x=a[p];<span class="hljs-keyword">if</span>(!~x) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(p==i) &#123; <span class="hljs-built_in">memcpy</span>(f[i],f[i<span class="hljs-number">-1</span>],<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f[i])); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(!~a[i]) &#123;f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>])%mod;<span class="hljs-keyword">if</span>(i&lt;p&amp;&amp;!j) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j])%=mod;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]&lt;x||((a[i]==x&amp;&amp;i&lt;p))) &#123;f[i][j]=f[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">if</span>(j) (f[i][j]+=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%=mod;&#125; <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>][j]%mod;&#125;&#125;ll sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) (sum+=f[n][i])%=mod;(ans+=sum*x%mod)%=mod;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1540B Tree Array 题解</title>
    <link href="/2022/cf1540b-solution/"/>
    <url>/2022/cf1540b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>逆序对是由两个元素构成的，所以对于逆序对的期望个数，可以看作是每一个数对能够成为逆序对的期望的和。</p><p>直接做很不可做，而每个逆序对只与两个数有关，一般这时候就要考虑计算贡献了。</p><span id="more"></span><p>由于是在树上操作，而所有操作都要跟在第一次标记后面，且根是不固定的，所以可以枚举每一个点作为根的情况，求出所有情况的和之后再乘<span class="math inline">\(\frac{1}{n}\)</span> 就好了。</p><p>考虑 <span class="math inline">\((i,j)\)</span>，其中 <spanclass="math inline">\(i &lt;j\)</span>，什么时候能够成为逆序对。显然，当且仅当 <spanclass="math inline">\(i\)</span> 在 <spanclass="math inline">\(j\)</span>之后被标记，这个期望是多少呢？由于规定了根，而后续的操作必然是不断由根向下标记，也就是说，当<span class="math inline">\(lca(i,j)\)</span>没有被标记的时候，两点被标记的概率都为 <spanclass="math inline">\(0\)</span>。而当 <spanclass="math inline">\(lca(i,j)\)</span>被标记后，才能不断向两点所在位置扩充。</p><p>要在 <span class="math inline">\(lca(i,j)\)</span>被标记之后这个局面求 <span class="math inline">\(i\)</span> 在 <spanclass="math inline">\(j\)</span> 之后被标记的概率（权值是 <spanclass="math inline">\(1\)</span>），才能算出对答案有贡献的期望。而其他局面的概率全部为<span class="math inline">\(0\)</span>，进而期望全部为 <spanclass="math inline">\(0\)</span>。考虑到每次的根是不固定的，但是对于到<span class="math inline">\(lca\)</span>距离相同的点对，产生逆序对的概率则是一样的，所以要如下设计状态。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为在某对点的 <spanclass="math inline">\(lca\)</span> 被标记后，到 <spanclass="math inline">\(lca\)</span> 距离为 <spanclass="math inline">\(i\)</span> 的点在到 <spanclass="math inline">\(lca\)</span> 距离为 <spanclass="math inline">\(j\)</span>的点之前被标记，所能贡献的期望逆序对个数。 <span class="math display">\[f(i,j) = 1 \cdot \frac{f(i-1,j)+f(i,j-1)}{2}\]</span> 当然这个 <span class="math inline">\(1\)</span>也可以省略，那么某种意义上说 <span class="math inline">\(f(i,j)\)</span>表示的也是概率……</p><p>可以 <span class="math inline">\(O(n^2)\)</span> 预处理。</p><p>当以 <span class="math inline">\(i\)</span> 为根时，预处理查找 <spanclass="math inline">\(lca\)</span> 的倍增数组，然后 <spanclass="math inline">\(O(n^2)\)</span> 枚举点对，累加期望即可。</p><p>最后乘 <span class="math inline">\(\frac{1}{n}\)</span>。</p><p>复杂度 <span class="math inline">\(O(n^3 \log_2n)\)</span>，官方题解说可以做到 <spanclass="math inline">\(O(n^3)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>;<span class="hljs-keyword">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, inv2=(<span class="hljs-number">1e9</span>+<span class="hljs-number">8</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> n, dep[N], fa[N][<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];ll ans, f[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    to[++tot]=y, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;    ll ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%mod,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) ans=ans*x%mod;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    fa[x][<span class="hljs-number">0</span>]=fr, dep[x]=dep[fr]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;++i) fa[x][i]=fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fr) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">8</span>;~i;--i) <span class="hljs-keyword">if</span>(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">8</span>;~i;--i) <span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i], y=fa[y][i];    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1ll</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)        f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i][j<span class="hljs-number">-1</span>])*inv2%mod;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;j;++k) &#123;            <span class="hljs-keyword">int</span> l=<span class="hljs-built_in">lca</span>(j,k);            (ans+=f[dep[j]-dep[l]][dep[k]-dep[l]])%=mod;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans*<span class="hljs-built_in">fp</span>(n,mod<span class="hljs-number">-2</span>)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Edu Codeforces Round」#131 (Div.2)</title>
    <link href="/2022/cf1701-solution/"/>
    <url>/2022/cf1701-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1701</strong>.</p><h2 id="a.-grass-field">A. Grass Field</h2><h3 id="分析">分析</h3><p>有 <span class="math inline">\(0\)</span> 个草地，答案为 <spanclass="math inline">\(0\)</span>。</p><p>有 <span class="math inline">\(1 \sim 3\)</span> 个草地，答案为 <spanclass="math inline">\(1\)</span>。</p><p>有 <span class="math inline">\(4\)</span> 个草地，答案为 <spanclass="math inline">\(2\)</span>。</p><span id="more"></span><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">int</span> t, a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;++j) a[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> cnt0=<span class="hljs-number">0</span>, cnt1=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;++j) &#123;<span class="hljs-keyword">if</span>(a[i][j]) ++cnt1; <span class="hljs-keyword">else</span> ++cnt0;&#125;<span class="hljs-keyword">if</span>(!cnt1) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt1&lt;<span class="hljs-number">4</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="b.-permutation">B. Permutation</h2><h3 id="分析-1">分析</h3><p>对于区间 <span class="math inline">\([1,n]\)</span>，其中 <spanclass="math inline">\(n \neq 1\)</span>，那么当 <spanclass="math inline">\(d = 2\)</span>的时候，成倍数关系的数对是最多的。直接输出 <spanclass="math inline">\(2\)</span> 即可。</p><p>然后先把所有 <span class="math inline">\(1\)</span> 和 <spanclass="math inline">\([2,n]\)</span>之间的所有偶数加入排列，并把每个加入排列的数打标记。之后对于每个没有被打标记的数，用类似埃氏筛的方式筛去它和它的<span class="math inline">\(2\)</span> 次幂倍并加入排列。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, cnt, n, p[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2\n&quot;</span>);<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i&lt;&lt;=<span class="hljs-number">1</span>) v[i]=<span class="hljs-number">1</span>, p[++cnt]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(!v[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j&lt;&lt;=<span class="hljs-number">1</span>) v[j]=<span class="hljs-number">1</span>, p[++cnt]=j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,p[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="c.-schedule-management">C. Schedule Management</h2><h3 id="分析-2">分析</h3><p>工人工作是同时进行的，不论是贪心还是 DP 都做不了，我还是太弱了……</p><p>二分答案转判定，明明想到了的，却没写出来……</p><p>二分一个 <span class="math inline">\(mid\)</span>，表示用 <spanclass="math inline">\(mid\)</span> 小时能否完成 <spanclass="math inline">\(m\)</span>个任务。对于每个工人，所有任务只有两种类型：精通的和不精通的。所以一个很显然的贪心策略就是，每一个任务都优先让精通它的工人去完成。记录<span class="math inline">\(cnt_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个工人精通的任务数量。</p><p>当 <span class="math inline">\(cnt_i &lt; mid\)</span> 时，<spanclass="math inline">\(i\)</span> 不仅能够用 <spanclass="math inline">\(cnt_i\)</span>小时完成所有精通的任务，还有时间完成其他的任务，可是其他的任务只能用<span class="math inline">\(\frac{1}{2}\)</span>的效率来完成，所以这种情况下一共能完成的任务数量为 <spanclass="math inline">\(cnt_i + \frac{mid - cnt_i}{2}\)</span>。</p><p>否则只能够完成 <span class="math inline">\(cnt_i\)</span>个任务。</p><p>是不是一想就明白了呢？我还是趁早退役咯~</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, m, a[N], cnt[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;ll tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(cnt[i]&lt;x) tot+=cnt[i]+(x-cnt[i])/<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> tot+=x;&#125;<span class="hljs-keyword">return</span> tot&gt;=m;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(cnt));n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) ++cnt[a[i]=<span class="hljs-built_in">read</span>()];<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) r=<span class="hljs-built_in">max</span>(r,cnt[i]*<span class="hljs-number">2</span>);<span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-permutation-restoration">D. Permutation Restoration</h2><h3 id="分析-3">分析</h3><p>下文除法均向下取整。</p><p>对于每个 <spanclass="math inline">\(b_i\)</span>，都有一个「决策区间」。意思是，只要<span class="math inline">\(a_i\)</span>属于这个区间，那么就一定满足条件。</p><p>考虑求出这个区间，当 <span class="math inline">\(b_i\)</span> 为<span class="math inline">\(0\)</span> 的时候，只需要保证 <spanclass="math inline">\(i &lt; a_i\)</span> 就好了，所以决策区间的左端点是<span class="math inline">\(i+1\)</span>，右端点一定是 <spanclass="math inline">\(n\)</span>。</p><p>当 <span class="math inline">\(b_i &gt; 0\)</span>时，其左右端点一定在 <span class="math inline">\([1,i]\)</span>里面，那就查找最小的使得 <span class="math inline">\(\frac{i}{x} \leb_i\)</span> 的 <span class="math inline">\(x\)</span> 作为做端点（因为<span class="math inline">\(x\)</span> 越小左式越大），查找最大的使得<span class="math inline">\(\frac{i}{x} \ge b_i\)</span> 的 <spanclass="math inline">\(x\)</span> 作为右端点（因为 <spanclass="math inline">\(x\)</span> 越大左式越小）。可以使用二分查找。</p><p>打表发现，如果 <span class="math inline">\(b_i &gt;0\)</span>，那么左端点为 <span class="math inline">\(\frac{i}{b_i +1}+1\)</span>，右端点为 <spanclass="math inline">\(\frac{i}{b_i}\)</span>。证明？不会。</p><p>然后贪心，对于一个 <spanclass="math inline">\(i\)</span>，将所有以它为左端点的元素加入决策集合，排除所有右端点小于<span class="math inline">\(i\)</span> 的元素，找到右端点最小的 <spanclass="math inline">\(x\)</span> 并令 <span class="math inline">\(a_x =i\)</span>。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fst first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sec second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, m, b[N], d[N], ans[N];priority_queue&lt;PII &gt; q;vector&lt;<span class="hljs-keyword">int</span>&gt; v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span>&amp; l,<span class="hljs-keyword">int</span>&amp; r)</span> </span>&#123;<span class="hljs-keyword">int</span> L=a, R=b;<span class="hljs-keyword">while</span>(L&lt;R) &#123;<span class="hljs-keyword">int</span> mid=(L+R)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(b/mid&lt;=x) R=mid; <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>; &#125;l=L;L=a, R=b;<span class="hljs-keyword">while</span>(L&lt;R) &#123;<span class="hljs-keyword">int</span> mid=(L+R+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(b/mid&gt;=x) L=mid; <span class="hljs-keyword">else</span> R=mid<span class="hljs-number">-1</span>;&#125;r=L;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> l, r;<span class="hljs-keyword">if</span>(!b[i]) &#123; l=i+<span class="hljs-number">1</span>, r=n; <span class="hljs-keyword">goto</span> record; &#125;<span class="hljs-comment">// bsearch(1,i,b[i],l,r);</span>l=i/(b[i]+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>, r=i/b[i];record: v[l].<span class="hljs-built_in">pb</span>(i), d[i]=r;<span class="hljs-comment">// printf(&quot;b[%d]=%d l: %d r: %d\n&quot;,i,b[i],l,r);</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();++j)q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-d[v[i][j]],v[i][j]));<span class="hljs-keyword">if</span>(-q.<span class="hljs-built_in">top</span>().fst&lt;i) q.<span class="hljs-built_in">pop</span>();ans[q.<span class="hljs-built_in">top</span>().sec]=i, q.<span class="hljs-built_in">pop</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]), v[i].<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-text-editor">E. Text Editor</h2><p>没看，不会。</p><h2 id="f.-points">F. Points</h2><p>没看，不会。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>Codeforces</tag>
      
      <tag>贪心</tag>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1271D Portals 题解</title>
    <link href="/2022/cf1271d-solution/"/>
    <url>/2022/cf1271d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>不难发现，对于一个城堡，早驻守不如晚驻守。因为驻守早了完全没有额外收益，驻守晚了也没有额外代价。所以对于每个城堡<span class="math inline">\(x\)</span>，记录 <spanclass="math inline">\(d(x)\)</span> 为 <spanclass="math inline">\(x\)</span>的最晚可控制时间。也就是它必须在哪一个城堡被攻下之前，必须派兵驻守。特别的，如果某个城堡是独立的，令这个时间为它自身的编号。</p><span id="more"></span><p>设 <span class="math inline">\(f(i,j)\)</span> 为已经攻下了前 <spanclass="math inline">\(i\)</span> 个城堡，攻打第 <spanclass="math inline">\(i\)</span> 个城堡之后还剩下 <spanclass="math inline">\(j\)</span> 个人，所能获得的最大收益。对于 <spanclass="math inline">\(i=0\)</span> 的所有状态，它们的初始值为0，其余为负无穷。</p><p>设 <span class="math inline">\(A=\max_{i=1}^n{ \{ a_i\}}\)</span>，<span class="math inline">\(B=\max_{i=1}^n{\{ b_i\}}\)</span>。</p><p>对于攻打城堡，就像背包问题一样 <span class="math display">\[f(i,j+b_i) = \max_{j \in [a_i,A+B]}{\{ f(i-1,j) \}}\]</span> 对于派兵驻守，则是要贪心地按照 <spanclass="math inline">\(d(x)\)</span>递增的顺序来求解。排序后，已经驻守过的城堡不需要再次驻守，所以维护一个指针<span class="math inline">\(pos\)</span>，每驻守一个，<spanclass="math inline">\(pos+1\)</span>，驻守的时间 <spanclass="math inline">\(x\)</span> 的时间必须是 <spanclass="math inline">\(d(x)\)</span>。转移也是很简单的 <spanclass="math display">\[f(i,j) = \max_{j \in [0,A+B-1]}{\{ f(i,j+1) + c_{pos} \}}\]</span> 答案就是 <span class="math inline">\(\max_{i \in [0,A+B]}{\{f(n,i) \}}\)</span>。</p><p>大佬们都说这题比较简单，可是蒟蒻我感觉并不那么容易。首先虽然容易想到是以「占领的城堡数」和「人数」为状态的内容，但是由于它涉及2种转移，边界处理和转移顺序较为麻烦，所以使用了填表法和刷表法混用的方式。</p><p>第一种转移应当先于第二种转移，因为前者完成之后，后者以来的状态已经计算完毕。尽管第二种转移实质上也是0/1 背包（每个城堡占领不占领），但是 <spanclass="math inline">\(j\)</span> 依赖 <spanclass="math inline">\(j+1\)</span>的状态，所以倒序循环是错的，只能通过用另一种转移来计算。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> n, m, k, a[N], b[N], c[N], d[N];ll f[N][N];pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> B=<span class="hljs-number">0</span>;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>(), c[i]=<span class="hljs-built_in">read</span>();        d[i]=i;        B+=b[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        d[y]=<span class="hljs-built_in">max</span>(d[y],x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) p[i]=<span class="hljs-built_in">make_pair</span>(d[i],c[i]);    <span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x7f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=a[i];j&lt;=k+B;++j)            <span class="hljs-keyword">if</span>(j+b[i]&lt;=k+B) f[i][j+b[i]]=<span class="hljs-built_in">max</span>(f[i][j+b[i]],f[i<span class="hljs-number">-1</span>][j]);        <span class="hljs-keyword">while</span>(pos&lt;=n&amp;&amp;p[pos].first==i) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k+B;++j) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][j+<span class="hljs-number">1</span>]+p[pos].second);            ++pos;        &#125;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k+B;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图匹配简单题 题解</title>
    <link href="/2022/graph-solution-1/"/>
    <url>/2022/graph-solution-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>写一下近期写的简单二分图题目的题解。</p><span id="more"></span><h2 id="luogu3967-匹配">luogu3967 匹配</h2><h3 id="分析">分析</h3><p><span class="math inline">\(TJOI\)</span> 板子题 <spanclass="math inline">\(\times 1\)</span>。</p><p>找出所有完美匹配的交集，意思是无论任何完美匹配都包含这些边，反过来，如果没有这些边中任意一边，都不存在完美匹配。</p><p>由于数据范围小，直接用 DFS 版的 <spanclass="math inline">\(KM\)</span>算法求出带权最大匹配。然后枚举每一条匹配边， 把它的边权置为 <spanclass="math inline">\(0\)</span>，表示删去它。如果此时求出的带权最大匹配小于之前求出的带权最大匹配，那么这条边就是必须包含的边。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">150</span>, inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<span class="hljs-keyword">int</span> n, dlt, match[N], t[N], w[N][N], la[N], lb[N], slack[N];ll Ans;<span class="hljs-keyword">bool</span> va[N], vb[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> x, y; &#125; p[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;va[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;y&lt;=n;++y) <span class="hljs-keyword">if</span>(!vb[y]) &#123;<span class="hljs-keyword">if</span>(la[x]+lb[y]==w[x][y]) &#123;vb[y]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) &#123;match[y]=x; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> slack[y]=<span class="hljs-built_in">min</span>(slack[y],la[x]+lb[y]-w[x][y]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">KM</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;la[i]=-inf, lb[i]=<span class="hljs-number">0</span>;match[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) la[i]=<span class="hljs-built_in">max</span>(la[i],w[i][j]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">memset</span>(va,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(va)), <span class="hljs-built_in">memset</span>(vb,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vb));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) slack[j]=inf;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">break</span>;dlt=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!vb[j]) dlt=<span class="hljs-built_in">min</span>(dlt,slack[j]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(va[j]) la[j]-=dlt;<span class="hljs-keyword">if</span>(vb[j]) lb[j]+=dlt;&#125;&#125;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=la[i]+lb[i];<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i][j]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,Ans=<span class="hljs-built_in">KM</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) t[i]=match[i];    <span class="hljs-comment">// match在之后的KM算法中要被修改，所以记录原来的匹配边，</span><span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=t[i], y=i, d=w[x][y];w[x][y]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">KM</span>()&lt;Ans) &#123;p[++tot].x=x, p[tot].y=y;&#125;w[x][y]=d;&#125;<span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+tot+<span class="hljs-number">1</span>);    <span class="hljs-comment">// 要求排序再输出</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,p[i].x,p[i].y);&#125;</code></pre></div><h2 id="luogu4304-攻击装置">luogu4304 攻击装置</h2><h3 id="分析-1">分析</h3><p><span class="math inline">\(TJOI\)</span> 板子题 <spanclass="math inline">\(\times 2\)</span>。这个貌似和网络流 24题中的骑士共存问题很想，不是那么板，但是只要会跑最大匹配就能过。</p><p>首先观察这个东西的攻击范围，不难发现，对于 <spanclass="math inline">\((x,y)\)</span>，它能够攻击的点的横纵坐标相加一定与<span class="math inline">\(x+y\)</span>异奇偶。于是乎直接将横纵坐标相加为奇数的看作左部点，偶数的为右部点。为了防止重复计数，钦定如果<span class="math inline">\((x,y)\)</span>为左部点且能够放置，那么由它向能够攻击到的右部点连边。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/1q57l20q.png" srcset="/img/loading.gif" lazyloadalt="借用洛谷题解上的图片，侵删" /><figcaption aria-hidden="true">借用洛谷题解上的图片，侵删</figcaption></figure><p>由于放置的装置不能互相攻击，等价于选出这张二分图的最大独立集。用能够放置的点数减去最大匹配的边数即可。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> T=<span class="hljs-number">205</span>, N=<span class="hljs-number">400005</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, dy[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">int</span> n, m, times, a[T][T], g[T][T], v[N];<span class="hljs-keyword">int</span> tot, match[N], h[N], to[<span class="hljs-number">8</span>*N], nxt[<span class="hljs-number">8</span>*N];<span class="hljs-comment">// 8倍空间</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(v[y]==times) <span class="hljs-keyword">continue</span>;        v[y]=times;        <span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) <span class="hljs-keyword">return</span> match[y]=x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xiongyali</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>((i+j)&amp;<span class="hljs-number">1</span>&amp;&amp;g[i][j]) &#123;        <span class="hljs-comment">// 从左部点 DFS</span>        ++times;        res+=<span class="hljs-built_in">dfs</span>(g[i][j]);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%1d&quot;</span>,&amp;a[i][j]);        <span class="hljs-keyword">if</span>(!a[i][j]) g[i][j]=++m;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)         <span class="hljs-keyword">if</span>(g[i][j]&amp;&amp;(i+j)&amp;<span class="hljs-number">1</span>)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">8</span>;++k) &#123;            <span class="hljs-comment">// 放置重复，只从左部点开始连边</span>            <span class="hljs-keyword">int</span> x=i+dx[k], y=j+dy[k];            <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>&amp;&amp;y&gt;<span class="hljs-number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=n&amp;&amp;g[x][y]) <span class="hljs-built_in">add</span>(g[i][j],g[x][y])；        &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,m-<span class="hljs-built_in">xiongyali</span>());&#125;</code></pre></div><h2 id="luogu3033-cow-steeplechase">luogu3033 Cow Steeplechase</h2><h3 id="分析-2">分析</h3><p>首先两条线段如果平行，那么必定没有交点。那么把竖着的线段作为左部点，横着的线段作为右部点。那么同一个点集内没有边，左部点<span class="math inline">\(i\)</span> 与右部点 <spanclass="math inline">\(j\)</span>最多有一条匹配边，符合二分图匹配模型。</p><p>钦定 <span class="math inline">\(x_{i,1} \le x_{i,2}\)</span>，<spanclass="math inline">\(y_{i,1} \le y_{i,2}\)</span>。</p><p>对于线段 <spanclass="math inline">\((x_{i,1},y_{i,1})\)</span>，<spanclass="math inline">\((x_{i,2},y_{i,2})\)</span> 和 <spanclass="math inline">\((x_{j,1},y_{j,1})\)</span>，<spanclass="math inline">\((x_{j,2},y_{j,2})\)</span>，它们相交的条件是</p><ol type="1"><li><span class="math inline">\(i\)</span> 是竖着的边，<spanclass="math inline">\(j\)</span> 是横着的边。那么要满足 <spanclass="math inline">\(x_{i,1} \ge x_{j,1}\)</span> 且 <spanclass="math inline">\(y_{i,1} \le y_{j,1}\)</span> 且 <spanclass="math inline">\(x_{i,2} \le x_{j,2}\)</span> 且 <spanclass="math inline">\(y_{i,2} \ge y_{j,2}\)</span>。</li><li><span class="math inline">\(i\)</span> 是横着的边，<spanclass="math inline">\(j\)</span>是竖着的边。那么就把上面的符号反过来。</li></ol><p>选出最多的不相交线段，等价于二分图最大独立集。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, x1[N], y11[N], x2[N], y2[N];<span class="hljs-keyword">int</span> tot, match[N], h[N], to[N], nxt[N];<span class="hljs-keyword">bool</span> l[N], v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(v[y]) <span class="hljs-keyword">continue</span>;        v[y]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) <span class="hljs-keyword">return</span> match[y]=x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xiongyali</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(l[i]) &#123;        <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));        res+=<span class="hljs-built_in">dfs</span>(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        x1[i]=<span class="hljs-built_in">read</span>(), y11[i]=<span class="hljs-built_in">read</span>();        x2[i]=<span class="hljs-built_in">read</span>(), y2[i]=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span>(x1[i]&gt;x2[i]) <span class="hljs-built_in">swap</span>(x1[i],x2[i]);        <span class="hljs-keyword">if</span>(y11[i]&gt;y2[i]) <span class="hljs-built_in">swap</span>(y11[i],y2[i]);        <span class="hljs-keyword">if</span>(x1[i]==x2[i]) ++m, l[i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// m是左部点数量，也就是竖着的边</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;        <span class="hljs-keyword">if</span>(l[i]&amp;&amp;!l[j]) &#123;            <span class="hljs-keyword">if</span>(x1[i]&gt;=x1[j]&amp;&amp;y11[i]&lt;=y11[j]&amp;&amp;x2[i]&lt;=x2[j]&amp;&amp;y2[i]&gt;=y2[j])                <span class="hljs-built_in">add</span>(i,j+m);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!l[i]&amp;&amp;l[j]) &#123;            <span class="hljs-keyword">if</span>(x1[i]&lt;=x1[j]&amp;&amp;y11[i]&gt;=y11[j]&amp;&amp;x2[i]&gt;=x2[j]&amp;&amp;y2[i]&lt;=y2[j])                <span class="hljs-built_in">add</span>(j,i+m);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-<span class="hljs-built_in">xiongyali</span>());&#125;</code></pre></div><h2 id="luogu4589-智力竞赛">luogu4589 智力竞赛</h2><h3 id="分析-3">分析</h3><p><span class="math inline">\(TJOI\)</span> 板子题 <spanclass="math inline">\(\times 3\)</span>。</p><p>首先明确，每个人答题顺序一定是一条简单路径，可以有人答相同的题目。而且所有题目构成一个DAG。</p><p>好了，DAG 最小路径可重复点覆盖。</p><p>二分答案，找到一个 <span class="math inline">\(mid\)</span>表示只能回答价值小于 <span class="math inline">\(mid\)</span>的问题。如果求得的路径条数小于 <spanclass="math inline">\(n+1\)</span>（亲友团加上小明），那么说明可行。特别的，如果回答所有问题也能满足条件的话，输出<code>AK</code>。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, T, a[N][N], d[N], match[N], v[N], vis[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;y&lt;=m;++y) <span class="hljs-keyword">if</span>(vis[y]!=T&amp;&amp;a[d[x]][d[y]]) &#123;        vis[y]=T;        <span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) <span class="hljs-keyword">return</span> match[y]=x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) match[i]=d[i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(v[i]&lt;x) d[++cnt]=i;    <span class="hljs-keyword">int</span> ans=cnt;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i)  &#123;        ++T; ans-=<span class="hljs-built_in">dfs</span>(i);    &#125;    <span class="hljs-keyword">return</span> ans&lt;=n+<span class="hljs-number">1</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        r=<span class="hljs-built_in">max</span>(r,v[i]=<span class="hljs-built_in">read</span>()); <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">while</span>(k--) &#123;            <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();            a[i][x]=<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;++k)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)                a[i][j]|=a[i][k]&amp;a[k][j];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(inf)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;AK&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">while</span>(l&lt;r) &#123;        <span class="hljs-keyword">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4042 骑士游戏 题解</title>
    <link href="/2022/lg4042-solution/"/>
    <url>/2022/lg4042-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>好久之前就见过的题，那时候不求甚解地把代码写上，认为自己已经明白了。</p><p>之后经历的那些事情，让我越发怀疑自己对所有东西的认识。经常想起这道题，因为「偷来的AC」，我难以原谅自己。</p><p>不过，这一切都已经过去了。那么差劲的自己，那么单纯的想法。</p><span id="more"></span><p>一年来，相对于大部分人，我的进步实在是太少了。在这个人均初三 D 类 Ag的年代，进队是不要想了。</p><p>我只想，把 OI 当作爱好。正因如此，我永远不会自称为OIer；同时，我也永远不会再为它黯然神伤。</p><h2 id="分析">分析</h2><p>DP。设 <span class="math inline">\(f(i)\)</span> 为杀死怪物 <spanclass="math inline">\(i\)</span>以及它直接或间接生成的怪物的最小代价。</p><p>只有魔法攻击才能杀死怪物，<span class="math inline">\(f(i)\)</span>的初始值为用魔法攻击杀死它的代价。</p><p>由于物理攻击杀死某个怪物后，又会生成很多怪物，而再杀死它们之后，又会再次生成其他怪物。无论怎样设计状态都必定存在环，只能从转移下手。</p><p>把怪物抽象成节点，如果杀死 <span class="math inline">\(x\)</span>生成 <span class="math inline">\(y\)</span>，那么连边 <spanclass="math inline">\((x \rightarrow y)\)</span>。设 <spanclass="math inline">\(ph(x)\)</span> 为用物理攻击杀死 <spanclass="math inline">\(x\)</span> 的代价。</p><p>对于 <span class="math inline">\(x\)</span>，求出用魔法攻击杀死 <spanclass="math inline">\(x\)</span> 与生成的 <spanclass="math inline">\(y\)</span> 的总代价 <spanclass="math inline">\(z\)</span>。</p><p>$$ z=ph(x) + _{(x y)} f(y)</p><p>$$</p><p>转移</p><p><span class="math display">\[f(x) = \min{\{ f(x),z \} }\]</span></p><p>放在 SPFA 的过程中转移即可。</p><p>看着似乎没问题，但是有环图没有拓扑序，没有固定的转移顺序。考虑到 SPFA中的队列，本质上是已经进行完一轮迭代之后，能够用到这些信息且不在队列中的点。那么再本题中就要将依赖于<span class="math inline">\(f(x)\)</span> 的点加入队列，也就是将所有<span class="math inline">\((u \rightarrow x)\)</span> 的 <spanclass="math inline">\(u\)</span> 加入队列。</p><p>方法是建立一张反图，对于杀死 <span class="math inline">\(x\)</span>生成 <span class="math inline">\(y\)</span>，加边 <spanclass="math inline">\((y \rightarrow x)\)</span>，表示 <spanclass="math inline">\(f(x)\)</span> 依赖于 <spanclass="math inline">\(f(y)\)</span>。如果更新了 <spanclass="math inline">\(f(x)\)</span>，将反图中所有从 <spanclass="math inline">\(x\)</span>出发直接到达的点加入队列即可。一开始则要把所有节点加入队列，因为每个点都能够更新其它点。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>; <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> c, h[N], to[N&lt;&lt;<span class="hljs-number">3</span>], nxt[N&lt;&lt;<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> cc, hh[N], ot[N&lt;&lt;<span class="hljs-number">3</span>], txn[N&lt;&lt;<span class="hljs-number">3</span>];ll f[N], ph[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++c]=y, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dda</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ot[++cc]=y, txn[cc]=hh[x], hh[x]=cc; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) q.<span class="hljs-built_in">push</span>(i), v[i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        v[x]=<span class="hljs-number">0</span>;        ll z=ph[x];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) z+=f[to[i]];        <span class="hljs-keyword">if</span>(f[x]&gt;z) &#123;            f[x]=z;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=hh[x];i;i=txn[i]) <span class="hljs-keyword">if</span>(!v[ot[i]]) v[ot[i]]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(ot[i]);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">int</span> x, y;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%d&quot;</span>,&amp;ph[i],&amp;f[i],&amp;x);        <span class="hljs-keyword">while</span>(x--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y), <span class="hljs-built_in">add</span>(i,y), <span class="hljs-built_in">dda</span>(y,i);    &#125;    <span class="hljs-built_in">spfa</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[<span class="hljs-number">1</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1349A Orac and LCM 题解</title>
    <link href="/2022/cf1349a-solution/"/>
    <url>/2022/cf1349a-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p><span class="math display">\[\gcd_{i,j \in [1,n] \text{ and } i&lt; j} \{\operatorname{lcm}(a_i,a_j)  \}\]</span></p><span id="more"></span><p><span class="math display">\[\gcd_{i,j \in [1,n] \text{ and } i &lt; j} \{  \frac{a_i\cdot  a_j}{\gcd(a_i,a_j)} \}\]</span></p><p>两两元素的最大公约数就是整个序列的最大公约数。<spanclass="math inline">\(\gcd(ka,kb)=k \gcd(a,b)\)</span>。 <spanclass="math display">\[\frac{\gcd_{i,j \in [1,n] \text{ and } i &lt; j} \{a_i,a_j \} }{\gcd \{a_1,a_2 \ldots a_n \}}\]</span> 对于 <span class="math inline">\(i \in[1,n]\)</span>，它对分数线上面的式子的贡献是 <spanclass="math inline">\(\gcd(a_i,a_{i+1} \ldotsa_{n})\)</span>，预处理后缀 <span class="math inline">\(\gcd\)</span>即可。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n;ll a[N], d[N];<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> x/<span class="hljs-built_in">gcd</span>(x,y)*y; &#125;<span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;ll a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ll ans=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) d[i]=<span class="hljs-built_in">gcd</span>(a[i],d[i+<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">gcd</span>(ans,a[i]*d[i+<span class="hljs-number">1</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/d[<span class="hljs-number">1</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Codeforces Round」#804 (Div. 2)</title>
    <link href="/2022/cf1699-solution/"/>
    <url>/2022/cf1699-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><strong>CF1699</strong>.</p><h2 id="a.-the-third-three-number-problem">A. The Third Three NumberProblem</h2><h3 id="分析">分析</h3><p>首先判断无解。</p><span id="more"></span><p>异或运算可以看作二进制「不进位加法」，而在二进制加法中，第一位也不会存在进位，所以<span class="math inline">\((a \oplus b) + (b \oplus c) + (a \oplusc)\)</span> 与 $(a+b) + (b + c) + (a + c) = 2(a+b+c) $ 奇偶性相同。所以<span class="math inline">\(n\)</span> 必然是个偶数，当 <spanclass="math inline">\(n\)</span> 为奇数时无解。</p><p>考虑 <span class="math inline">\(a,b,c\)</span> 可以相同且能够取<span class="math inline">\(0\)</span>，而 <span class="math inline">\(0\oplus x = x\)</span>，那么只要取 <spanclass="math inline">\(a=0\)</span>，<spanclass="math inline">\(b=0\)</span>，<span class="math inline">\(c =\frac{n}{2}\)</span> 就能够满足条件。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> t, n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n/<span class="hljs-number">2</span>);    &#125;&#125;</code></pre></div><h2 id="b.-almost-ternary-matrix">B. Almost Ternary Matrix</h2><h3 id="分析-1">分析</h3><p>很关键的一点，<span class="math inline">\(n\)</span> 与 <spanclass="math inline">\(m\)</span> 都是偶数。</p><p>称如下矩形为 <span class="math inline">\(1\)</span> 类矩形。</p><p><img src="https://s2.loli.net/2022/07/05/M6ODlKLtgupzB5I.png" srcset="/img/loading.gif" lazyload /></p><p>称如下矩形为 <span class="math inline">\(2\)</span> 类矩形。</p><p><img src="https://s2.loli.net/2022/07/05/AnOC8UNtj64hYiK.png" srcset="/img/loading.gif" lazyload /></p><p>那么，无论 <span class="math inline">\(n\)</span> 与 <spanclass="math inline">\(m\)</span> 取何值，<span class="math inline">\(n\times m\)</span> 的矩阵必然能够由若干 <spanclass="math inline">\(1\)</span> 类与 <spanclass="math inline">\(2\)</span> 类矩形构成。不难发现，对于单个的 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span> 类矩形，一定满足条件。如果在 <spanclass="math inline">\(1\)</span> 类矩形的左边或右边拼上一个 <spanclass="math inline">\(2\)</span>类矩形，仍然满足条件，反之亦然；如果在一个 <spanclass="math inline">\(1\)</span> 类矩形的上方或下方拼上一个 <spanclass="math inline">\(2\)</span> 类矩形，仍然满足条件，反之亦然。</p><p>那么对于每 <span class="math inline">\(2\)</span> 行，每 <spanclass="math inline">\(2\)</span> 列，交替填入 <spanclass="math inline">\(1\)</span> 类或 <spanclass="math inline">\(2\)</span> 类矩形就得到答案了。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> t, m, n, ans[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SB1[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=&#123;    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SB2[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=&#123;    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,fg1=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>,fg1^=<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>,fg2=<span class="hljs-number">1</span>;j&lt;=m;j+=<span class="hljs-number">2</span>,fg2^=<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 注意原本两行算一行，两列算一列</span>            <span class="hljs-keyword">if</span>(fg1&amp;&amp;fg2||!fg1&amp;&amp;!fg2) &#123;                <span class="hljs-comment">// 在奇数行中，奇数个放 1 类</span>                <span class="hljs-comment">// 在偶数行中，偶数个放 1 类</span>                ans[i][j]=SB1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], ans[i][j+<span class="hljs-number">1</span>]=SB1[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];                ans[i+<span class="hljs-number">1</span>][j]=SB1[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=SB1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fg1&amp;&amp;!fg2||!fg1&amp;&amp;fg2) &#123;                <span class="hljs-comment">// 在奇数行中，偶数个放 2 类</span>                <span class="hljs-comment">// 在偶数行中，奇数个放 2 类</span>                ans[i][j]=SB2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], ans[i][j+<span class="hljs-number">1</span>]=SB2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];                ans[i+<span class="hljs-number">1</span>][j]=SB2[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=SB2[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i,<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i][j]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve1</span>();&#125;</code></pre></div><h2 id="c.-the-third-problem">C. The Third Problem</h2><h3 id="分析-2">分析</h3><p><spanclass="math inline">\(\operatorname{MEX}\)</span>，完全不会啊！</p><p>首先对于任意 <span class="math inline">\(l,r \in [1,n]\)</span>，满足<span class="math display">\[\operatorname{MEX}([a_l,a_{l+1},\ldots,a_r])=\operatorname{MEX}([b_l,b_{l+1},\ldots,b_r])\]</span> 这表明，假如他们的值为 <spanclass="math inline">\(x\)</span>，那么 <spanclass="math inline">\([1,x-1]\)</span> 一定都在 <spanclass="math inline">\([l,r]\)</span> 中出现过了。</p><p>设 <span class="math inline">\(p(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 在 <spanclass="math inline">\(a\)</span> 中的位置，由于是 <spanclass="math inline">\([0,n-1]\)</span>的排列，所以为了防止混淆，下文无论是数字都是 <spanclass="math inline">\([0,n-1]\)</span> 中的。</p><p>尝试直接构造 <span class="math inline">\(b\)</span>。首先，<spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 中 <spanclass="math inline">\(0\)</span> 的位置是不能变化的，否则 <spanclass="math inline">\(\operatorname{MEX} ([a_{p(0)},a_{p(0)}])\)</span>必然不同于 <span class="math inline">\(\operatorname{MEX}([b_{p(0)},b_{p(0)}])\)</span>。<span class="math inline">\(1\)</span>的位置也不能变化，可以轻松构造例子，不再赘述。</p><p>设当前区间为 <span class="math inline">\(l,r\)</span>，假设 <spanclass="math inline">\(p(0)&lt; p(1)\)</span>，起初 <spanclass="math inline">\(l=p(0)\)</span>，<spanclass="math inline">\(r=p(1)\)</span>。</p><p>如果 <span class="math inline">\(p(2) \in [l,r]\)</span>，那么 <spanclass="math inline">\(2\)</span> 放在哪里都可以。因为此时这个区间的<span class="math inline">\(\operatorname{MEX}\)</span> 已经和 <spanclass="math inline">\(0,1,2\)</span> 无关了，由于 <spanclass="math inline">\(0,1\)</span> 已经被确定，方案数累乘 <spanclass="math inline">\((r-l+1) -2\)</span>。如果 <spanclass="math inline">\(p(2)&lt;p(0)\)</span> 或者 <spanclass="math inline">\(p(2)&gt;p(1)\)</span> 呢？那就令 <spanclass="math inline">\(l=p(2)\)</span> 或者 <spanclass="math inline">\(r=p(2)\)</span>。同时对方案数没有贡献，因为只要<span class="math inline">\(2\)</span> 不在 <spanclass="math inline">\(b_{p(2)}\)</span>的位置，一定不合法，同样很容易找出例子。</p><p>接下来，如果 <span class="math inline">\(p(3) \in[l,r]\)</span>，那么分两种情况讨论</p><ul><li>在上一轮中，<span class="math inline">\(p(2) \in[l&#39;,r&#39;]\)</span>，那么此时 <spanclass="math inline">\([l&#39;,r&#39;] = [l,r]\)</span>，确定了 <spanclass="math inline">\(0,1,2\)</span> 的位置，<spanclass="math inline">\(3\)</span> 只有 <spanclass="math inline">\((r-l+1) - 3\)</span> 种选择，累乘即可。</li><li>在上一轮中，<span class="math inline">\(p(2) \notin[l,r]\)</span>，那么区间的边界一定会变化并让 <spanclass="math inline">\(p(2)\)</span> 在新区间的一端，仍然确定了 <spanclass="math inline">\(0,1,2\)</span>，累乘 <spanclass="math inline">\((r-l+1)-3\)</span>。</li></ul><p>如果 <span class="math inline">\(p(3) \neq[l,r]\)</span>，修改区间就行了。</p><p>以此类推，最终就能得到答案。</p><h3 id="code-2">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> t, n, a[N], p[N];ll ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    ans=<span class="hljs-number">1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), p[a[i]]=i;    <span class="hljs-keyword">int</span> l=p[<span class="hljs-number">0</span>], r=p[<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l,r);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">if</span>(p[i]&lt;l) l=p[i];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[i]&gt;r) r=p[i];        <span class="hljs-keyword">else</span> &#123;            (ans*=(r-l+<span class="hljs-number">1</span>)-i)%=mod;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="d.-almost-triple-deletions">D. Almost Triple Deletions</h2><p>先证明一个结论，如果一个区间 <spanclass="math inline">\([l,r]\)</span>，满足 <spanclass="math inline">\(a_l \ldots a_r\)</span>能够用题目中的操作完全删去，那么一定满足 <spanclass="math inline">\(r-l+1\)</span> 是偶数且 <spanclass="math inline">\([l,r]\)</span>中出现次数最多的数，其出现次数不超过 <spanclass="math inline">\(\frac{r-l+1}{2}\)</span>。</p><blockquote><p>证明：</p><p>每一次操作只能选择 <span class="math inline">\(2\)</span> 个数，如果<span class="math inline">\(r-l+1\)</span>是个奇数，显然不行。而每次操作只能选择 <spanclass="math inline">\(2\)</span> 个不同的数，如果某个数出现次数超过了<spanclass="math inline">\(\frac{r-l+1}{2}\)</span>，那么将这个数与一个与它不想等的数两两配对后，会只剩下这个数，无法进行操作。</p></blockquote><p>考虑 <span class="math inline">\(DP\)</span>。</p><p>设 <span class="math inline">\(f(i)\)</span> 为由 <spanclass="math inline">\([1,i-1]\)</span> 某些子序列和 <spanclass="math inline">\(a_i\)</span> 构成的最终序列的长度。初始时，如果<span class="math inline">\([1,i-1]\)</span> 能够完全删去，<spanclass="math inline">\(f(i)=1\)</span>，表示长度为 <spanclass="math inline">\(1\)</span> 的序列。否则 <spanclass="math inline">\(f(i)=0\)</span>，表示长度为 <spanclass="math inline">\(0\)</span> 的子序列。</p><p>转移，枚举 <span class="math inline">\(j \in [i+1,n+1]\)</span>，如果<span class="math inline">\(a_i = a_j\)</span> 并且 <spanclass="math inline">\([i+1,j-1]\)</span> 这一段能够完全消掉，那么就能将<span class="math inline">\(a_j\)</span> 放在 <spanclass="math inline">\(a_i\)</span> 后面，<spanclass="math inline">\(f(j) = f(i) +1\)</span>。需要注意的是 <spanclass="math inline">\(i\)</span> 必须满足 <spanclass="math inline">\(f(i) &gt; 0\)</span>，因为最终序列只能由相同数字构成，而上述转移让 <spanclass="math inline">\(j\)</span> 从 <spanclass="math inline">\(i+1\)</span> 开始，默认了 <spanclass="math inline">\([i,i-1]\)</span> 这部分能被消去。</p><p>特别地，当 <span class="math inline">\(j=n+1\)</span> 时，如果 <spanclass="math inline">\([i+1,n]\)</span> 能被消去，就让 <spanclass="math inline">\(f(n+1)=f(i) +1\)</span>。最终答案是 <spanclass="math inline">\(f(n+1)-1\)</span>。</p><p>为啥要这么干？因为状态时这样设计的，核心思想是将两个想等元素之间所有元素消除之后，让这两个元素使得答案序列长度<span class="math inline">\(+1\)</span>。</p><h3 id="code-3">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> t, n, a[N], f[N], cnt[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cnt[i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    f[<span class="hljs-number">0</span>]=f[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> most_element=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) &#123;        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>&amp;&amp;most_element&lt;=(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>) f[i]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> f[i]=<span class="hljs-number">0</span>;        most_element=<span class="hljs-built_in">max</span>(most_element,++cnt[a[i]]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> awa=<span class="hljs-number">1</span>;awa&lt;=n;++awa) cnt[awa]=<span class="hljs-number">0</span>;        most_element=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(f[i]) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n+<span class="hljs-number">1</span>;++j) &#123;            <span class="hljs-keyword">if</span>((j-i)%<span class="hljs-number">2</span>&amp;&amp;most_element&lt;=(j-i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>&amp;&amp;(a[i]==a[j]||j==n+<span class="hljs-number">1</span>))                f[j]=<span class="hljs-built_in">max</span>(f[j],f[i]+<span class="hljs-number">1</span>);            most_element=<span class="hljs-built_in">max</span>(most_element,++cnt[a[j]]);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div><h2 id="e.-three-days-grace">E. Three Days Grace</h2><p>太菜了看都没看。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>DP</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF359B Permutation 题解</title>
    <link href="/2022/cf359b-solution/"/>
    <url>/2022/cf359b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>小清新构造题。</p><span id="more"></span><p>不难发现，对于一个有序序列，假设是 <span class="math display">\[[1,2,3,4,5,6]\]</span> 那么 <span class="math display">\[\sum_{i=1}^3 | a_{2i} - a_{2i-1} | = | \sum_{i=1}^3  a_{2i} - a_{2i-1} |= 3\]</span> 把 <span class="math inline">\(2\)</span> 提前， <spanclass="math display">\[[2,1,3,4,5,6]\]</span> 发现得到的结果是 <span class="math inline">\(2\)</span>。</p><p>把 <span class="math inline">\(3\)</span> 提前， <spanclass="math display">\[[3,1,2,4,5,6]\]</span> 发现得到的结果是 <span class="math inline">\(4\)</span>。</p><p>把 <span class="math inline">\(j\)</span> 提前，<spanclass="math inline">\(a_2-a_1=1 - j =-(j-1)\)</span>，而在左式中直接绝对值没了，对答案贡献 <spanclass="math inline">\(j-1\)</span>，而右式则会让答案减少 <spanclass="math inline">\(j-1\)</span>。其他的都是一一对应的，一减就没了。那么把<span class="math inline">\(j\)</span> 提前的答案就是 <spanclass="math inline">\(2 \cdot (j-1)\)</span>。</p><p>直接把 <span class="math inline">\(k+1\)</span>提前，其他的顺序输出。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> n, k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k), n&lt;&lt;=<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,k+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,i,<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4852 yyf hates choukapai 题解</title>
    <link href="/2022/lg4852-solution/"/>
    <url>/2022/lg4852-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>不是那么显然的 DP。</p><p>对于每一次连抽，只会累计开始连抽的那张卡的欧气值，损失之后 <spanclass="math inline">\(c-1\)</span>张卡的欧气值。而单抽则不会损失欧气值。题目要求最大化欧气值，那么就是要尽量减小连抽损失的欧气值。</p><span id="more"></span><p>形式化地，对于一次在 <span class="math inline">\(i\)</span>位置开始的连抽，得到 <span class="math inline">\(a_i\)</span>，损失<span class="math inline">\(\sum_{j=i+1}^{i+c-1} a_i\)</span>的欧气。对于 <span class="math inline">\(j\)</span> 位置的单抽，只会得到<span class="math inline">\(a_j\)</span> 的欧气值。设 <spanclass="math inline">\(b_i = \sum_{j=i+1}^{i+c-1}a_i\)</span>，那么目标为最小化选出的 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(b_i\)</span>。可以用前缀和预处理。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 为进行了 <spanclass="math inline">\(j\)</span> 次连抽，其中第 <spanclass="math inline">\(j\)</span> 次连抽从 <spanclass="math inline">\(i\)</span> 开始，且 <spanclass="math inline">\([1,i-1]\)</span> 已经抽完了，所能选出 <spanclass="math inline">\(j\)</span> 个 <spanclass="math inline">\(\{b\}\)</span> 中元素的最小值。</p><p>思路是枚举上一次连抽的位置，由于两次连抽中间必然全是单抽且不成超过<span class="math inline">\(d\)</span> 次，而连抽必须抽 <spanclass="math inline">\(c\)</span> 个，那么对于 <spanclass="math inline">\(f(i,j)\)</span>，上一次连抽的位置 <spanclass="math inline">\(i&#39; \in[i-c-d,i-c]\)</span>。确定位置之后，直接加上 <spanclass="math inline">\(b_i\)</span> 就行。</p><p><span class="math display">\[f(i,j) = \min_{i&#39; \in [i-c-d,i-c]} \{ f(i&#39;,j-1)  + b_i \}\]</span></p><p>设 <span class="math inline">\(len = n \times c +m\)</span>，则复杂度为 <span class="math inline">\(O(n \cdotlen^2)\)</span>。</p><p>对于 <span class="math inline">\(i &gt; i_0\)</span>，<spanclass="math inline">\(i\)</span> 的合法决策区间的左右端点必然严格大于<span class="math inline">\(i_0\)</span>的合法决策区间的左右端点，直接单调队列优化。</p><p>对于能够成为答案的 <spanclass="math inline">\(f(i,n)\)</span>，必须满足<spanclass="math inline">\(i \in [1,len-c+1]\)</span> 且 <spanclass="math inline">\(len-(i+c-1) \led\)</span>，即最后一次连抽后单抽不能超过 <spanclass="math inline">\(d\)</span> 次。</p><p>最终答案 <span class="math inline">\(\sum_{i=1}^n a_i -\max\{f(i,n)\}\)</span>。</p><p>复杂度 <span class="math inline">\(O(n \cdot len)\)</span> 。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">200005</span>;<span class="hljs-keyword">int</span> n, m, c, d, a[N], q[N], pre[N][<span class="hljs-number">45</span>];ll s[N], b[N], f[N][<span class="hljs-number">45</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> t)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!i) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">print</span>(pre[i][t],t<span class="hljs-number">-1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), d=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> len=c*n+m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) s[i]=s[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len-c+<span class="hljs-number">1</span>;++i) b[i]=s[i+c<span class="hljs-number">-1</span>]-s[i];    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=d+<span class="hljs-number">1</span>;++i) f[i][<span class="hljs-number">1</span>]=b[i];    <span class="hljs-comment">// 注意第一次连抽的位置区间是[1,d+1]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) &#123;        <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len-c+<span class="hljs-number">1</span>;++i) &#123;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;i-c-d) ++l;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;i-c&gt;<span class="hljs-number">0</span>&amp;&amp;f[i-c][j<span class="hljs-number">-1</span>]&lt;f[q[r]][j<span class="hljs-number">-1</span>]) --r;            <span class="hljs-keyword">if</span>(i-c&gt;<span class="hljs-number">0</span>) q[++r]=i-c;            <span class="hljs-keyword">if</span>(l&lt;=r&amp;&amp;q[l]&gt;=i-c-d&amp;&amp;q[l]&lt;=i-c) f[i][j]=f[q[l]][j<span class="hljs-number">-1</span>]+b[i], pre[i][j]=q[l];        &#125;    &#125;    <span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>;    ll ans=<span class="hljs-number">1e15</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len-c+<span class="hljs-number">1</span>;++i) &#123;        <span class="hljs-keyword">int</span> j=i+c<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(len-j&lt;=d&amp;&amp;ans&gt;f[i][n]) ans=f[i][n], p=i;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s[len]-ans);    <span class="hljs-built_in">print</span>(p,n);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#5 网络流定义与最大流</title>
    <link href="/2022/notes-graph-5/"/>
    <url>/2022/notes-graph-5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="定义">定义</h2><p>一个网络 <span class="math inline">\(G= (V,E)\)</span>是一张有向图，对于每条有向边 <span class="math inline">\((x \rightarrowy)\)</span> 都有一个权值 <spanclass="math inline">\(c(x,y)\)</span>，称之为这条边的<strong>容量</strong>。另外，存在特殊节点<span class="math inline">\(S\)</span>，称为<strong>源点</strong>；<spanclass="math inline">\(T\)</span>，称为<strong>汇点</strong>。</p><span id="more"></span><p>设函数 <span class="math inline">\(f(x,y)\)</span>，其定义域为 <spanclass="math inline">\(x,y \in V\)</span>，满足</p><ol type="1"><li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 <spanclass="math inline">\(f(x,y) \le c(x,y)\)</span></li><li>斜对称性：每条边的流量与其相反边的流量之和为 0，即 <spanclass="math inline">\(f(x,y) = -f(y,x)\)</span></li><li>流守恒性：从源点流出的流量等于汇点流入的流量，即 <spanclass="math inline">\(\sum_{(u ,x) \in E} f(u,x) = \sum_{(x,v) \in E}f(x,v)\)</span></li></ol><p>那么称 <span class="math inline">\(f\)</span>为这个网络的<strong>流函数</strong>，对于边 <spanclass="math inline">\((x \rightarrow y)\)</span>，<spanclass="math inline">\(f(x,y)\)</span>称为它的<strong>流量</strong>，<spanclass="math inline">\(c(x,y)-f(x,y)\)</span>称为它的<strong>剩余容量</strong>。</p><p>整个网络的流量为<strong>从源点发出的所有流量之和</strong>，即 <spanclass="math inline">\(\sum_{(S,x) \in E} f(S,x)\)</span>。</p><p>由于流量守恒性质，可以知道<strong>除了源点与汇点之外，其他的节点不储存流，「流」只是从源点流出，流经整个网络，最终归于汇点</strong>。</p><h2 id="最大流">最大流</h2><p>对于一个网络，有很多合法的流函数，但是使得整个网络的流量最大的流函数<span class="math inline">\(f\)</span>，也就是 <spanclass="math inline">\(\sum_{(S,x) \in E} f(S,x)\)</span>，这样的流函数<span class="math inline">\(f\)</span>称为该网络的<strong>最大流</strong>。</p><h3 id="edmonds-karp-算法">Edmonds-Karp 算法</h3><p>是 Ford-Fulkerson 方法基于 BFS 的一个实现。</p><p>如果存在一条从源点 <span class="math inline">\(S\)</span> 到汇点<span class="math inline">\(T\)</span>的路径，满足每一条边的剩余容量都大于 <spanclass="math inline">\(0\)</span>，那么称这条路径为一条<strong>增广路</strong>，注意不同于二分图匹配中的增广路。</p><p>如果让更多的流沿着 <span class="math inline">\(S\)</span> 流到 <spanclass="math inline">\(T\)</span>，那么就能使网络流量增大，且这个值为路径上最小的剩余容量。Edmonds-Karp算法的思想是利用 BFS不断寻找增广路，知道网络中不存在增广路。此时不可能增加网络的流量，那么必然得到了最大流。</p><p>具体流程如下</p><p>在寻找增广路的过程中，只考虑 <span class="math inline">\(f(x,y) &lt;c(x,y)\)</span> 的边，用 BFS 找到任意 <spanclass="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的路径， 计算出路径上最小的剩余容量<span class="math inline">\(minf\)</span>，同时累加总流量。</p><p>如果存在一条边满足 <span class="math inline">\(f(x,y) &gt;0\)</span>，那么它的反向边有 <span class="math inline">\(f(y,x) &lt;0\)</span>，此时 <span class="math inline">\(f(y,x) &lt;c(y,x)\)</span>，由于 <span class="math inline">\(c(x,y) =c(y,x)\)</span>，那么反向边也有可能成为增广路的一部分，应该考虑边集<span class="math inline">\(E\)</span>中每条边的反向边。我一开始有一个小问题，网络不是有向图吗？为什么也能用反向边呢？后来想明白了，并不是网络中真的有了反向边，对于<span class="math inline">\((x \rightarrowy)\)</span>，选择它的反边相当于把通过它的流退了回来，并且能够发现新的增广路。</p><p>图解。</p><figure><img src="https://s2.loli.net/2022/07/03/16qMpVeyK2LswTm.png" srcset="/img/loading.gif" lazyloadalt="一个普通的网络" /><figcaption aria-hidden="true">一个普通的网络</figcaption></figure><p>初始状态，钦定 <span class="math inline">\(1\)</span> 为源点，<spanclass="math inline">\(6\)</span> 为汇点。</p><p>手动 BFS 找到一条增广路 <span class="math inline">\((1 \rightarrow 2\rightarrow 5 \rightarrow6)\)</span>，同时发现无法再找到增广路了。将增广路上的边都增加上最小的剩余容量<span class="math inline">\(2\)</span>。最大流是 <spanclass="math inline">\(2\)</span> 吗？</p><p><img src="https://s2.loli.net/2022/07/03/mLOMUrCnN5JKicV.png" srcset="/img/loading.gif" lazyload /></p><p>建立反向边，发现新的增广路 <span class="math inline">\((1 \rightarrow4 \rightarrow 5 \rightarrow 2 \rightarrow 3 \rightarrow6)\)</span>，其中只有 <span class="math inline">\(2\)</span>走的是原来边的反向边。将路径上走正向边都加上最小剩余容量 <spanclass="math inline">\(1\)</span>，走反向边的都减去最小剩余容量 <spanclass="math inline">\(1\)</span>。可以验证这条增广路是合法的，且最大流又增加了<span class="math inline">\(1\)</span>。</p><p><img src="https://s2.loli.net/2022/07/03/45KP8yjOaHYidJN.png" srcset="/img/loading.gif" lazyload /></p><p>注意画出的红蓝箭头指的是两条增广路，不是网络的真是流向，但是根据增广路可以构造出合法的流向。由于<span class="math inline">\((2 \rightarrow 5)\)</span> 减去了 <spanclass="math inline">\(1\)</span>，但是在 <span class="math inline">\((2\rightarrow 3)\)</span> 又加上了 <spanclass="math inline">\(1\)</span>，所以总流量不变， <spanclass="math inline">\((1 \rightarrow 2)\)</span>的流能通过<strong>分流</strong>的方式到达汇点。<spanclass="math inline">\((1 \rightarrow 2)\)</span> 分流导致原来走的 <spanclass="math inline">\((5 \rightarrow 6)\)</span>也腾出了空间，正好能容纳 <span class="math inline">\((4 \rightarrow5)\)</span> 流过来的部分。图中写出来的边权 <spanclass="math inline">\(f(x,y)/c(x,y)\)</span> 是正向边的流量。</p><p>图中流的路径为 <span class="math inline">\((1 \rightarrow 4\rightarrow 5 \rightarrow 6)\)</span>，<span class="math inline">\((1\rightarrow 2 \rightarrow 5 \rightarrow 6)\)</span> 和 <spanclass="math inline">\((1 \rightarrow 2 \rightarrow 3 \rightarrow6)\)</span>，每条流量都为 <spanclass="math inline">\(1\)</span>。这样做才能求得最大流 <spanclass="math inline">\(3\)</span>。</p><p>还有一点，EK 算法遍历的是网络中所有节点和剩余容量大于 <spanclass="math inline">\(0\)</span>的边构成的子图，称为<strong>残量网络</strong>。代码中的边权都是<strong>残量网络的边权</strong>，也就是还能容纳多少。对于一条正向边<span class="math inline">\((x \rightarrow y)\)</span>，容量为 <spanclass="math inline">\(z\)</span>。初始还能容纳 <spanclass="math inline">\(z\)</span>，所以加边<code>add(x,y,z)</code>，而其反向边则是<code>add(y,x,0)</code>，只有正向边减少才能为反向边腾出空间。</p><p>于是乎 EK 算法就没有悬念了，上代码。</p><p>复杂度 <spanclass="math inline">\(O(nm^2)\)</span>，实际远远达不到这个上界，<del>但依然很慢</del>，大概能处理<span class="math inline">\(n=10^3 \sim 10^4\)</span> 规模的网络。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">0x7fffffff</span>, N=<span class="hljs-number">205</span>, M=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> n, m, s, t, pre[N], F[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>], w[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-comment">// 注意tot=1</span><span class="hljs-keyword">bool</span> v[N];ll maxflow;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 快读</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));    <span class="hljs-comment">// v[i]表示i是否被访问过</span>v[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);F[s]=inf;    <span class="hljs-comment">// 源点为正无穷</span><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(v[y]||!z) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 被访问过或者剩余容量为0</span>F[y]=<span class="hljs-built_in">min</span>(F[x],z);pre[y]=i;            <span class="hljs-comment">// 记录增广路上的边</span>v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            <span class="hljs-comment">// 到达汇点，找到增广路</span>&#125; &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 不存在</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x=t;<span class="hljs-keyword">while</span>(x!=s) &#123;<span class="hljs-keyword">int</span> i=pre[x];w[i]-=F[t], w[i^<span class="hljs-number">1</span>]+=F[t];        <span class="hljs-comment">// 正向边剩余容量减少，反向边剩余容量增加</span>x=to[i^<span class="hljs-number">1</span>];        <span class="hljs-comment">// 因为从tot=1开始储存，所以i^1定位到i的反向边</span>&#125;maxflow+=F[t];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);        <span class="hljs-comment">// 反向边权值（剩余容量）最初为0</span>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-built_in">update</span>();    <span class="hljs-comment">// 存在增广路就更新</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,maxflow);&#125;</code></pre></div><h3 id="dinic-算法">Dinic 算法</h3><p>EK 算法每轮可能会遍历整个残量网络，但是最多找出 1条增广路，效率较低。</p><p>设 <span class="math inline">\(d(x)\)</span> 为起点到 <spanclass="math inline">\(x\)</span>最小的边数，称为<strong>层次</strong>。在残量网络中，满足 <spanclass="math inline">\(d(y) = d(x) +1\)</span> 的边 <spanclass="math inline">\((x \rightarrow y)\)</span>构成的子图称为<strong>分层图</strong>，这显然是一张 DAG。使用 BFS很容易实现。</p><p>Dinic 算法基于分层图，其流程如下：</p><ol type="1"><li>在残量网络上使用 BFS 求出节点的层次，构造分层图。</li><li>在分层图上寻找任意一条增广路，进行增广，并将答案加上增广流量。</li><li>貌似一次 DFS 能够找出所有增广路。</li><li>如果无法再次建立分层图，当前流量即为最大流。</li></ol><p>一个重要的优化是<strong>当前弧优化</strong>。定义点 <spanclass="math inline">\(x\)</span> 的当前弧为 DFS 过程中遍历过的 <spanclass="math inline">\(x\)</span>的最后一条出边。首先如果一条边被增广过了，那么他便不会再次被增广，如果再遍历这些边的话相当浪费时间，所以对于节点<span class="math inline">\(x\)</span>，每遍历一条边，都让再次访问 <spanclass="math inline">\(x\)</span>时从这条边开始，且不去遍历之前的边。具体实现看代码。</p><p>此外，还有一个优化。递归完回溯时，如果返回的是0，说明已经增广完毕，直接将这个点移出分层图。</p><p>效率高于 EK 算法，复杂度为 <spanclass="math inline">\(O(n^2m)\)</span>，但是很难达到这个上界，能够处理<span class="math inline">\(n = 10^4 \sim 10^5\)</span> 规模的网络。用Dinic 算法求解二分图最大匹配的复杂度为 <span class="math inline">\(O(m\sqrt n)\)</span>，实际表现更快。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">0x7fffffff</span>, N=<span class="hljs-number">205</span>, M=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> n, m, s, t, hh[N], d[N];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>, h[N], to[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>], w[M&lt;&lt;<span class="hljs-number">1</span>];ll maxflow;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 省略快读</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;to[++tot]=y, w[tot]=z, nxt[tot]=h[x], h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[s]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();hh[x]=h[x];        <span class="hljs-comment">// hh[]要把h[]复制一份</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]||!z) <span class="hljs-keyword">continue</span>;q.<span class="hljs-built_in">push</span>(y);d[y]=d[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(y==t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> flow)</span> </span>&#123;     <span class="hljs-comment">// flow表示当前增广路的最小剩余容量</span><span class="hljs-keyword">if</span>(x==t||!flow) <span class="hljs-keyword">return</span> flow;    <span class="hljs-comment">// 到达汇点或者增广完毕</span><span class="hljs-keyword">int</span> res=flow;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i=hh[x];i;i=nxt[i]) &#123;        <span class="hljs-comment">// i是个引用，当前弧优化</span>       <span class="hljs-comment">// i变为nxt[i]时也直接让h[x]变为nxt[i]，最终导致从x出发直接到达它的当前弧</span><span class="hljs-keyword">int</span> y=to[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]!=d[x]+<span class="hljs-number">1</span>||!z) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 不是分层图中节点或者不再残量网络中就不搜索</span><span class="hljs-keyword">int</span> k=<span class="hljs-built_in">dinic</span>(y,<span class="hljs-built_in">min</span>(res,z)); <span class="hljs-comment">// 取最小值</span><span class="hljs-keyword">if</span>(!k) d[y]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> w[i]-=k, w[i^<span class="hljs-number">1</span>]+=k, res-=k;        <span class="hljs-comment">// 优化。移出分层图</span><span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">return</span> flow;        <span class="hljs-comment">// 加这句话快在洛谷的板子 700ms -&gt; 50ms</span>&#125;<span class="hljs-keyword">return</span> flow-res;    <span class="hljs-comment">// 返回的其实就是所有k的和，表示从这个点出发能够增广的值之和</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) maxflow+=<span class="hljs-built_in">dinic</span>(s,inf);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,maxflow);&#125;</code></pre></div><h3 id="二分图最大匹配">二分图最大匹配</h3><p>对于一张 <span class="math inline">\(n\)</span> 个节点，<spanclass="math inline">\(m\)</span> 条边的二分图，可以新增一个源点 <spanclass="math inline">\(S\)</span> 和一个汇点 <spanclass="math inline">\(T\)</span>，从 <spanclass="math inline">\(S\)</span> 到每个左部节点连有向边，从每个右部节点到 <span class="math inline">\(T\)</span> 连有向边，原本的<span class="math inline">\(m\)</span>条边看作左部节点到右部节点的有向边，形成一张 <spanclass="math inline">\(n+2\)</span> 个节点，<spanclass="math inline">\(m+n\)</span> 条边的网络。</p><p>把网络中每条边的容量都设为1，该二分图最大匹配数就等于网络的最大流量。求出最大流后，所有存在「流」经过的点和边就是匹配点、匹配边。</p><p>如果要求该二分图的多重匹配，只需要把 <spanclass="math inline">\(S\)</span> 到左部节点 <spanclass="math inline">\(i\)</span> 的有向边容量设置为匹配数量上限 <spanclass="math inline">\(kl_i\)</span>，右部点到 <spanclass="math inline">\(j\)</span> 到 <spanclass="math inline">\(T\)</span> 的有向边容量设置为匹配数量上限 <spanclass="math inline">\(kr_j\)</span>。</p><p>参考：</p><ul><li><p><ahref="https://blog.csdn.net/qq_39670434/article/details/80952337">最大流算法之一——EK算法</a>by 千杯湖底沙</p></li><li><p><a href="https://oi.men.ci/dinic-notes/">Dinic 学习笔记</a> byMenci</p></li><li><p><ahref="https://2745518585.github.io/post/maximum-flow-Dinic">最大流Dinic</a> by 赵悦岑</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最大流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1338B Edge Weight Assignment 题解</title>
    <link href="/2022/cf1338b-solution/"/>
    <url>/2022/cf1338b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>没错还是构造……</p><p>明确某个数异或另一个数偶数次，结果仍然是它本身。</p><p>再明确所有的数字都是正整数，不能用 <spanclass="math inline">\(0\)</span>。</p><span id="more"></span><p>任意两个叶子之间的路径权值的异或和为 <spanclass="math inline">\(0\)</span>，如果它们之间的距离是偶数的话，那么都填同一个数就好了。最小数量为<span class="math inline">\(1\)</span>。</p><p>如果存在某两个叶子之间的距离不为偶数，如下图 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(5\)</span>。</p><p><img src="https://s2.loli.net/2022/07/02/pLqGWyH7XKi9hul.png" srcset="/img/loading.gif" lazyload /></p><p>钦定 <span class="math inline">\((1 \rightarrow 3)\)</span> 的权值为<span class="math inline">\(39\)</span>，那么如果 <spanclass="math inline">\((3 \rightarrow 4)\)</span> 或者 <spanclass="math inline">\((4 \rightarrow 5)\)</span> 任何一个是 <spanclass="math inline">\(39\)</span>，<span class="math inline">\(39\operatorname{xor} 39 =0\)</span>，结果都是另一条边的权值。所以假如<span class="math inline">\((4 \rightarrow 5)\)</span> 是 <spanclass="math inline">\(815\)</span>，那么 <span class="math inline">\((3\rightarrow 4)\)</span> 只有是 <span class="math inline">\(39\operatorname{xor} 815=776\)</span> 才能满足异或和为 <spanclass="math inline">\(0\)</span>。</p><p>其实这就相当于把两条边「合并」为一条边，权值为它们的异或值，这样奇数距离就转化成了偶数。至于更长的奇数距离的情况，依旧这样去做，不难发现这种情况下最少使用<span class="math inline">\(3\)</span> 种权值。</p><p>那么最多呢？直接做不好想，考虑从它的补集入手。如果没有任何限制，那么一定是每一条边一个权值，共有<span class="math inline">\((n-1)\)</span>种。然后再减去会「因为某些边权的确定而被动确定的边」就行了。</p><p>依旧是上图，假如上述权值不变，那么 <span class="math inline">\((2\rightarrow 3)\)</span> 能够填什么呢？<span class="math inline">\((1\rightarrow 5)\)</span> 和 <span class="math inline">\((2 \rightarrow5)\)</span>，在 <span class="math inline">\((3 \rightarrow 5)\)</span>这一段是重叠的，只有 <span class="math inline">\((2 \rightarrow3)\)</span> 的权值与 <span class="math inline">\((1 \rightarrow3)\)</span> 相同，才能让异或和为 <spanclass="math inline">\(0\)</span>。不难发现，对于同一个父亲的叶子节点，它们与父亲之间的边只能是一种。假如一个点<span class="math inline">\(x\)</span> 有 <spanclass="math inline">\(t_x\)</span> 个叶子节点，其中 <spanclass="math inline">\(t_x-1\)</span>条边的权值一定是与剩下那一条相同的。</p><p>综上所述，权值最多的情况，就是 <span class="math display">\[n-1 - \sum_{x \in V \text{ and } t_x \ge 1} t_x -1\]</span> 注意如果 <span class="math inline">\(t_x=1\)</span>，贡献是<span class="math inline">\(0\)</span>，如果 <spanclass="math inline">\(t_x=0\)</span> 也没有贡献。</p><p> </p><p>因为是无根树，所以要钦定根节点。</p><p>对于寻找最小数量，可以找到一个叶子节点作为根，判断它到其他叶子节点的距离是否都是偶数，是的话答案为<span class="math inline">\(1\)</span>，否则为 <spanclass="math inline">\(3\)</span>。因为树的奇妙性质所以不会存在某个叶子和另一个叶子到「根」的距离是偶数，但是它们之间的距离是奇数的问题。</p><p>在寻找最大值时，如果还从叶子节点开始搜索的话会产生遗漏，所以从以一个非叶子节点为根，统计<span class="math inline">\(t_x\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, sum;<span class="hljs-keyword">int</span> tot, h[N], to[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> flag=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; to[++tot]=y, nxt[tot]=h[x], h[x]=tot; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> dis)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!nxt[h[x]]&amp;&amp;dis&amp;<span class="hljs-number">1</span>) flag=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 与某个叶子节点距离为奇数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(y,x,dis+<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=to[i];        <span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs2</span>(y,x);        t+=!nxt[h[y]];        <span class="hljs-comment">// !nxt[h[y]]=1，叶子</span>    &#125;    <span class="hljs-keyword">if</span>(t) sum+=t<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1 1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    &#125;    <span class="hljs-keyword">int</span> root=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;!root&amp;&amp;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!nxt[h[i]]) root=i;    <span class="hljs-comment">// 叶子节点</span>    <span class="hljs-built_in">dfs1</span>(root,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    root=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;!root&amp;&amp;i&lt;=n;++i) <span class="hljs-keyword">if</span>(nxt[h[i]]) root=i;    <span class="hljs-comment">// 非叶子节点</span>    <span class="hljs-built_in">dfs2</span>(root,<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,flag? <span class="hljs-number">1</span>:<span class="hljs-number">3</span>,n-sum<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1416B Make Them Equal 题解</title>
    <link href="/2022/cf1416b-solution/"/>
    <url>/2022/cf1416b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p><del>构造题使人神清气爽</del>。</p><p>先判断无解的情况，如果 <span class="math inline">\(n \nmid\sum_{i=1}^n a_i\)</span>，那么显然无解。</p><p>做构造题不能只局限于样例给出的方法，因为它们一般都是特殊情况，而我们的目标是使用一般方法进行构造。</p><span id="more"></span><p>注意到无论怎么操作，元素的总和是不变的，我们可以尝试把所有值移动到一个元素上，然后因为<span class="math inline">\(n \nmid \sum_{i=1}^na_i\)</span>，所以一定能够用 <span class="math inline">\((n-1)\)</span>次操作平均分。</p><p>如果这么做，那么必然除了那个元素，其他的元素都是 <spanclass="math inline">\(0\)</span>。对于一个操作 <spanclass="math inline">\((i,j,x)\)</span>，如果想让 <spanclass="math inline">\(a_i\)</span> 置为 <spanclass="math inline">\(0\)</span>，那么必须满足 <spanclass="math inline">\(i \mid a_i\)</span>。对于 <spanclass="math inline">\(i \nmid a_i\)</span> 的情况，则要事先将 <spanclass="math inline">\(a_i\)</span> 增大到满足 <spanclass="math inline">\(i \mid a_i\)</span>。</p><p>增大多少呢？<span class="math inline">\(i-a_i \bmodi\)</span>，这是显然的。如果操作是 <spanclass="math inline">\((j,i,x)\)</span>，想让 <spanclass="math inline">\(a_i\)</span> 变大，其值必定是 <spanclass="math inline">\(j\)</span>的倍数。为了能够增加任意值，钦定都移动到 <spanclass="math inline">\(a_1\)</span> 上。</p><p>那么对于 <span class="math inline">\(i \nmid a_i\)</span>，必定先使用<span class="math inline">\((1,i,k)\)</span>，其中 <spanclass="math inline">\(k = i - a_i \bmod i\)</span>。那么将 <spanclass="math inline">\(a_i\)</span> 清零，使用 <spanclass="math inline">\((i,1,\frac{a_i}{i})\)</span>。如此至多使用 <spanclass="math inline">\(2 \cdot (n-1)\)</span> 次操作，再使用 <spanclass="math inline">\((n-1)\)</span> 次 <spanclass="math inline">\((1,i,ave)\)</span>，其中 <spanclass="math inline">\(ave = \frac{\sum_{i=1}^na_i}{n}\)</span>。总操作数 <span class="math inline">\(3 \cdot(n-1)\)</span>，满足条件。</p><p>有一个疑问，<span class="math inline">\(a_i\)</span>难道不会在残酷的修改中变为负数吗？假如 <spanclass="math inline">\(a_2\)</span> 就需要进行增加操作，必然 <spanclass="math inline">\(a_i\)</span> 要减小一个值。但是这个值是 <spanclass="math inline">\(2 - a_2 \bmod 2\)</span>，由于 <spanclass="math inline">\(2 \nmid a_2\)</span>，所以这个值一定是 <spanclass="math inline">\(1\)</span>。而 <span class="math inline">\(a_i \in[1,10^5]\)</span>，所以绝对不是负数。</p><p>而后至少要增加 <span class="math inline">\(2\)</span>（将 <spanclass="math inline">\(a_2\)</span> 置 <spanclass="math inline">\(0\)</span>），所以当修改 <spanclass="math inline">\(a_3\)</span> 时，<spanclass="math inline">\(a_1\)</span> 至少是 <spanclass="math inline">\(3\)</span>，如果要让 <span class="math inline">\(3\mid a_3\)</span>，那么 <span class="math inline">\(a_1\)</span>减少的量又一定小于 <span class="math inline">\(3\)</span>，接着加上至少<span class="math inline">\(3\)</span>。如此类推，不会出现小于 <spanclass="math inline">\(0\)</span> 的情况。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> T, n, a[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> i, j, x; &#125;;vector&lt;node&gt; ans;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;    ans.<span class="hljs-built_in">clear</span>();    n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum+=(a[i]=<span class="hljs-built_in">read</span>());    <span class="hljs-keyword">if</span>(sum%n) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">int</span> ave=sum/n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">int</span> k=a[i]%i;        <span class="hljs-keyword">if</span>(k) k=i-k;        ans.<span class="hljs-built_in">pb</span>(&#123;<span class="hljs-number">1</span>,i,k&#125;);        a[<span class="hljs-number">1</span>]-=k, a[i]+=k;        <span class="hljs-comment">// 如果k=0，这一步可以没有，但是下一步必须要有</span>        ans.<span class="hljs-built_in">pb</span>(&#123;i,<span class="hljs-number">1</span>,a[i]/i&#125;);        a[<span class="hljs-number">1</span>]+=a[i], a[i]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) ans.<span class="hljs-built_in">pb</span>(&#123;<span class="hljs-number">1</span>,i,ave&#125;);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans.<span class="hljs-built_in">size</span>());    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,a.i,a.j,a.x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1542B Plus and Multiply 题解</title>
    <link href="/2022/cf1542b-solution/"/>
    <url>/2022/cf1542b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>等价于判断 <span class="math inline">\(n\)</span> 能否写成如下形式<span class="math display">\[n = a^x + by\]</span> 多乘个 <span class="math inline">\(a\)</span> 或者多加个 <spanclass="math inline">\(b\)</span> 仍然形如这样。</p><span id="more"></span><p>这就相当于 <span class="math display">\[n \equiv a^x \quad (\bmod b)\]</span> 因为 <span class="math inline">\(y\)</span>是个未知数，可以利用这个转化同余方程。或者说，<spanclass="math inline">\(x \equiv y \quad (\bmod b) \iff b \mid(x-y)\)</span>。注意这里的 <span class="math inline">\(x,y,b\)</span>是任意的。</p><p>这个就很简单了，枚举 <span class="math inline">\(x\)</span>，满足<span class="math inline">\(a^x \in [1,n]\)</span>，判断 <spanclass="math inline">\(a^x \bmod b\)</span> 是否等于 <spanclass="math inline">\(n \bmod b\)</span>。</p><p>为什么只用枚举使得 <span class="math inline">\(a^x \in [1,n]\)</span>的 <span class="math inline">\(x\)</span>？因为 <spanclass="math inline">\(a,b \in \mathbb{Z^+}\)</span>，那么如果 <spanclass="math inline">\(a^x\)</span> 大于 <spanclass="math inline">\(n\)</span> 的话，就不可能了。</p><p>注意特判，当 <span class="math inline">\(a=1\)</span> 时，等价于<span class="math inline">\(n \equiv 1 \quad (\bmodb)\)</span>，如果成立的话，有两种情况。第一种可以直接判断 <spanclass="math inline">\(n \bmod b\)</span> 是否为 1，第二种，如果 <spanclass="math inline">\(b=1\)</span>，那么 <spanclass="math inline">\(n\)</span> 为任何数时都成立。其他情况都无解。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> T, n, a, b;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;a,&amp;b);    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span>(n%b==<span class="hljs-number">1</span>||b==<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> y=n%b;    <span class="hljs-keyword">for</span>(ll x=<span class="hljs-number">1</span>;x&lt;=n;x*=a) &#123;        <span class="hljs-keyword">if</span>(x%b==y) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5535 &amp; luogu1414 题解</title>
    <link href="/2022/lg5535-1414-solution/"/>
    <url>/2022/lg5535-1414-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="luogu5535-小道消息">luogu5535 小道消息</h2><h3 id="分析">分析</h3><p>关于伯特兰·切比雪夫定理，我们只需要用百科里说的“较弱”的说法。</p><p>对于整数 <span class="math inline">\(n \ge1\)</span>，至少存在一个质数 <spanclass="math inline">\(p\)</span>，满足 <span class="math inline">\(p \in(n,2n)\)</span>。</p><span id="more"></span><p>有什么用？</p><p>首先 <span class="math inline">\(k \in[1,n]\)</span>，由于每个人衣服上的数是下标 +1，那么第 <spanclass="math inline">\(k\)</span> 个人衣服上的数就满足 <spanclass="math inline">\(k+1 \ge 1\)</span>。从而 <spanclass="math inline">\((k+1,2k+2)\)</span>，也就是 <spanclass="math inline">\([k+2,2k+1]\)</span> 之中必定有一个质数。</p><p>如果 <span class="math inline">\(k+1\)</span>是个质数，那么显然除了它的倍数之外的数，与它的最大公约数都为1。那么只要保证它的最小倍数 <span class="math inline">\(2k +2 &gt;n+1\)</span> 就能 1 天就传达完成。</p><p>那如果 <span class="math inline">\(k+1\)</span>不是质数呢？<del>根据质数的分布</del>传给上面那样的质数就行了，2天。</p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n, k;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isprime</span>(k+<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-number">2</span>*k+<span class="hljs-number">2</span>&gt;n+<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);&#125;</code></pre></div><h2 id="p1414-又是毕业季ii">P1414 又是毕业季II</h2><h3 id="分析-1">分析</h3><p>定义 <span class="math inline">\(p_i\)</span> 表示质因数 <spanclass="math inline">\(i\)</span> 在每个能力值中出现的次数。</p><p>明确对于 <span class="math inline">\(k=i,j\)</span> 其中 <spanclass="math inline">\(i &gt;j\)</span>，所输出的最大默契程度必然是单调不增的。因为多选一个人不会让最大公约数变大。</p><p>当 <span class="math inline">\(k=1\)</span>时，答案是最大的能力值，设其为 <spanclass="math inline">\(mx\)</span>。那么就令 <spanclass="math inline">\(ans=mx\)</span>，如果 <spanclass="math inline">\(p_{ans} &lt; i\)</span>，那么让 <spanclass="math inline">\(ans-1\)</span>，这样一定是最大的。</p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, a[N], p[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> mx=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), mx=<span class="hljs-built_in">max</span>(mx,a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=a[i];++j) <span class="hljs-keyword">if</span>(a[i]%j==<span class="hljs-number">0</span>) &#123;            ++p[j];            <span class="hljs-keyword">if</span>(j*j!=a[i]) ++p[a[i]/j];        &#125;    &#125;    <span class="hljs-keyword">int</span> ans=mx;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">while</span>(p[ans]&lt;i) --ans;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF482A Diverse Permutation 题解</title>
    <link href="/2022/cf482a-solution/"/>
    <url>/2022/cf482a-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>话说这题为啥要写题解啊？</p><p>因为，我最最最最不擅长的构造题，我最最最最期望的「构造作战」，还是要从水题开始攻克吧。</p><span id="more"></span><p>如何构造 <span class="math inline">\(k\)</span> 种差值呢？ <spanclass="math display">\[[1,k+1,2,k,3,k-1 \cdots]\]</span> 这样构造的差值是 <span class="math inline">\(k,k-1,k-2\cdots\)</span>，那么就可以用 <span class="math inline">\(k+1\)</span>个数字构造出 <span class="math inline">\([1,k]\)</span>中所有的差值。</p><p>照这样，维护两个指针 <span class="math inline">\(i=1\)</span> 与<span class="math inline">\(j=k+1\)</span>，这样就确定了一个差值。然后让<span class="math inline">\(i+1\)</span>，<spanclass="math inline">\(j-1\)</span>，又确定一个差值，知道 <spanclass="math inline">\(i \ge j\)</span>。如果这样操作之后出现了 <spanclass="math inline">\(i=j\)</span> 的情况，那么就说明 <spanclass="math inline">\(k+1\)</span> 是个奇数，进而 <spanclass="math inline">\(k\)</span> 是偶数。由于一轮确定 2 个数，假设进行了<span class="math inline">\(t\)</span> 轮，那么就有了 <spanclass="math inline">\(2t\)</span> 个数确定了 <spanclass="math inline">\(2t-1\)</span>个差值，这显然是个奇数。所以还要再补上一个 <spanclass="math inline">\(i\)</span>。</p><p>那么后面的怎么搞呢？我们只用到了 <spanclass="math inline">\([1,k+1]\)</span> 的数，且一定全部用完并包含 1这个差值。那么只要顺序输出 <span class="math inline">\([k+2,n]\)</span>所有的数就能满足条件。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, k, ans[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, j=i+k;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d &quot;</span>,i++,j--);        <span class="hljs-keyword">if</span>(i&gt;=j) &#123;            <span class="hljs-keyword">if</span>(i==j) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,i,<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2294 狡猾的商人 题解</title>
    <link href="/2022/lg2294-solution/"/>
    <url>/2022/lg2294-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="solution1-带权并查集">solution1 带权并查集</h2><p>给出的信息是区间和的形式，搞个前缀和数组 <spanclass="math inline">\(a_i\)</span>，表示 <spanclass="math inline">\([1,i]\)</span> 月的总收益。</p><p>假如知道 <span class="math inline">\([x,y]\)</span> 月的收益与 <spanclass="math inline">\([y,z]\)</span> 月的收益，那么就能推出 <spanclass="math inline">\([x,z]\)</span> 月的收益。这时候如果后来的 <spanclass="math inline">\([x,z]\)</span>月的信息产生冲突，那么必定是假的。</p><span id="more"></span><p>由于不同区间的信息具有可合并性和传递性，考虑带权并查集。</p><p>首先明确 <span class="math inline">\(a_i\)</span> 此时表示 <spanclass="math inline">\([fa(i),i]\)</span>的和。这是带权并查集的固定套路。</p><p>当给出一个区间信息 <span class="math inline">\((u,v,w)\)</span> 表示<span class="math inline">\([u,v]\)</span> 这一段的和为 <spanclass="math inline">\(w\)</span> 时，找到 <spanclass="math inline">\(x=fa(u-1)\)</span>，<spanclass="math inline">\(y=fa(v)\)</span>。</p><p>如果 <span class="math inline">\(x \neq y\)</span>，那么令 <spanclass="math inline">\(fa(y)=x\)</span>，也就是将这两段区间合并。关键在于如果处理合并后区间的和。</p><p><img src="https://s2.loli.net/2022/06/30/9EuZjHrnCLa7vR2.png" srcset="/img/loading.gif" lazyload /></p><p>很明确了。更新 <span class="math inline">\(a_y =a_{u-1}+w-a_v\)</span>。</p><p>如果上图中 <span class="math inline">\(x\)</span> 在 <spanclass="math inline">\(y\)</span> 的右边也没有问题，只不过 <spanclass="math inline">\(a_y\)</span> 是个负数，理论上也是讲得通的。</p><p>如果 <span class="math inline">\(x=y\)</span>，那么直接判断 <spanclass="math inline">\(a_v - a_{u-1}\)</span> 是否等于 <spanclass="math inline">\(w\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">5005</span>;<span class="hljs-keyword">int</span> T, n, m;<span class="hljs-keyword">namespace</span> union_set &#123;    <span class="hljs-keyword">int</span> a[N], f[N];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x==f[x]) <span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">get</span>(f[x]);        a[x]+=a[f[x]];        <span class="hljs-comment">// 路径压缩必定要做的事</span>        <span class="hljs-keyword">return</span> f[x]=t;    &#125;     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;        n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) f[i]=i, a[i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">bool</span> fg=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(m--) &#123;            <span class="hljs-keyword">int</span> u=<span class="hljs-built_in">read</span>(), v=<span class="hljs-built_in">read</span>(), w=<span class="hljs-built_in">read</span>();            <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">get</span>(u<span class="hljs-number">-1</span>), y=<span class="hljs-built_in">get</span>(v);            <span class="hljs-keyword">if</span>(x==y) &#123;                <span class="hljs-keyword">if</span>(a[v]-a[u<span class="hljs-number">-1</span>]!=w) fg=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> f[y]=x, a[y]=a[u<span class="hljs-number">-1</span>]-a[y]+w;        &#125;        <span class="hljs-built_in">puts</span>(fg? <span class="hljs-string">&quot;true&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>);    &#125;&#125;;</code></pre></div><h2 id="solution2-差分约束系统">solution2 差分约束系统</h2><p>这个更显然了。但是给出了是 <span class="math inline">\([u,v]\)</span>区间和一定是 <span class="math inline">\(w\)</span>。那么直接转化 <spanclass="math inline">\(X_v - X_{u-1} = z\)</span>，<spanclass="math inline">\(X_{u-1} - X_v =-z\)</span>。由于是直接等于，那么直接添加双向边<code>add(u-1,v,z)</code>和<code>add(v,u-1,-z)</code>。</p><p>SPFA 跑最短路，判负环。</p><p>图不一定连通，那就搞一个超级源点 <spanclass="math inline">\(n+1\)</span>，对于节点 <spanclass="math inline">\(i \in[0,n+1]\)</span>，连接<code>add(n+1,i,0)</code>。注意 <spanclass="math inline">\(u-1\)</span> 能取到 0，所以不能用 0当超级源点。</p><p>有负环说明账本是假的。</p><h2 id="code-1">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> cfys &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">int</span> dep[N], d[N], v[N];    <span class="hljs-keyword">int</span> cnt, h[N], to[M], nxt[M], w[M];    queue&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; to[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) d[i]=inf, v[i]=<span class="hljs-number">0</span>, dep[i]=<span class="hljs-number">0</span>;        d[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(n+<span class="hljs-number">1</span>), v[n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;            <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();            v[x]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;                <span class="hljs-keyword">int</span> y=to[i], z=w[i];                <span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;                    d[y]=d[x]+z;                    <span class="hljs-keyword">if</span>(++dep[y]&gt;n+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 0到n一共n+1个节点</span>                    <span class="hljs-comment">// 最短路长度超过n+1说明存在负环</span>                    <span class="hljs-keyword">if</span>(!v[y]) v[y]=<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(y);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;        cnt=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(h));        n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">while</span>(m--) &#123;            <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), z=<span class="hljs-built_in">read</span>();            <span class="hljs-built_in">add</span>(x<span class="hljs-number">-1</span>,y,z), <span class="hljs-built_in">add</span>(y,x<span class="hljs-number">-1</span>,-z);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(n+<span class="hljs-number">1</span>,i,<span class="hljs-number">0</span>);        <span class="hljs-built_in">puts</span>(<span class="hljs-built_in">SPFA</span>()? <span class="hljs-string">&quot;true&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>);    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>差分约束系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Summertime Record</title>
    <link href="/2022/Summertime-Record/"/>
    <url>/2022/Summertime-Record/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="66be6a08bacdacaa35a8b3aba4f3f72f2107535a9413b4a3f07b8c13ee747870">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e11e690263bb5d36833d00286098962a2298c1afb2dc7ad29d40459db0aa4acffd9c364dc57d80d02fd5cc7d3fed20fe857d8b637add5a027ea47a1529f8353dea3c97e31b953653a8bd03132de113505189c1a7cce853f75067d146bf4fc900746ba07ecf1ffeaecf7aa10f875aa4224d2ebef12cba6ab645002d0ae383a01f349a27c3368293fcf7c31ed16261f0d445a8e90b69502bb82e00727fdb69c2bd0ede4184f8106da81c7b25b1160a60a28d74eae4669c7f95da07ec59d503d3178bca31eb1baf9bec4662a07a04ed01d63f6ce56bb0c2a37b456b49c771405b79b440467c1666d6fbf529d05121d838feb30913a77399b83ab8ade436df4fa3029b40c20934558e72fc55b48a1b3d445252d9f2f1adeea4c6114634f1d4a3dcfbe92df36d056d54add1b3a33e4b88e1411a31bb9fede16337969107b0670ae6d374e63ebaacc11db3081ecdc9ee5797a58164bd02586ca0065d169205564fef53b683aaa957e6ad77fbc8598d542525fd94d241612314e10fd297ac5558c56a2c69105dd21817e3a19f314b47d5fa8e81b0510eea64d7f951f5c5c2dbdb17406e3830ef6cff74da9b44c9b5b54679eb1c8e381e135a4d888b3f34da54a1b75069bfd75a3f3b6c2f676f8b795eaec2954dc653019a6267a69b17eeb7ab8ebd9abeb1a4e2c54ef3510d083911b74653c84e88345d920e4c6c0ef1e1e05199754cac9c37b12554d4e8b81f00086a548734c549cbb14226f16dbd8b775269a55a4357718320e70f09b2ba79cd6913fb1885a62b77c36d809661f28871059639bca3756fbf5ba71d979d3f02af4cee4a8f58b04f6fd53f33058de28443d48eebdf8e5ccea9f0c0aad712f4035a9be5ccefd3b8138cf11144377525a5f1e2fc4d0dea8ca187c46831aab3de1db0b5615080e1fc25ce9261b95f14e7c9c30a18fb58d5126b0a1f884130bbc23b20c778ab4f2d8e9771525005e58c32e7e522214052000f0db97f90e480a72934452ab3a4ef4548c28f2b792fd1b37bda228215159c298004f444eb0a3a37e979968cabf178a2180ffb1a5c708bc703a82b85f098b7e63558d4e8117f5b78d6f84cfeaba172735d9be4cf2360d4d2a28ff180c6869b2cf28afeacad4057522b2265351ab6ff3bb09b33f042daf4b9df60bc9ba104021babb673913dc975fced1842c14213819bb9df768d46929c00f213f4b10d5d0c2a34ddbea9a24e152d5d33c0d3ad1172c302871744721eab86807b5c6475da36b8c9da25f7b21533855bd329a06decb508082199b475efe689bea5a6caf32285934e11e230e8745c7234d9000e70b20aa7c0731b90bc608c7a003d4d56603f229cd1ee57aeb8ed4b21de53810f289ea46845e6521759628c1aa2ceeda33881a3c3b30dac4ff1c774c4090aea73a118d22837f9e18a60afb9488852c40eb4edb3388c8feca63a73dfbb7626fa4c4502d0fc68b268fe1af609a833e2a34c59bb2dc080e9e219efd9ea7babcd77daa349ddeb38b82cc44680313116597c9ba5c4906588fee493e39e1967cf57dd0a92aad880b08a57c1a1161417ee208e2e38642db5af78c4b0830d0eb1ea75a2d012d87e85306483caa6bc765d2c381863c5bcd17e1bb8e044e20e80c77b106eb9326325a405ed35dfbdd7b7d477e22ac457409ebe9595d242505bcb3255e7f1f854b63b14abe314d3984da8fd01b18647079e74b4d20890163fd308f012fa9140d54bad6c645ef84246ec3f99a5fa002ccbb22c6cc998eafd7ba7d80758b954c151da9b968474585fb0bce7585f6304143e8667326b1b4ee702895935d38c937cea81f222feb23b6734f6477865cc9a47513340f7e2ec284db2f4b6c5c096e41087acf12995c9669f8cca1d335497a88f4a2c72c212dc41d4154432f95aa91748a41f3a77e5d0d95ca1f33e376a8661df52ca4b44f7475c5bf0507e5fa790f3784f09ad52c3e80ecb17f6745d661042322b11739285ea4a3db8adcd442f0ad538487b5beac83289bf756fc9b02806c54c527089aff9374d4b5354b30f946a66f40c3a2069da22384427f39051e1a291d140fafebfcd0bd1d6af844ae2e7a8be562f81eaa31403556e7c2b513116fc4c8226d45d3e0e1b57985a7d064eb2d094e9fb938bb137f8824771678fb18d26a40924ff889b4dbef922877c09b006b800bc4fed8e8470703901bbc30d8f4a4444de15304a995970e884982aa014d649a638fee1d9f872f7d3a14ba3c0c81573598a446cba1b8252d0daadb5608ac5a9f16c7813df4325717eaac1849ca7d6a46dfb3ef8e4f70825fddd5ada5a25a8c3e0276a47db68dc22b37322a6b8e821037ff4fb37780d0d0abe6d55d584fe01610cb0bfcfa42af0cde2e8cf8b10431467e7f54ed57bab258321abf6cd1fb974f9739872842bfa92c6525de2b4be7798af880e96dd99033ce0d95457984f8c18ebeb6fabab0927b973734271bc2c1dc2d8da883263de234843ed0e721cbb305fc72bb9e7ccc6bd73eafb88fa27c25c43e1a72df0e5a67e681ea187319f40bbc51861f2bdf162693b46af3207ac5b2d28d4adb3914984815954aa3c3585ffba5d456fdc16fdddb1ee189c35cda03698442b78852de9cb7bd922060cb10c2ee6ac12801237d3c1dca20510386a941d865939a920663ab691f0e633cb001994fb3e9f18aed0082f6f3179c3765ce247f17eb4995caf4579d7afa0350191e2835d2e4606491da229b279e6d43db39e2be6ed2f6fb551e2eee470de6548680f95de54b95bee59092648135d1eec759bba6123c69607de1f5ab71b94d235988211d6261432d913ca8eb79641a08ef6a4e641af56be31282c1703e72c8ed99a5c2507f678ef8614380d8f8b0b58ca80114135fb659a7fa48ceaa12118d3ca859c93e9b6fa81879a07442d0da0a5181ae8fc6542938b6d3e17832e44e0cc292613ba3b3113864941e53a6b9291f2ebb21a1919d7d7cce176af35a88fe79aba4474f7c995c6c827519aad7214f79522d8d3cb1ab5268e19d494b8b7232821ae72f230ca3870bf32439cd3719e8841f33410c82e203f6338e9a9326923403fc84d25f64f0eda077fa51e0fc928cc187b5120aee06288be8fbb58e8de7635</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作战，可能要失败了</title>
    <link href="/2022/before-failed/"/>
    <url>/2022/before-failed/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="cd1d4e79ab95d9d186bb95094edb32b169f6254bbf92a8924eb80aeaccd4b4e0">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e1c8daff8637877dcbc3e16862f8935b514938a8e435ec280c93a7f9f2e4382fffba0ba546080edf3d32fd8358cf1762747d01f48ba754e7ba245a6ed330ee8e21dc24fb43c140dad81c3b27a3a8a8ca629752482b6be4c5881ce066ada9c7115c4fed9e391e917f5d9e906134b36e1c146a4257f715866c585da2dccdf62a576177c8f3c6c60225ae98941e2d13e5c8398b8c8f70b35dd8ff2c1e0bbf037543e661e0b37ef5f45a74e61a30bf5101e9b98cc4a13ce4ad1115ac371f18bdca6d293601fa8b4ae2c61eaae073e0ccff8c1c6952ef4c95af4276a1ff22d5a05bc6c5ef5b58a69272766d8e6f067d6406d35505db0ad3daff722c3f147830929781122620f52611a420d19948b95ee915c8bac180e9af0197bc88642d9a66ea31c54f942dd2e90b552cdeeabc06e803864e109accefd88f7c51ce94e7f5f060040841c4ecb08e93cf7192a89e7927e0eb1aef99172683ab44d8f9cf41e8104994554caad277e5c2fb53f867b55918c28d64c5d7e2fef23404f06739ed66c8ab44512533e45431979d568240ee6641083cfed3426a16769afc37aaf6d179fb4f20d9bace6ca072db955be878b89fa0fdd8383c0c8d70d749048ac5a9e1aab32d913f88b40d99896ee25578071ce26a637afbd319dc8b9326cc2c8f7fecaef79339b34c191aef4f1c4e643e513179fec65cacd5af545702489d31129aa30a8a6f9025c64e01c3c3d9283588543b0d08ce13f8027cc8de15b8ad5ad85cf7ab6b668f751805ebdaedbd730f2a5344b36682db4cb3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#10 最后的作战</title>
    <link href="/2022/yume-10/"/>
    <url>/2022/yume-10/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9872a34300eac35616e0f086e01f060a25fe40fa22770445c36e7a37c7b7d433">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d805ff010550e9831b5932356eff5e98a3577ee63135542c44014e7a20a6367f3a26cb11e2bfc1577906d6f0cb9f275d5f0accc8a623f50ece5e4d4cad0a517f37bc17b7338d6b6bfe4d7e814f337837c1c902ce78b17822f37338127aff6ed79ef2482ff24c8fe7a832d4c07d7285e69254ba660dac86d96174f53af93b5968ed3f5cd610c13c104974ecf7914cb111401834a18cdd54eadcaf88cad79728f83630f7e5302cc6e14c0d0b361308acf70c464efa6ba60c5b1c6e59688de18bec9503dbc898ef101dc71c0f07136ec875a6aea20db7848dbbda5cda88f75f6103565f9a78a083bdf591452b1afb2485651eed736e563a6f03ac04941dc75a966da17107971ecd4357ba5353e2adc4b1d639adbb8d69f04157c4421ec1eea17bf108ac076caf8380e9e1f3db8de6892c79a54a0be047fb06a373682600adb46b6740d8636dc42c149d9f2d068c7237c360c8e7d0ab2544e4b39d0260297358a48625d5423aa6b029653e442af53ce36adb35fc73999aaac60792cbc682cfbfd875e4a5a599e020ccf040f87ca19d4eeb45dd8d436a68c9ebdc1df6ebb8ab4d00e47912a9ca525cd6ed24a0064eac892650df5f3b25ef3aad7e103bd493e845e72b589f57cde2a3703e720d19b24e01a5899d044b93beae1e73d9218f57235d2f64e63e4afb4cffcff8eca20bed3011ad0a4577936a497ed42223a6f68bf1d17a7a2bb507021da523d10f68ee337a94e7d0cb8a9415cacd1cad0fe8094671f73ac4faadea2e6511b1f143959bcda6de73c26a148920a764977621e195ef9d12577d91f55e9ec5d967812b480224eeb758b7f58455d74f5d1f40da9d1ec276610682de2f51d4e28faf9354614aa53961b5a16ffe787553274f190e79e906a19e75cd19b53237f1c5118d6a839d090c40c877eb1c91da041c8f8545ebf7c62b5778cf74e5f843e952866d5477fde3ccd8c6383c8bc5a21f0e2d5a0db432bbc58b72ca3f166dc70c82a8955c8f6971b521d49c6ba1f14d357d11353f6303cfe3de83e58e1c3b53b358cc53933dfbcd611a6d569ea6efc77606d773e9a842b94ade47d9e2f196637d765d0278df46e6f82fbc4e20a179c3db9fb4df5ef0c972d91ca30c8e398069a59765edfa41d15c5347e444d6789d117ef4d3cd3ca5322b28a076e65c50ceebe94c3ca69f14828e809312740764076557c75c031c4986d9989f05823a46b5313344181ce78e544f0c148a80dbca11b15115650d9dd09152dd6043479a15e19326d61df9a695e0a686227592e498284783cf61004c4ec750b21f12ffafbb315b0d3e9f84226d841f9916a5373014b2b9c5301e90e4dfe4df9c63493f39e93b98912939d3d010b6b3cc83c0c5d1068c80acfd76ddeb45eed5aa9c6f9dbdc7a94b2c0fbd48f26b9e7cec05a0eca2b4388741c964b2c7cbab016c21e2b23fb2a4d49193149c03eb4073b2f3f00ded1e44c82d062e3573d2f7eec61f25c64c58c434f1d713670cf04f225e63bdeb5bf7919f0dd55a6f25593ace30b4b601c37a2a2dbdeaf19b78ed59faa6f7944754d5488299a25f39a63f9ac74aa5a0f0274efb0e6c16cb91a3995bb06e2bbe8dea510d831d29571572e510312e51ab684070eb11c47aa7cd2162875bc18aba5c0882ec24216470eee3b5bce2c7b2c9e9513673aee4aced4a4759e48b986f1b38ed7884dee459c677a1957cd369f392c37efe85dddd62aa73b4bdb2caef21a0218ed93d568779814b5b7a55173d2087ccbb331faeb9040782cdad4a2d64921ed48d6086710611fe964a655ff2536ba4a03a6c047d64801c43faefae700d39e8437b8803500a59c4ce5f6f7e2e092ddf5b3fdb8d83793ed44d9be82101dbc437f8ad84a1dd8fb5cb1c561f47ece8748fe31548499f11918e2860969a21cd1c6cb1d2eb7a2fe26e7c2e4a2a816fb89e5ecc548026b3e9b3e9be34a23e80f2fe5f39741ea7bdb90a90c102622a860465a18c19fe308c5ea62893f8c0082bc9a9039f7cf927d46bf7d914bb516ba9f9fff9b7fc29cd1ba7f293173f265dc3ed8c79e18f4c4507e6a6739d90dcdd3f0731d2d815c32b00a1dcf1fc174e5ee4c370b52137c65622874d6e359cd4e994d62d4cd5c8d8b509787ac7b4f6d51b8b3b04e8bff48cd55228463716f28b4a7cd93d8bda9b1868a90dd695246e2027ae904b84b500ce817f5a0a64f19da05675a79c6c87969bdc1cbfe4017d9dfc00ded819ffd43ca327cf211350ef33d3e9076eab58cc190ceef43b935f651d293714003a1c74f3508abe562fb4a80727a081f50b18de6d0cbf25d1838e3ff3d7f48b34c49cab442679b206be7c8d2d1374c75830123cf49f52084b478b88760febb1a26c3d6a06f1472af723ab03e714493e4b1458571ba6efbdc7ff3ae01c97a83e5b6c38d34fd38222c2268c4aa8041a402301293a2c0d27d684f1d9bc6dc9d8ae2a9f56d135356dfc80d888dd24a332766c39536f5b7d3d934c17f3cfbc8ad1f0e1e660468a8891221782dbce05b8027c48a6e309aaa926784d3b3d3ce1bdafa3e0495b209cfb2a6989d4c95fa4a4f48bfa04454c260ae1d488c509140c56c25497265ea247cb6d3cba22c86a954cec60e87bd460ff8bc5e6f8738755d9cf1f9831ed299e684699603b36e9533e45e4cda9fc4710f327f0b82c1566e5027e1ccfd6bd2055b1b9cd3b922d213df3350aefaf9670cc196fb629544423ce259394ca6d180a3dfd6e1ee7c4fd6e1bb21f858c846d96bfa95b01fa56834097d5ffcb6fd2367bdd92d54019b1018b65fe513de24cba7518fe8f9190a55e5642e37881e9ae464ff4acfaf475c58e84f535961802a1a8ad5802f167b094b9b554fc195049634d6eae8a10f79996eea3487d17bca9634afcce065b4dc653622bd645b782af137d8242198b5c2ce773d417b52f3b489ff63ca423168f3158d08ed372dcc686370aedec4128bda1f7493333831ae5df6d31042158345633d6d3fe9538b7313d103d4b11a3e7f7726888593a3a5b547218e6237c371fddfcc86dc9a96ec54c49750131e3f540381b447bf729c363db05d0a2bea5f470e963123f4bbdd88b4132488adbef7fd5e02ecd48b763b2e67d6038f6cdc5d4fb5a0a13191baa9a5e3adc272198dc3a1cbcb76d93a12388b3da4b44135cd9ba61ac74d236f938cfac7318231b2b2a285b29a8cb4c141bbe258dd7c3cb88df3cbe3d5980294fc0cb419a74e2438939c5aa08943daa3fa7104b0d3eeffb875330a1c453857854ba0c4cc52385a8780ac1ab1c112586de40068ffea5508b28be7109908a3ff916d9c3b0adfab8e0e5efe0cda2a894b41e790cda6beb1355a5fc0ba014c49de944a3d7d728c42533fbe82fd9391f45cfcfdf6e849b96a8f6357bf07c5358b2a0141c1580433a451acf9eb200e902fa9f034fd127aa8f014bae8f213f8dccd57c67f7d47c4dc466bdc084c3636fce3a55845eaaebf66a2040c3d127c0a8773b48b799eeb904ae4dc180d4c7b61f038131912e5177f733060f5f319fb8b994ea3f92dc09102b54de8fc64748869ca983959729ca368e48ccf71ab3ed437c25cbc81408cb2bf06b0f7630cfc74a960c9c7abb0da445230c856af177616ff3a78cd267db9b34f88f117026962d103725965ecfaaca4aef98fc590e74e5e531ad836a11f4c767da9019a0215ec83887d83cb5e2ee39bc855538f39417bd3df00469b34ad65c21cfebd91089d1f3143ddf717e9b2bb50755273afba1aba7b46dd949cbb1bc31c21eea86d63adc189514f1d3a8cb1d3209f78e29a95a9daedfea17f1ebc3dc002233a89bbfcfed9cc9b663e12bde7c190c9fbae90dc6924beedde458dd2cf2564a7c9938328452ecb5ce6aef2f5a3693a7f1cb9dafacc3d2b84c171e65dbfd99409fd05f81a4475e9657ab9fd7a77a1283d03203119e642cea27de70bf7cf4380787e067a211c60a0c71bc7fa0f21c8d04c1e0570c4b287b1e405ae3c52a7289742c945a42f0c96e8da46d0de405a9d5f001b9ace9a615a3afa98bf292d26ef4415a2cff892aac54ff855e81349e8f02b55c8f92c25264f09652fee65d0bc88de130c39287e43fe45add20457582c5a66124acde909c130a513b97dead8dbf5b0283367ee1d473e273b54cb7484bfb8ebc448a393f29b01b549f6773787ec118e8e6d7033ada1e89ddbd0e41feeaef0a7ad5ce86b40862a72e1c7e8997c6092a698b2645857921be50786769f706903edf55ecc3d7b26c92b218dd8d358771c9719033c3924774b597a7bf7e3cb50efa357761fc07ee48bbdb57666e38fa40654383504155d5b49630e65341f7e7bab54d61ac7d103dbe2b9d2d8546efaec2a0923eb189720f8dc35b775771b61b7d38c3771c87a290f3e56730980e7739d79a4b027b529f576cff2b0bba0c4a3fd91ddc6fef7c6a162271753f8ddd01f407f218b475c428449288fce5c4d18ef89a43370c939184e25444b46f4a85c45436455727b26b77a3419bb55e611730bdac61e02552e07bba81703cb6ac10785b962e4931217503e1d41c777ae2da59a70f1aea7d234dba7eb015e435fcf2ac8b0134654d40d800440d97bd43969da8b2ff56911c30f81e145c2a3e68aa8f82eeb0ab5d2afca4700e52a69d1b394019b66a3f4b701284990386417f0fd3ab698fb3654a59acf058f7e9ed75059087fa5b41e508c578fb74a37b834e52b3a13666437719e72d048194365133f2b8107ef334d98cb46b8ebcfd442aaa7bb4ea8645d3365d46dae5c0487dd2f5e213ea3b261b6286bf69d5d7e443097d2a223e9bcdecba35cc7b2160ae9719e0dc5beca5e4418163261fd9e4869d4ee66634a61e041d461bf1695e4c8d799ca9dc4a9371efe8fffb83fa6c51dd9832e0eb6637f418e92c5fed006140a7a3a69ad840da17b6de416365fe65d6dd47438ade082a1d5ab11aa3a54e5f5b299da148cde40999d20367305d41f37f4bb199521d1826ac27279829b846cd32c0690ffc6f3fb4bdfc2078d7025251ee487ea0b64ee88c7aace1b2ca4d257232447545766099078ecf5f603fafe5c6f6fb942ef878fe5ed6aadb1c92ad7d5a746b60eeef7ba11e654751cec9e0759ca80149cbdb6713f80d63e12e3d75367edbcad402eb5a743017706c44cc9acc8ae5642cc99cb6a0e1735352ccf31c79a45c71f3260d5e3dfe41e2c138dad017e5e26eb5b2d220091715c5dc71ddd1ca3ccb0a9b8fa8bc52c0020fe534c056b426264d646bbba3e376fcb8aac9ebd0302b664679e839369dfedde29eb38d1013c70904e938b886071ee19b04330db63b9627d39426c8bf5464f050f4b5b216f0d30ff844d8e5d574b1c61abe7bb1c52c5882a1a12726c90ebb5337a0f2f11ebb9cf12c2568c89c7c564dd99b6cf01b21ceb8885e5fba81b76d077e1c6c62cdcd899dc521682d0dd8dd79da864d70f629ad2b9a87f4ffec2d1c60898907c8c02515ce6bbdaca22ec72993f85ce66f0fcb799ae953450b0708ba0a4d99244c8ac8305b0392a9b7c0fab2e8878195a503d75d31686fade002ed6b8ef7bb950abda751eaf60e43d2ffd294e13bd4390bcc07c2c8b11d1235d3c3bba6a007dbbbb29ce2a9043affdee8bc01c561f2d8ab75841f693cedf3353ac90adf0b3e295b9bd267811a758bf423992cf4a4fa10ea01213e362aca1fe2af2d1130b7cff767ff53edd69d4427fe406b988427504b4d8a70a249c425da988a9b397f8e61907be1a2aa81c101bb83e3a9355ef0e722f6d4fe458b45e7e902bc4942b796f232ec8f262fb74f0379a9c22dc54c2efd720f0c5065184c9fe8fc01a95bb87cf6ce3aa4377e0be74ab8d60a3f6b9c03efd1b51408190e35195a1cdc9055c247bc2799d280b623dd7feb197e0327621dcdf48bc3564dcb0b68bfeef96848ead6fe38745a1d72678e4ed725f4e767932191caa76f09d6e637260929f8bfaa2f630eceee780157ffbba45b129e8b13cf47b70307de2ae531299d6c08b46ac11b00f17dbaaf7da1a9756f69f9c4185916b824c9fd4a79bf735909f75bdc91acf3a7509e5c68bb6c08fb2e8b010d5b0c00390fed49b185829f86e7783c36d9a9c5adcdd26712ba836ff0300bad4f8a2b2479f50a3f44844deb35337215bee85e552a224c990400e44309cd59b397398b79a0add740788168b058b7d169b470b981f91c3ef50f379e8e344608a5b153a9386aff556e0f5ed7f9cb5eb61cd7723295c21e44c748265554f5696fe0846891fe56535ab5c1941a5fd5643aed435ea431c6d048a11f1f327f4258231131c81b188fec227c06bcc2f25113bd3104f9ba3a3acdb9e39d3fd2be328ef1ab36e91776982af2d14a21d39c87a6a6ab2556f9727951c839a798bbfd02b3a08ae13d9e7bd800d1a92b38dad18dc517d4393ce48a959d30d5695e52720f6ff543772e824e4ed6a9768333636835661f352c8491da8b361fc9ee197f8238a63b5f8185f45cbaabb2c10fdbf9eb647fd72910ea67dd1f847aef3bdbae12673502e9cce784d3b2440a61592503cec98a58e9f68de30a11b36939ea02dde66e047e22d6e2e9ff7957a0d37ecf5fdd254c8eb33342a5cba69ef4af8b0d8579ccc6d4576b432759d1064d7ef0d4223ed43ed827791b307871843e4bd4f04ae72ff5e0e50f27434325f1359ae25141e0b43d7261d32e8ded9fb7bba7a37156faf91f922420e4fb1ac023a74e59aa15737989aa1129ba8c9556ed8b5bd9df350c5e84a5a03531cac0a84a9d1ec6d8b427a0c782fbd2dd3d6429f2fdcea239011511fc25d93946c88e97eb03e52adb186f07a097654dd319161c2d9396fd3ec4cde0c04eb11a2aab65259148e9c98918e88bafe15ca6d9758dfa33e45125a95e66c097097916490516acfcabf4f5a0887c2333c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#4 二分图相关</title>
    <link href="/2022/notes-graph-4/"/>
    <url>/2022/notes-graph-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="二分图最小点覆盖">二分图最小点覆盖</h2><p>给定一张二分图，求出一个最小的点集 <spanclass="math inline">\(S\)</span>，使得图中任意一条边都至少有一个端点在<span class="math inline">\(S\)</span>中。这个问题称为<strong>二分图的最小点覆盖</strong>，简称<strong>最小覆盖</strong>。</p><span id="more"></span><h3 id="textkonig-定理"><spanclass="math inline">\(\text{k\&quot;onig}\)</span> 定理</h3><p>二分图最小覆盖包含的点数等于此图最大匹配包含的边数。</p><p>看证明过程时，请牢记增广路，最大匹配，匹配点，匹配边的定义，不然像我这种不太聪明的可能会多想很多没用的东西。</p><blockquote><p>证明：</p><p>二分图的最大匹配是所有此图边的子集，且其中的边两两没有共同端点。那么最小覆盖中必然包含最大匹配中每一条边的任意一个端点，不然存在一条最大匹配中的边满足任意一个端点都不在其中。也就是最小覆盖包含的点数大于等于最大匹配包含的边数。</p><p>如下进行构造。</p><ol type="1"><li>求出二分图最大匹配。</li><li>从左部每一个非匹配点进行 DFS寻找增广路，必定失败，同时标记访问过的点。</li><li>取左部未被标记的点、右部被标记的点。得到最小覆盖。</li></ol><p>以下证明它的正确性。由于出发点是左部非匹配点，那么左部匹配点一定没有被标记。而右部被标记的一定是匹配点，否则就找到了一条增广路，与已经求出最大匹配相矛盾。这样选出的点数恰好是最大匹配的边数。</p><p>以下证明它能够覆盖所有的边。分类讨论。</p><ol type="1"><li>连接两个匹配点的边，只会有一个端点被选择，即被覆盖。这是因为求出最大匹配的DFS中匹配点与非匹配点必然是交替访问的，而由于左边选没有标记的，右边选有标记的，所以绝对不会出现下图中选择<span class="math inline">\(1\)</span> 与 <spanclass="math inline">\(A\)</span>的情况。进一步知道，对于一条匹配边，它的两个端点必然只选其中一个。</li><li>连接两个非匹配点的边。求出最大匹配后便不存在了，不然就是一条增广路。</li><li>连接左部非匹配点 <span class="math inline">\(u\)</span>，右部匹配点<span class="math inline">\(v\)</span>。<span class="math inline">\((u\rightarrow v)\)</span> 一定被访问，<spanclass="math inline">\(u\)</span> 一定不被选中，<spanclass="math inline">\(v\)</span> 一定被选中，被覆盖。</li><li>连接左部匹配点 <span class="math inline">\(u\)</span>，右部非匹配点<span class="math inline">\(v\)</span>。如果 <spanclass="math inline">\(u\)</span> 被访问了，那么沿着 <spanclass="math inline">\((u \rightarrow v)\)</span>一定能找到一条增广路，矛盾。所以 <span class="math inline">\(u\)</span>一定不被访问，进而二者没有被标记。那么就一定选择 <spanclass="math inline">\(u\)</span>，一定不选择 <spanclass="math inline">\(v\)</span>，被覆盖。</li></ol></blockquote><p>图片侵删。</p><p>红色边为最大匹配，红色点为最小覆盖。</p><p><img src="https://img-blog.csdnimg.cn/2020031711564475.png" srcset="/img/loading.gif" lazyload /></p><h2 id="二分图最大独立集">二分图最大独立集</h2><h3 id="一般图情况">一般图情况</h3><p>给定一张无向图，求出一个点集，满足任意两点之间没有边相连，称之为这张图的一个<strong>独立集</strong>。包含点最多的那个称为<strong>最大独立集</strong>。</p><p>给定一张无向图，求出一个点集，满足任意两点之间都有一条边相连，称之为这张图的一个<strong>团</strong>。包含点最多的那个称为<strong>最大团</strong>。</p><p>一个定理：对于无向图 <spanclass="math inline">\(G\)</span>，其最大团为其补图 <spanclass="math inline">\(G&#39;\)</span> 的最大独立集。</p><p><span class="math inline">\(G=(V,E)\)</span> 的补图 <spanclass="math inline">\(G&#39;=(V,E&#39;)\)</span>，其中 <spanclass="math inline">\(E&#39; = \{(x,y) \notin E \}\)</span>。也就是对于<span class="math inline">\(x,y \in V\)</span>，如果它们两个点 <spanclass="math inline">\(G\)</span> 中没有边，那么在 <spanclass="math inline">\(G&#39;\)</span>中就有边，反之没有边。也可以理解为，将 <spanclass="math inline">\(G\)</span>扩展成一个完全图，然后减掉原有的边。</p><p>很重要的<strong>补图转化思想</strong>，从问题的另一面打开突破口。</p><p>对于一般图，最大团与最大独立集是 NPC问题。（<del>好了不用学了</del>）</p><h3 id="二分图情况">二分图情况</h3><p>一个定理：</p><p>设 <span class="math inline">\(G\)</span> 为有 <spanclass="math inline">\(n\)</span> 个节点的二分图，<spanclass="math inline">\(G\)</span> 的最大独立集为 <spanclass="math inline">\(n\)</span>减去最大匹配的边数（最小覆盖的点数）。</p><blockquote><p>证明：</p><p>选出最多的点构成独立集。等于在图中去掉最少的点，使得剩下的点两两不相连。也就是用最少的点去覆盖所有的边（然后把它们删了）。</p></blockquote><h2 id="dag-的最小路径点覆盖">DAG 的最小路径点覆盖</h2><p>给定一个 DAG，要求用尽量少的不相交的简单路径，恰好覆盖 DAG的所有点，这个问题成为 DAG 的<strong>最小路径点覆盖</strong>问题。</p><p>设原来的 DAG 为 <span class="math inline">\(G = (V,E)\)</span>，共有<span class="math inline">\(n\)</span> 个节点。对于 <spanclass="math inline">\(x \in V\)</span>，把它拆成 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(x+n\)</span> 两个点。将 <spanclass="math inline">\([1,n]\)</span> 作为左部点，<spanclass="math inline">\([n+1,2n]\)</span>作为右部点建立二分图。对于原图中的边 <span class="math inline">\((x\rightarrow y)\)</span>，再二分图中连 <span class="math inline">\((x\rightarrow y+n)\)</span>。最终得到的二分图 <spanclass="math inline">\(G&#39;\)</span> 称为 <spanclass="math inline">\(G\)</span> 的拆点二分图。</p><blockquote><p>定理：</p><p><span class="math inline">\(G\)</span>的最小路径点覆盖包含的路径条数等于 <spanclass="math inline">\(n\)</span> 减去 <spanclass="math inline">\(G&#39;\)</span> 的最大匹配数。</p></blockquote><p>证明暂略，有时间补上。</p><p> </p><p>如果简单路径可相交，那么就是 DAG的<strong>最小路径可重复点覆盖</strong>问题。</p><p>最小路径可重复点覆盖中，如果有两条路径 <span class="math inline">\((x\rightarrow p \rightarrow y)\)</span>，<span class="math inline">\((u\rightarrow p \rightarrowv)\)</span>，那么这两条路径是相交的。但是如果添加一条边 <spanclass="math inline">\((x \rightarrowy)\)</span>，那么就能让他们不相交了。</p><p>进一步地，对于任意能够间接连通两个点，都添加一条边让它们直接连通，然后c拆点跑最大匹配，用<span class="math inline">\(n\)</span>减去就行了。但是一旦加边后，这就不再是一个 DAG了，所以如果要用网络流算法求最大匹配的话，对于间接连通的点对 <spanclass="math inline">\((x,y)\)</span>，只需要添加 <spanclass="math inline">\((x \rightarrowy+n)\)</span>。但如果是匈牙利算法的话就不用考虑，因为邻接矩阵的特殊结构。</p><p>上述判断间接连通可以用 Floyd 传递闭包实现。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1582E Pchelyonok and Segments 题解</title>
    <link href="/2022/cf1582e-solution/"/>
    <url>/2022/cf1582e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>倒着选区间。</p><p>设 <span class="math inline">\(f(i,k)\)</span> 表示从 <spanclass="math inline">\([i,n]\)</span> 中选择 <spanclass="math inline">\(k\)</span>个区间，其中最后一个区间（也就是最长的，最靠近 <spanclass="math inline">\(i\)</span> 的区间）的最大值。</p><span id="more"></span><p>当 <span class="math inline">\(k=1\)</span> 时 <spanclass="math display">\[f(i,k) = \max{\{ f(i+1,k),a_i \}}\]</span> 当 <span class="math inline">\(i+k-1 \le n\)</span> 且 <spanclass="math inline">\(S(i,i+k-1) &lt; f(i+k,k-1)\)</span> 时 <spanclass="math display">\[f(i,k) = \max{\{ f(i+1,k),S(i+k,k-1) \}}\]</span> 限制条件是由于</p><ol type="1"><li>选择包括 <span class="math inline">\(i\)</span> 在内的长度为 <spanclass="math inline">\(k\)</span> 的区间不能越界。</li><li><span class="math inline">\(f(i+k,k-1)\)</span>实际上就是上一个区间的最大值，要符合题意，<spanclass="math inline">\(S(i+k,k-1)\)</span> 这一段和必须严格小于它。</li></ol><p>最后倒序枚举 <span class="math inline">\(k\)</span>，首个非 0 的<span class="math inline">\(f(1,k)\)</span> 中的 <spanclass="math inline">\(k\)</span> 即为答案。</p><p><span class="math inline">\(\frac{k(k+1)}{2} \le n\)</span>，是 <spanclass="math inline">\(O(\sqrt n)\)</span> 级别的。</p><p>复杂度 <span class="math inline">\(O(n \sqrt n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, K=<span class="hljs-number">505</span>;<span class="hljs-keyword">const</span> ll inf=<span class="hljs-number">1e16</span>;<span class="hljs-keyword">int</span> t, n, a[N], lim;ll s[N], f[N][K];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;lim=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i*(i+<span class="hljs-number">1</span>)&lt;=<span class="hljs-number">2</span>*n;++i) f[n+<span class="hljs-number">1</span>][i]=-inf;    <span class="hljs-comment">// 边界</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i;--i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k*(k+<span class="hljs-number">1</span>)&lt;=<span class="hljs-number">2</span>*n;++k) &#123;<span class="hljs-keyword">if</span>((k+<span class="hljs-number">1</span>)*(k+<span class="hljs-number">2</span>)&gt;<span class="hljs-number">2</span>*n) lim=k;        <span class="hljs-comment">// 如果成立，表示这个k合法，下一个就不合法了</span>        <span class="hljs-comment">// lim记录最大的k，不然开平方会有误差。</span>f[i][k]=f[i+<span class="hljs-number">1</span>][k];ll S=s[i+k<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) f[i][k]=<span class="hljs-built_in">max</span>(f[i][k],<span class="hljs-number">1ll</span>*a[i]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&amp;&amp;i+k<span class="hljs-number">-1</span>&lt;=n&amp;&amp;S&lt;f[i+k][k<span class="hljs-number">-1</span>]) f[i][k]=<span class="hljs-built_in">max</span>(f[i][k],S);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=lim;k;--k) <span class="hljs-keyword">if</span>(f[<span class="hljs-number">1</span>][k]&gt;<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,k); <span class="hljs-keyword">return</span>; &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">solve</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1197D Yet Another Subarray Problem 题解</title>
    <link href="/2022/cf1197d-solution/"/>
    <url>/2022/cf1197d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>还有比我菜的人吗？</p><h2 id="分析">分析</h2><p>最难处理的地方在于 <span class="math inline">\(\Delta =k \lceil\frac{r-l+1}{m} \rceil\)</span>。</p><p>设 <span class="math inline">\(g(x) = x \bmodm\)</span>，首先这是个在非负整数域上周期为 <spanclass="math inline">\(m\)</span> 的周期函数。循环节为 <spanclass="math inline">\([0,m-1]\)</span>。其次在每一个周期中 <spanclass="math inline">\(g(x) \in [1,m-1]\)</span> 的 <spanclass="math inline">\(x\)</span> 与下一个周期 <spanclass="math inline">\(g(x)=0\)</span> 的 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(\lceil\frac{x}{m} \rceil\)</span> 的值都是相等的。这启发我们从区间长度模 <spanclass="math inline">\(m\)</span> 的值下手。</p><span id="more"></span><p>设 <span class="math inline">\(f(r,k)\)</span> 为右端点是 <spanclass="math inline">\(r\)</span>，其左端点 <spanclass="math inline">\(l\)</span> 满足 <span class="math inline">\(r-l+1\bmod m = k\)</span>。</p><p>考虑最特殊的 <span class="math inline">\(m=1\)</span>的情况，设区间长度为 <spanclass="math inline">\(len\)</span>，上面那个式子永远是就是 $ klen$。当区间长度变为 <spanclass="math inline">\(len+1\)</span>，右端点到 <spanclass="math inline">\(r+1\)</span> 时，<spanclass="math inline">\(\Delta + k\)</span>，整个式子增加 <spanclass="math inline">\(a_{r+1} -k\)</span>。</p><p>当 <span class="math inline">\(m\)</span>是个一般数值时，就要用到取模了。设 <span class="math inline">\(len \bmodm = k\)</span>，其中 <span class="math inline">\(k \neq m-1\)</span> 且<span class="math inline">\(k \neq 0\)</span>，那么区间向右扩展到 <spanclass="math inline">\(r+1\)</span> 时，只会增加 <spanclass="math inline">\(a_{r+1}\)</span>，因为这是在 <spanclass="math inline">\(g(x)\)</span> 的同一个周期内，<spanclass="math inline">\(\Delta\)</span> 相同。 <spanclass="math display">\[f(r+1,k+1) = f(r,k)+a_{a_r+1} \quad k \in [1,m-2]\]</span> 如果 <span class="math inline">\(k=m-1\)</span>，那么 <spanclass="math inline">\(k+1 \midm\)</span>，进入下一个周期了。但是仍然相同，增加 <spanclass="math inline">\(a_{r+1}\)</span>。 <span class="math display">\[f(r+1,k+1) = f(r,m-1) + a_{r+1} \quad k=m-1\]</span> 还有一种情况，当 <span class="math inline">\(k=0\)</span>时，可以“重新开启一段新区间”的。新区间的权值为 <spanclass="math inline">\(a_{r+1}-k\)</span>。如果重启新区间，由上述讨论知道权值会增加<span class="math inline">\(a_{r+1}-k\)</span>。 <spanclass="math display">\[f(r+1,1) = \max{\{ f(r,0) + a_{r+1} ,a_{r+1}-k\}}\]</span> 有意思的是，当 <span class="math inline">\(m=1\)</span>的时候，<span class="math inline">\(k\)</span> 只能取0，享受同级待遇。😅</p><h2 id="code">CODE</h2><p>上文为了方便叙述，转移用的是刷表法，代码里用的是填表法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;ll n, m, k, ans, a[N], f[N][<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>||m==<span class="hljs-number">1</span>) f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+a[i]-k,a[i]-k);        <span class="hljs-comment">// 特殊状态</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!j) f[i][j]=f[i<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>]+a[i];        <span class="hljs-comment">// j-1 mod m = m-1</span><span class="hljs-keyword">else</span> f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i];        <span class="hljs-comment">// 一般状态</span>ans=<span class="hljs-built_in">max</span>(ans,f[i][j]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5687 网格图 题解</title>
    <link href="/2022/lg5687=solution/"/>
    <url>/2022/lg5687=solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>直接建图跑最小生成树只有 <spanclass="math inline">\(64pts\)</span>。</p><p>注意到对于一个节点 <span class="math inline">\((i,j)\)</span>，同在第<span class="math inline">\(i\)</span>行的节点向它们的右边节点连边的代价都是 <spanclass="math inline">\(a_i\)</span>，同在 <spanclass="math inline">\(j\)</span> 列的节点向它们的下方节点连边的代价都是<span class="math inline">\(b_j\)</span>。那么把 <spanclass="math inline">\(\{a\}\)</span> 与 <span class="math inline">\(\{b\}\)</span> 递增排序，此时就相当于把网格图交换了行与列。</p><span id="more"></span><p>这时候 <span class="math inline">\((1,1)\)</span> 既对应着最小的<span class="math inline">\(a_1\)</span>，又对应着最小的 <spanclass="math inline">\(b_1\)</span>，那么第一行与第一列都是要选择的，否则一定不是最小的。同时也可以推广到对于一个<span class="math inline">\(a_i\)</span> 或 <spanclass="math inline">\(b_j\)</span>，要么不连，要么能连的连起来，才能保证最优性。</p><p>最小生成树不能有环。画图不难发现，在第一行和第一列都被选择的情况下，如果在格子图中出现了环（格子图中的最简单环是个正方形），那么一定存在<spanclass="math inline">\((i,j)\)</span>，在某个时刻（不关心先后顺序）既选择了所有<span class="math inline">\(a_i\)</span>，又选择了所有 <spanclass="math inline">\(b_j\)</span>，其中 <spanclass="math inline">\(i,j\)</span> 均不为1。为了防止出现这种情况，已经考虑过的部分不能被后面的决策影响。</p><p>所以就很明确了，维护变量 <span class="math inline">\(row\)</span>记录当前行，<span class="math inline">\(col\)</span>记录当前列，维护指针 <span class="math inline">\(p1\)</span> 表示 <spanclass="math inline">\(a_{p1}\)</span>，<spanclass="math inline">\(p2\)</span> 表示 <spanclass="math inline">\(b_{p2}\)</span>。</p><p>当 <span class="math inline">\(a_{p1} \le b_{p2}\)</span>时，连起来这一行能连的边，前 <span class="math inline">\(col\)</span>列已经使用过了，贡献为 <span class="math inline">\(a_{p1} \cdot(m-col)\)</span>，这一行不能再考虑，<spanclass="math inline">\(a_{p1}\)</span> 不能再使用，<spanclass="math inline">\(row+1\)</span>，<spanclass="math inline">\(p1+1\)</span>。反之贡献为 <spanclass="math inline">\(b_{p2} \cdot (n-row)\)</span>，<spanclass="math inline">\(col+1\)</span>，<spanclass="math inline">\(p2+1\)</span>。</p><p>当 <span class="math inline">\(p1&gt;n\)</span> 或者 <spanclass="math inline">\(p2&gt; m\)</span>的时候，图已经连通，也就求出了最小生成树。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m;ll a[N], b[N], ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;b[i]);<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>), <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+m+<span class="hljs-number">1</span>);ans+=a[<span class="hljs-number">1</span>]*(m<span class="hljs-number">-1</span>)+b[<span class="hljs-number">1</span>]*(n<span class="hljs-number">-1</span>);<span class="hljs-keyword">int</span> row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span>, c1=<span class="hljs-number">2</span>, c2=<span class="hljs-number">2</span>;<span class="hljs-keyword">while</span>(c1&lt;=n&amp;&amp;c2&lt;=m) &#123;<span class="hljs-keyword">if</span>(a[c1]&lt;=b[c2]) ans+=a[c1++]*(m-col), ++row;<span class="hljs-keyword">else</span> ans+=b[c2++]*(n-row), ++col; &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#3 二分图匹配</title>
    <link href="/2022/notes-graph-3/"/>
    <url>/2022/notes-graph-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="二分图的定义与判定">二分图的定义与判定</h2><h3 id="定义">定义</h3><p>对于一张有 <span class="math inline">\(n\)</span>个节点的无向图（<span class="math inline">\(n \ge2\)</span>），可以分成两个集合 <span class="math inline">\(A\)</span> 与<span class="math inline">\(B\)</span> 两个非空集合，满足 <spanclass="math inline">\(A \cap B =\varnothing\)</span>，且任意一个集合内的点之间都没有边相连。那么称这张图为二分图。</p><span id="more"></span><h3 id="判定">判定</h3><p>不加证明地给出一个定理：</p><blockquote><p>一张无向图是二分图，当且仅当图中不存在奇环。</p></blockquote><p>根据这个定理，可以用染色的方法进行二分图判定。用黑白二色标记图中节点，当一个节点被交际后，将所有与它直接相连的点标记为与它相反的颜色。那么对于一个点<span class="math inline">\(x\)</span>，颜色为 <spanclass="math inline">\(col_x\)</span>，存在与它直接相连且已经被染色的点<span class="math inline">\(y\)</span>，满足 <spanclass="math inline">\(col_x = col_y\)</span>，那么说明图中存在奇环。</p><p>复杂度 <span class="math inline">\(O(n+m)\)</span>，其中 <spanclass="math inline">\(n\)</span> 为点数，<spanclass="math inline">\(m\)</span> 为边数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> color)</span> </span>&#123;v[x]=color;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-keyword">int</span> y=e[i].to;<span class="hljs-keyword">if</span>(v[y]==color) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!v[y]&amp;&amp;!<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-color)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="二分图最大匹配">二分图最大匹配</h2><p>如果一个边集满足「任意两条边都没有公共端点」，那么这个<strong>边集</strong>称为该图的一组<strong>匹配</strong>。在二分图中，包含边数最多的一组匹配称为<strong>二分图的最大匹配</strong>。</p><p>对于一组匹配 <span class="math inline">\(S\)</span>，属于 <spanclass="math inline">\(S\)</span>的边称为“匹配边”，不属于它的边称为“非匹配边”。匹配边的端点称为“匹配点”，其他节点称为“非匹配点”。</p><p>在二分图中，如果存在链接两个非匹配点的路径 <spanclass="math inline">\(p\)</span>，且非匹配边与匹配边在 <spanclass="math inline">\(p\)</span> 上交替出现，那么 <spanclass="math inline">\(p\)</span> 就是 <spanclass="math inline">\(S\)</span> 的<strong>增广路</strong>。</p><p>它必然有以下性质：</p><ul><li>长度 <span class="math inline">\(l\)</span>为奇数。否则连接某一个端点的增广路上的边是匹配边，与它是非匹配点相矛盾。</li><li>路径上第 <span class="math inline">\(1,3,5,\cdots l\)</span>条边是非匹配边，<span class="math inline">\(2,4,6,\cdots l-1\)</span>条边为匹配边。由定义不难得出。</li></ul><p>由于这两条性质，得出在增广路上，匹配边的数量必定是非匹配边的数量-1，那么如果将路径上所有的边的状态取反，那么就能减少一条增广路，得到一个新的匹配<span class="math inline">\(S&#39;\)</span>，其中匹配边的数量为 <spanclass="math inline">\(S\)</span> 中匹配边的数量 +1。进而得到推论：</p><blockquote><p>二分图的一组匹配 <span class="math inline">\(S\)</span>为最大匹配，当且仅当图中不存在 <span class="math inline">\(S\)</span>的增广路</p></blockquote><h3 id="匈牙利算法">匈牙利算法</h3><p>又称为增广路算法，用于计算二分图最大匹配，其过程为：</p><ol type="1"><li>设 <span class="math inline">\(S =\varnothing\)</span>，即图中所有边都是非匹配边。</li><li>寻找增广路 <spanclass="math inline">\(p\)</span>，并且所有状态取反，得到更大的匹配 <spanclass="math inline">\(S&#39;\)</span>。</li><li>重复第 2 步，直到图中不存在增广路，此时得到的 <spanclass="math inline">\(S&#39;&#39;\)</span> 即为改二分图的最大匹配。</li></ol><p>这个算法的核心为寻找增广路。</p><p>称 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 匹配当且仅当 <spanclass="math inline">\((x \rightarrow y)\)</span> 在匹配 <spanclass="math inline">\(S\)</span>之内。匈牙利算法依次尝试给每一个左部节点 <spanclass="math inline">\(x\)</span> 寻找一个匹配的右部节点 <spanclass="math inline">\(y\)</span>。<span class="math inline">\(x\)</span>与 <span class="math inline">\(y\)</span>能够匹配，需要满足以下条件之一。</p><ol type="1"><li><p><span class="math inline">\(y\)</span> 本身是非匹配点。那么 <spanclass="math inline">\((x \rightarrow y)\)</span>就是一条非匹配边，构成长度为 1 的增广路。</p></li><li><p><span class="math inline">\(y\)</span> 已经与左部节点 <spanclass="math inline">\(x&#39;\)</span> 匹配，但是从 <spanclass="math inline">\(x&#39;\)</span> 出发能够找到一个右部节点 <spanclass="math inline">\(y&#39;\)</span> 与它匹配。此时 <spanclass="math inline">\(x \rightarrow y \rightarrow x&#39; \rightarrowy&#39;\)</span> 是一条增广路。</p></li></ol><p>找到增广路之后直接回溯，将路径上的匹配状态取反， <spanclass="math inline">\(S\)</span> 中边的个数就 +1。</p><p>这个算法的正确性基于：当一个节点成为匹配点后，至多因为找到新的增广路而更换匹配对象，但不会变为非匹配边。</p><p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-keyword">int</span> y=e[i].to;<span class="hljs-keyword">if</span>(!v[y]) &#123;v[y]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) &#123; match[y]=x; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) ++ans;&#125;&#125;<span class="hljs-comment">// ans即为最大匹配</span></code></pre></div><h2 id="二分图多重匹配">二分图多重匹配</h2><p>二分图，<span class="math inline">\(N\)</span> 个左部点，<spanclass="math inline">\(M\)</span> 个右部点，从中选出尽可能多的边，使得第<span class="math inline">\(i\)</span> 个左部节点至多与 <spanclass="math inline">\(kl_i\)</span> 条选出的边相连，第 <spanclass="math inline">\(j\)</span> 个右部点最多与 <spanclass="math inline">\(kr_j\)</span>条选出的边相连。称之为二分图的多重匹配。</p><p>有 4 中解决方案。</p><ol type="1"><li>拆点。把第 <span class="math inline">\(i\)</span> 个左部点拆成 <spanclass="math inline">\(kl_i\)</span> 个点，把第 <spanclass="math inline">\(j\)</span> 个右部点拆成 <spanclass="math inline">\(kr_j\)</span> 个右部点。对于原图中的边 <spanclass="math inline">\((i,j)\)</span>，在 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span>拆成的节点之间分别连边。然后跑最大匹配。</li><li>如果所有的 <span class="math inline">\(kl\)</span> 都为 1 或者所有的<span class="math inline">\(kr\)</span> 都为1，那么只有一侧是多重的。假如左侧是多重的，方法是在匈牙利算法让每个<spanclass="math inline">\(i\)</span> 执行 <spanclass="math inline">\(kl_i\)</span> 次 DFS。</li><li>在上一种方案中，左右两侧是可以交换的。设右侧为多重，那么让每个右部节点<span class="math inline">\(i\)</span> 可以匹配 <spanclass="math inline">\(kr_i\)</span>次，超过匹配次数后，依次递归每个匹配的左部点。</li><li>网络流。</li></ol><h2 id="二分图带权匹配-km-算法">二分图带权匹配 &amp; KM 算法</h2><p>对一张带权的二分图求最大匹配，称为二分图带权最大匹配。注意前提是<strong>匹配数最大</strong>，再<strong>最大化边权和</strong>。</p><p>想了好久，找到了相对比较好理解的讲解方法。</p><p>先引入几个概念。</p><h3 id="完备匹配">完备匹配</h3><p>给定一张二分图，其左右节点数均为 <spanclass="math inline">\(n\)</span>。如果改二分图最大匹配含有 <spanclass="math inline">\(n\)</span>条边，那么该二分图具有完备匹配。也就是从每个节点出发寻找匹配都能成功。</p><h3 id="顶标">顶标</h3><p>在二分图中，给左部节点 <span class="math inline">\(i\)</span>一个权值 <span class="math inline">\(A_i\)</span>，右部节点 <spanclass="math inline">\(j\)</span> 一个权值 <spanclass="math inline">\(B_j\)</span>。满足 <span class="math inline">\(A_i+ B_j \ge w(i,j)\)</span>，其中 <spanclass="math inline">\(w(i,j)\)</span> 为两点之间的边权。这样的 <spanclass="math inline">\(A_i\)</span> 与 <spanclass="math inline">\(B_j\)</span> 成为顶标。</p><h3 id="相等子图">相等子图</h3><p>二分图中所有节点与满足 <span class="math inline">\(A_i + B_j =w(i,j)\)</span> 的边 <span class="math inline">\((i,j)\)</span>构成的子图叫做这张二分图的相等子图。</p><blockquote><p>若相等子图中存在完备匹配，则这个完备匹配就是二分图的带权最大匹配。</p><p>证明：</p><p>在相等子图中，完备匹配的边权和为 <spanclass="math inline">\(\sum_{i=1}^n (A_i +B_i)\)</span>，也就是顶标之和。</p><p>因为 <span class="math inline">\(A_i + B_j \gew(i,j)\)</span>，所以在二分图中，任何一组匹配的边权和都不大于顶标之和。</p></blockquote><h3 id="交错树匈牙利树">交错树（匈牙利树）</h3><p>在匈牙利算法的过程中，如果从某个左部结点出发寻找匹配失败，那么在 DFS的过程中，访问过的节点和边构成一棵树，满足根为一个左部节点，叶子均为左部节点，且奇数层的边均为非匹配边，偶数层的边均为匹配边。这样的树称为交错树。</p><p>一个没用的推论，交错树高度为奇数。</p><p>匈牙利算法中的<code>dfs(i)=1</code>就代表不存在以 <spanclass="math inline">\(i\)</span> 为根的交错树。</p><p>很多地方没有提到的一点就是，如果有交错树，那么必然没有完备匹配，否则与每个从节点出发都能找到匹配相矛盾。这也是下文一系列操作的基础——修改标顶使得尽可能多的边进入相等子图。</p><p>知道大概就行了，深入讲真的不太好理解，可能更加学术一点？总而言之，我们的相等子图中不能存在交错树，否则就没有完备匹配，就没有带权最大匹配了！</p><p> </p><h3 id="流程">流程</h3><p>对于 <span class="math inline">\(i\)</span>，可以把 <spanclass="math inline">\(B_i\)</span> 设置为 0，<spanclass="math inline">\(A_i\)</span> 设置为 <spanclass="math inline">\(\max_{(i \rightarrow j)}{\{ w(i,j)\}}\)</span>，这样一定满足条件。</p><p>调整顶标是为了让更多的边 <span class="math inline">\((i,j)\)</span>满足 <span class="math inline">\(A_i + B_j =w(i,j)\)</span>，也就是扩大相等子图。</p><p>设当前节点为 <span class="math inline">\(k\)</span>且满足<strong>在相等子图中</strong>存在以它为根的交错树。找到 <spanclass="math inline">\((i,j)\)</span>，满足 <spanclass="math inline">\(i\)</span> 在以 <spanclass="math inline">\(k\)</span> 为根的交错树中但是 <spanclass="math inline">\(j\)</span> 不在，那么如果把 <spanclass="math inline">\((i,j)\)</span>加入相等子图，就能够消去这棵交错树了。</p><p>如果把这棵交错树中所有左部节点的顶标都减去一个 <spanclass="math inline">\(\Delta\)</span>，右部节点都加上一个 <spanclass="math inline">\(\Delta\)</span>，那么对于相等子图中一左一右两个节点<span class="math inline">\((u,v)\)</span>，<spanclass="math inline">\(A_u + B_v\)</span> 和不变，仍然在相等子图中。而<span class="math inline">\(A_i + B_j\)</span> 变小了，因为 <spanclass="math inline">\(j\)</span> 不在交错树中。</p><p>怎么样保证 <span class="math inline">\((i,j)\)</span>一定进入相等子图呢？这要求 <span class="math inline">\(A_i + B_j =w(i,j)\)</span>。找到交错树中的任意节点 <spanclass="math inline">\(i\)</span>，令 <spanclass="math inline">\(\Delta=A_i+B_j-w(i,j)\)</span>，那么就相当于 <spanclass="math display">\[A_i - (A_i + B_j - w(i,j)) + B_j = w(i,j)\]</span></p><p>这个显然是成立的。至于 <span class="math inline">\(i\)</span>是啥我们不关心，只要这样做就能让 <spanclass="math inline">\((i,j)\)</span>加入相等子图。如果减去太多导致某两个点的顶标和小于边权和了怎么办呢？对于<span class="math inline">\(j \in [1,n]\)</span>，取 <spanclass="math inline">\(A_i + B_j - w(i,j)\)</span>的最小值。这个可以在匈牙利算法的过程中预处理出来，记为 <spanclass="math inline">\(slack(j)\)</span>。</p><p>最终只要把边权和加起来就是答案了。</p><p>这么一来最优情况下复杂度是 <spanclass="math inline">\(O(n^3)\)</span>，但是很容易就会被卡到 <spanclass="math inline">\(O(n^4)\)</span>。使用 BFS 优化匈牙利算法可以做到<span class="math inline">\(O(n^3)\)</span>，有时间再写。</p><p>KM算法代码较简单，且在稠密图上表现较好，但是只适用于“原图一定存在完备匹配”的情况。至于费用流的算法，以后再说咯~</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;va[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>;y&lt;=n;++y) <span class="hljs-keyword">if</span>(!vb[y]) &#123;<span class="hljs-keyword">if</span>(la[x]+lb[y]==w[x][y]) &#123;            <span class="hljs-comment">// la[x]+lb[y]=w[x][y]，(x,y)在相等子图中</span>            <span class="hljs-comment">// vb[y]=1表示如果村子交错树，那么y必定在其中</span>vb[y]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!match[y]||<span class="hljs-built_in">dfs</span>(match[y])) &#123;match[y]=x; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> slack[y]=<span class="hljs-built_in">min</span>(slack[y],la[x]+lb[y]-w[x][y]);        <span class="hljs-comment">// 不在相等子图中就更新slack</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;la[i]=-inf, lb[i]=<span class="hljs-number">0</span>;match[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) la[i]=<span class="hljs-built_in">max</span>(la[i],w[i][j]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) v[a]=v[b]=<span class="hljs-number">0</span>, slack[j]=inf;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 这样就没有交错树了</span>dlt=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!vb[j]) dlt=<span class="hljs-built_in">min</span>(dlt,slack[j]);        <span class="hljs-comment">// 取最小值修改标顶</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(va[j]) la[j]-=dlt;<span class="hljs-keyword">if</span>(vb[j]) lb[j]+=dlt;&#125;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=w[match[i]][i];    <span class="hljs-comment">// ans+=la[i]+lb[i]</span>    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7961 数列 题解</title>
    <link href="/2022/lg7961-solution/"/>
    <url>/2022/lg7961-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>好强的状态设计啊，从来没有见过。</p><p>可是暴力分竟然给到了一半，连一半都拿不到吗？</p><p>那个时候连记忆化搜索都写不熟练，总是止步于似懂非懂的家伙。</p><p>我承认，那时候的遗憾，和我即将面临的抉择，没有任何关系。但是，连续地与期望失之交臂，真的会感觉自己是彻头彻尾地废物。</p><p>25 号，什么时候到来啊！马上要见分晓了！</p><p>卷王同学们在一次迷惑的提前批招生后安定下来，只有一面之缘的朋友的情况也渐入佳境。</p><p>我只能不去关心“他们”的事情，这般沉溺于夏日，沉溺在自己的世界中。</p><span id="more"></span><h2 id="暴力">暴力</h2><h3 id="分析">分析</h3><p>首先明确 <span class="math inline">\(a_i \in [0,m]\)</span>。</p><p>设 <span class="math inline">\(f(x,S)\)</span> 为当前 <spanclass="math inline">\(\{a_i\}\)</span> 有 <spanclass="math inline">\(x\)</span> 项，其中 <span class="math inline">\(S= \sum_{i=1}^x 2^{a_i}\)</span>，还能够产生的权值和。</p><p>状态总数为 <spanclass="math inline">\(O(2^{m}nm)\)</span>，只要保证转移在 <spanclass="math inline">\(O(m)\)</span> 之内实现就可行。</p><p>这个状态明显是记忆化搜索。</p><p>如果多选 <span class="math inline">\(a_{x+1}=k\)</span>，那么必然<span class="math inline">\(k \in [0,m]\)</span>，同时 <spanclass="math inline">\(S+2^k\)</span>，状态变成了 <spanclass="math inline">\(f(x+1,S+2^k)\)</span>，对 <spanclass="math inline">\(f(x,S)\)</span> 产生的贡献为 <spanclass="math inline">\(f(x+1,S+2^k) \cdotv_k\)</span>。这个状态的每一个前继状态都必定要在算权值的时候乘上 <spanclass="math inline">\(v_k\)</span>，由于乘法结合律与分配律，只要边界设置对了，这样做就是对的。枚举<span class="math inline">\(k\)</span>，转移 <spanclass="math inline">\(O(m)\)</span>。 <span class="math display">\[f(x,S) = \sum_{i=0}^m f(x+1,S+2^{m}) \cdot v_i\]</span> 然后就是边界，如果上面我们这么干，那么必须 <spanclass="math inline">\(x=n\)</span> 且 1 的个数小于 <spanclass="math inline">\(k\)</span> 的状态的贡献为 1，否则为 0。</p><p>最终答案 <span class="math inline">\(f(0,0)\)</span></p><p>复杂度 <span class="math inline">\(O(2^m m^2 n)\)</span></p><p>期望得分 <span class="math inline">\(50pts\)</span></p><h3 id="code">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">35</span>, M=<span class="hljs-number">105</span>;<span class="hljs-keyword">const</span> ll mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, k, v[N];ll f[N][<span class="hljs-number">123000</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=a*<span class="hljs-number">10</span>+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(ll x)</span> </span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-comment">// 统计x中1的个数</span><span class="hljs-function">ll <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,ll s)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(s)&lt;=k;<span class="hljs-keyword">if</span>(f[x][s]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][s];ll dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) (dlt+=<span class="hljs-built_in">dp</span>(x+<span class="hljs-number">1</span>,s+(<span class="hljs-number">1</span>&lt;&lt;i))*v[i])%=mod;<span class="hljs-keyword">return</span> f[x][s]=dlt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) v[i]=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));&#125;</code></pre></div><h2 id="正解">正解</h2><h3 id="分析-1">分析</h3><p>暴力状态无论如何优化都无法承受了，考虑重新设计状态。</p><p>暴力状态瓶颈的原因在与状态数量太多，十进制下 <spanclass="math inline">\(S\)</span>实在是太大了。那么可以试着按照二进制位设计状态。</p><p>建议好好品一下<strong>样例解释 #1</strong>……</p><p>当一个 <span class="math inline">\(a_i\)</span> 确定时，只会发生 2种情况。</p><ol type="1"><li><span class="math inline">\(a_i\)</span> 这个数首次出现，那么 <spanclass="math inline">\(S\)</span> 的二进制中 1 的个数增加 1。</li><li><span class="math inline">\(a_i\)</span> 这个数之前出现过了，那么<span class="math inline">\(S\)</span> 的二进制中那一位就要向前一位进1，同时变成 0。由于不知道下一位是啥所以无法预测 1 的数量变化。</li></ol><p>但是对于任何一位，他只能向更高的一位进，至于最后到了那里不重要，可以到更高位的时候再考虑。从高位状态转移到低位状态无后效性，还是记忆化搜索。</p><p>那么一个神级状态就要产生了！</p><p><span class="math inline">\(f(k,i,x,y)\)</span>，表示已经确定了 <spanclass="math inline">\(S\)</span> 二进制的 <spanclass="math inline">\(k\)</span> 位，其中 <spanclass="math inline">\(\{a\}\)</span> 数列确定了 <spanclass="math inline">\(i\)</span> 项，有 <spanclass="math inline">\(x\)</span> 个 1，同时第 <spanclass="math inline">\(k-1\)</span> 位进了 <spanclass="math inline">\(y\)</span> 个 1 到 <spanclass="math inline">\(k\)</span> 位，还能够产生的贡献。</p><p>为什么这么设计呢？首先它能够唯一确定地表示 <spanclass="math inline">\(S\)</span> 与 <spanclass="math inline">\(\{a\}\)</span>，并且状态数量级别是 <spanclass="math inline">\(O(mn^3)\)</span>。要知道测试点中 <spanclass="math inline">\(m \in [7,100]\)</span>，<spanclass="math inline">\(n \in[5,30]\)</span>，这是相当大的优化了。而且样例的做法启发我们用组合数求出方案，用<span class="math inline">\(v_k\)</span> 的不同次方来统计贡献。</p><p><span class="math inline">\(k\)</span> 其实隐式代表着 <spanclass="math inline">\(v_k\)</span>。转移的时候枚举 <spanclass="math inline">\(j \in [0,n-i]\)</span>，表示剩下的 <spanclass="math inline">\(n-i\)</span> 项中，<spanclass="math inline">\(k\)</span> 用几项。那么从 <spanclass="math inline">\(n-i\)</span> 个位置里任选 <spanclass="math inline">\(j\)</span> 个为 <spanclass="math inline">\(k\)</span>，方案数为 <spanclass="math inline">\(C_{n-i}^j\)</span>，都会产生 <spanclass="math inline">\(v_k^j\)</span> 的贡献。</p><p>最关键的是剩下两个状态如何表示。</p><p>上一位进了 <span class="math inline">\(y\)</span> 个 1，这一位多了<span class="math inline">\(j\)</span> 个1，二进制下满二进一，那么就是进 <span class="math inline">\(\lfloor\frac{y+j}{2} \rfloor\)</span> 个 1 到 <spanclass="math inline">\(k+1\)</span> 位。</p><p>由于规定了进位顺序，当 <span class="math inline">\(y+j\)</span>是奇数时，<span class="math inline">\(k\)</span> 位上必定留下 1，<spanclass="math inline">\(x+1\)</span>，否则 <spanclass="math inline">\(x\)</span> 不变。</p><p>好的！转移 <span class="math inline">\(O(n)\)</span>！ <spanclass="math display">\[f(k,i,x,y) = \sum_{j=0}^{n-i} f(k+1,i+j,x+d(y+j),\lfloor \frac{y+j}{2}\rfloor) \cdot C^j_{n-i} \cdot v_k^j\]</span> 当 <span class="math inline">\(t\)</span> 为奇数时，<spanclass="math inline">\(d(t)\)</span> 为 1，反之为 0。</p><p>边界依然很重要。当 <span class="math inline">\(k&gt;m\)</span>时，不存在这样的 <spanclass="math inline">\(S\)</span>，这个状态直接返回 0。</p><p>当 <span class="math inline">\(i=n\)</span> 的时候，此时 <spanclass="math inline">\([1,k]\)</span> 位上有 <spanclass="math inline">\(x\)</span> 个 1，前面进了 <spanclass="math inline">\(y\)</span> 个 1。由于 <spanclass="math inline">\((k,m]\)</span> 此时全为 0，那么 <spanclass="math inline">\(y\)</span> 个 1 最后产生的 1 数量是它的二进制中 1的个数。所以就像暴力方法一样，如果 1 的数量合法，那么返回 1，否则返回0。</p><p>答案 <span class="math inline">\(f(0,0,0,0)\)</span></p><p>复杂度 <span class="math inline">\(O(mn^4)\)</span></p><p>期望得分 <span class="math inline">\(100pts\)</span></p><h3 id="code-1">CODE</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">35</span>, M=<span class="hljs-number">105</span>;<span class="hljs-keyword">const</span> ll mod=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, kk;ll c[N][N], v[M][N], f[M][N][N][N];<span class="hljs-comment">// c[i][j]是组合数，v[i][j]是v[i]的j次幂</span><span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;ll a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=a*<span class="hljs-number">10</span>+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(ll x)</span> </span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x) cnt+=x&amp;<span class="hljs-number">1</span>, x&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function">ll <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(i&gt;=n) <span class="hljs-keyword">return</span> x+<span class="hljs-built_in">count</span>(y)&lt;=kk;<span class="hljs-keyword">if</span>(k&gt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(f[k][i][x][y]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[k][i][x][y];ll dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n-i;++j) (dlt+=<span class="hljs-built_in">dp</span>(k+<span class="hljs-number">1</span>,i+j,x+(y+j)%<span class="hljs-number">2</span>,(y+j)/<span class="hljs-number">2</span>)*c[n-i][j]%mod*v[k][j]%mod)%=mod;<span class="hljs-keyword">return</span> f[k][i][x][y]=dlt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), kk=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) v[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>();c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;c[i][<span class="hljs-number">0</span>]=c[i][i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j) c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;v[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;++j) v[i][j]=(v[i][j<span class="hljs-number">-1</span>]*v[i][<span class="hljs-number">1</span>])%mod;&#125;    <span class="hljs-comment">// 预处理组合数与次幂</span><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">00</span>));&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7960 报数 题解</title>
    <link href="/2022/lg7960-solution/"/>
    <url>/2022/lg7960-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>那段时间里，一直过着双面生活。</p><p>一面，是在学校里苦于愈发紧张的文化课，对考试名次嗤之以鼻。</p><p>一面，是梦已破碎、逃避现实，有疑问无人解答，有肺腑之言无处倾诉的彷徨。</p><p>在学校，我是一个在“重点班”，文化课成绩一直下降却无动于衷的“怪人”。</p><p>在家中，我是一个迷茫颓废的失败者。</p><p>究竟持续了几个月，早已记不清了。</p><span id="more"></span><h2 id="分析">分析</h2><p>首先判断某个数十进制中是否含有 7 这个很简单。</p><p>然后用筛子把它的倍数筛掉就行了。</p><p>瓶颈在于，如何快速回答下一个要报出的数。枚举的话只有 70pts。</p><p>考虑一个数 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(p(x)=0\)</span> 且不存在 <spanclass="math inline">\(y\)</span>，满足 <spanclass="math inline">\(p(y)=1\)</span> 且 <span class="math inline">\(y\mid x\)</span>，它一定是某个数“下一个要报出的数”。</p><p>而每一个数“下一个要报出的数”一定是单调增的。</p><p>所以设 <span class="math inline">\(r_x\)</span> 为 <spanclass="math inline">\(x\)</span>下一个要报出的数，如果它本身不合法，那么就是 -1。</p><p>我们可以在筛数的过程中，维护 <spanclass="math inline">\(lst\)</span>。如果 <spanclass="math inline">\(x\)</span> 满足条件，直接令 <spanclass="math inline">\(r_{lst}=x\)</span>，<spanclass="math inline">\(lst = x\)</span>。因为 <spanclass="math inline">\((lst,x)\)</span>这个区间里的数都是不合法的，否则与 <spanclass="math inline">\(x\)</span> 为“下一个要报出的数”相矛盾。</p><p>注意当 <span class="math inline">\(x=10^7\)</span> 时，答案为 <spanclass="math inline">\(10^7+1\)</span>。</p><p>预处理之后就可以直接输出 <spanclass="math inline">\(r_x\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, r[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=a*<span class="hljs-number">10</span>+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">7</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(x) &#123;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;x/=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// pd(x)=1表示x十进制中有7或者是7的倍数</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(r,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(r));<span class="hljs-keyword">int</span> lst=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1e7</span>+<span class="hljs-number">1</span>;++i) &#123;<span class="hljs-keyword">if</span>(v[i]) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// v[i]=1就代表i不合法</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">pd</span>(i)) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=<span class="hljs-number">1e7</span>+<span class="hljs-number">1</span>;j+=i) v[j]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> r[lst]=i, lst=i;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// freopen(&quot;d:\\number\\number4.in&quot;,&quot;r&quot;,stdin);</span><span class="hljs-comment">// freopen(&quot;d:\\number\\out.out&quot;,&quot;w&quot;,stdout);</span>t=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,r[x]);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7915 回文 题解</title>
    <link href="/2022/lg7915-solution/"/>
    <url>/2022/lg7915-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>这题是真的暴力。</p><p>可是怎么就是做不出来呢？</p><p>是你会的从来都只是套路性的表面功夫，还是你从来就没有静下心来好好提高思维水平呢？</p><p>面对现实吧，二者皆有。</p><span id="more"></span><h2 id="分析">分析</h2><p>首先明确，字典序最小是操作序列的字典序。</p><p>只剩下最后一个数的时候，操作 1 和 2是等价的。由于要求字典序最小，所以操作序列最后一个必定是<code>L</code>。</p><p>再考虑第一个操作。因为第一次只能操作序列 <spanclass="math inline">\(a\)</span>中的第一个数或最后一个数，且最后它必将留在序列 <spanclass="math inline">\(b\)</span> 的第一个位置。而回文序列 <spanclass="math inline">\(b\)</span>中最后一个数必然和第一个数相同。那么就能知道一定是枚举 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(a_{2n}\)</span> 两种操作选择，再通过满足 <spanclass="math inline">\(a_i = a_1\)</span> 或 <spanclass="math inline">\(a_i = a_{2n}\)</span> 的位置 <spanclass="math inline">\(i\)</span> 作为一个操作的临界点。</p><p>一旦确定了 <span class="math inline">\(i\)</span>，那么 <spanclass="math inline">\(i\)</span>必定是最后一个操作。我们可以将顺序的操作与倒序的操作的数相对应，满足最终得到回文串。于是考虑搜索。</p><p>建议玩一下样例。 <span class="math display">\[[4, 1, 2, 4, 5, 3, 1 ,2, 3, 5 ]\]</span></p><p><span class="math display">\[[ 4, 5, 3, 1, 2, 2, 1, 3, 5, 4 ]\]</span></p><p>不难发现每一次只能操作两个数，左边的位置单调增，右边的位置单调减。不妨设为<span class="math inline">\(L\)</span> 与 <spanclass="math inline">\(R\)</span>。一开始 <spanclass="math inline">\(L=1\)</span>，<spanclass="math inline">\(R=2n\)</span>。而倒序操作也只能操作两个数，左边的位置单调减，右边的位置单调增，且一开始始终是<span class="math inline">\(i-1\)</span> 与 <spanclass="math inline">\(i+1\)</span>。记为 <spanclass="math inline">\(l\)</span> 与 <spanclass="math inline">\(r\)</span>。</p><p>这里默认一开始操作的是 4。</p><p>第一步用 1 操作把 4 放到第一位，那么 <spanclass="math inline">\(L+1\)</span>，<spanclass="math inline">\(R\)</span> 不变，此时可以操作的数为靠左的 1与靠右的 5。这个时候要选择能与 <span class="math inline">\(a_l\)</span>与 <span class="math inline">\(a_r\)</span>对应的数，否则绝对不是回文序列。那么显然就是 <spanclass="math inline">\(a_r\)</span>，靠左的 5。所以要使用操作 2 加入5，<span class="math inline">\(R-1\)</span>，<spanclass="math inline">\(L\)</span> 不变。 由于 <spanclass="math inline">\(r\)</span> 在 <spanclass="math inline">\(i\)</span> 右边，最后一定是用 2 操作将 <spanclass="math inline">\(a_r\)</span> 归位的。此时 <spanclass="math inline">\(a_r\)</span> 已经不可使用，<spanclass="math inline">\(r+1\)</span>，<spanclass="math inline">\(l\)</span> 不变。当然，要记录每个操作。</p><p>接下来是将 <span class="math inline">\(a_r\)</span> 与 <spanclass="math inline">\(a_R\)</span> 配对，<spanclass="math inline">\(a_l\)</span> 与 <spanclass="math inline">\(a_R\)</span> 配对。</p><p>相信大家都看出来套路了。就是择优配对，先考虑可行性，然后贪心选择。<code>L</code>必须尽可能靠前，因此优先度递减排序为<span class="math inline">\(L\)</span> 与 <spanclass="math inline">\(l\)</span>、<span class="math inline">\(L\)</span>与 <span class="math inline">\(r\)</span>、<spanclass="math inline">\(R\)</span> 与 <spanclass="math inline">\(l\)</span>、<span class="math inline">\(R\)</span>与 <span class="math inline">\(r\)</span>。</p><p>当 <span class="math inline">\(l=L\)</span> 并且 <spanclass="math inline">\(r=R\)</span> 时操作结束。</p><p>但是还有一些小边界问题。这是由于边界的增减且不能越界造成的。</p><ol type="1"><li>当 <span class="math inline">\(L \le l\)</span> 时，必须满足 <spanclass="math inline">\(L &lt; l\)</span> 才能让 <spanclass="math inline">\(L\)</span> 与 <spanclass="math inline">\(l\)</span> 配对，满足 <spanclass="math inline">\(r \le R\)</span> 时就能让 <spanclass="math inline">\(L\)</span> 与 <spanclass="math inline">\(r\)</span> 配对。</li><li>当 <span class="math inline">\(r \le R\)</span> 时，满足 <spanclass="math inline">\(L \le l\)</span> 就能让 <spanclass="math inline">\(R\)</span> 与 <spanclass="math inline">\(l\)</span> 配对，必须满足 <spanclass="math inline">\(r &lt; R\)</span> 时才能让 <spanclass="math inline">\(R\)</span> 与 <spanclass="math inline">\(r\)</span> 配对。</li></ol><p>由于只有能够成为回文串才贪心操作，所以第一次到达 <spanclass="math inline">\(l = L\)</span> 且 <span class="math inline">\(r =R\)</span> 时一定是字典序最小的回文串。</p><p>复杂度 <span class="math inline">\(O(Tn)\)</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, flag, n, a[N];<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span> </span>&#123;    <span class="hljs-comment">// l与r，L与R同上文</span>    <span class="hljs-comment">// p表示序列b中有多少个数</span><span class="hljs-keyword">if</span>(l&lt;L&amp;&amp;r&gt;R) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(p&gt;n) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;(a[l]==a[L]&amp;&amp;L&lt;l||a[r]==a[L]&amp;&amp;r&lt;=R)) &#123;s[p]=<span class="hljs-string">&#x27;L&#x27;</span>;<span class="hljs-keyword">if</span>(a[l]==a[L]&amp;&amp;L&lt;l) s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r,L+<span class="hljs-number">1</span>,R);<span class="hljs-keyword">else</span> s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l,r+<span class="hljs-number">1</span>,L+<span class="hljs-number">1</span>,R);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r&lt;=R&amp;&amp;(a[l]==a[R]&amp;&amp;L&lt;=l||a[r]==a[R]&amp;&amp;r&lt;R)) &#123;s[p]=<span class="hljs-string">&#x27;R&#x27;</span>;<span class="hljs-keyword">if</span>(a[l]==a[R]&amp;&amp;L&lt;=l) s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l<span class="hljs-number">-1</span>,r,L,R<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> s[<span class="hljs-number">2</span>*n-p+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-built_in">dfs</span>(p+<span class="hljs-number">1</span>,l,r+<span class="hljs-number">1</span>,L,R<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;flag=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);s[<span class="hljs-number">2</span>*n]=<span class="hljs-string">&#x27;L&#x27;</span>; <span class="hljs-comment">// 一定的</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) <span class="hljs-keyword">if</span>(a[i]==a[<span class="hljs-number">1</span>]) &#123;s[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;L&#x27;</span>;        <span class="hljs-comment">// 一开始用1操作位置1，对应的最后一次操作位置是i</span>        <span class="hljs-comment">// 顺序操作区间[2,2n]</span><span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>,i<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>*n);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i) <span class="hljs-keyword">if</span>(a[i]==a[<span class="hljs-number">2</span>*n]) &#123;s[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;R&#x27;</span>;        <span class="hljs-comment">// 一开始用2操作位置1，对应的最后一次操作位置是i</span>        <span class="hljs-comment">// 顺序操作区间[1,2n-1]</span><span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>,i<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">sol</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7913 廊桥分配 题解</title>
    <link href="/2022/lg7913-solution/"/>
    <url>/2022/lg7913-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="前言">前言</h2><p>我几乎搞砸了 2021 年 8 月 31 日之后的所有事。</p><p>无论是 OI 与 文化课，还是人际关系与整个自己。</p><p>我根本不配参加 CSP 与NOIP，最终的结果也在预料之中。更何况在那之后的</p><p>那些煎熬着，逃避着的日子啊……</p><span id="more"></span><h2 id="分析">分析</h2><p>不难发现国际区与国内区完全没有关系，分开处理就行了。</p><p>注意到当某个区只有一个廊桥的时候，就等价于保证在选择第一个区间的情况下，选择最多数量的不相交区间。</p><p>那么如果廊桥数量更多呢？</p><p>显然如果在廊桥数量为 1 时选择了最多数量的不相交区间，那么当廊桥数量为2 时仍然能够选取这么多，方法是钦定选出来的飞机只能用第 1个廊桥。多出来的这个廊桥又能够再对剩下的的飞机做一次选择最多数量的不相交区间。这样一定是最多的。</p><p>归纳一下就得到</p><ul><li>廊桥越多，所容纳的飞机数量单调不减，且具有最优子结构性质，可以直接贪心。</li><li>如果某个区有 <span class="math inline">\(n_0\)</span>个廊桥，那么最多容纳的飞机数量就是做 <spanclass="math inline">\(n_0\)</span> 次选择最多不相交区间。</li></ul><p>因为只有 <span class="math inline">\(n\)</span> 个廊桥，那么国内去分<span class="math inline">\(n_0\)</span> 个，国外区一定有 <spanclass="math inline">\(n - n_0\)</span> 个。这样只要预处理出每个区分配<span class="math inline">\(k \in[0,n]\)</span>个廊桥最多能容纳的飞机数量，那么就能 <spanclass="math inline">\(O(n)\)</span> 取最大值了。</p><p>维护每个区的飞机用<code>std::set</code>，它本身是有序的，自带<code>lower_bound</code>而且还支持删除操作。</p><p>廊桥分配情况是 <span class="math inline">\(O(n)\)</span>的，每个飞机最多进出<code>set</code>一次。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, c[<span class="hljs-number">2</span>], ans[<span class="hljs-number">2</span>][N];set&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; s[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;c[<span class="hljs-number">0</span>],&amp;c[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c[i];++j) &#123;<span class="hljs-keyword">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);s[i].<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(l,r));&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">1</span>;++k) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans[k][i]=ans[k][i<span class="hljs-number">-1</span>];        <span class="hljs-comment">// 先继承i-1个廊桥的数量</span><span class="hljs-keyword">int</span> lst=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(!s[k].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> p=s[k].<span class="hljs-built_in">upper_bound</span>(<span class="hljs-built_in">make_pair</span>(lst,<span class="hljs-number">0</span>));<span class="hljs-keyword">if</span>(p==s[k].<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">break</span>;lst=p-&gt;second, ++ans[k][i];s[k].<span class="hljs-built_in">erase</span>(p);&#125;&#125;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) res=<span class="hljs-built_in">max</span>(res,ans[<span class="hljs-number">0</span>][i]+ans[<span class="hljs-number">1</span>][n-i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中考2022 游记</title>
    <link href="/2022/zhongkao2022/"/>
    <url>/2022/zhongkao2022/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="day--1">DAY -1</h2><p>最后一个周末了。</p><p>难得几乎没有作业，周末返校不考试。（笑）</p><span id="more"></span><p>数学老师发了去年中考最后两个大题让我们练手，我又想起了压轴题某个点的运动轨迹是个抛物线，但我当成直线算的痛苦……</p><p>带回了一些没啥用的书，看了看错题。</p><p>然后依旧是好好放松~</p><p>话说我没报 B校的“小语种招生”，班主任还找我谈话了。不管因为什么原因，我都不想进入 B校的“A区”。一是我文化课实在没有那个水平（应该也考不上），而是我不想自讨苦吃，三是对我学OI 没有帮助。</p><p>所以全班就我一个人没报。</p><p>后来因为 B校作为高考中考考场，高一高二学生都“放假”了，就来了几个我们班主任之前的学生，给我们讲高中一些事情和怎么考“小语种招生”。某位爷说，当时数学选择题有很多是多项选择，但是他都按照单项选的。出场一对答案直接少了三十多分。语文出了各种奇葩题，有现代文猜作者（汪曾祺），千字议论文。他英语还扣了10+ 分，物理扣了 1 分。最后满分 360（语数英物），他考了 310+，以第 9名的身份进入 A 区。真是无语了，什么怪物。</p><h2 id="day-0">Day 0</h2><p>周日早晨返校。</p><p>先是核酸检测，然后复习了一上午语文。看不下去……</p><p>午餐终于改善了55555，还挺好吃。</p><p>下午复习物理化学，看了看错题。</p><p>4 点多要去看考场时变天了，但是没有下雨。</p><p>考场在 X 校。39 考场，5 楼。</p><p>X校作为我是著名的公私合营中学，那硬件设施自然是不差的。只不过这纯木桌凳舒适有点不太舒服，而且不如B 校的椅子舒服。</p><p>差不多就回去了，一路上一直看着车窗外的风景。</p><p>晚上依旧是物理化学。</p><p>由于不上第三节晚自习，所以 9 点就回宿舍了。我们宿舍只剩下 6个人，于是我和其他 3 个人去对面宿舍玩狼人杀。十点多睡了觉。</p><h2 id="day-1">Day 1</h2><p>不得不说早睡觉是真的舒服，6:10 自然醒。</p><p>到教室后发了农夫山泉和士力架，随便看看语文后就去考试了。</p><h3 id="语文">语文</h3><p>发下卷来一看，好家伙，又是孟子！去年前年考的都是课内的孟子，今年考了个课外的！这篇好像做过？课内竟然是大道之行也。</p><p>于是文言文就切掉一半了，但是最后一问</p><blockquote><p>结合某某某谈论对“货物其弃于地也，不必藏于己。力恶其不出于身，也不必为己”的理解。</p></blockquote><p>乱写，orz。</p><p>名著考的是昆虫记，没啥难的。</p><p>现代文阅读竟然是莫言在五四前夕的信？好家伙连文章都不必读了，最后一问又是结合实际，orz。</p><p>作文有 3 个主题。</p><ol type="1"><li>自律：自己约束自己。</li><li>《人世间》疫情版歌词，最后好像有一句“就像种子，永远向着太阳”。</li><li>貌似是责任担当？</li></ol><p>于是秒选2，仔细读了一下就发现，应该是对生活有希望，成长奋斗啥的。</p><p>所以我写了一个极其无语的题目“沐雨，向阳”。</p><p>沐还写错了，加了一个点啊啊啊啊。</p><p>但是通篇下来语言和逻辑都挺好的，最后一段议论成功点题。嗯，看来写博客还有点用。</p><p>然后回校。</p><h3 id="物理化学">物理＆化学</h3><p>中午 1 点多就去坐车，有点困。天气不太好，于是我带了雨伞。</p><p>刚好下车时开始下雨，考生们都一窝蜂地往校门里挤。到了排队进楼的时候，狂风大作，大雨裹挟而来，我的伞都被吹崩了一次qwq。SB的 X校硬是堵着不让进，雨是斜着下的，伞上的积水又流到旁边的人的身上，然后基本每个人的衣服后背都湿透了。</p><p>试卷发下来后，发现物化是真的简单，完全没有难题。化学写完+检查用了30+min，物理写得比较谨慎，写完大概剩下35min。我自认为是做的不错的。</p><p>但是我还是把 <span class="math inline">\(NH_3\)</span>中氮元素的化合价写了 +3，物理有一个奇葩作图题少做了一个对称。</p><p>回校之后吃了某看起来价格不菲的面包，还行。</p><p> </p><p>晚自习一直在看数学。</p><p>依旧在宿舍里玩了狼人杀。</p><h2 id="day2">Day2</h2><p>吃了好几个巧克力，被同学说流鼻血。</p><p>昨天物理化学简单到离谱，于是我认为数学英语应该会比较难。</p><p>在车上看了很多职校的传单，说真的对于数学有点紧张。</p><h3 id="数学">数学</h3><p>无语了。</p><p>选择题完全没有难点，最后一个竟然是瓜豆原理板子题，问你在三角形两边上两个线性运动的点连成的线段的中点，运动轨迹是个啥。那必然是线段，它的中位线。</p><p>填空最后一个会做，但是平移的时候疏忽导致答案错了，orz。</p><p>倒数第二个大题，有人竟然用的四点共圆证明，orz。我大概 2min切掉了。</p><p>压轴题更是没有水平，只不过最后一问的四个答案中，有两个需要暴力因式分解推出的四次等式才能解出来，我也没有算对qwq。只有一半分。</p><p>这，看来英语会难些吧。</p><h3 id="英语">英语</h3><p>事实证明我错了，英语除了听力不太简单，别的都很常规。</p><p>所以 facet 为什么 Here means "face"。</p><p> </p><p>明天只考政治历史了，同学们貌似都轻松了不少，用教室的多功能黑板放歌听。我放了一首Daze，结果很快就被切掉了。</p><p>晚自习一直在看政治，但是发现我啥也背不过了，于是摸鱼。</p><p>还玩了狼人杀。</p><h2 id="day-3">Day 3</h2><p>要结束了吗？</p><p>天气很不错，踩着重叠着的树荫到教室，随便看了看昨日不曾翻阅的时政。</p><p>起行，校长竟然向我们招手了。沿途的风景差不多已经厌倦了啊，迎着跃动的朝阳小憩片刻。</p><p>马上就到了。</p><h3 id="政治-历史">政治 ＆ 历史</h3><p>政治竟然考了我昨晚看的每一道题，运气不错啊。</p><p>历史就比较恶心，一堆总结材料的题目，比一二模要难一些，我竟然用了将近50min。当然我故意在中考放慢了做题速度，毕竟早做完也没什么用。</p><p>最终写完还有 20min。</p><p>出考场之前，X校竟然强制用广播向我们宣传他们的”昌乐二中并行班“，但估计没人会报名声不怎么好的X 校。</p><p>结束了，中考结束了。</p><h3 id="毕业">毕业</h3><p>全班就我一个人去餐厅吃饭了。</p><p>家委会买了一堆吃的喝的，但是我没着急吃。一是不饿，二是我没有那么兴奋。</p><p>好多人都带手机来了。</p><p>吃喝发言过后，就是毕业典礼。相当吵闹啊。</p><p>然后就是冗长的等待拍毕业照的时间，某些班拍个照都要十几分钟。</p><p>我没有心情去做那些事情，比如和同学拍照或打游戏。仅仅是，在烈日下回想起了去年夏天。</p><p>可是迎着摇曳的阳炎，所描绘出的是一幕幕我不想去回忆的情景，不管那时候我有多激动，我都想毁灭这些东西。我嘲笑那时候我的天真，我真想回去叫醒那时候的我。</p><p>「你能不能看清楚你到底什么样？」</p><p>「我不能原谅你……」</p><p>估计他也不会想到，一年后会变成这个样子。</p><p>憧憬着的故事，不过是擦肩而过的浅薄梦幻，在六月的阵雨中早已随大风舞去。留下的，是永远的伤痕。</p><p>我发誓，有条件的话，我会尽力拿到省一，让这个故事有个说得过去的结局。</p><p>然后我就会离开。</p><p>……</p><p>一转眼，已经要离校了。阳光抚平了这一切，回首，是生活了三年的校园。那一霎，曾经眺望过的校园中，染上了天边漾起的茜色。厌恶的教室藏在葱葱绿叶的罅隙中，竟有丝丝不舍划过脸颊，吹拂在彷徨的心中。我紧紧抓着书包的背带，卸下无数次脸上对母校摆出的种种偏见，用不曾涌现也不曾停息的留恋与遗憾，大声在心里说出：“再见啦！”。</p><p>再见了，称不上是朋友的同学们；再见了，配合的不是那么好的老师们；再见了，每一个曾唤起我的回忆的角落；再见了，我的初中生活！</p><p> </p><p>今后，一定要快乐地生活下去啊！</p><p>各位保重！</p><h2 id="day-998244353">Day 998244353</h2><p>出成绩一个月了，我才回来补上。</p><p>语文：<span class="math inline">\(100/120\)</span></p><p>数学：<span class="math inline">\(114/120\)</span></p><p>英语：<span class="math inline">\(116/120\)</span></p><p>理综：<span class="math inline">\(116/120\)</span></p><p>文综：<span class="math inline">\(104/120\)</span></p><p>总分：<span class="math inline">\(550/600\)</span></p><p>全市名次（不含提前批）<spanclass="math inline">\([102,123]\)</span></p><p>够用了。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文化课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT2558 Many Moves 题解</title>
    <link href="/2022/at2558-solution/"/>
    <url>/2022/at2558-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="关于此题">关于此题</h2><p>去年夏天，我就从朋友那里知道了这道题。</p><p>素不相识、相隔千里的几人竟然能互相敞开心扉，这是我那是坚持下去的一个重要因素。他说这题很有意思，我便不顾自己的水平就放入了做题计划，这一放，就是将近一年。</p><span id="more"></span><p>“线段树优化 DP，好厉害啊！”</p><p>“什么时候我也能会写线段树呢？”</p><p>一年中发生了太多的事，他已经不再那么热衷于 OI了，我也从黄粱一梦中醒来。但是，仍然不变的，是一想到他就会燃起的小小斗志，是我不甘又无奈的形单影只。</p><p>也许我再也不是那个连背包问题都无法理解，只会对着题解研究代码的菜鸟了。但是……</p><h2 id="分析">分析</h2><p>读完题面第一反应，就是把操作“离线”了。（没啥用，和纯数据结构题的离线不同）。</p><p>考虑完成 <span class="math inline">\(i\)</span>个操作时，一定有一个棋子在 <span class="math inline">\(x_i\)</span>的位置。那么可以设 <span class="math inline">\(f(i,j)\)</span>为完成了前 <span class="math inline">\(i\)</span>个操作，其中另一个棋子的位置在 <spanclass="math inline">\(j\)</span>。</p><p>转移则有 2 种。</p><p>对于 <span class="math inline">\(f(i,j)\)</span>，可以将 <spanclass="math inline">\(f(i-1,j)\)</span> 中位置在 <spanclass="math inline">\(x_{i-1}\)</span> 的棋子放过来，代价是 <spanclass="math inline">\(\Delta x = |x_i - x_{i-1}|\)</span>。 <spanclass="math display">\[f(i,j) = f(i-1,j) + \Delta x\]</span>还可以将位置在另一个棋子放过来。由于状态无法直接表示，所以要枚举另一个棋子的位置<spanclass="math inline">\(k\)</span>。但是把「另一个棋子」放过来后，它位于<span class="math inline">\(x_i\)</span>，按照上文状态的设计，就转移到<span class="math inline">\(f(i,x_{i-1})\)</span> 了。</p><p>仔细想一想，<span class="math inline">\(f(i-1,k) \rightarrowf(i,x_{i-1})\)</span> 这种情况还挺少见的，有点意思。😅 <spanclass="math display">\[f(i,x_{i-1}) = \min_{k \in [1,n]}{\{ f(i-1,k) + |k-x_i| \}}\]</span> 直接这样做复杂度是 <span class="math inline">\(O(Qn)\)</span>的，考虑优化。</p><p>套路地把绝对值符号拆开，当 <span class="math inline">\(k &gt;x_i\)</span> 时，有 <span class="math display">\[f(i,x_{i-1}) = \min_{k \in [x_i+1,n]}{\{ f(i-1,k) + k \}} - x_i\]</span> 当 <span class="math inline">\(k \le x_i\)</span> 时，有 <spanclass="math display">\[f(i,x_{i-1}) = \min_{k \in [1,x_i]}{\{ f(i-1,k) - k \}} + x_i\]</span> 这样问题就变成了，在 <spanclass="math inline">\([1,x_i]\)</span> 中快速查找最小的 <spanclass="math inline">\(f(i-1,k)-k\)</span>，在 <spanclass="math inline">\([x_i+1,n]\)</span> 中快速查找最小的 <spanclass="math inline">\(f(i-1,k)+k\)</span>。</p><p>而第一种转移其实变相地告诉我们，<spanclass="math inline">\(i-1\)</span> 的状态是可以通过 <spanclass="math inline">\(\Delta x\)</span> 转移到 <spanclass="math inline">\(i\)</span> 的状态的。</p><blockquote><p>实际上不难发现，对于第一种转移，只有 <spanclass="math inline">\(j=x_i\)</span>的时候才是最划算的，所以可以直接单点查询得到。但是这样就会被第二种转移中的<span class="math inline">\(k=x_i\)</span>的情况覆盖了，所以可以完全无视第一种转移。</p></blockquote><p>所以可以建立一棵线段树，维护 <spanclass="math inline">\(f(j)\)</span> 这一层。</p><p>对于每个操作 <span class="math inline">\(i\)</span>，维护 <spanclass="math inline">\(f(i-1,k)+k\)</span> 与 <spanclass="math inline">\(f(i-1,k)-k\)</span> 的值。全局加上 <spanclass="math inline">\(\Delta x\)</span> 更新状态，最后单点修改 <spanclass="math inline">\(x_{i-1}\)</span> 的值。</p><p>初始值 <span class="math inline">\(f(1,A) = |B-x_1|\)</span>，<spanclass="math inline">\(f(1,B)=|A-x_1|\)</span></p><p>答案 <span class="math inline">\(\min_{k \in [1,n]}{\{ f(Q,k)\}}\)</span></p><p>由于只设计全局加，所以可以直接用打标记的方式实现。</p><p>复杂度 <span class="math inline">\(O(Q \log_2 n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">200005</span>;<span class="hljs-keyword">const</span> ll inf=<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>;<span class="hljs-keyword">int</span> n, Q, a, b, x[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segment_Tree</span> &#123;</span><span class="hljs-keyword">int</span> l, r;ll tag, v[<span class="hljs-number">3</span>];    <span class="hljs-comment">// tag是区间加标记</span>    <span class="hljs-comment">// v[0]是f(i,k)，v[1]是f(i,k)-k，v[2]是f(i,k)+k</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l(u) t[u].l</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r(u) t[u].r</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tag(u) t[u].tag</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> v(u) t[u].v[0]</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> v1(u) t[u].v[1]</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> v2(u) t[u].v[2]</span>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,ll val)</span> </span>&#123; <span class="hljs-built_in">tag</span>(u)+=val, <span class="hljs-built_in">v</span>(u)+=val, <span class="hljs-built_in">v1</span>(u)+=val, <span class="hljs-built_in">v2</span>(u)+=val; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<span class="hljs-built_in">v</span>(u)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">v</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">v</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));<span class="hljs-built_in">v1</span>(u)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">v1</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">v1</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));<span class="hljs-built_in">v2</span>(u)=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">v2</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">v2</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">tag</span>(u)) &#123;<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">tag</span>(u)=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-built_in">l</span>(u)=l, <span class="hljs-built_in">r</span>(u)=r;<span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">v</span>(u)=<span class="hljs-built_in">v1</span>(u)=<span class="hljs-built_in">v2</span>(u)=inf; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// 初始值</span><span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(u);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,ll p,ll val)</span> </span>&#123;    <span class="hljs-comment">// 单点修改</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">l</span>(u)==<span class="hljs-built_in">r</span>(u)) &#123;<span class="hljs-built_in">v</span>(u)=val, <span class="hljs-built_in">v1</span>(u)=val-p, <span class="hljs-built_in">v2</span>(u)=val+p;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">pushdown</span>(u);    <span class="hljs-keyword">int</span> mid=(<span class="hljs-built_in">l</span>(u)+<span class="hljs-built_in">r</span>(u))/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>,p,val);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,p,val);<span class="hljs-built_in">pushup</span>(u);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span> </span>&#123;    <span class="hljs-comment">// 区间查询</span><span class="hljs-keyword">if</span>(l&lt;=<span class="hljs-built_in">l</span>(u)&amp;&amp;<span class="hljs-built_in">r</span>(u)&lt;=r) &#123; <span class="hljs-keyword">return</span> t[u].v[id]; &#125;<span class="hljs-built_in">pushdown</span>(u);<span class="hljs-keyword">int</span> mid=(<span class="hljs-built_in">l</span>(u)+<span class="hljs-built_in">r</span>(u))/<span class="hljs-number">2</span>;ll ans=(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>);<span class="hljs-keyword">if</span>(l&lt;=mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,id));<span class="hljs-keyword">if</span>(r&gt;mid) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,id));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;Q,&amp;a,&amp;b);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x[i]);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a,<span class="hljs-built_in">abs</span>(b-x[<span class="hljs-number">1</span>]));<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,b,<span class="hljs-built_in">abs</span>(a-x[<span class="hljs-number">1</span>]));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=Q;++i) &#123;ll dlt=<span class="hljs-built_in">abs</span>(x[i]-x[i<span class="hljs-number">-1</span>]), r1=(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>), r2, r3;<span class="hljs-comment">//r1=query(1,x[i],x[i],0)+dlt;</span>r2=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,x[i],<span class="hljs-number">1</span>)+x[i];r3=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x[i]+<span class="hljs-number">1</span>,n,<span class="hljs-number">2</span>)-x[i];r1=<span class="hljs-built_in">min</span>(r1,<span class="hljs-built_in">min</span>(r2,r3));<span class="hljs-built_in">maketag</span>(<span class="hljs-number">1</span>,dlt); <span class="hljs-comment">// 全局加上dlt</span><span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,x[i<span class="hljs-number">-1</span>],r1); <span class="hljs-comment">// 修改f(i,x[i-1])</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">v</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 全局最小值</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4926 倍杀测量者 题解</title>
    <link href="/2022/lg4926-solution/"/>
    <url>/2022/lg4926-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先明确，对于 <span class="math inline">\(o=1\)</span> 的选手 <spanclass="math inline">\(A\)</span>，他不用女装的条件是 <spanclass="math inline">\(X_A \ge X_B \cdot(k-T)\)</span>。对于 <spanclass="math inline">\(o=2\)</span> 的选手 <spanclass="math inline">\(A\)</span>，他不用女装的条件是 <spanclass="math inline">\(X_A \cdot (k+T) &gt; X_B\)</span>。</p><p>这样是不能用差分约束系统来求解的，因为变量之间的关系是乘法，但是如果将它们换成同底数的对数，那么相对大小不变且乘法就转化成了加法。<span id="more"></span>所以<span class="math display">\[X_A \ge X_B \cdot(k-T)\]</span></p><p><span class="math display">\[\log_2 (X_A) - \log_2 (X_B) \ge  \log2 (k-T)\]</span></p><p>从 <span class="math inline">\(B\)</span> 向 <spanclass="math inline">\(A\)</span> 连一条权值为 <spanclass="math inline">\(\log2 (k-T)\)</span> 的边。 <spanclass="math display">\[X_A \cdot (k+T) &gt; X_B\]</span></p><p><span class="math display">\[\log_2 (X_A) + \log_2 (k+T) &gt; \log_2 (X_B)\]</span></p><p><span class="math display">\[\log_2(X_A) - \log_2 (X_B) &gt; - \log_2(k+T)\]</span></p><p>从 <span class="math inline">\(B\)</span> 向 <spanclass="math inline">\(A\)</span> 连一条权值为 <spanclass="math inline">\(- \log_2 (k+T)\)</span> 的边。</p><p>虽然两个式子一个是大于等于一个是大于，但是允许 <spanclass="math inline">\(10^{-4}\)</span>的精度误差存在，所以这样连边是没问题的。</p><p>注意这样连边要用 SPFA跑最长路判断正环（其实和最短路判断负环完全一样）。</p><p>还要建立一个虚拟源点 <spanclass="math inline">\(n+1\)</span>，保证图连通。</p><p> </p><p>要找到最大的 <spanclass="math inline">\(T\)</span>，显然二分答案，值域是 <spanclass="math inline">\([0,\min{\{ k \}}]\)</span>，否则 <spanclass="math inline">\(k-T\)</span> 就会出现负数。</p><p>题目中还给出了一些人的分数，一种方法是直接向虚拟源点 <spanclass="math inline">\(n+1\)</span>连边。但是这么做的致命缺陷在于会导致一个节点有过多的子节点，会严重影响SPFA 算法的速度。<del>说不定还会卡掉 DFS-SPFA</del>。</p><p>所以再建一个虚拟节点 <span class="math inline">\(0\)</span>，对于每个<span class="math inline">\(C,x\)</span>，由 <spanclass="math inline">\(0\)</span> 向 <spanclass="math inline">\(C\)</span> 连一条权值为 <spanclass="math inline">\(\log_2(x)\)</span> 的边，由 <spanclass="math inline">\(C\)</span> 向 <spanclass="math inline">\(0\)</span> 连一条权值为 <spanclass="math inline">\(-\log_2(x)\)</span>的边。这是常见的维护差分约束系统中已知量与未知量相对大小的套路。</p><p>这样做比直接连 <span class="math inline">\(n+1\)</span> 要快大概200ms。</p><p>由于 <span class="math inline">\(T\)</span>是二分确定的，所以加边的时候加的是原来的权值，通过 <spanclass="math inline">\(o\)</span> 的不同分类讨论确定边权。</p><p>最后，如果有正环，说明不全成立，一定有人要女装。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5005</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<span class="hljs-keyword">int</span> n, s, t;<span class="hljs-keyword">int</span> tot, h[N], cnt[N];<span class="hljs-keyword">double</span> d[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> nxt, to, type; <span class="hljs-keyword">double</span> w; &#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-comment">// type1是o=1，type2是o=2，type3是特殊边</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">double</span> z,<span class="hljs-keyword">int</span> typ)</span> </span>&#123;e[++tot].to=y, e[tot].w=z, e[tot].nxt=h[x], e[tot].type=typ, h[x]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">double</span> dlt)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) d[i]=-inf, cnt[i]=<span class="hljs-number">0</span>, v[i]=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;d[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(n+<span class="hljs-number">1</span>), v[n+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();v[x]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-keyword">int</span> y=e[i].to; <span class="hljs-keyword">double</span> z=e[i].w;<span class="hljs-keyword">if</span>(e[i].type==<span class="hljs-number">1</span>) z=<span class="hljs-built_in">log2</span>(z-dlt);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[i].type==<span class="hljs-number">2</span>) z=-<span class="hljs-built_in">log2</span>(z+dlt);<span class="hljs-keyword">if</span>(d[y]&lt;d[x]+z) &#123;d[y]=d[x]+z, cnt[y]=cnt[x]+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(cnt[y]&gt;n+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                <span class="hljs-comment">// 最长路中包含超过n+1条边，说明有正环</span>                <span class="hljs-comment">// 比判断入队次数更快</span><span class="hljs-keyword">if</span>(!v[y]) q.<span class="hljs-built_in">push</span>(y), v[y]=<span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">double</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">10</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;t);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=s;++i) &#123;<span class="hljs-keyword">int</span> op, a, b; <span class="hljs-keyword">double</span> x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%lf&quot;</span>,&amp;op,&amp;a,&amp;b,&amp;x);<span class="hljs-built_in">add</span>(b,a,x,op);<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) r=<span class="hljs-built_in">fmin</span>(r,x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-built_in">add</span>(n+<span class="hljs-number">1</span>,i,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i) &#123;<span class="hljs-keyword">int</span> c; <span class="hljs-keyword">double</span> x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf&quot;</span>,&amp;c,&amp;x);<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,c,<span class="hljs-built_in">log2</span>(x),<span class="hljs-number">3</span>), <span class="hljs-built_in">add</span>(c,<span class="hljs-number">0</span>,-<span class="hljs-built_in">log2</span>(x),<span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-comment">// 最小的T还不成立，无解</span><span class="hljs-keyword">while</span>(r-l&gt;eps) &#123;<span class="hljs-keyword">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分约束系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1712 区间 题解</title>
    <link href="/2022/lg1712-solution/"/>
    <url>/2022/lg1712-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>既然要最小化选出的最长区间长度减去最短区间长度，那么很容易想到一个典型的双指针算法：</p><p>将区间长度递增排序，维护指针 <span class="math inline">\(l\)</span>和 <span class="math inline">\(r\)</span>，表示选择 <spanclass="math inline">\([l,r]\)</span> 中所有的线段。</p><span id="more"></span><p>依次选择每条线段（也就是 <span class="math inline">\(r\)</span>在递增），在满足有一个点被覆盖 <span class="math inline">\(m\)</span>次的条件下，尽可能将 <span class="math inline">\(l\)</span>提前并删去对应的线段。答案就是 <span class="math inline">\(\min{\{len_r-len_l \} }\)</span>。</p><p>所以离散化，在离散化后的值域上建一棵线段树，维护区间内的点被覆盖的最多次数。</p><p>那么只要根节点的值大于等于 <spanclass="math inline">\(m\)</span>，就是合法的选取方案。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, cnt, c[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">L</span> &#123;</span> <span class="hljs-keyword">int</span> l, r, len; &#125; a[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(L a,L b) &#123; <span class="hljs-keyword">return</span> a.len&lt;b.len; &#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segment_Tree</span> &#123;</span><span class="hljs-keyword">int</span> l, r, w, tag;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l(u) t[u].l</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r(u) t[u].r</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> w(u) t[u].w</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tag(u) t[u].tag</span>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maketag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> val)</span> </span>&#123; <span class="hljs-built_in">tag</span>(u)+=val, <span class="hljs-built_in">w</span>(u)+=val; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123; <span class="hljs-built_in">w</span>(u)=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">w</span>(u&lt;&lt;<span class="hljs-number">1</span>),<span class="hljs-built_in">w</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">tag</span>(u)) &#123;<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">maketag</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,<span class="hljs-built_in">tag</span>(u));<span class="hljs-built_in">tag</span>(u)=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-built_in">l</span>(u)=l, <span class="hljs-built_in">r</span>(u)=r;<span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">w</span>(u)=<span class="hljs-built_in">tag</span>(u)=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-built_in">pushup</span>(u);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(l&lt;=<span class="hljs-built_in">l</span>(u)&amp;&amp;<span class="hljs-built_in">r</span>(u)&lt;=r) <span class="hljs-built_in">maketag</span>(u,val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">r</span>(u)&lt;l||r&lt;<span class="hljs-built_in">l</span>(u))) &#123;<span class="hljs-built_in">pushdown</span>(u);        <span class="hljs-keyword">int</span> mid=(<span class="hljs-built_in">l</span>(u)+<span class="hljs-built_in">r</span>(u))/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,val);        <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,val);<span class="hljs-built_in">pushup</span>(u);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">w</span>(<span class="hljs-number">1</span>); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);a[i].l=l, a[i].r=r, a[i].len=r-l;c[++cnt]=l, c[++cnt]=r;&#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>);cnt=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>)-c<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i].l=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>,a[i].l)-c;a[i].r=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+cnt+<span class="hljs-number">1</span>,a[i].r)-c;&#125;    <span class="hljs-comment">// 离散化</span><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, ans=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,cnt);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-comment">// r是递增的，直接用i代替</span><span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a[i].l,a[i].r,<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">query</span>()&gt;=m) &#123;ans=<span class="hljs-built_in">min</span>(ans,a[i].len-a[l].len);<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,a[l].l,a[l].r,<span class="hljs-number">-1</span>);++l;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans!=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)? ans:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#9</title>
    <link href="/2022/yume-9/"/>
    <url>/2022/yume-9/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="12368755cd9a7db935dfbd8a43ec765e54797878bbc601e60efa80785d775e3d">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8df424c99be363f07929f61d832db04c71a00a4f4b03efd18a403a9f37c0dfaae01edbee195de6884243cc168e70b86c2651640b0c05ec9f0053eb49deaa52ebcd5281b025cd227deaf72bc4716de8a376a948ed9bccd2415a3b7cba48ccd1a6c41efe712b47326ad4cca38e0fa3629f6eab33c5128a60ca9c4f88b143b2a35bce396c5554ac2c5519e5558dd98ffbe0eff50d8fad8b83460c082b918719677e72059e80a070ebc14085638c39b75ca093e6b97737aca382f54efaab2cfae473e3836d7b460042bdcb788772f5942b6d2b2352e8526d3745cb25064a17061d89c5695c741627a975cb78fa39965c286387d78a7f20a50990d64e90c89a2e66ce7edeaaa66e8e68bf1cbdbd8d0d2d6efc04c530a39fcd0761f1ae6ff3a7c8aede3cbb7c50fe0f8b0e71db1b8d7a16c5fa8cb5f0a703b98a8546c336a1a5284bae85c269d37d56367077673ff89f8c0063fe6a7029927a669f5ed77a7e0e11e0ccff4a61a80e9ce8924875c9684db08010f3bed01b413f48690f4790bafae6ff90103490b005741e8a2478d7d2631f71e51437e87d5957942fe59ccc380a7ffde73bd7e9ee8098615595fb49bfbca947ae12bccd211a974de86f3d0f39206cd5207146a9cf4e5e24cf9e3940efd92fe109bf91fcc8b0550771adb0ad90338577efd953657450808415d9d70a961ab9690de879eb7fd184d21f67ad6cc48fe31751ff6e5e66c0cfb628c34e4663b96da20e52b5b8ed145efad7700b1ccd5dbbfc5b14063824ef7652ec4774b475fbf5ef146278b466d4e267b79ba42380b87c93bef53b2e2504261539ea73143ca5c8e9d55458cc2e43c3df54c3f87839113cd961b5a9a161cb92bf8a8801169dc64afdc38920565451f0dbf501d5d413db527c96b534f84bc3a69aa6eac689c9abff32da3f4523c4550dcdf70ae74aa05f58ab41022badd612ba351a219fa43498b363c2b5e7466b3945654a933fb10730502e3560c0db53700c24cf2b23fd72ae05cb1ee656651a53460efdfe0e19ffd3b6b877f8ce236d8827175fe445eadca104a345e0e8f929c9ebe6edc3045f7d0a01189edee119ee759d1ff3cb00ed04d64beb314e234a65c39608ab7cd4c6dc70ee9615c48ff34eef927a4babbeb34f8b3079521f1040e0aaf57a6c2a9b4153defa1df43eca38cd309db8ef9b74505ea6bd6de326171be94f3365e964da26987977de0215a2241c1ee0950ce5e98e529c18fbca290077ca87e368c6cc542999746313203c2d18ad19c8462ec182a7de8fddc6c7aa6b9616c1d99059d7b252ff3f73dbd7b968c6196a36a00d95f7e8d9ed555336d6b8f61f370173fffd95f7ec70126a8a3b4a91950041a9eee66c8df36acea4a44f697cb15f4adcfa0a720980ea6c5add56d3fa538039c5a2775e7dd12f819810b575369282ae2df287e5c358c737120e381c48e25029fdacfca85ce9ea6d37a391a60256adfa83cfbe0f0452e1d739546bf98329d6c8aec63f4e468f9093e287202a9bac658308f574e1e04501a45577196b14dd5a46bd28279120c88bad457c5e127d79da3df8b0fa4b7c1a9d5fb54dacfd626ffb70940c091ef911dc98e2a60ecf7361fcffafceef43e6cf4eeed99e39c94af7b54629c3aff90cd02e3d3de08fb49ca308534549a3ac3e52c74ae4a82ddb3eba619b781961234729b67b41252f9408b514054afd5815e17b65148f9296b96d9d850211758319bd2b3bef7ed53b0343ed8fda0728fd9252e8ae417e30cd713813bfc1da02f6ffb74a721f45a6c1106e2f81c2831f91efe8f54ba713a9b56c494e6466319d532e12838ad60ac4c5062bf1ba565044bb48895b88872957c3f0501faf67b1e0fe9dcac93772c8a46911ce47205c5580db30a0b75c2d3f42ce15cca7aed12f6e2b8800aae3839ebb4c5f8ce2b8e976d199f138018442e82d1519c06ee9781bc330b8ec5710ed7ae0ca5b3395680adf10f85ebb0ae22197a600355d9615e28d6fc667ca963616173e024ffaa3c3f548b1ef42ddde74cb7b21bfe52e70c814047158ae3657f88a6dd34ad513cf00352a7100bdb68c3ad3b4ec9143d64540a9a92cfda0463446756319dc5acacca08e5ec5e1540203c3ad3ba2138d78dfb09f8003d65c040d31206f85f1057045c94070ffdf1843e2f153766c7cb795b3fcbc50830f7aa6279c1f03e1ea079c73bbd39562ca2d32cf0a09fb5cf1262ce3ea3e80d1089e6fdc567454084fa6360dd1cf391412b299fc533643642f4f3a396412488ff0d4acd369007c79e7d763c656a05b29f14ef7c4b4e48cef46f7a96425b1722994fcbd96bbed85d36b40e00a516655018773d685523341176159ab21ff55387b9b4b121b9140df4c5e9d2a4db84d67c8d68b6068e8b5b72e4e44a857685fc7a41eb6615e619d756822c894aecdffbe6fbb066079557789b803e24214934abc5104e11be4ddf5754fcd440375ec309234bbbe83bfb212f98ce1e7f88b4e8fdd7f0af968f98a000a5ab8fc657a9acf563220094c933f2338df5d642111a66a380f9f3dcba12f596c1092ee80114dcbd94ba2abfb6cd9f10953280631e885f86b0a8f4bc54ea661614b7ff57140d948ff7b2d4ccfab87461680abc768a90f0625c4cd0dc87b60c7c4c764c3ef97353cc33bf5948a7f6cc0c006cb380057a499795911ded1b4e7cc4fcb9dca89390a6ee0a092c301708c49efeb9ca9a3255142b47eb897586744e994895bd6a816ff63a65d53e0693c933b81d95b532a0784d2312078efabf2747668d475577096326e2bd3c45830d475d0c64064d986d40958739314266fff6a6e91ea57b7a03cddf40d87e5e8634d8efbf8392abc73a6c188a63ad34a7e82cd8821525c3c0bae9cc41b7087036d1c4abc95d71bbbe0391af924e531124ce11bd6e3eb4b30b9b2c8db049f5bea270e8bca9d334aa9e18429a847dc57ba93d7bcfe67297787e3c2c1bedb66167e1990f6e73214d7ea6b223f2f3d338dee5b672d5c5135bf4e6d7b2913f7040690779642e3623213fe31a28f911bec9ac9dff29b1be5fe56b69e5ceab812a89f8d7962c93e02149bcbfd31dfa75031bdd4b77e62dad2c2c03cf128778e35bf166fd35bcdda704c0baee9310d5070ddcee08cbfe7290f6aac361a5771891606d6123d7c07469df5a2946bdab9d81584f8d8475a365eb71f35024a4d15a6ad6af1c99a8dc5c018515fd99bf2aaf09a73418ddb97993a0d0358b004e6d3aac75fc527919ead40327f07d7a3ec5fd023c5c099b537080512206ea70d6ed34740f748d3e4a733b32b8ef0acdfe6eeea086e42ab1ff7a066cf20045aaf34be60346eb6f5aa8ac2f0e2714452f22bb571adfe4f7f15db21fcc2a84457161b336b8aa72cfda96581fad8a37fac4892c79d0db84d6db57ef9d2f0778d5cafe41c3d75037bb3f1e032d1f04c514e484beabaffd5fc35782ac28cb68a32d873f386fd97c042ea91205445302cc751dda4fad09e26ffb3d0e6fcd6a908addbb340ab68529878e11dedaa1e0ae54b2528e9225712df07990fa7ecce7f221466978f48627c2fe92b5864a5cbfa6fe42a8917dae119b4ad0afe6951f0be149c1bc1eba36064ba38185a6b447af60fdd6af32bdbbab688a91efc7f22df1a0941bbd2558dd7e852a987521a08ba7bdee379d64acfa98dafd7ee7ad654be9faa71d20b3719c5d883ab89d0dbfc0c2b4e4e834a4aa26c7e2cbac8aa73ef9f8d23825bc9172ba4cb5927adf17c8bcc7464b390115eaa9b322207b61e2f06a1c55be562db893d132f19661b037eee2f3597fa671dfbdc92f7168c42f963a95610572e10a6eae79f0b4b3276935aba3e046e661448a5a881fbf982a9995b3ef975cfeba7c44df7fb6e42ac0f6244cdb3d4e52479cd5b0df158d299fa6a5c5c0691e91cec0777bd9994cb205e2672bb8ea590c28c9365a4c512d266ea59201f58b8a467f526b5187199ed20c0dffa09a6c0d3919b9f6b9037c390054471dd9f11a9063afb6d39f5242ac57dfb21154e404379cf016e08b964d79910bf84e25b9ad662e16809ed977d29008fb0fd718b7066c3f4f933e0b1416f9f295c518c5c3d2ebf998f01b8eb8815716268caba8f314d9382f7c2faddaee92f36a75726d0b0a90922ca0e33d74f32a1af9235b02847d5c65d420a35fe44bee01d0985ac504e46588275c08f5cd7d2ceb9e0c7a97f1405b52ef3c471a63a81dc0b58921a61d458e17815032e1593e85191c626cbe013f418ac2dd0dd7808293b0b91d176ee29c41339ae8961e77c58bc1cdbbaf5fc3bcfb2b042ae71adc2e47d1048da6e0c46fa28d79f03d5266f11b1a31df0a8917335144583f0a5e53df1bb7f8b7993b38142c93bf9071996970896bbfea5e5552ce68f4c784481a698e807b0e613fc78ec490d3a5b46f242491b288982d48bc325f6a1c5edfa5001523d2c68eb39053f48b9367ec22916d04a33ad6d1559e33a22294e83c957c1b493b02c5b968b26ebf7be39ef5bfc7fa23d2c9d3e7ccd2cc98731291804d1902221c265c12bdb90ee46aab5a6936f4a828f35deb4bdabcd28a4d00ff62bf7cc45ffb0f2256022f0559bb3c76357a37b96a53a656db2052b2d4d2bc314cb493c98a674f392ed6625be8a2f32912619c67f4cb1a5da3636dff23b5b9cfdb20c76f2e1522eea3b4732cc4c39c55f8f389727eceddb7834aee1a819219b27d8eb29d9af261f03650abeda61bf21057c6ec0f7a6bafdccf7323158851623c21309c7e3b41ab5e718e4225686677552846eb52185a3afd07b7ea1854ffe55469f13f5174d325e528c9f7d876c1abe5f3b54aa7ce6926159bcf5a7d9cae6adc96f83e719ec9971c7031666a5e9667b9dcf04b536f6ecd608a8082b3ef72c4835fe701d8438b6aaedc8053c6d0965aafcf279ab1f06ddaf22e3ab9d9ebcfd1663d33a669f0cb462b79e77dbf64331f46bc49758a3aa72a81f724bd40047a5d6ae538bd90efed8433217da3ca5d8beddb054a869dc32dbf66a36f106a586f8e1b24802449afb9969b3a04f371a02f879e172ea3975e796c401b112b544e366a1363299f3f7db07da41c484d970156c3cb9687dd9f0a59946092f4dff6ae9611292b64a9a9848249f96b020e37f18f317d6a78180fc8c823221b57f671d7b8487288e9007bc5960036089085d6574ff113743040393a836adade90c9b5ce022d343aa6dc50d84c0fbbe77dfb986f0d31413c60e01e5919651b5c5a1ae7975bb4317e833410e9f64cf15cd5d391cad0ede89defe6fb37a0019bab24124f6fb8f3535aa12844685d6fe072f4527c3722b32f062aa693b96630a0c20547720e519194acb4c51ff126c8a85aa281b008812070c59a31e19fece4ca16faec1f0b5f4128325d7ed1e06406b2ec928347f882e364d142bba1a5c51a777b8f0d39b8e488ad7b122f9af5a0aa5d5d3322f990e432cd03848196fe6193289431ac30b5271d0f7c8da2a05fd30ce371bf862a16b9ba47acb6fbfad565f36dca86541479f4111a9507f3eef8b2656ab0efe007474fb254e892588b6f89191c3f0e1c49895994c759e1742de80bcc317a032768f3c08bf5f79cb5c30da0f59c155ee6d7cc7bfc21f85ffb73775edba5a3c1a532638ee7e0d178a246483234ff69536c326425a032a062dca5ba9a47e9cb04af90841f6d0e0ad97ca0915961d0b5f289aab9a4c640fd5452cb1ce5707edca0125f1452538f79af6e0d1410685b039590391048d806b0149d91b097db70027723735584914a7ac1ce0212860a7d51458541e26387b524281a0e251ead4203c6b3655e7452385bc63b266aeb25d9f8216d301b1abca9f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2679 子串 题解</title>
    <link href="/2022/lg2679-solution/"/>
    <url>/2022/lg2679-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>莫名其妙地想把这道题的题解写了。</p><p>设 <span class="math inline">\(f(i,j,k)\)</span> 为 A 的前 <spanclass="math inline">\(i\)</span> 个字符取出了 <spanclass="math inline">\(k\)</span> 段，恰好匹配到 B 中 <spanclass="math inline">\(j\)</span> 的位置的方案数。</p><span id="more"></span><p>如果 <span class="math inline">\(A_i \neqB_j\)</span>，那么不会产生任何贡献。</p><p>如果 <span class="math inline">\(A_i =B_j\)</span>，那么有两种情况</p><ol type="1"><li><span class="math inline">\(i\)</span> 接着上一段那么 <spanclass="math inline">\(f(i-1,j-1,k) \rightarrow f(i,j,k)\)</span></li><li><span class="math inline">\(i\)</span>是下一段的第一个。那么它的前继状态有 <spanclass="math inline">\(k-1\)</span> 段，匹配到了 <spanclass="math inline">\(B_{j-1}\)</span>，但是 <spanclass="math inline">\(i\)</span> 能取 <spanclass="math inline">\([1,i-1]\)</span> 中任何一个位置。所以维护 <spanclass="math inline">\(g(i,j,k) = \sum_{x=1}^if(x,j,k)\)</span>，转移就是 <span class="math inline">\(g(i-1,j-1,k-1)\rightarrow f(i,j,k)\)</span>。</li></ol><p>另一种理解，<span class="math inline">\(f(i,j,k)\)</span> 就相当于<span class="math inline">\(i\)</span> 这个位置必须选的方案数，<spanclass="math inline">\(g(i,j,k)\)</span>则是选不选都可以。后者显然是包含前者的，所以最终答案是后者。</p><p>这样会爆内存，可以滚动数组优化掉 <spanclass="math inline">\(i\)</span> 这一维。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1005</span>, M=<span class="hljs-number">205</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, m, K, f[N][M][<span class="hljs-number">2</span>];<span class="hljs-comment">// f[i][j][0]是上文的g，f[i][j][1]是上文f</span><span class="hljs-keyword">char</span> a[N], b[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%s%s&quot;</span>,&amp;n,&amp;m,&amp;K,a+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>);    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 简单设初值就够了</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j;--j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=K;++k) &#123;        <span class="hljs-keyword">if</span>(a[i]!=b[j]) &#123; f[j][k][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-comment">// 因为有滚动数组，所以要置为0</span>        f[j][k][<span class="hljs-number">1</span>]=(f[j<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>]+f[j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>])%mod;        f[j][k][<span class="hljs-number">0</span>]=(f[j][k][<span class="hljs-number">0</span>]+f[j][k][<span class="hljs-number">1</span>])%mod;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[m][K][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3216 数学作业 题解</title>
    <link href="/2022/lg3216-solution/"/>
    <url>/2022/lg3216-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(f(i)\)</span> 为 <spanclass="math inline">\(Concatenate(i) \bmod m\)</span> 的值。</p><p>那么显然有 <span class="math inline">\(f(i) = \Big( f(i-1) \cdot 10^k+ i \Big) \bmod m\)</span>，其中 <span class="math inline">\(k = \lfloor\lg i \rfloor +1\)</span>。</p><span id="more"></span><p>这个直接递推绝对是 T 飞的，<span class="math inline">\(n \in[1,10^{18}]\)</span>。</p><p>但是这明显是个线性递推式，可以用矩阵优化。</p><p>定义一个向量为 <span class="math inline">\(\begin{bmatrix} f(i-1) \\i-1 \\ 1 \end{bmatrix}\)</span>，我们的目标是把它变换成 <spanclass="math inline">\(\begin{bmatrix} f(i) \\ i \\ 1\end{bmatrix}\)</span>，这个 1 是来辅助把 <spanclass="math inline">\(i-1\)</span> 变换成 <spanclass="math inline">\(i\)</span> 的。</p><p>手算不难得到这个矩阵就是 <span class="math inline">\(\begin{bmatrix}10^k &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1\end{bmatrix}\)</span>，设它为 <spanclass="math inline">\(A\)</span>。</p><p>那么就有 <span class="math display">\[\begin{bmatrix} f(i) \\ i \\ 1 \end{bmatrix} =  A \begin{bmatrix} f(i-1)\\ i-1 \\ 1 \end{bmatrix}\]</span> 进一步得到 <span class="math display">\[\begin{bmatrix} f(n) \\ i \\ 1 \end{bmatrix} = A^{n-1} \begin{bmatrix} 0\\ 0 \\ 1 \end{bmatrix}  \]</span> 由于 $i +1 $ 在 <spanclass="math inline">\([1,9]\)</span>，<spanclass="math inline">\([10,99]\)</span>，<spanclass="math inline">\([100,999]\)</span>这一类区间里面都相同，所以可以按照每一段分别处理，具体见代码。</p><p>注意上面的矩阵变换！必须保证先处理矩阵的幂，再统计答案。统计答案只需要累乘每一次的结果就行了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5</span>;ll n, mod;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span> &#123;</span>ll m[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j) m[i][j]=<span class="hljs-number">0</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i) m[i][i]=<span class="hljs-number">1</span>; &#125;&#125; ans, f;Matrix <span class="hljs-keyword">operator</span>*(Matrix a,Matrix b) &#123;Matrix c; c.<span class="hljs-built_in">reset</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;++k)c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;<span class="hljs-keyword">return</span> c;&#125;Matrix <span class="hljs-keyword">operator</span>^(Matrix x,ll y) &#123;Matrix z; z.<span class="hljs-built_in">reset</span>(), z.<span class="hljs-built_in">id</span>(); <span class="hljs-comment">// 矩阵快速幂要把m[i][i]置为1</span><span class="hljs-keyword">for</span>(;y;x=x*x,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll p,ll b)</span> </span>&#123;f.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=p%mod;ans=(f^b)*ans;    <span class="hljs-comment">// 一定是这样的计算顺序，不然WA</span>&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;mod);ans.m[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f.m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=f.m[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=f.m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=f.m[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=f.m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// f就是上文的A</span>ll r=<span class="hljs-number">10</span>;<span class="hljs-keyword">while</span>(r&lt;=n) <span class="hljs-built_in">solve</span>(r,r-(r/<span class="hljs-number">10</span>)), r*=<span class="hljs-number">10</span>;<span class="hljs-built_in">solve</span>(r,n-r/<span class="hljs-number">10</span>+<span class="hljs-number">1</span>); <span class="hljs-comment">// 特殊情况，不是一个完整的形似[10^n,10^(n+1) -1]这样的区间</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3620 数据备份 题解</title>
    <link href="/2022/lg3620-solution/"/>
    <url>/2022/lg3620-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>很容易发现选择不相邻的两个办公楼是不划算的。</p><p>所以记 <span class="math inline">\(d_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 与第 <spanclass="math inline">\(i+1\)</span> 个办公楼之间的距离。</p><span id="more"></span><p>由于任一个办公楼都属于唯一的配对组，所以一旦选择了 <spanclass="math inline">\(d_i\)</span>，<spanclass="math inline">\(d_{i-1}\)</span> 与 <spanclass="math inline">\(d_{i+1}\)</span> 也就不能再选择。</p><p>考虑特殊情况，当 <span class="math inline">\(k=1\)</span>的时候，答案是就 <span class="math inline">\(\min{\{ d_i\}}\)</span>。</p><p>当 <span class="math inline">\(k=2\)</span> 的时候，设最小的是 <spanclass="math inline">\(d_a\)</span>，那么答案一定是</p><ol type="1"><li><span class="math inline">\(d_a\)</span> 加上除了 <spanclass="math inline">\(d_a\)</span>，<spanclass="math inline">\(d_{a-1}\)</span>，<spanclass="math inline">\(d_{a+1}\)</span> 之外的最小值，</li><li><span class="math inline">\(d_{a-1}\)</span> 与 <spanclass="math inline">\(d_{a+1}\)</span>。</li></ol><p>两种决策其中一个。</p><p>为什么会出现这种情况呢？因为选择 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(a-1\)</span> 与 <spanclass="math inline">\(a+1\)</span> 便不能再选。可是如果 <spanclass="math inline">\(d_a\)</span> 加上除了上述三者之外的最小值后还不如<span class="math inline">\(d_{a-1}\)</span> 加上 <spanclass="math inline">\(d_{a+1}\)</span> 小，那么就是另一种答案了。</p><p>那么就有一个结论，<span class="math inline">\(a-1\)</span> 与 <spanclass="math inline">\(a+1\)</span>，在 <spanclass="math inline">\(a\)</span> 不被选择时同时不选，在 <spanclass="math inline">\(a\)</span> 不选时一定同时被选择。</p><p>感性理解一下，对于任何 <span class="math inline">\(k \ge2\)</span>，这个都是成立的。</p><p>单纯地贪心不能保证当前最优就是全局最优，可是能够修改某一个决策的方式维护全局最优，这其实是一个反悔贪心。</p><p>所以维护 <span class="math inline">\(d_i\)</span> 的集合 <spanclass="math inline">\(S\)</span>，贪心地将最小值 <spanclass="math inline">\(d_a\)</span> 加入答案，同时删去 <spanclass="math inline">\(d_a\)</span>，<spanclass="math inline">\(d_{a-1}\)</span>，<spanclass="math inline">\(d_{a+1}\)</span>。加入一个新的元素 <spanclass="math inline">\(a&#39;\)</span>，其中 <spanclass="math inline">\(d_{a&#39;}=d_{a-1}+d_{a+1}-d_a\)</span>。</p><p>这样当取出的最小值为 <span class="math inline">\(d_{a&#39;}\)</span>时，实际上表明第 2 种决策优于第 1 种决策，加入 <spanclass="math inline">\(d_{a&#39;}\)</span> 后也相当于一步反悔，把加入的<span class="math inline">\(d_a\)</span> 消去了。</p><p>既然要快速查找相邻元素，可以用链表维护，用优先队列实现贪心。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>, inf=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;<span class="hljs-keyword">int</span> n, k, pre[N], nxt[N], a[N], d[N], v[N];<span class="hljs-comment">// v[x]代表x是否被删去了</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> x, val; &#125;;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.val&gt;b.val; &#125; priority_queue&lt;node&gt; q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(node t)</span> </span>&#123;<span class="hljs-keyword">int</span> l=pre[t.x], r=nxt[t.x];v[l]=v[r]=<span class="hljs-number">1</span>;pre[t.x]=pre[l], nxt[pre[l]]=t.x;    nxt[t.x]=nxt[r], pre[nxt[r]]=t.x;    t.val=d[t.x]=(l&amp;&amp;r)? <span class="hljs-built_in">min</span>(d[l]+d[r]-d[t.x],inf):inf;    q.<span class="hljs-built_in">push</span>(&#123;t.x,t.val&#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) d[i]=a[i+<span class="hljs-number">1</span>]-a[i], pre[i]=i<span class="hljs-number">-1</span>, nxt[i]=i+<span class="hljs-number">1</span>;    nxt[n<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) q.<span class="hljs-built_in">push</span>(&#123;i,d[i]&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;    <span class="hljs-keyword">while</span>(v[q.<span class="hljs-built_in">top</span>().x]) q.<span class="hljs-built_in">pop</span>();         <span class="hljs-comment">// 优先队列不方便删除元素，可以额外标记已经被删除的</span>node t=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();             ans+=t.val;        <span class="hljs-built_in">updata</span>(t); <span class="hljs-comment">// 更新链表</span>    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1332E Height All the Same 题解</title>
    <link href="/2022/cf1332e-solution/"/>
    <url>/2022/cf1332e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>首先转化一下题意。</p><p>对于一个 <span class="math inline">\(n \times m\)</span>的格子图，每个格子都有一个初始权值 <spanclass="math inline">\(a_{i,j}\)</span>，有两种操作：</p><ol type="1"><li>将两个相邻格子的权值都 +1</li><li>将一个格子的权值 +2</li></ol><p>求能将所有格子的权值变为相同且满足每个权值都在 <spanclass="math inline">\([L,R]\)</span> 范围内的初始局面的个数。</p><span id="more"></span><p>这种题目可以从奇偶性下手。</p><p>对于操作 1，实质是同时改变两个相邻格子的奇偶性。</p><p>对于操作 2，实质是在不改变该格子的奇偶性的前提下增大或减小权值。</p><p>那么只要我们让所有格子权值的奇偶性相同就行了。</p><p>设奇数个数为 <span class="math inline">\(A\)</span>，偶数个数为 <spanclass="math inline">\(B\)</span>。那么有 <span class="math inline">\(n\times m = A + B\)</span>。</p><p>考虑操作 1，如果那两个格子都是奇数，那么 <spanclass="math inline">\(A+2\)</span>，如果一奇一偶，那么 <spanclass="math inline">\(A\)</span> 不变，如果都为偶数，那么 <spanclass="math inline">\(A-2\)</span>。也就是说，无论怎样改变使用操作1，都不会改变 <span class="math inline">\(A\)</span> 的奇偶性，同时<span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 此消彼长，<spanclass="math inline">\(B\)</span> 的奇偶性也不会变化。</p><p>由于最终一定会让 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 的其中一个变成 0，所以 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 中至少有一个是偶数，否则无解。</p><p><del>但是似乎题目保证有解。</del></p><p>先说一下，向下图这样，将两个格子所在的路径上所有的格子都进行操作1，最终就会单独改变这两个格子的奇偶性。</p><p><img src="https://s2.loli.net/2022/05/15/XAtmTSQCOpI9Na5.png" srcset="/img/loading.gif" lazyload /></p><p>因此只要 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 其中一个是偶数，就有解。</p><p>如何计数呢？再分成两种情况讨论。</p><ol type="1"><li><span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 一奇一偶</li></ol><p>由于 <span class="math inline">\(n \times m = A + B\)</span>，那么<span class="math inline">\(n \times m\)</span> 是奇数，从而 <spanclass="math inline">\(n\)</span> 与 <spanclass="math inline">\(m\)</span> 都是奇数。</p><p>在这种情况下，要么 <span class="math inline">\(A\)</span>是奇数，要么 <span class="math inline">\(B\)</span>是奇数。所以无论图中初始权值是多少，都一定能满足上述条件，随便选就行。</p><p>由于每个格子的取值都在 <span class="math inline">\([L,R]\)</span>中，所以答案为 <span class="math inline">\((R-L+1)^{n \timesm}\)</span></p><ol start="2" type="1"><li><span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 都是偶数</li></ol><p>不难得到 <span class="math inline">\(n \times m\)</span> 是偶数。</p><p>由于要保证 <span class="math inline">\(A\)</span> 是偶数，所以答案是<span class="math display">\[\sum_{2 \mid A}^{nm} C_{nm} ^A \cdot k^A \cdot l^B\]</span> 其中 <span class="math inline">\(k\)</span> 是 <spanclass="math inline">\([L,R]\)</span> 中的奇数个数，<spanclass="math inline">\(l\)</span> 为 <spanclass="math inline">\([L,R]\)</span> 中的偶数个数。</p><p>然而这个式子是没法求的，根本找不到 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span>。</p><p>考虑二项式定理 <span class="math display">\[(k+l)^{nm} = \sum_{a=0}^{nm} C_{nm}^a \cdot k^a \cdot l^{nm-a}\]</span></p><p><span class="math display">\[(k-l)^{nm} = \sum_{a=0}^{nm} (-1)^{a} C_{nm}^a \cdot k^a \cdot l^{nm-a}\]</span></p><p>由于 <span class="math inline">\(B = n \times m -A\)</span>，所以将两式相加，<span class="math inline">\(a\)</span>是奇数时相抵消，<span class="math inline">\(a\)</span>是偶数时算了两遍，最终答案是 <span class="math display">\[\frac{(k+l)^{nm} + (k-l)^{nm}}{2}\]</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> ll p=<span class="hljs-number">998244353</span>;ll n, m, L, R;<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;ll z=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;y;x=x*x%p,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=z*x%p;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;L,&amp;R);ll w=R-L+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>)&amp;&amp;(m&amp;<span class="hljs-number">1</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">fp</span>(w,n*m));<span class="hljs-keyword">else</span> &#123;ll k=R/<span class="hljs-number">2</span>-(L<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;ll l=w-k;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(<span class="hljs-built_in">fp</span>((k+l)%p,n*m)+<span class="hljs-built_in">fp</span>(k-l+p,n*m))*<span class="hljs-number">499122177</span>%p);        <span class="hljs-comment">// 499122177是2在模998244353意义下的逆元</span>&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4155 国旗计划 题解</title>
    <link href="/2022/lg4155-solution/"/>
    <url>/2022/lg4155-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>既然区间没有包含关系，那么把所有区间按照左端点递增排序，这样右端点也是递增的。</p><span id="more"></span><p>断环为链，当区间 <span class="math inline">\([l_i,r_i]\)</span>被强制选择时，只要贪心地选择靠右的区间，记录达到 <spanclass="math inline">\(l_i+m\)</span>位置时经过的区间数量。（也就是把环覆盖一遍）</p><p>这个算法是没问题的，但是要求出每个区间的情况，复杂度 <spanclass="math inline">\(O(n^2)\)</span>，不能承受。</p><p>要优化的是暴力求固定边界的区间数量，可以用倍增。</p><p>设 <span class="math inline">\(f(x,i)\)</span> 为区间 <spanclass="math inline">\(x\)</span> 经过 <spanclass="math inline">\(2^i\)</span> 个区间所能达到的区间编号。</p><p>注意最后要加上 2，自己和最后一个区间统计不到。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">int</span> n, m, len, ans[N], f[N][<span class="hljs-number">22</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Interval</span> &#123;</span> <span class="hljs-keyword">int</span> l, r, id; &#125; a[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Interval a,Interval b) &#123; <span class="hljs-keyword">return</span> a.l!=b.l? a.l&lt;b.l:a.r&lt;b.r; &#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>, ed=a[x].l+m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]&amp;&amp;a[f[x][i]].r&lt;ed) ans+=<span class="hljs-number">1</span>&lt;&lt;i, x=f[x][i];<span class="hljs-keyword">return</span> ans+<span class="hljs-number">2</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m), len=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r), a[i].id=i;<span class="hljs-keyword">if</span>(a[i].l&gt;a[i].r) a[i].r+=m;     <span class="hljs-comment">// 特殊处理，此时是l&gt;m，r&lt;m</span><span class="hljs-keyword">else</span> a[++len]=&#123;a[i].l+m,a[i].r+m,i&#125;;        <span class="hljs-comment">// 断环为链</span>&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+len+<span class="hljs-number">1</span>);a[len+<span class="hljs-number">1</span>].r=<span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// 这里一定要足够大</span><span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) &#123;<span class="hljs-keyword">while</span>(r&lt;=len&amp;&amp;a[r+<span class="hljs-number">1</span>].l&lt;=a[i].r) ++r;f[i][<span class="hljs-number">0</span>]=r;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">20</span>;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) <span class="hljs-keyword">if</span>(a[i].l&lt;=m) ans[a[i].id]=<span class="hljs-built_in">solve</span>(i);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,ans[i],<span class="hljs-string">&quot; \n&quot;</span>[i==n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#8 从今往后</title>
    <link href="/2022/yume-8/"/>
    <url>/2022/yume-8/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="89ae4b27189cc41e86765493ccf1129214945231f7041271dde58e1fb77b0bd1">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d87fa1003960097328b6597052d0d7e7b3db10b03f2e8796ceb6299c536bee8a276281c84244d96b91a83ebe53d0c7a9e2f8a28fb5291261e703d2657d07285599b2a7c630ed4a6d2392acc61b1f1dceebe9a2de69cc62edfb164bb669c1d7f95c15a1affae712aac771bfa72f26eaf9d8a89c2dcae61c4e71aca12994ee023d08d11e247c820a8e3e03b2e0fd2a8ab111b22a35a15317eadc0934745264e153cc5cf238c960840fecf88b695cce622b47534715d000e1681e9a48802070ffd34f838e3cf4148079c013ae91fddbb836fcf86bb7ccd30dd6bcc0f83f3750f5bd3d88542ed14507a1a1f4f5be632fe6ee969dd62dad296ffe4430e48a65600953c85d901dd810b3b4ad73b729d6b7bd903f992e3fa7ee9c1c3bd71668d9afabb9567b4b533277ea859fd7ef7e1c76e7a7769a44aa8c2f0828fc57e4adfc6f31d7daec5334dd6182c5e93f388cd0df2cde29cacd3acc3af19b09b73b52d75ce3daab47f7c1fb8ca8e34a525ae46814b9ba4aa33043396391823f90fbb5c2798e807cf377f2c140f3593ac2d977eac2a4fd00a6a659e0a976ff2cb15eb8cef44f3b1c9ddea65c2554d1c21d7b6ddcedb1aed46b6e7f78cf812a72ccf9940c6d34dcd9078dd843a4f3a5579cb415e5f3036dba2a51fe603c2d34656dd2fc06b15cdf93e160e2c96fd340ab0b8eb60bfbcd6b576fdedc46b5495c940ac8673abe88777ddd2251e9784516a5be9f0dd1696a133fd87286025920974a3313eb67c8bae955d0b2b903dddbe07353a9177ad0aef106fb0e5b428e5b4e854baa772c56b07937cc392995fde5878fa6d24dad8188cdd632beb02b1831e28893584c61a4568724767b549dbdc1eebc546d36cb9519f7b6adadd9776ea395b97b71489ff9895119b1f1a82051c198ffd78b3be3426778923d42f3435e75dc2dffeccdcc0df19617987eaf71413ebf46eae56e9731b39d0cbb263b580e497e37a3bd9aaad4e8c7f2a199c482194605893fb02bea69f17fa35b1bb6d221e3313f5cf6f179cd9379d7c41afe148d99a81e7636df6cc6e5349bedeb98953c0fa11586819798ccac791ef1af544584da1d5d3ffb0e352bb0525f1e8bb600fffd4d1c1f0f191e4f12439408f65d232a28a46e712a500bb80703ae2691a166edae6bc104ecea5a2938d744fe82c76cea8982dfa04ec59b0521408e36e8a395bc0c05290e2faea714268ff363c378b5338ff7fe888b7777c6558f24761d38e9def3f01abd852bf62ff0951565015808275ecbc91fdd01de1f76f49564db7cbd432307716a343ee36d7da5206d3d9a00039c5df36a46399632d23d7e6e16c1144b9e6fee519eae508124395fd35668eab5e1c1b53b3fb1a6af9ddf942cd778ababf77f289bc72c9fd6e931ab9b2b8695bd4dfa864ce38534bd5f5e5e273a86d7c2fd79cd258f00aa69e0441cb6eec0acb020c129d467ecb61cb6527f5ef90a26b51bfe89b150407388658c88e120db35062eb94a438cd8652bbc1e0ba366c72fa50200efe3cc9b553db84bfbf5210b1c9a7f81a0f2b3617d8a78a3ac17473d83ef5144307350ae1a94b581edf0643d60a8b7bd3afb2f775d4b6c0cca63a12336d150b7b782b0d7eb42a391db39c5fdaa7cfc6f470357dcaca9389c268132b5f2e07ba4b324bb14ad07ea313f633f5c1d4331031d3027956e1ba9b9f3afb889fbd837d114b8dc2c29bb47c915c195f64551bde103c1414742c43096fdcad1d0e7d27daabfb53fbab11f2d7c52621bd74df82983585c8795b3996795ea0dbce58bfe708d5099a08dc77f607f5d3bb0fa86fbd97cd31e63a9f5935917ae5e0ccbe3259924806acc3d244f3a81c63c725f69c883e8fa9e46a03780c01b7e99617f756b55109137f6d5959aa5e2724e370502bc35bdf43c253165f57e57303c35642a1f973c5b972acc5eddab5b0030b81bdd5a54247eabc89a196c19e7dd519cea51b3e78ba7ad39d83f69d7b76733374fe58501ba3bd86f17471025437bd27ecc9e6d50f70687e81bcf1cb160b06dfd5c3ded604efd1b7b15f4536f4483a6eb41116eab1a03edcf71dc52d1ac9990746529fa4f4f481aa966f1417aa97f820af21e1099cd02e7ecaef0c16f8dc39251335fbb6a5d98ec0c12c5cb6fd2069f83ee80aae4710f3e66762f375cba5372c43b41b93c0f6317b4b50eb641a059226036d971e81dd63b076e2865b21a67170e5afe5cffa759b53a42d817e01e9612633eda752d1179c21daa6bb928002c0833131f2db4a5d9b5338350a362ccef6b2a6875df5cc72e910486b3de689dce867f64e24ca1db2548f4be84d97134c52a74bc2b5ebdac16b3b51c9d40a0f01d3157370c0066b974c2cdfbe5e5c28454f64f0f7f6f24088c8dd2cf0b9e471a462cb23da6e96591d44e3cfd4d04c20ef8ef9af8bb1003f46fa3bff27d23cf9dccb21b450b2c4ae8d3b8be5a6bf6eb7fcd9fe912ad298934f72d5767f7cdfcca5bc6668ff6611bfe91f6798811f7ea5c58186b3bf7becb70bdccf4d0e4e11de07f13bc8af6d0b05a413c89cfdefc544c807fb20d714f73a921835cc3a8c4d80a8f81b4c6f35886ff37dcca3d9de24f7ba984dc3147119e1724a57d26d8af2e9eb7f4a3e5250b37e1e82a2feba9ea5e4c9dbc78cdf2c62159d665f1cc14f902f4d449c75a3413074f833f25b2980fe8d1379b26ccfb5f93edcc6b946b84b381bb81746adfe516afef889a5125ae4abb87716a8cdfca6fd1cd779d9a29cb97b84695494b829f5ff190793e2ce48bcdccd132db452df25282619ee80e5726289c47c7976995f013748d5dbd442f0b12243e0981845bdf39fc2ed2971c9294d28c65d966a08a0498676207035ac12993b978faa8aadb40c6fe5418407d457236128df218c67c20b76c6cdbddaa39d01cbe9cd6d941876c27224f9b113a5ed2bff0f8c77d480027744772de33625e3026f8dedefe77c070ca56e05b7057579554ba24b690e3208c33ae3086d1bbf3b73ebca2d6225b7bf40023b3ab20d030f90ae592548d466330dff3c5427bf696c1b23452960f805ad44e8a7e9a929396433eca13799224f0a27474f8b46d7c4c17cf59cc2b24804e13151ae70829475fe0888458988bca04cc2fa04fd63effd633b3a26f639996361b88bedef7298d8ddc86b847f47d45a43f9ad6aaf0e83562d846acdb259618e8a3f2c6201be092925a7829faaf04cd96f9a7f6013918266d3af23dc85fcfa1e8663341dcc924e5dd0329b82c3f6bcc976f446ce0ea1aa99d1c3f6e61f102574500b6c62e7f89600c3064fcc0863dbf1b105f3daf1a94f523df75f1693e2716baf7d46ef5e3f062201f4fd58046d438a7d33a8a932bac316790fcf4385ec25be47e5edb68e06dbf2f07de08d9c4a93783afa726d93845e5ff4c1e6b6bc8df6dc8019a824f5971e86cc38ad7e623a0b422450c5e75d1e4a6c16d22d09024e7ac0f0312eea02ad06782cc337ecd99ce2c220f35a311b5e58a08382e16bd7f056b979e071f3efb06b1e831ca8ca3f133b84dc34517510d2e128aec41b77bcb69579d0abca63a4ae1fc4678490e43e5a5160bf917972e2f696c2c878425fe8037d959323c58297ba5582c5932441b93f58223c3c6df898d8a505d6ae8ed986f59d56714ccb1ab1f60f6300b38be2553a52a09cbffca4c67d4ec88c0d1893f6df79d7ee230e5b6b928f04fc953d98adb09f1f464fa88984dd83843a2a600db29678c7d4a72ffc0c46841e6e63e8803a80968c3e545407d40eb23473b6e0f3dc9b90cecce6766d4af660d6bc0e160c0cc270ba31ba1cd0e84456b09835f6117fc4b45360b243f67132593f6f814fe1a103f1bd575b459204245b008592d7127091e9320adff096cb58f46ee71b293992d5d2f6e8238071f094afc889aabc4519018ffe0270fedcff5f7d0a55c4d46dcc312e51a1b59d6ab99de4ec6a4a344ff5023dfe4472a806f38bf78a5dbeab002db5fd20c8a187c599b6cbb716b2be7fcdd0714a362e973bb1116fd959cf89dd4f6474026323145e4082b8497a79cdba1093d3000446b38697ae3d46082d150bbf4c1a51928dc9ecde64eb47b19365e1a389c7f383a7fed8dc0509bda8a60b4978c2dfa15f487365f179492d955bf8b553b0ca5ad1acc4d25ae9d5eacad7f76d529f571501f185a2a302f6a3988e8774a67bd18264e9a0748b92c44c49196df048523f403a723e1d1bc55b0597cdae46185c2fb7c17ff7c8c5661eba4c2816dbf60d0a14a939d207c1ec738206d3bdeeb23c9f0bf44bf4585bca118a7c0ea6a92087c2f402b923c80465bd43cec8f686b1bc903dfcbc7915d631fb98ce0b6562eb3f02aaaf5c1519aabfe0e2b07236f9e76579a1f5910f791d0b4160d4437ce3f0fef842d996ee51a531dab6cf90cfcab69194ed6a750fc328b41be11ebca509eb5e8f4be14e71aafb07c7442ca542f63e81118153136e2f9789b17764cd73187e1d9714c5952f7758437a29f37dd95534c5be9e36fa7fcf0ac0f95aad9098787cbd6964c44f2204f8f7c3285fe73c5ecd96312f29614b30a848eed892c17ec7a415921c6d67bdc838c86b54ca8cceb08555188d0fb7d98954800794eac11ca9c16cea7ed45f83f50b9ea14c8f75f03083f21f5912b7c81b4cc90dcb466a27a26291cd82bbe31f3771a6b610e030587393d2f2598ffb213da1f8dabb3d62941f998cf04e5e7948028249716ec5267d307d6e157f67fbabb124714ea7df65d9be9a3c378dd8a6cfbcdea57442413920a5701b2aaed3e10a3b01df741bfc024df6a975b76091806f8a595ab5d6b8cc542bd8221c37486e7732aa60be8f70d3fccb714ba80655ddd31aa1fe0508d10f8158f87fb3588b712812b44ea3e07a52721af1e7eb792a7064a44ad2f6c6378301c0e2c94447a392a04e4eb18e99d4fafff05753b81080d7bda688ff996bdc8b77aaa79c5397b371ca948a0924f2eceb84c62adab9777acd0bd77617a92a5f7b743d56416bfe5584fc27d74f3952a1218ca54aca859058c7df48987ce4f86258c9cb9c273a58a184b592325bdbaee7209e245280ab8410ee86ccac3596d3f61f65b28e469d132f34cd17fadb30eb38c04895aad84dc5ee0a1779c029906ca5829668f0c21a9a14521addca4e9105e26aa7cf6c91a7952c94663d56a5794ec1069c777d88afd3755b3926fe67077f6873d271d484090e2c81f37ed2d3a1a5621a9edd054db4c64472e81d4266c8ec2d0b1f238ba7ef16c2262853392c5617e9e49b5c0dd8b5c0301b3049977bb17f519f7e1061a754906ff5f00bd7c930027e711abe4878dab04ad7c8c4c7b24fe392799cfed5e7c7d1e602eb59b6cdbd6a07bdab22ce766a5c86c2e2444c83e97c9aa06d66480696ffdf3c3b24a2f6ec8ffbdba6963f41b99b19fa0b6d44e8aa5b45acae4615ba15d40ac5ec7c4d7b2993de72abd771448929b93cd518bcfc96f5b0d1a8e78df1535e4be7e106057b3c0bacccf85262c09142a8fc6301fea963d3fc667c8a5f27658a2c02a4fab4e6dd299e9bb3a77b86a8b55783e57840ae6cecf3a4eb76808e014ef09a2908c366125124e2d36bf1f9ead4211804a3f11439d5d30cba1e331af8cd78113f403a4a8a0f5c795a85c31d25ffd215f38994950dbe1925f056a260d27f60ef8ad477f0494de62ae4f3308681d708022dbb51a10b831bf93f66c9ab913590341c53a288d0474a00aa9ebd04506186e72f35c45d74235d3e79aaa8511285d2d16f349459eed98fe3724e727f8309f00589d4df0fc73d046e51d99cb33ce4aa4ffcc61201d66553ff0ae0b7694d2e32492388a9f498544c0408565002d71a9b69d56f27ad5ff8e5c2bff5157335e35cebeb69a4d5c86deef9b5b87b12b704496df51085c63c9d68fa6e029fecf2080d4790178047f9d6dbba8a1dd725b2def187b7a27af32c0b046a52f10f722c1eb78eedd86e12f13dfdd48b29942ef0a315695aca18b440e6ac6ae92251639b95c276a6dead4b6e062042e60ff103f4f68b004390bfd5fbbfff4e7ec84fe0f8f52798384e5240c92d48a1412676bb8b879088e0ccefba431e326219738825a39ee8463b3c8c995be57c1c93c58c6583e29dadc968ff4e1c73ccd25b346cff615c442a6d297f8fa90fb3b4097193ced77d40685c4d206fcfbd1a7f12b4b3a643fae194292074f1402b973f564f3aa16cbce82f2ddfb45aa9e6c1242142a5620bd5f61812b9a9fab11185350b97c57bc1e8a2450491a37c0466b3dc41f30fd26483bd54c30a8b6f90ff591c7dc5ff8d26ede1a353f35f9f782f7942f13c833b4c4d77bd094f3b133fb10c48045cba09d72c82313614b689fe657dff0ec5cc41f0a7a7843f0f8f06966ff0a81dcc5b69c598be22e16c433b28d7864beac30fd081b6e07e37944523da082cdaa70e9b608e74d5b246ac4e935421f83ed4e3afb2e4fa26bdbbd39323601384a7a8bb32b9b5cce788ee14b4d077522a2392b90a95ad0782fd581b3dd8672a287df9a5ff0c889be1bcc6b05d8e88b57dbb2ef3052a219afe555d41cce6fdd07b580aea62de1ce831565aea3ecafcbe197c07718ec38354460de82241ff15381e51108f10dda7808fa93bc02e2af5feda91cca6c0fe33f515bdbd72ece018de85619f32030b337e4615daf1708ea1243a3df5186ea39f714427cd92602afba4ead1f5d6f0132e8710501aff8e63c833f997adb1b6feed28d0b5f9d0545f4aa4d3099b1753e922f766668efe362a2f19ca9f20fadb47583ea9fcd551bd931dc932556bf2b0aabdb7860b73ba9eba82ac81bd8037cfeee271deb2fc94de291ae9371668f9bb3c729627e64e8e9b47e174afe5ac7352da02c7bd5b4b3e5372f4b2f4ef2832e03a9fd2ced310d76f9e75d644fe24b250775f7711c7337da5b3a73091c83b77fb3e22bfaa807c84902f20412f967297c740e7bbc1f2dbc4fbe9f7485492d252a37f49b91b8c46638d3a53cee9ef6bb3f11f72624ed490f13f7034e3ae73c4b5ee9d365673c199f861902b0d3bc398551654d63607714ca9742a2e8ccaae3e8355675f8f3d1c4cf27341ad815124c9f400975f2a818cc3095bc4e93781f4a697433af555ede0f35db6287bd7683abf788fa953ff6e9f369abe953271c343c79d81d116f3cc3810db0646c45e39fe0551bf67bbe35bdf3933eff9d058aacee86b95</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6186 冒泡排序 题解</title>
    <link href="/2022/lg6186-solution/"/>
    <url>/2022/lg6186-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>手算一下不难发现，一轮冒泡排序会让所有逆序对个数大于 1 的位置减少 1个逆序对，逆序对为 0 的则不受影响。</p><span id="more"></span><p>设 <span class="math inline">\(f_i\)</span> 表示位置 <spanclass="math inline">\(i\)</span> 的逆序对数，那么经过 <spanclass="math inline">\(k\)</span> 轮冒泡排序后，逆序对的个数为 <spanclass="math display">\[\sum_{ i=1  \text{ and } f_i &gt; k}^n f_i - k \cdot \sum_{i \in [1,n]}[f_i &gt; k]\]</span> 树状数组维护之，具体见代码。交换的操作分类讨论就行了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, a[N];ll sum, f[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BIT</span> &#123;</span>ll c[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c)); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 放置下标为0</span><span class="hljs-keyword">for</span>(;x&lt;=n;x+=x&amp;-x) c[x]+=y;&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll x)</span> </span>&#123;ll y=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;x;x-=x&amp;-x) y+=c[x];<span class="hljs-keyword">return</span> y;&#125;&#125; t1, t2;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t1.<span class="hljs-built_in">modify</span>(a[i],<span class="hljs-number">1</span>);f[i]=t1.<span class="hljs-built_in">query</span>(n)-t1.<span class="hljs-built_in">query</span>(a[i]);<span class="hljs-comment">//printf(&quot;%lld\n&quot;,f[i]);</span>t2.<span class="hljs-built_in">modify</span>(f[i],f[i]);&#125;    <span class="hljs-comment">// 先利用t1求出原本的逆序对，再维护f[i]的权值数列</span>    <span class="hljs-comment">// t2维护t1对应的和</span>t1.<span class="hljs-built_in">reset</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) t1.<span class="hljs-built_in">modify</span>(f[i],<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-built_in">pre</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> op, x; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);<span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123;t1.<span class="hljs-built_in">modify</span>(f[x],<span class="hljs-number">-1</span>), t1.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],<span class="hljs-number">-1</span>);t2.<span class="hljs-built_in">modify</span>(f[x],-f[x]), t2.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],-f[x+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 把交换的这两个数先从树状数组中删了</span><span class="hljs-keyword">if</span>(a[x]&gt;a[x+<span class="hljs-number">1</span>]) --f[x+<span class="hljs-number">1</span>]; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[x]&lt;a[x+<span class="hljs-number">1</span>]) ++f[x];            <span class="hljs-comment">// a[x]&gt;a[x+1]，交换后x+1这个位置的逆序会减少1</span>            <span class="hljs-comment">// 反之，x这个位置逆序对会增加1。</span><span class="hljs-built_in">swap</span>(f[x],f[x+<span class="hljs-number">1</span>]), <span class="hljs-built_in">swap</span>(a[x],a[x+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 交换他们的值</span>t1.<span class="hljs-built_in">modify</span>(f[x],<span class="hljs-number">1</span>), t1.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);t2.<span class="hljs-built_in">modify</span>(f[x],f[x]), t2.<span class="hljs-built_in">modify</span>(f[x+<span class="hljs-number">1</span>],f[x+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 重新插入回去</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(x&gt;=n) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;<span class="hljs-keyword">int</span> cnt=t1.<span class="hljs-built_in">query</span>(n)-t1.<span class="hljs-built_in">query</span>(x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t2.<span class="hljs-built_in">query</span>(n)-t2.<span class="hljs-built_in">query</span>(x)<span class="hljs-number">-1ll</span>*cnt*x);            <span class="hljs-comment">// 注意1ll*cnt</span>&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu6185 序列 题解</title>
    <link href="/2022/lg6185-solution/"/>
    <url>/2022/lg6185-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p><del>好像这种加一减一无限次操作的都有差不多的套路。</del></p><p>把每个位置 <span class="math inline">\(i\)</span> 看作点，把 <spanclass="math inline">\(\{a_i\}\)</span> 与 <spanclass="math inline">\(\{b_i\}\)</span> 做差作为点权。</p><span id="more"></span><p>对于 2 操作，一加一减，那么它们的和不变。所以对于 2 操作的 <spanclass="math inline">\((u,v)\)</span>，从 <spanclass="math inline">\(u\)</span> 向 <spanclass="math inline">\(v\)</span>连一条边。这样，在每一个连通块中，无论如何操作，所有点权的总和不变。按照连通块缩点，用并查集维护即可。</p><p>对于 1 操作，同时加减 <spanclass="math inline">\(1\)</span>，那么他们的奇偶性同时变化。在缩点后的图中，对于操作1 的 <span class="math inline">\((u,v)\)</span>，从 <spanclass="math inline">\(f_u\)</span> 向 <spanclass="math inline">\(f_v\)</span>连一条边。（也就是缩点后它们所在的连通块）</p><p>将这张图黑白染色，如果这张图是二分图，那么由于每对点都只能同加减，若左部点权和不等于右部点权和，那么肯定不能把点权全部变为<span class="math inline">\(0\)</span>。</p><p>如果不是二分图，由于不同连通块之间只能同时改变奇偶性，所以总权值和的奇偶性不变。那如果总点权是奇数，也不能全部变为<span class="math inline">\(0\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, m, cnt, f[N], u[N], v[N], a[N], b[N], vis[N];ll s[N], c[<span class="hljs-number">3</span>];vector&lt;<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[i]=i, s[i]=vis[i]=<span class="hljs-number">0</span>, p[i].<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span> </span>&#123;    vis[x]=k, c[k]+=s[x];    <span class="hljs-keyword">bool</span> fg=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) &#123;        <span class="hljs-keyword">if</span>(vis[y]==k) fg=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(!vis[y]&amp;&amp;!<span class="hljs-built_in">dfs</span>(y,<span class="hljs-number">3</span>-k)) fg=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> fg;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]);    <span class="hljs-built_in">init</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">int</span> op, x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>) f[<span class="hljs-built_in">get</span>(x)]=<span class="hljs-built_in">get</span>(y); <span class="hljs-keyword">else</span> u[++cnt]=x, v[cnt]=y;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) s[<span class="hljs-built_in">get</span>(i)]+=b[i]-a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;++i) &#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">get</span>(u[i]), y=<span class="hljs-built_in">get</span>(v[i]);        p[x].<span class="hljs-built_in">push_back</span>(y), p[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(i)==i&amp;&amp;!vis[i]) &#123;        c[<span class="hljs-number">1</span>]=c[<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">bool</span> fg=<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(fg&amp;&amp;c[<span class="hljs-number">1</span>]!=c[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(!fg&amp;&amp;(c[<span class="hljs-number">1</span>]+c[<span class="hljs-number">2</span>])&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">solve</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5588 小猪佩奇爬树 题解</title>
    <link href="/2022/lg5588-solution/"/>
    <url>/2022/lg5588-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>分类讨论一下。</p><p>对于颜色 <span class="math inline">\(w_i\)</span></p><p>若 <span class="math inline">\(w_i=0\)</span>，随便选两个点都可以，<span class="math inline">\(\frac{n(n-1)}{2}\)</span>。</p><p>若 <span class="math inline">\(w_i = 1\)</span>，设这个点为 <spanclass="math inline">\(x\)</span>，那么只要两个点之间的路径经过 <spanclass="math inline">\(x\)</span>，就是合法的。<span id="more"></span>为了不重不漏，要按照一定的顺序去计算。对于一条边<span class="math inline">\((x \rightarrow y)\)</span>，我们先令答案累加<span class="math inline">\(sz_x \cdot sz_y\)</span>，再将 <spanclass="math inline">\(sz_x\)</span> 加上 <spanclass="math inline">\(sz_y\)</span>。最后累加 <spanclass="math inline">\(sz_x \cdot(n-sz_x)\)</span>。手算一下就知道是对的，可以直接处理任何一个节点的颜色数量为1 的情况，直接查询即可。</p><p>可是对于其他情况就不是那么好处理了。不难想到对于 <spanclass="math inline">\(w_i&gt;1\)</span>，由于两点间有且仅有一条简单路径，所以想要经过所有这个颜色的点，就必须保证这些点全部都在同一条链上，也就是端点数量为2。</p><p>图中的蓝色就无法找到合法的点对，贡献为 0。</p><figure><img src="https://s2.loli.net/2022/04/30/UcuIbZlRiQXEoMT.png" srcset="/img/loading.gif" lazyloadalt="没有贡献" /><figcaption aria-hidden="true">没有贡献</figcaption></figure><p>图中红色的分布就在一条链上，不难发现贡献是左端点的子树大小乘右端点子树大小。</p><figure><img src="https://s2.loli.net/2022/04/30/QAXMYjbgv6ma3ky.png" srcset="/img/loading.gif" lazyloadalt="能够产生贡献" /><figcaption aria-hidden="true">能够产生贡献</figcaption></figure><p> </p><p>如何快速统计同一种颜色的分布情况呢？对于每种颜色单独处理是不行的。</p><p>在 dfs 的过程中，设当前节点为 <spanclass="math inline">\(x\)</span>，颜色为 <spanclass="math inline">\(c_x\)</span>，设 <spanclass="math inline">\(pre_{c_x}\)</span> 为 颜色 <spanclass="math inline">\(c_x\)</span> 的链上，到 <spanclass="math inline">\(x\)</span>的位置时经过的点数。用一个变量<code>fg</code>维护信息。（因为非链就不会产生贡献，不影响答案）</p><p>如果 <span class="math inline">\(x\)</span> 是端点且此时 <spanclass="math inline">\(pre_{c_x}=0\)</span>，那么搜索完与 <spanclass="math inline">\(x\)</span> 直接相连的边后最多让颜色 <spanclass="math inline">\(c_x\)</span> 的点的个数+1。相邻节点有颜色相同的，让<code>fg+=1</code>。</p><p>如果 <span class="math inline">\(pre_{c_x} \neq 0\)</span> 或者不是<span class="math inline">\(c_x\)</span>的最后一个节点，那么就让<code>fg+=1</code>，这两种情况都会让 <spanclass="math inline">\(x\)</span>可能为端点。（硬说的话前者是有机会成为后搜索到的端点，后者是有机会成为先搜索到的端点）</p><p>可以对着下面的图理解。</p><p>这样如果 <spanclass="math inline">\(fg=1\)</span>，那么就一定是一个端点了。</p><p>然后记录左右端点，设它们为 <spanclass="math inline">\((x,y)\)</span>。</p><p>对于下图情况，直接让 <span class="math inline">\(sz_x \cdotsz_y\)</span></p><p><img src="https://s2.loli.net/2022/04/30/KeP5mGdpYcBb69A.png" srcset="/img/loading.gif" lazyload /></p><p>对于下图情况，设 <spanclass="math inline">\(dep_x&gt;dep_y\)</span>，<spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 的链上第一个经过点是 <spanclass="math inline">\(z\)</span>，那么答案是 <spanclass="math inline">\(sz_y \cdot (n-sz_z)\)</span></p><p><img src="https://s2.loli.net/2022/04/30/zniNcKvrRAsLkjW.png" srcset="/img/loading.gif" lazyload /></p><p>实现的时候要用好多映射，就不一一写了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, col[N], cnt[N], pre[N], sz[N];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans1[N], ans2[N];<span class="hljs-keyword">int</span> cc, h[N], p[N], v[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> nxt, to; &#125; e[N&lt;&lt;<span class="hljs-number">1</span>]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;e[++cc]=&#123;h[x],y&#125;, h[x]=cc;&#125;<span class="hljs-comment">// cnt[i]，颜色i的总数</span><span class="hljs-comment">// col[i]，i的颜色</span><span class="hljs-comment">// pre[i]，颜色为i的链上已经经过的点数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">int</span> c=col[x], t=pre[c], fg=<span class="hljs-number">0</span>, z=<span class="hljs-number">0</span>;sz[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=e[i].nxt) &#123;<span class="hljs-keyword">int</span> y=e[i].to;<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> lst=pre[c];        <span class="hljs-comment">// 这里没有算上x</span><span class="hljs-built_in">dfs</span>(y,x);ans1[x]+=<span class="hljs-number">1ll</span>*sz[x]*sz[y];sz[x]+=sz[y];<span class="hljs-keyword">if</span>(lst!=pre[c]) ++fg, z=y;        <span class="hljs-comment">// 搜到了相同的颜色，记录z</span>&#125;ans1[x]+=<span class="hljs-number">1ll</span>*sz[x]*(n-sz[x]);<span class="hljs-keyword">if</span>(t||pre[c]+<span class="hljs-number">1</span>!=cnt[c]) ++fg;++pre[c]; <span class="hljs-comment">// x也在pre[c]的链上</span><span class="hljs-keyword">if</span>(fg==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(!v[c]) p[c]=x;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> s=z? n-sz[z]:sz[x];            <span class="hljs-comment">// n-sz[z]的情况实际是搜索到的第一个这个颜色的节点就是端点</span>ans2[c]=<span class="hljs-number">1ll</span>*sz[p[c]]*s;&#125;++v[c]; <span class="hljs-comment">// 端点数量</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;col[i]);++cnt[col[i]], p[col[i]]=i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!cnt[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">1ll</span>*n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt[i]==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans1[p[i]]);        <span class="hljs-comment">// 注意i是颜色，要用p[i]映射过去</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[i]==<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans2[i]);        <span class="hljs-comment">// 有两个端点</span><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树上问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#7</title>
    <link href="/2022/yume-7/"/>
    <url>/2022/yume-7/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="88786b17acdb482f8989d7cc1eaafefe14dcd0f8edf528b34a7d3ef00c5b6a1f">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d0e76118eaef23424f2ccdd348b543f18773a40b21de4a6a5cce05fc54f57fb32de916d8cc129207bbf7edb07122693e63757e4e9c83b144c9be2622330a1de67e772184a13a640b135ecd9df94a71dd65a26abd59edd7e00989c153400e56ab465b135ea61e61b7e14313f25633ef687d111565a0408b3268afdf52ad0f97809e6688305cc8865e3e87ee1af4d45a9cd67e820ef5580295d797ce6789ba50845e771ca6c1391ec74e2f3c31bba646d9dab21c13ff02cbbbfdfbc7a773b9b365e4b5c2ac02bace62902c91f38bc780250789e892fbbb4a71a7417424f948a9875cc5595644b31a08b9280ea04e62e8143e625927bbe70745e554f416c6f9a7ee128762adc711bbad1a263ee98806adf0fd24de794260fda889b985b957412afed470fc64a3bf70c00bb48ff78ae521f681a63560b1f92c3624354580f5edae8cf8dfe877966fd9cefe2dbfb377001fa5bcb1442da9db05b9e58f7cc84b6a7e331a25a99de171d752fb0d7a446bc82f8054d62073198a49e0a18f8c30d43c4bd912c8483459700659c8b7895bdaefe94a75f91a6b06621782b48ea9e3f73bc2083658ccfacdfe51adba880bedb336e87eea235a49c5225e008b1433878d7c51d8562fab1b48561f396906798c3d87ef4ed7d65cef51fede59db9dabc27547b0ac02963c329661e76a2be09dd228118c5fbbc6ac7da1e6f0fa85a342a11d0751137a7a70cf92ea5da1f36aeea762a016c6a4c163bdfca2f565ae1425bc4a3bfda693b5d8639a6daf3798f40ec40c4eebbc2b724db7d5ef262877320a9a81cce1138046e235e0dcf6b41a9277e3d6096d2f9dd78cb638b1358b7013ac323b588f5b23e56a874795394919b70057c010c564842c21e9f0ee5971748035da9a4bcbdd21c2f730937ca3f242c6f8afc84669b3eb8d8088d6c9b7b0b16bc3a7ebfec5741204abe050d4c1cb6d1e7c8a724c86a680c37b3432bac492568bdd8730bc301217a67621fcdd82797e1c924a3697fcfe9efc534b3e35dbc3747a3f692d749b08830edf56f675e8c525c37d21dcae6d270fde50f3a52a62c4cfa1b011ee3e851b698efb61202c7a5512e97d92bd03a7d33eae066891dea57a133bcd07325bf05061d75c83f2be03c9e8ef6ecf638b9a43456e1b3a83cfafdfaadad13be735e40ade997b2044d7530549a994f2dc2f966da4ab7e38a193823118d8472dacefde6e8a4ac0c593effc46a7abf48c7ec50b56a5e000715583f426492a7f3f49721b2bb8f00a65ba725dbc606852a5041f855efec473c974f176aea74f445a3bb8cee934a05faa2a47c10868577ef534a4fe6bccf1ce96ed973573ad9bcad58ca08c467f7566136142c14494020faca31fc860b01464adb0c0d4b411b8bbeb3c3f56172388cbd4ccab8b18a8ab5a6f58caa70d7465c5df6f0ff3285f012e598b9dd0898cc9406d31d67ff2b4505400c0d3171416adab0d5b8fd0fa8b6d09c491f2373508eee2336e4da77e55f282e0ed7474cdbb8f11c2bbd7c1850a87a78a7b7c1219409c61d5a7b28be5b08e460f1f4c237e5404fdd2ea0fdbaf80b8681b4c25795ed9a6d5117cb940b3984335c1c463e34fe72ccc45146c6b7ce1fe9b88dabca113cc48f4be188c49a96c67da02be4fc6018d86ddac736ae0bfae2309ae434632371e7614d9d1d10512bc8c57d7e37b374fce426d13f677a06069916601e0164cdbabd52ef74fdafebc447b32e6284680279daa88e8ab4184e9400d209047db7719b348878117ed87c9dc33eb6260dfcfa3d09ef613a67ef272d69e66f8e12ac979c8f7e03448695994ed13abbe06764fff199d8778af4de8daac3553fc3cc74fda06a6b8d0016996f288404173305348ef024b7e0333b61ccb68442320d2971bf131bef70dea388af72964a5f7ebb59c59d6396b17308150fd472f381b2f5b387459dbe6dec502979698d139652019a233d796f1a77d412b85071c71906d4c29a9ef8241aaaffb5115a495c0ca2af1c77cfcfe8fa3dda9f81b096c75dc309d0ab1b996fbba7ebc715e5e84468bc9938e74461e4d153f5f929c37f72a798f7337b0c472aa87ca8b3bb27314e9027158ec1d9c102e1bb40039a86a14a6e9789cbf749ee9a4d8112c4ef712535752e073bd2152914ceb3d91fa530c27817188359fadfa6edba8eeb63832aeb9d6ff6d77fb75097e2484959ddd3ba9cdcbd095f9d37162afc46c84cf5929227ea7eff4393bd56895f5dba65212f93e4ad929616d8f607ac075f67e05a6e7341d0c539a9077234010b29ee69c1bbbac82e979cade8d05cb17e5fcf5530a9ff976bb1a71498c6e440a0feaaa8da3936d165c3b8a55d229db1cc43e7476f9c9a70b62e9bc37a9354cc91c025268ac818dfdf8d2114166dd95c8e4281cd425d2496a853f708b209f23541f745621836e6ec3808c68d18d64c70c3f80a9fa4e8dbd215962ac1e6b0a4dc31ccb779dad93db5b9739d86449a1834d333e4e4a5f4986c4c1cf06bfd288fd0d5c1acb3af1841b6bccf306c6281ccfd3e0d7ce8ba1d84f78e7b45d92e40902a7a623185d4af04c0e970fd43fa3da98c0ab429e48df3efeaf2b754a8b8bdb6455af0b6ddb25868585978e58cc5befd21e65ef932876dfb6b87fc62a8faef724711fc497c1c7bad4d7af9a1de59b43061d943407253e4d56fb2e3815ab3c97ccd4574947087fa57fb22db2ec02274f85a6d02bc31400b771edb5d20e65b26320a108f2c0cc63c1af2ef41d8819c4b30c4d4963c85d317c780459f0b7573a92de23860981e417951151ba8394ec074d0aa9d18a9a6fa3243d62a43501b408d57c6ab82fc35f30ca4b1024504b729a4953dfcfbd5a5ee6c10f55668d40d9a9d060a3415cf9d66e4d03ba468d883b8fea6ff05fc8d503ff07503a53d461159f657296885ba618ab6f4ace457b8e85b2ef89916d9e3a83151c7a6387acdfde04d6b4a1c7f8a1dca9129c29c2a1b85d2263ac6d397569cccf6eb7728abd8b830d8459745f4740b4946f469909cfba86a34e315c498a2eb7f8da6659e548e7cf386744136457f8995e1d577eeef1380297ff4da484fae4c75d12fe6feac95528529701be085a5627a4bb8a58245699b48d26a3101e9f753f447568b031007ba64762afe25de75ac1c1f67cbecfe3a541fa2546d6786aeac501b58cff348e30d3caaca41841abdc52aae12eaf7eca543512e919b20de6e98cbfc5994953e0410fb4f0250a7c8c61042ed5952e74add6bfdfbb33ec936b0682be0be48b71d338fada83c8f1a483702475f1647c72df688d6042acd31b4bf600fc6eeeb80812ea664d9c3ccaca76395bd6e172024e0a96f2b0d90df10ebd21abeb91a9ff7561fa1923c3007fad823a3d234c2039cb3f43ed4e0bd35e4e2f2061b9305c7e8e55bd8c135cc0db8196633c48ead99f6c536b2b2fada98544747543ecbbade96670228e9badfb3e3c516b5a79820c5d99fd1fd206e268774b0d9b4edbacede9804d02f227fe834d3fb34685310cdab8605710840f9912ae15e85418942175277f47176679ea8b14018eaf0180e065980aaac2d517fbfb09ef20b0618a7aa565486e9fa65f087cce4f7bf2de5e81202e0e6c57bb727dfd31c3400c4e79708785a0711ed0c65267248eb7077619c013d2da530090d0f0d27c75ba9ff6c6dacf803951b16116e327ba35511245fefc35f0b195006489d83fe7013f96fe437f3cc51e763e0351a6f71e27e2c341637e4f2a9688558eaa6d43f2d7ab07a7259d3fb684147913d0f4bafc619e17aaf592daa295a1642cb9433d4764f4cc7b3d506a973fda4a6ea55b0ee346a81bb58d567b6fe4039e304b3dd8926790239bef1f90c3f65af013a461d16bc2cdb4d03a200c70b51d83f4fd2244cbcc4d9718e930724f1736f854e9bb64a6bc84d8dbab19fc4b48e4d7dba0c7e4f7eea7deea53b46c7ef92ebe9ddd394786541a01c52a89378353582a70ea611667b9c315712939121af4e87b297683a68d7c49412015466fb5e008d0cad9a5fc68eec06c5283c797891c4e1d8b4b6ffd3a4cdb3075206db6ddf3316a538d26548d06ac6d05d9109806208472aa3cf64be49080cf4b1e443fc80b0f71bf2afdedccface60ece709324e87c409d8caaf7ec5efc9a7f17ec444fdea10ee78bf1a893be1f204abb0faca886cbfcff055f8a1ccce5c8d96f1aa2dedaa2e9c6187a20149cc74437ee92e47e3d37476bf33217af49da6b2dd412b8ac0ae67926feeb9fdbfba150a0d945ce61d5539a08c32735405ac9057e57ffa6f55eeee4cabb62e65c7407dc30af0e3f443d6d4b5e717fc24665a30f9eb23571bfe781ef14d1f7d1c3710c69ffeeed6e6b3a7501e388d58b110898b94d5333f0928fd7dab21569677fe27e2eacfb7ccd9cafa36e5897dcb7942c0f8054302e94a879d0aa21fc47767c08ce82e75d30a37328009be440e1eb4c935d48e62de5cd411209abb4f2063b50adeb5116c172d2e087ebb31db3311470ca053d6a13db5ac11b07b9175db1b5f48c8867f47eeb96f6b9af0e42a39a85f38f4f72a4c31628cb2de28e98897ef05476c617900cb87246af002c69177d602af90a76de262ef991745fcdf52ea2ed3d75a83f413cee8fac21adcbdd636489f2403f5d72345663f3f55e1170ce51d1e29cab923b9c3d0bd2e7ee39c98b1a57989957e90083e8b80e43aa2227b4d9f4e61c715263c56c5116b7a9286667985b05973f324449005b4c8fc56121a1ef0af1f59e05d6ab83630d053f652627158b2e30a16ea462a5e4566df73f7d6b583f0afed1cec799a12e7c4ce7e0b684683e38b217509380e61daa0d95b85572800f0aaf4258a67f4f0da3ce5616cf49005dea405c18f043d2e89036869382b2e2e02ee3b4a5a6e0a5fdff3a148a05a1cae460306c67458c76fbfa384e77298d5a1f0d90ca3f4f7fa85b267df7a04d35b455a559681d9e74155987e0600e54e43d7a27e09f88ced479ae5cdb663cd39081cc4026eb34a0607298007819c313c7fd573eb927bbcfb5d8bf74432c2d809556a9ed6b78edc20aa762c63f36fee4aa6b610bc1244b3a19a6080ec800b5212747b7a34f4c8e7a9a96a4021fcb3a1fb7d18fd5364e73a44b52d4d8159654f22dd65cf4c12f9ec23909c028fe3682ed3843160461d7e619c9f5430aff9a6da18979305f276a756f67d367d4992fa5200c793365d7ae4563484fa6c7e175133514c5fc3e62cbeac1db7735c74d88e9b0ceda40c6dfdffba408428c42d9a5a64ddf102ed099cfcba34c1580c7d1e5e4ff3072c08b99e76c0e72b04d4876e0ac0bd8282fb69c9018d98cfbab35cb9dee451b714e3eccaef5de8714f2c409794ebe948234ac2deb55f2d76137feb98138640ccf323f0532e90bc4043af0cf67e8bca25098fafc1c033181c17ca585811eeb1fa9568873322ff19d4322ebb3aa4809c8c76b0a9e6e23ffe9ed95b0e11347413182ea33a0b6878a3f8e8f372048a43bf649ce32a32bbdd11918685f46cf3d64f0c006a25d23a80c8240157b06c8a9f6aaaed447cc9bdabe06575ce31ae281dfb3ee2b11e96e8aadc6beb12f71730c5f5e0faeffb02cf5fc72b31b8093f0d86f4121ddd59a1b27b472e5f8d11f722f234c35a86c9a9ed8160fba33006df65692b7917b9690e282330391b6a045e011d4a8129d07050c2af96fd694880313129dbac996fc8c2ff791ba5b7d6301cba2a69d3591c8f5b2d8a9b2d1163d5d108bedb895a5a4594b3a935d74611f03d54a8a2c4316d85a1496138095a4772152cc355d4c8f806723cd87ba7fe7de4d7de3307edc1b1e844855a3206362268194b90e6999b6258539f4495ba1817dc580c3117fb1df45dcf1f8336f89a64a0e74cc346007599c28d8c5cead35a5ca8a5d7ab6e8a3f1dcff3009e4918a950e86b9d5a44e7b4e1ce49ac309e2cc08499b43a0ab18e85c66441007bc673f4f6b87f58297d71cf8ca29371c6fcdb4bb505bbead9a0e6c97cf6198f68356174faf645b605480db61834f61eb3896dbf1486c24163dadbbbc51f6836a960b906fcfbeffc789529743bf45352007939035286151a67651c8752cd03fb9eb1d4f28f2b624d33856a373ae5f25944895f6678b429409bdb61a8c4463f4d1719140469a4ecbe840683e05bb7cb0350795408335abfbef50909b87e653bbfee52dc6552509513cff3f63a779e553a1dbc0532fb9b8c65feea8205770587151dc8957d708702a78681a4a162c8df823ce3a10f4cea7ec5af0b755adf211a6d6d12aa2f1452da699274e5ed878abb05a3f06bf8f9bfc2a267c31e65054e908212ac54229bcdf98a0cbf4725c0c84bec348d1b7af48301b2e1d00be887b083cb3997fc73384b56917b2f140773094af2d45bb22618cfd845ce1b5f179629ed6f57790a8e10b79f4e3e5d9ec2e14ad59d72cf1ff1fc73ace225b17559afeaf5c08ef3f22cda1d55f9ab544444b0359a74c3ea3a070eb5f528861287133d5e4344d17320eee0c4f474e6e4e2b34d728cbeeac9acaf93ff86ac871f83cdf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2519 problem a 题解</title>
    <link href="/2022/lg2519-solution/"/>
    <url>/2022/lg2519-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>说假话的人最少，可以转化成求说真话的人最多。</p><p>考虑按照成绩递增排序的情况，如果第 <spanclass="math inline">\(i\)</span> 个人有 <spanclass="math inline">\(a_i\)</span> 个人分数比他高，<spanclass="math inline">\(b_i\)</span> 个人分数比他低，那么 <spanclass="math inline">\([b_i+1,n-a_i]\)</span>这个区间表示的就是分数和他相等的人。</p><span id="more"></span><p>令 <span class="math inline">\(l_i = b_i+1\)</span>，<spanclass="math inline">\(r_i=n-a_i\)</span>。如果 <spanclass="math inline">\(l_i &gt; r_i\)</span>那么这个人一定说假话。如果存在 <span class="math inline">\(i\)</span> 和<span class="math inline">\(j\)</span> 两个人，满足 <spanclass="math inline">\(l_i = l_j\)</span>，<spanclass="math inline">\(r_i =r_j\)</span>，就相当于这两个人的分数相等。同一分数相等的人不能超过 <spanclass="math inline">\(r_i - l_i +1\)</span>。</p><p>所以我们把每个 <span class="math inline">\(l_i\)</span> 与 <spanclass="math inline">\(r_i\)</span>看作线段的端点，端点相同（分数相同）的人数看作这天线段的权，那么问题就转化成了尽可能多地选择不相交的线段。因为如果两条线段相交，这与<span class="math inline">\([l_i,r_i]\)</span>表示相同分数的区间相矛盾。</p><p>以上可以用 Map 来快速实现。</p><p>最后设 <span class="math inline">\(f_i\)</span> 表示前 <spanclass="math inline">\(i\)</span> 条线段所能获得的最大权值，<spanclass="math inline">\(k_i\)</span> 表示与 <spanclass="math inline">\(i\)</span> 这个人分数相同的人数，显然 <spanclass="math display">\[f_i = \max_{1 \le j &lt; i}{\{ f_i,f_j + k_j \}}\]</span> <span class="math inline">\(f\)</span>显然是单调增的，只要二分查找出第一个大于当前 <spanclass="math inline">\(l_i\)</span> 的 <spanclass="math inline">\(r_j\)</span>，那么 <spanclass="math inline">\(j\)</span> 就是最优决策。最后用 <spanclass="math inline">\(n\)</span> 减。</p><p>复杂度 <span class="math inline">\(O(n \log_2 n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mk make_pair</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, len, d[N], f[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> l, r, k; &#125; a[N];<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(edge a,edge b) &#123; <span class="hljs-keyword">return</span> a.r&lt;b.r; &#125;map&lt;pii,<span class="hljs-keyword">int</span>&gt; mp;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y,l,r;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);l=y+<span class="hljs-number">1</span>, r=n-x;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 第一种不合法</span>pii e=<span class="hljs-built_in">mk</span>(l,r);<span class="hljs-keyword">if</span>(mp[e]==r-l+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 第二种不合法</span><span class="hljs-keyword">if</span>(!mp[e]) a[++len].l=l, a[len].r=r;++mp[e];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) &#123;<span class="hljs-keyword">int</span> k=mp[<span class="hljs-built_in">mk</span>(a[i].l,a[i].r)];a[i]=(edge)&#123;a[i].l,a[i].r,k&#125;;&#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+len+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) d[i]=a[i].r;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i) &#123;<span class="hljs-keyword">int</span> k=<span class="hljs-built_in">lower_bound</span>(d+<span class="hljs-number">1</span>,d+i,a[i].l)-d<span class="hljs-number">-1</span>;f[i]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>],f[k]+a[i].k);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-f[len]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4588 数学计算 题解</title>
    <link href="/2022/lg4588-solution/"/>
    <url>/2022/lg4588-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>比较巧妙的题目。</p><p>乘上一个数再除以它，相当于在 <span class="math inline">\(x\)</span>中去掉了这个因子。我们的目的是快速找到那个因子并且快速维护 <spanclass="math inline">\(x\)</span> 的值。</p><span id="more"></span><p>在 <span class="math inline">\([1,q]\)</span>上建一颗线段树，起初每个节点值为 1，根节点表示这 <spanclass="math inline">\(q\)</span>个数的积。因为每个节点最多操作两次（一次乘一个数，一次去掉），所以对于第<span class="math inline">\(i\)</span> 个操作<code>1 m</code>，就把第<span class="math inline">\(i\)</span> 个节点改为 <spanclass="math inline">\(m\)</span>，更新根节点；对于操作<code>2 pos</code>，把<span class="math inline">\(pos\)</span> 位置的节点改为1，更新根节点，相当于除以这个数。</p><p>你甚至只需要写建树和单点查询……</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> T, q, mod;ll t[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    t[o]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(o&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> pos,ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l==r) &#123; t[o]=x; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(pos&lt;=mid) <span class="hljs-built_in">update</span>(o&lt;&lt;<span class="hljs-number">1</span>,l,mid,pos,x);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(o&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,pos,x);    t[o]=(t[o&lt;&lt;<span class="hljs-number">1</span>]*t[o&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>])%mod;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> op, m, pos;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;q,&amp;mod);    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,q);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);        <span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,q,i,m);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t[<span class="hljs-number">1</span>]);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;pos);            <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,q,pos,<span class="hljs-number">1</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,t[<span class="hljs-number">1</span>]);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1385E Directing Edges 题解</title>
    <link href="/2022/cf1385e-solution/"/>
    <url>/2022/cf1385e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>可以把给无向边一个方向的过程看作加有向边的过程。</p><span id="more"></span><p>如果在原来有向边组成的图中有环，那么无论如何加边都不可能变成一张DAG，无解。</p><p>考虑到在 DAG 中，对于一条有向边 <span class="math inline">\((x\rightarrow y)\)</span>，<span class="math inline">\(x\)</span>的拓扑序一定小于 <spanclass="math inline">\(y\)</span>。所以根据这个来构造，在原图上求出拓扑序。对于一条无向边<span class="math inline">\((x \rightarrow y)\)</span>，如果 <spanclass="math inline">\(y\)</span> 的拓扑序大于 <spanclass="math inline">\(x\)</span> 的，那么就从 <spanclass="math inline">\(x\)</span> 向 <spanclass="math inline">\(y\)</span> 连一条边，否则就反过来。</p><p>题目中说图不一定连通，但是不影响判环和求拓扑序。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, m, tot, in[N], topo[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; a[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();topo[x]=++num;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);&#125;&#125;<span class="hljs-keyword">return</span> num==n;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;tot=cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) h[i]=in[i]=topo[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> op, x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);a[++tot]=<span class="hljs-built_in">make_pair</span>(x,y);<span class="hljs-keyword">if</span>(op) &#123;<span class="hljs-built_in">add</span>(x,y), ++in[y];&#125;&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">toposort</span>()) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=a[i].first, y=a[i].second;        <span class="hljs-comment">// 这里是直接存了所有边</span>        <span class="hljs-comment">// 因为如果a[i]是有向边，那么topo[x]一定小于topo[y]，不影响</span><span class="hljs-keyword">if</span>(topo[x]&gt;topo[y]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,y,x);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,x,y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">sol</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7514 卡牌游戏 题解</title>
    <link href="/2022/lg7514-solution/"/>
    <url>/2022/lg7514-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>要求极差尽量小，也就是让最小值尽量大，最大值尽量小。</p><p>套路就是固定一个值，然后贪心地去扩展另一个值。</p><span id="more"></span><p>把 <span class="math inline">\(a_i\)</span> 与 <spanclass="math inline">\(b_i\)</span> 放在一起排序，记为 <spanclass="math inline">\(c_i\)</span>。不难发现每一个区间 <spanclass="math inline">\([l,r]\)</span>，都能用 <spanclass="math inline">\(c_r - c_l\)</span>表示它的极差。而如果要满足最小值尽量大，最大值尽量小，可以固定最大值<span class="math inline">\(r&#39;\)</span>，尽量让 <spanclass="math inline">\(l&#39;\)</span> 提前。</p><p>这也就意味着我们已经确定了 <spanclass="math inline">\([l&#39;,r&#39;]\)</span>内元素的值（也就是每一张牌的正反）。反过来，也确定了 <spanclass="math inline">\([1,l&#39;]\)</span> 与 <spanclass="math inline">\([r&#39;,n]\)</span> 的值。所以开一个标记数组 <spanclass="math inline">\(v\)</span>，如果 <span class="math inline">\(v_i =1\)</span> 说明第 <span class="math inline">\(i\)</span>张牌已经被确认了，一张牌不能确认两次。</p><p>如果确定了一张牌，那么如果确定的值是正面，那么使用的翻转次数为0，反之为 1。总的翻转次数不超过 <spanclass="math inline">\(m\)</span>。</p><p>这样就可以用双指针求解了。维护两个指针 <spanclass="math inline">\(l\)</span> 和 <spanclass="math inline">\(r\)</span>。</p><p>开始先尽可能把 <span class="math inline">\(r\)</span>往后放，接着再尽可能把 <span class="math inline">\(l\)</span>提前。最后不断让 <span class="math inline">\(r\)</span> 向前，贪心地提前<span class="math inline">\(l\)</span>，记录答案就好了。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, ans=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">bool</span> v[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">card</span> &#123;</span> <span class="hljs-keyword">int</span> x, id, fg; &#125; c[N*<span class="hljs-number">2</span>];<span class="hljs-comment">// 数字，属于的牌的编号，翻到反面操作几次</span><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(card a,card b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i].x), c[i].id=i, c[i].fg=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i+n].x), c[i+n].id=i, c[i+n].fg=<span class="hljs-number">0</span>;<span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">2</span>*n, cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(cnt+c[r].fg&lt;=m&amp;&amp;!v[c[r].id]) &#123;cnt+=c[r].fg, v[c[r].id]=<span class="hljs-number">1</span>;--r;&#125;<span class="hljs-keyword">while</span>(cnt+c[l].fg&lt;=m&amp;&amp;!v[c[l].id]) &#123;cnt+=c[l].fg, v[c[l].id]=<span class="hljs-number">1</span>;++l;&#125;    <span class="hljs-comment">// 有标记数组v的存在，不用担心l&gt;r的情况</span><span class="hljs-keyword">while</span>(r&lt;n*<span class="hljs-number">2</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,c[r].x-c[l].x);cnt-=c[r+<span class="hljs-number">1</span>].fg, v[c[r+<span class="hljs-number">1</span>].id]=<span class="hljs-number">0</span>;++r;<span class="hljs-keyword">while</span>(cnt+c[l].fg&lt;=m&amp;&amp;!v[c[l].id]) &#123;cnt+=c[l].fg, v[c[l].id]=<span class="hljs-number">1</span>, ++l;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">min</span>(ans,c[r].x-c[l].x));    <span class="hljs-comment">// 这里少比较了一次，所以最后要取min</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu7914 括号序列 题解</title>
    <link href="/2022/lg7914-solution/"/>
    <url>/2022/lg7914-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>明显是一个区间 DP，但是合法串情况比较多，所以要仔细分类。</p><p>设 <span class="math inline">\(f(l,r)\)</span> 为区间 <spanclass="math inline">\([l,r]\)</span> 内的合法串的数量，<spanclass="math inline">\(q(l,r)\)</span> 为 <spanclass="math inline">\([l,r]\)</span> 能否变成不超过 <spanclass="math inline">\(k\)</span> 个<code>*</code>组成的串。</p><span id="more"></span><p>以下转移都是在满足 <span class="math inline">\(l\)</span>能够成为左括号，<span class="math inline">\(r\)</span>能够成为右括号的前提下。</p><p> </p><ol type="1"><li><code>()</code></li></ol><p>显然，特判 <span class="math inline">\(l+1=r\)</span> 就好了。 <spanclass="math display">\[1 \rightarrow f(l,r)\]</span></p><ol start="2" type="1"><li><code>(S)</code></li></ol><p>这种情况只会发生在 <span class="math inline">\(l+1 \neq r\)</span>的时候。左右括号都已经确定了，只要里面的能构成一整个长度合法的<code>*</code>串，就能贡献1 个方案数。而 <span class="math inline">\([l+1,r-1]\)</span>不管怎么样都能产生 <span class="math inline">\(f(l+1,r-1)\)</span>的贡献。 <span class="math display">\[f(l+1,r-1) + q(l+1,r-1) \rightarrow f(l,r)\]</span></p><ol start="3" type="1"><li><code>(SA)</code></li></ol><p>枚举<code>S</code>最后一个字符的位置 <spanclass="math inline">\(k\)</span>，如果 <spanclass="math inline">\(q(l,k)=1\)</span>，那么就转移。 <spanclass="math display">\[q(l,k) \cdot f(k+1,r) \rightarrow f(l,r)\]</span></p><ol start="4" type="1"><li><code>(AS)</code></li></ol><p>与上一步相同，枚举 <span class="math inline">\(A\)</span>的最后一个字符的位置 <spanclass="math inline">\(k\)</span>，可以与上一步一起转移。 <spanclass="math display">\[f(l,k) \cdot q(l+1,k) \rightarrow f(l,r)\]</span></p><ol start="5" type="1"><li><code>AB</code></li></ol><p>枚举断点 <span class="math inline">\(k\)</span>，暴力转移。 <spanclass="math display">\[f(l,k) \cdot f(k+1,r) \rightarrow f(l,r)\]</span> 且慢！</p><p><code>()()()</code></p><p>这个串是不是被重复计算了？<span class="math inline">\([1,2]\)</span>与 <span class="math inline">\([3,6]\)</span>，<spanclass="math inline">\([1,4]\)</span> 与 <spanclass="math inline">\([5,6]\)</span>。</p><blockquote><p>至理名言：当你想到一个 fAKe 的思路时，想想它为什么是 fAKe 的。</p></blockquote><p>由于从不同的断点断开组成了相同的串，所以重复计算了。</p><p>如何避免？如果强制让 <span class="math inline">\(A\)</span> 是由上面4 种转移方式得到的串，那么 <span class="math inline">\([1,4]\)</span>这个区间就不合法了。因为以上 4种方法要求左右端点组成<code>()</code>，所以<code>()()</code>里面的<code>)(</code>是不合法的，因此<span class="math inline">\([1,4]\)</span>这个种断开方法不会产生贡献。如果不这样，那么<code>()()</code>可以看作<code>A=()</code>，<code>B=()</code>组成的<code>AB</code>形式的合法串，就重复了。</p><p>所以设 <span class="math inline">\(g(l,r)\)</span> 为前 4 种转移对<span class="math inline">\(f(l,r)\)</span>产生的贡献，能够在处理完后直接求出。</p><p>转移 <span class="math display">\[g(l,k) \cdot f(k+1,r) \rightarrow f(l,r)\]</span></p><ol start="6" type="1"><li><code>ASB</code></li></ol><p>同上，枚举 <span class="math inline">\(A\)</span> 的最后一位 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(B\)</span> 的第一位 <spanclass="math inline">\(j\)</span>。</p><p>那么 <span class="math inline">\(A = [l,i]\)</span>，<spanclass="math inline">\(S=[i+1,j-1]\)</span>，<spanclass="math inline">\(B[j,r]\)</span>。</p><p>转移 <span class="math display">\[\sum_{i=l+1}^{i&lt;r} \sum_{j=i+2}^{j&lt;r} g(l,i) \cdot q(i+1,j-1)\cdot f(j,r)\]</span> 单是这个转移就是 <span class="math inline">\(O(n^2)\)</span>的，考虑优化。</p><p>首先，<code>S</code>这个串必须是连续的，而只有能够出现一个<code>S</code>才能产生贡献。所以，能够产生贡献的一定是一个连续的区间。（想象一下“滑动窗口”）。</p><p>所以一定能找到一个 <span class="math inline">\(p\)</span>，满足 <spanclass="math inline">\(\forall k \in[i,p]\)</span>，都有 <spanclass="math inline">\(q(i,k)=1\)</span>。</p><p>所以提一下公因式 <span class="math inline">\(g(l,i)\)</span>，得到<span class="math display">\[\sum_{i=l+1}^{i&lt;r} \Big(  g(l,i) \cdot \sum_{j=i+2}^{j \le p} f(j,r)\Big)\]</span> 关于 <span class="math inline">\(j\)</span> 的那一项是能够<span class="math inline">\(O(1)\)</span>计算的。右端点固定，左端点不同，可以使用后缀和优化。这个可能不太熟悉，但就是把前缀和对<span class="math inline">\([1,k]\)</span> 求和改为对 <spanclass="math inline">\([k,n]\)</span> 求和。</p><p>设 <span class="math inline">\(S_k\)</span> 为 <spanclass="math inline">\([k,r]\)</span> 这一段的和，于是转移就有了 <spanclass="math display">\[\sum_{i=l+1}^{i&lt;r} \Big(  g(l,i) \cdot (S_{i+2}-S_{p+1} ) \Big)\rightarrow f(l,r)\]</span>  </p><p>最终答案 <span class="math inline">\(f(1,n)\)</span></p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>; <span class="hljs-keyword">int</span> n, k;<span class="hljs-keyword">char</span> s[N];ll f[N][N], g[N][N], q[N][N], sum[N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span>(s[l]==<span class="hljs-string">&#x27;(&#x27;</span>&amp;&amp;(s[r]==<span class="hljs-string">&#x27;)&#x27;</span>||s[r]==<span class="hljs-string">&#x27;?&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(s[l]==<span class="hljs-string">&#x27;?&#x27;</span>&amp;&amp;(s[r]==<span class="hljs-string">&#x27;)&#x27;</span>||s[r]==<span class="hljs-string">&#x27;?&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">// 判断是否合法</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;k,s+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=l;r&lt;=n;++r) &#123;<span class="hljs-keyword">if</span>(s[r]!=<span class="hljs-string">&#x27;*&#x27;</span>&amp;&amp;s[r]!=<span class="hljs-string">&#x27;?&#x27;</span>) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;k) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 长度不超过k</span>q[l][r]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;++len) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l+len<span class="hljs-number">-1</span>&lt;=n;++l) &#123;<span class="hljs-keyword">int</span> r=l+len<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(l,r)) &#123;<span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span>==r) (f[l][r]+=<span class="hljs-number">1</span>)%=mod; <span class="hljs-comment">// 1</span><span class="hljs-keyword">else</span> (f[l][r]+=f[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>]+q[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>])%=mod; <span class="hljs-comment">// 2</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l+<span class="hljs-number">1</span>;k&lt;=r<span class="hljs-number">-2</span>;++k) &#123;(f[l][r]+=f[l+<span class="hljs-number">1</span>][k]*q[k+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>]+f[k+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>]*q[l+<span class="hljs-number">1</span>][k])%=mod;                <span class="hljs-comment">// 3和4放到一块转移了</span>&#125;g[l][r]=f[l][r];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l+<span class="hljs-number">1</span>;k&lt;=r<span class="hljs-number">-2</span>;++k) (f[l][r]+=g[l][k]*f[k+<span class="hljs-number">1</span>][r]%mod)%=mod;            <span class="hljs-comment">// 5</span><span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sum));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=r;k&gt;=l;--k) (sum[k]+=sum[k+<span class="hljs-number">1</span>]+f[k][r])%=mod;            <span class="hljs-comment">// 后缀和数组</span><span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l+<span class="hljs-number">1</span>;k&lt;=r<span class="hljs-number">-2</span>;k++) &#123;p=<span class="hljs-built_in">max</span>(p,k+<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(q[k+<span class="hljs-number">1</span>][p]) ++p; (f[l][r]+=g[l][k]*(sum[k+<span class="hljs-number">2</span>]-sum[p+<span class="hljs-number">1</span>])%mod)%=mod;                <span class="hljs-comment">//就和前缀和数组求区间和要a[r]-a[l-1]一样，这里p要+1</span>&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[<span class="hljs-number">1</span>][n]+mod)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5658 括号树 题解</title>
    <link href="/2022/lg5658-solution/"/>
    <url>/2022/lg5658-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>水一篇题解，明天写 CSP-S2021 T2 括号序列。</p><span id="more"></span><p>考虑序列上的情况，设 <span class="math inline">\(f_i\)</span>为序列中以 <span class="math inline">\(i\)</span>结尾的合法序列的数量（注意是以 <span class="math inline">\(i\)</span>结尾，不是 <span class="math inline">\([1,i]\)</span>中的合法序列数量）。那么如果 <span class="math inline">\(s_i\)</span>是左括号，那么将它入栈，<span class="math inline">\(f_i=0\)</span>。如果 <span class="math inline">\(s_i\)</span>为右括号，则有 <span class="math display">\[f_i = f_{l_i-1} + 1\]</span> 其中 <span class="math inline">\(l_i\)</span> 是与 <spanclass="math inline">\(i\)</span> 配对的左括号位置。</p><p>最终答案为 <span class="math inline">\(\sum_{i=1}^nf_i\)</span>。</p><p>现在考虑树上的情况。由于是一棵树，两点之间有且仅有一条简单路径，所以我们每次都是处理一条链的情况。在链上，<spanclass="math inline">\(l_i-1\)</span> 就变成了 <spanclass="math inline">\(l_i\)</span> 的父亲节点，其他都是一样的。</p><p>还是一样，遇到左括号就将它入栈。否则就如果栈顶元素是左括号，维护信息；如果是右括号，那就把它入栈。处理完一个节点要回溯时，撤销当前节点的操作，不影响下一条链的信息。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">int</span> n, tp, f[N], fr[N], sk[N];<span class="hljs-keyword">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];ll ans;<span class="hljs-keyword">char</span> s[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++c]=y, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,ll res)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(s[x]==<span class="hljs-string">&#x27;(&#x27;</span>) sk[++tp]=x;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span>(!tp||s[sk[tp]]==<span class="hljs-string">&#x27;)&#x27;</span>) sk[++tp]=x;        <span class="hljs-keyword">else</span> y=sk[tp], f[x]=f[fr[sk[tp--]]]+<span class="hljs-number">1</span>;    &#125;    res+=f[x], ans^=<span class="hljs-number">1ll</span>*x*res;    <span class="hljs-comment">// 统计答案</span>    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-built_in">dfs</span>(ver[i],res);    <span class="hljs-keyword">if</span>(y) sk[++tp]=y; <span class="hljs-keyword">else</span> --tp;    <span class="hljs-comment">// 撤销本次操作</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(R <span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;fr[i]), <span class="hljs-built_in">add</span>(fr[i],i);    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1359E Modular Stability 题解</title>
    <link href="/2022/cf1359e-solution/"/>
    <url>/2022/cf1359e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>由于 <span class="math inline">\(a_1\)</span>时最小的，所以对于长度为 <span class="math inline">\(k\)</span> 的序列<span class="math inline">\(\{a_i\}\)</span>，取模每一项最后的结果是<span class="math inline">\(x \bmod a_1\)</span>。</p><p>而对于下标的任意排列，显然 <span class="math inline">\(\forall p_i&lt; p_1\)</span>，都必须满足 <span class="math inline">\(x \bmod a_1 =x \bmod a_i\)</span>，即 <span class="math inline">\(a_1 \mida_i\)</span>，不然最后的结果就会改变。当 <spanclass="math inline">\(a_1\)</span> 为首项时，就得到了 <spanclass="math inline">\(\forall i \in [1,k]\quad a_1 \mida_i\)</span>。</p><span id="more"></span><p>所以，我们只要枚举首项 <span class="math inline">\(a_1\)</span>，在<span class="math inline">\([1,n]\)</span> 范围 <spanclass="math inline">\(a_1\)</span> 的倍数个数为 <spanclass="math inline">\(\lfloor \frac{n}{a_1}\rfloor\)</span>，我们要从中选取 <spanclass="math inline">\(k-1\)</span> 个数作为其他项，所以答案就是 <spanclass="math display">\[\sum_{i=1} ^n C_{\lfloor \frac{n}{i} \rfloor -1} ^ {k-1}\]</span> 统计就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,j,k) for(i=(j);i&lt;=(k);++i)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> ll p=<span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, k;ll fac[N], inv[N], ans;<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n,ll m)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> fac[n]*inv[m]%p*inv[n-m]%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    fac[<span class="hljs-number">0</span>]=<span class="hljs-number">1ll</span>, inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1ll</span>;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">5e5</span>) &#123;        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%p;        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) inv[i]=(p-p/i)*inv[p%i]%p;    &#125;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">5e5</span>) inv[i]=inv[i]*inv[i<span class="hljs-number">-1</span>]%p;    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;        <span class="hljs-keyword">if</span>(n/i&lt;k) <span class="hljs-keyword">break</span>;        (ans+=<span class="hljs-built_in">C</span>(n/i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>))%=p;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT5759 ThREE 题解</title>
    <link href="/2022/at5759-solution/"/>
    <url>/2022/at5759-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题构造一下链和菊花的情况会理解地更透彻一些。</p><p>“三步走”战略啊不，距离为 3的点，它们所在的深度肯定是不同的。也就是说，我们能把整棵树按照节点深度奇偶性黑白染色，分成两个集合，距离为3 的点一定在不同的集合里。</p><span id="more"></span><p>对于 <span class="math inline">\((i,j)\)</span>，要求 <spanclass="math inline">\(p_i \cdot p_j \equiv 0 \; (\bmod 3)\)</span> 或者<span class="math inline">\(p_i + p_j \equiv 0 \; (\bmod3)\)</span>，又可以按照节点编号模 3 的结果来分成 3 个集合。其中模三为 0的那个集合是最特殊的，因为其中的任意一个点和其他所有点组成的点对都是合法的。</p><p>为了方便，称 n 类点 表示模 3 为 n 的点。</p><p>很容易知道 0 类点的个数为 <span class="math inline">\(\lfloor\frac{n}{3}\rfloor\)</span>，接下来就是大胆构造，<del>绝不证明</del>。</p><p>如果黑白某个集合节点个数小于等于 <span class="math inline">\(\lfloor\frac{n}{3}\rfloor\)</span>，那么如果把所有的 0类点放到这个集合里，另一个集合无论怎么选，都是一组合法解，因为乘积均为 3的倍数。</p><p>但是如果每个集合都大于 <span class="math inline">\(\lfloor\frac{n}{3}\rfloor\)</span> 呢？</p><p>注意到 1 类点和 2 类点，它们的和模 3 为 0，即 3的倍数。所以一个集合全放 1 类点，一个集合全放 2 类点，0类点随便放——因为它们和任何点组成的点对都是合法的。</p><p>实现还是 STL 好用。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">int</span> n, col[N], p[N];vector&lt;<span class="hljs-keyword">int</span>&gt; g[N], c[<span class="hljs-number">2</span>], v[<span class="hljs-number">3</span>];<span class="hljs-comment">// c存节点黑白染色，v存模3</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    col[x]=col[fr]^<span class="hljs-number">1</span>, c[col[x]].<span class="hljs-built_in">pb</span>(x);    <span class="hljs-comment">// 按照深度奇偶黑白染色</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:g[x]) <span class="hljs-keyword">if</span>(y!=fr) <span class="hljs-built_in">dfs</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) v[i%<span class="hljs-number">3</span>].<span class="hljs-built_in">pb</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">int</span> x, y; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        g[x].<span class="hljs-built_in">pb</span>(y), g[y].<span class="hljs-built_in">pb</span>(x);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()&lt;c[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(c[<span class="hljs-number">0</span>],c[<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 取较小的集合</span>    <span class="hljs-keyword">if</span>(c[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()&lt;=n/<span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">1</span>]) p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 全放0类点</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">0</span>])        <span class="hljs-keyword">if</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">1</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">1</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">2</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-keyword">else</span> p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 随便放</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">1</span>])            <span class="hljs-keyword">if</span>(v[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">1</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">1</span>].<span class="hljs-built_in">pop_back</span>();            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 分别放1类点和0类点，不足用0类点补齐</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cc:c[<span class="hljs-number">0</span>])        <span class="hljs-keyword">if</span>(v[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">2</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">2</span>].<span class="hljs-built_in">pop_back</span>();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) p[cc]=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">back</span>(), v[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop_back</span>();    &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p[i]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5664 Emiya 家今天的饭 题解</title>
    <link href="/2022/lg5664-solution/"/>
    <url>/2022/lg5664-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题很有启发意义：不要为了 DP 而去DP。对于一个计数问题，应当灵活地去划分。</p><p>题目中的三个条件，如果直接去计数做的话，信息冗余太多，很难理清思路。但是注意到我们能极其容易地求出满足前两个条件的方案数，而且三个条件都满足的方案一定在满足前两个条件的方案数中。所以如果我们能够单独求出不满足第三个条件的数量，就能够求出满足三个条件的方案数。这是一种常见的套路。</p><span id="more"></span><p>显然对于一种烹饪方法 <span class="math inline">\(i\)</span>，能够做出<span class="math inline">\(A_i = \sum_{j=1}^m a_{i,j}\)</span>道不同的菜。</p><p>由于每一种烹饪方法都可以不选，但是又不能每一种都不选，所以满足前两个条件的方案数为<span class="math display">\[\prod_{i=1}^n (A_i+1) -1\]</span> 接下来单独考虑第三个条件。</p><p>这个可以 DP，但不是直接用 DP统计目标方案数。因为太过苛刻的转移条件会大大增加复杂度，而加入可承受范围内的冗余信息有时是能够简化问题的。</p><p>所以，设 <span class="math inline">\(f_{i,j,k}\)</span> 为前 <spanclass="math inline">\(i\)</span> 种方法，选择了 <spanclass="math inline">\(j+k\)</span> 种方法，其中 <spanclass="math inline">\(j\)</span> 次用到了当前食材 <spanclass="math inline">\(x\)</span>。</p><p>转移比较简单 <span class="math display">\[f_{i,j,k} = f_{i-1,j,k}+a_{i,x} \cdot f_{i-1,j-1,k} + (A_i-a_{i,x} )\cdot f_{i-1,j,k-1}\]</span> 最终答案 <span class="math inline">\(\sum f_{n,j,k} \quad j&gt; k\)</span>。</p><p>这样状态数为 <span class="math inline">\(n^3\)</span>，转移为 <spanclass="math inline">\(O(1)\)</span>，但是还要对于 <spanclass="math inline">\(m\)</span> 种食材分别计算，所以复杂度为 <spanclass="math inline">\(O(n^3m)\)</span>。这个不够优秀。</p><p>转移和枚举是优化不了的，只能从状态下手。可以看到，对于食材 <spanclass="math inline">\(x\)</span>，我们只关心使用它的方案数是否占到一半以上，不关心具体选择方案。这也有一种常见的优化技巧。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为前 <spanclass="math inline">\(i\)</span> 种方法，其中选择食材 <spanclass="math inline">\(x\)</span> 的方法数量减去其他方法数量结果是 <spanclass="math inline">\(j\)</span>，若 <span class="math inline">\(j &gt;0\)</span>，那么就说明占到了一半以上。但是这个下标可能为负数，所以要加上一个偏移量。</p><p>这样状态数降到了 <span class="math inline">\(n^2\)</span>，转移呢？<span class="math display">\[f_{i,j} = f_{i-1,j}+a_{i,x} \cdot f_{i-1,j-1} + (A_i-a_{i,x}) \cdotf_{i-1,j+1}\]</span> 依旧是 <span class="math inline">\(O(1)\)</span>。</p><p>所以这个 DP 的复杂度为 <spanclass="math inline">\(O(n^2m)\)</span>。</p><p>答案为 <span class="math inline">\(\prod_{i=1}^n (A_i+1) -1 -\sumf_{n,j} \quad j&gt;0\)</span></p><p>具体细节见代码。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, M=<span class="hljs-number">2005</span>, mod=<span class="hljs-number">998244353</span>, dlt=<span class="hljs-number">105</span>;<span class="hljs-keyword">int</span> n, m, S=<span class="hljs-number">1</span>, ans, a[N][M], s[N], f[N][<span class="hljs-number">2</span>*N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (s[x]-a[x][y]+mod)%mod; &#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;        a[i][j]=<span class="hljs-built_in">read</span>();        s[i]=(s[i]+a[i][j])%mod;    &#125;    (S*=s[i]+<span class="hljs-number">1</span>)%=mod;    &#125;    (S-=<span class="hljs-number">1</span>)%=mod;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);        f[<span class="hljs-number">0</span>][n]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=n-j;k&lt;=n+j;++k)            f[j][k]=(f[j<span class="hljs-number">-1</span>][k]+f[j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>]*a[j][i]%mod+f[j<span class="hljs-number">-1</span>][k+<span class="hljs-number">1</span>]*<span class="hljs-built_in">calc</span>(j,i)%mod)%mod;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) (ans+=f[n][n+j])%=mod;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,(S-ans+mod)%mod);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5052 GO 题解</title>
    <link href="/2022/lg5052-solution/"/>
    <url>/2022/lg5052-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>这题评紫确实过了。很容易看出来是套路的区间 DP。</p><p>设 <span class="math inline">\(f(i,j,t,0/1)\)</span> 表示抓到了区间<span class="math inline">\([i,j]\)</span> 的宝可梦，花费的时间为 <spanclass="math inline">\(t\)</span>，在 <spanclass="math inline">\(i\)</span> 或 <spanclass="math inline">\(j\)</span> 的位置，所获得的最大收益。</p><span id="more"></span><p>转移情况比较多，用刷表法比较方便，而且要注意时间限制，否则下面的<span class="math inline">\(B\)</span> 是不能加的。 <spanclass="math display">\[f(i-1,j,t +\Delta t,0) =\max \begin{cases}f(i,j,t,0) + B_{i-1}\\f(i,j,t,1) + B_{i-1}\end{cases}\]</span></p><p><span class="math display">\[f(i,j+1,t +\Delta t,1) =\max \begin{cases}f(i,j,t,0) + B_{j+1}\\f(i,j,t,1) + B_{j+1}\end{cases}\]</span></p><p>计算 <span class="math inline">\(\Delta t\)</span>只需要将对应的编号相减就行了。</p><p>注意状态中的 <span class="math inline">\([i,j]\)</span>指的是按照编号排序后排名为 <span class="math inline">\([i,j]\)</span>的宝可梦，而不是房子编号，不然复杂度不对。这一步就相当于离散化。</p><p>边界为 <span class="math display">\[f(i,j,t,0/1) =\begin{cases}0 &amp; i=j=k\\-\infty &amp; \text{otherwise}\end{cases}\]</span> 复杂度 <span class="math inline">\(O(m^2 \maxT)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, maxt=<span class="hljs-number">2005</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, k, ans, T, f[N][N][maxt][<span class="hljs-number">2</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qwq</span> &#123;</span> <span class="hljs-keyword">int</span> num, v, t; &#125; a[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(qwq a,qwq b) &#123; <span class="hljs-keyword">return</span> a.num&lt;b.num; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i].num,&amp;a[i].v,&amp;a[i].t);T=<span class="hljs-built_in">max</span>(T,a[i].t);&#125;a[++m]=(qwq)&#123;k,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 原点</span><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(a[i].num==k) &#123; p=i; <span class="hljs-keyword">break</span>; &#125;f[p][p][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=f[p][p][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=T;++t) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">1</span>;len&lt;=m;++len) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> j=i+len<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(f[i][j][t][<span class="hljs-number">0</span>]!=-inf) &#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> tt=t+a[i].num-a[i<span class="hljs-number">-1</span>].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-keyword">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[i<span class="hljs-number">-1</span>].t) dlt=a[i<span class="hljs-number">-1</span>].v;f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>],f[i][j][t][<span class="hljs-number">0</span>]+dlt);&#125;&#125;<span class="hljs-keyword">if</span>(j!=m) &#123;<span class="hljs-keyword">int</span> tt=t+a[j+<span class="hljs-number">1</span>].num-a[i].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-keyword">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[j+<span class="hljs-number">1</span>].t) dlt=a[j+<span class="hljs-number">1</span>].v;f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>],f[i][j][t][<span class="hljs-number">0</span>]+dlt);&#125;&#125;&#125;<span class="hljs-keyword">if</span>(f[i][j][t][<span class="hljs-number">1</span>]!=-inf) &#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> tt=t+a[j].num-a[i<span class="hljs-number">-1</span>].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-keyword">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[i<span class="hljs-number">-1</span>].t) dlt=a[i<span class="hljs-number">-1</span>].v;f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][tt][<span class="hljs-number">0</span>],f[i][j][t][<span class="hljs-number">1</span>]+dlt);&#125;&#125;<span class="hljs-keyword">if</span>(j!=m) &#123;<span class="hljs-keyword">int</span> tt=t+a[j+<span class="hljs-number">1</span>].num-a[j].num;<span class="hljs-keyword">if</span>(tt&lt;=T) &#123;<span class="hljs-keyword">int</span> dlt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(tt&lt;=a[j+<span class="hljs-number">1</span>].t) dlt=a[j+<span class="hljs-number">1</span>].v;f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(f[i][j+<span class="hljs-number">1</span>][tt][<span class="hljs-number">1</span>],f[i][j][t][<span class="hljs-number">1</span>]+dlt);&#125;&#125;&#125;ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">max</span>(f[i][j][t][<span class="hljs-number">0</span>],f[i][j][t][<span class="hljs-number">1</span>]));&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1120D Power Tree 题解</title>
    <link href="/2022/cf1120d-solution/"/>
    <url>/2022/cf1120d-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h3 id="part-1">part 1</h3><p>对子树操作，自然想到DFS。但是题目里的操作仅仅是针对叶子节点的，所以用的不是纯粹的 DFS序。通过这种办法，就能把子树操作转化为序列操作，而每个子树内所有的叶子要对应一个叶子编号的区间。</p><span id="more"></span><p>具体实现时我们只需要维护节点 <span class="math inline">\(x\)</span>子树内叶子节点编号的左端点 <span class="math inline">\(l_x\)</span>和右端点 <span class="math inline">\(r_x\)</span>。说明如果控制了 <spanclass="math inline">\(x\)</span>，能够让我们对 <spanclass="math inline">\([l_x,r_x]\)</span> 区间内的叶子修改一个值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;l[x]=n+<span class="hljs-number">1</span>, r[x]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 初值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(y==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);l[x]=<span class="hljs-built_in">min</span>(l[x],l[y]), r[x]=<span class="hljs-built_in">max</span>(r[x],r[y]);        <span class="hljs-comment">// 维护最左和最右编号</span>&#125;<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">1</span>&amp;&amp;deg[x]==<span class="hljs-number">1</span>) l[x]=r[x]=++num; <span class="hljs-comment">// 叶子，赋值编号</span>e[++m]=(edge)&#123;l[x],r[x]+<span class="hljs-number">1</span>,w[x],x&#125;; <span class="hljs-comment">// 下面会提到这一步</span>&#125;</code></pre></div><p>做完了这一步，似乎离解决还很远。</p><p>不要忘了本题最开始的目标，无论权值是多少，都能把所有叶子节点的权值变为0。</p><p>这个该怎么入手？我们能做的只有区间加减法，怎么才能做到把权值都变为0？</p><p>如果我们从「终态」去想，就能发现本题的巧妙之处。</p><p>一个全 0 序列，它的差分序列也全为 0！</p><p>而差分操作是在左端点 <span class="math inline">\(l\)</span>修改上一个值，在右端点后一个位置 <spanclass="math inline">\(r+1\)</span> 修改一个值。感性理解，就像是把 <spanclass="math inline">\(l\)</span> 的值传递给了 <spanclass="math inline">\(r+1\)</span>，如果传递的这个值就是 <spanclass="math inline">\(l\)</span> 的权，那么 <spanclass="math inline">\(l\)</span> 处将变为0。这不就是一种无视具体权值，构造出 0 的办法吗？</p><p>更进一步的，从 <span class="math inline">\(r+1\)</span>再往后传，一直传达到 <span class="math inline">\(n+1\)</span>的时候，序列就变成了全 0！</p><p>差分序列全 0，原序列有两种情况。</p><ol type="1"><li>全 0。显然是正确的。</li><li>全相等。但是如果我们在区间修改的时候在把这个值去掉，那么最终也还是全0。</li></ol><p>呼之欲出了！</p><p>我们之前处理了每个点能控制的区间。能从 <spanclass="math inline">\(l_x\)</span> 修改一个值到 <spanclass="math inline">\(r_x+1\)</span>，不妨看作从 <spanclass="math inline">\(l_x\)</span> 向 <spanclass="math inline">\(r_x+1\)</span> 连了一条边，再建一个虚拟节点 <spanclass="math inline">\(n+1\)</span>。</p><p>这样，当且仅当这张图连通时，能够把序列变为全0。而当且仅当选择的边组成其最小生成树时，代价最小！</p><h3 id="part-2">part 2</h3><p>事情到这还没完。如果仔细看题面的话，就会发现他让输出的是最优解种可能的最小权值，可能的节点数以及可能的点。</p><p>转化一下，就是最优解的并集。</p><p>有不同最优解，当且仅当最小生成树不唯一，也就是有相同边权。</p><p>解决这个问题，我们只要再 Kruskal算法里，分别处理权值相同的边，相当于缩成一个“点”。具体看注释。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num+<span class="hljs-number">1</span>;++i) f[i]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> j=i;<span class="hljs-keyword">while</span>(j&lt;m&amp;&amp;e[i].z==e[j+<span class="hljs-number">1</span>].z) ++j;        <span class="hljs-comment">// 如果有权相等的边，那么这些边都可能在最小生成树里。为什么是可能？如果不连通的话就不在了</span>        <span class="hljs-comment">// 所以下面根据连通与否来分别统计，跑两遍是因为如果一边合并一边统计就会导致错误</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=j;++k) &#123;<span class="hljs-keyword">int</span> x=e[k].x, y=e[k].y;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123; ++t, v[e[k].id]=<span class="hljs-number">1</span>; &#125;&#125;        <span class="hljs-comment">// 统计可能在最优解中的点，这里的点指的原来的图中的点</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=j;++k) &#123;<span class="hljs-keyword">int</span> x=e[k].x, y=e[k].y;x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);<span class="hljs-keyword">if</span>(x!=y) &#123; f[x]=y, ans+=e[k].z; &#125;&#125;        <span class="hljs-comment">// 合并[i,j]这些点，正常统计边权</span>i=j;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %d\n&quot;</span>,ans,t);&#125;</code></pre></div><p>最后按照<code>v</code>数组输出就行了。</p><p>剩下的代码</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, num, m, t, w[N], l[N], r[N], deg[N], f[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>]; <span class="hljs-keyword">bool</span> v[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> x, y, z, id; &#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(edge a,edge b) &#123;<span class="hljs-keyword">return</span> a.z&lt;b.z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> f[x]==x? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x), ++deg[x], ++deg[y];&#125;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">kruskal</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(v[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>贪心</tag>
      
      <tag>生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#6</title>
    <link href="/2022/yume-6/"/>
    <url>/2022/yume-6/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="29cc48511add40921b6f5955b2cf916781ce3b336d83f9f7f2c47e8fe40140a1">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d673c47d5b1bcb833488aaa90760c3082775d7067a26eb6e7a0e17c9bd8887b36ea1b4d58e660fbd78efbabb636949248cc164942b94a178005824b5154ae0df228ca79f6ea3ade16ec70e7c258565a2e7d82c540bf19e2d4978d15211790d2babef15dc0d8dda11fea66e6bad8ac95795e9ab35fbf7202381db2a0621f19bfaabe07a09c6cd2a917799e5019a5ea92fa3a78b8f48e623fdd5cf0543f2378682bf58efc8a46d2b2e9dad8e1cc186cb2188abbac06cfe896c2ee528a995e3c258fe206b96837b76210052fb0bb035a04f0117d72ec610818498bd6991e31a2a8cd5f88bd088bc228ab35cde7b06e7012f71bd74b3dee8c43035472b4ebabfe3ae51c84d53ac267786518e15eb8ca4de2360d0e4d7fe5630385f572eda02d4c5c8a0c4ae20d04fb9dc42bb55e6524683ec4a4c037d7b360fbe9b64632fbbcd5be64a9cf47a675dbbb7ff9fbbc59547740d9097340281b678faffb38333b5190c7562a75b0f4687e6becec19068ee14fc35d6cc43d7f1624805c452ae5f08b3b4f1acf94c80280a63d85a8ca313be346e4a33650ec4ab0675a8df736279795d05106a4d4950b63f464c0811bca1c57cbbffed7373bca925fc8e2c5e14c93213e25b40bde8fc0d2140c2ab3ee393d337c4a5c79c582d5ae9c10396bf8998ce2f4c50ef34e600e669411fd3f5b35a160e3341f12b2efb6557b0c14ac49f12658087ab089adccb8c009c019d4a0755483b9ac663e47215a1d23878d4ffa4a41e15a58d545a161c73404befbe046dabf832d3ee9e06b6f4fba8287f52716c717f53d24db2e184f0b11430d87225bc7059b72a681a3a4e50630d59e968f7cf175e41666c4d007fc33e6d3ea26ed3f1b06fdad0a7545268d98aa0834c6163e92226362e88dc5840b830e279b85b83c6237e4a059ed123b84914150bd7f42f285c023a9dbda7a346f48a2464a03e4048f2d6c27f9cc150d8e6bff64ed7b176d78a00af9fd5a7da511b2c383786074ec985ab9f4d2e0b9a33dbf371acd80e08468359cc0dd4f5f2cb404e7a754a220492392c5a8043ea3292d1a0cd13b59413c564b5d0852be53b07a8ae27445f380c00b066890ca7c41113f65cf115e12842baced21a9cdf528c619c93eedeef06fc8872a632119c5298f8175d5688371bfe4feda3706946921ef35badf566a1a06d05c686d786a3e1c947c5d31e9ef63988b1eb033ead175c87f0f74921c056dff09abd737ac9b95ee7f2593408659880b1e840c8302bff6dab44d5f56d2bc815e8e5208460acde93883f22e1930017f5e282d96da1576d0997d09b933d769cec4396f722881e65a185561a57bcda38c29f45de56998d40fb26399cf74ecbc5f94dcf9d2b56b8cf9abd7a7811cc95cd9a0dd9abdd4e7cc966c20abc35e310d7eedaa402d1a0123300a5affa9ce7e1aea754af952bbe15c7121cd789bd9bdccdfa1842a2a490e6e973b70a8d5cd809c55520797ba96bb696ff5e74b8aa70a1e3ecce4f2240c196452e5a99cbd174da7097118f4b34be1262a8aa037f2f4ed5f4e351596023c45437c634a1ffcef82ee5fe4d45a2544ccc44815d6b2fcdb531ff729e24f6026c22e411657e1bcffaba3445deb8cd6805e1c7c18f397433586240547858e97302bda2ebbd6bf049b69d628ae2ca17b65a52bf83b5593428f2d3e817080fb5cf7ea076e0fbe6e8c391532a20097b2d682bdd1d788c322b995726dbd24fc367d4d1136bbe3a06fde0a63c6ee011fd413d4f358b607c227f64de22e06518884c7f6a138282d5bc9f8368365440bfe332e74899c6df5eb13b8ab7ebeb0252ea799a2df175d1c4ac873b0d60f09b742ffc3cc71c8fc4933de9705243b02bd89f42ac9c8cc03c4fe9850c10d201955a2a970f559119937416742fee701d4a0344cdb5a68d739076916ccdfcc98d651a13cc496d121f4863f34ed3d72ba14a1042f056caeac4b045096065ea06b5d8c6e736ee8f9bc6c2928930009720ceea170ef1bbb06e26dc26c92aab0cfbae07a8be2564d78a3a086157fd34d67f145e2a322791a36f9c580e9672cd8cb1a02634c16685cf2c4626027af7217d72b0cb1480ec175070f9fa2266652e096bc3bf0ad18834857c93d1f923040bb8b2ec872147d5e756cfca3e3433e34c44e00ddc32b2fac34a2cf7ca9ca70d6f7953f5cf12dceaa3605a010ea906d694a311e57156fb409673e1583fbdc9c1409bef33c70d9a7e25ed67fa69152427a267bf7c38cb6d1e9a84d7df1f8df93616494a2c052abbe2ebfc63a939a695d2be4105de87312427a9baa9e840e1c6a36b67a7578b87f9ded452eb8643db266182baa717ea3e55572158351454cdf46ae290778e89714607b962f365f00f33b6cd03368ceeb9c831dfc6f6acefea7a19b0879688c1070048a7ed0569c5e1d0e6a4b0535121ee980385b6348eb30641213d9bcaa61878a8ce372f5060431fa6b5e669367b0a956684fc9fc310b353a34f1730bed60d9fde29082e372c983c15e1545a759d77ebf894bde2750ea6e77b6e0354e3f68b6e3b21b532326d93feec5d32d16c8d7cc4d74b19f123d67d36b85f9771125a8d57a6dfe13d802fb4c703b674f60ab3ca09b528c1633022c3f913707b0c77ee1ecbeadc2e18b3b98365dc2fad245c359b39f9ba045c55c79f5e3cb81ce10acc2e136682f6297898e6385a8093c44381e8e7a68faa9b746c94e2918216e77cc6efd190895c200e5d774ae1a051d1aff01788f47df065e76a7b8d21dcd7f22802b6006b9830d1e452c046cbbc29e3d636ba26a50233127b711ff92b97ef6e67db4dac74dbc420512101eef07fc2cc4ee1683539fc8456cec986ad8753dae07b8cb54a242d7ded246ac020c0fd3d93a586a56c226435065873e68f8c1d354d5c838ec531256426287880b465d1b419f5684d111d6d2e018b55dbef5200844d2e4991a803a3550e357d897274f350eeab3da14a7781d083bcd5183822282b194400ceeaa519d2337af763b7e2d50ef07e4553ac7edfe7d26bb2b67cdd7d917284661f6fb3d6af149ed695f7cfeb49ed3941e8b4c5f1adbc74c08b4f5d31737c6d33354da2b83b129cf7ca1034a0f24356c0bcfc0a13ad833f88fa359f208cbe9ddaa27a9b34efed69d637535ec1268e78b44a9c132ca55255e86130d4a4d2a87d2901073acf90619cf4652a14ec80c6a6b99ff5f30807eab3f3806352391d9ba6e33fb3c0daf536d34b8d77834b35f10506f98daf3d02f38c600dcae4f02eb5e560b350c5dbf1c2600cdc9a2e761a2e9dee46a173a59cfaba14c6437b54f911670996f48c467960f726b474bc47fc32e90831a5b69bb59880877156bb81c990eba98a348d4b3e8b1aaa62b892651990776eef53cd7bd646c13a6b52063270dbf5602dc0b9600479b1bed750fafbe8bc2371ad9aa1e4d0c7b62af3afb62144e0da12430876989aaea8a9fab5fad0f93fc2d4ae2cf7f53e779f3660bbe8270096dc1a60b3584d2fd6950e6cfac315a476b4dea3d43758fbf8d3376b4ef6cd7f61e9c446f5829b924d62ab24aa337747aa0f22eecdb5b9cd94e2d5b2d51ff0ce1643b99c4b131f00a41f14b890eda77fb71b210ca074b307243a473be622f5a06349825f0e9254d80bceb15c8c154adb371987e0609a6a11012097bc5d2861bca1c669aa805becde649574d0fdf7e3bc5b56a8143740f08ea12447c6ed4c9aae01afa2516adc9e897c06e26b229c0c8dd632c201b23e5243f7f34d1aa2f8c820970234a48da485d22089164b27b15babb79e24a5bdb3aaf191eaafad31d561c56ff1275b40c4bde9691f9d92206d079c25a49aacaf63267791259f976e7198313863c8487dd4c2dd2d3067024221b80f4f059ac23cbe1577ee290a435f7bd4ae0b94b132cc49d2173c33a528f92a4bcb8dd432fd1017722a16d0a52479a946be2ff1c4edc07a4fd0102dd915e103290d561ff48f07d8d8227c3eb4a89315d117680d4b26821a51f25b498b9937cfe5e2844e08dc4ab554ec3aaee95d7ca49b20ec1da8f51837c1b27567e5e06e5b925953fea656572f481e5d327e9fa9fd7b54575f0431fd9493f9bbea4f2f21fff1e19f70aa2f7356db6e8f70a26203f5ceb3c29e32554c79178432006320f077a6927cadc88e47a6f532055690232a9a088d10b8a88b1f2cdc9ff55980ad238c22203c0cfa3ff3d82a1b99f77868f3ea976eb33f3dc6f7287e826c18d6dde76380d027f2517488066e3739f05eee6b0b5861d4eb637d5f4f9595d0215451acb4f09c3a4b9f6e40ba934d194a16f629a44662ec5d80e0a73ce26a2722952a87ba75a695ac25333958e43a18c8ae773f24f6ab4642dc68885843d52c9ae6598edeee06f04cdaac5ce3b0aca5c6cbe645320334e7fcbdc5ef3c081b140de561f1ee92f6d4d6fe412ed65b6b684aeccdec67e8adb781fcbd07ed63a970ce7a1bebdc8a13a52d4ba5ec51783fd4cc8847aef45b414c04d0a736093330d8d9f98bc6c593d52e4692ea75f64c6bc6c9c2e8bb3e0abeed3582d46c5cd7977b09bb6175b831569eb24ea2997461e4039689c0204e21d3da21507cee0dc0a667d1b0a8ddf1aa85e97b730c28e8e03a00a2e6df30aa0fd040bedaa9ba6a805a7918fa8dda569c4623db636d30a88b8536c1a22cabc574544cbeac5f0b62405c77ffe546e9d3781f5c6de5d7223a7c416891bd08eaeb0f172b4fdd90e1589327ce31af2bc86b6baaa2771cea02c2e8d7167119f05221e44d8abc21d599780f98321b3de23c1efc6323ada912208c9cc8666b3c9aa5cef609684a9e2bb3a5f7eeeabb5bea9788662eb7ef3c535dc55e91e383255f514084d81fd1c4c99df4a0df091aff8f8d794e0bf75130a8cdacf3533008a0ec71327d45eeccf891ed26cea10c7d176661dc518c39fd4083ec70eba6b70db693796fb6eab841a805455a52af271c508fbae9c8fca088e83c810b4f532818c35885d9665c1bfb2d08076dc24fe4b20a8adeb4d3d37e6a65abc9cebf1d80753285bbbb9e560f369ea85ee8450ea3d56f236e7a43d9d5ff2d84e58fbf7d3511306d17e7c1ea295cedd013e8e5b98a1752d5b3c918fc9cab831b9d71dc859eb98755e986e8f45f1875cc9493ba88c73e6676cd649512d651520033ace86db886f2d5449d5c332039338a628327952e4119779b2acae4349a3b038fee7d4e182c41288abebd1c8bfa4cfd477e8d97160cf324c09a896b4a6c92073414b1e0ba31c79c43dc9bf6306a72af391e07054ccefde6b9d404a21db58f12470347245fef0856ffe541d340f8ae6331fe1fbb4f33fefb3e49bdc535e3e6d0e5e057ad5ac5b6bf0b9fc861ce87277ac2b207206cc0f0d3b8dd763f79655b11580a4c4ae0527a009c8bfdf4a3f9f50eadff5e7ba08402d8b64a39d4a7b3bbb172cf3bf1105970cdf78edc4caa4db271a4197039fd665a484b447f68d188efaa29233b3e1c8d8fcd82ece9c6e855eec7e8ddf8eb769a86f2c5e7f463c34e59e43037cc2510f35e902fb6092688b2a6af6100da0f36b0dddac516a050727c27fb67c23f64ce8b10d5f9ce824e6576822fafc8c06bd4f915ab7247b1e984d41e3a65c514f3c84f030f6ccd80ff3bd11ef672de08b7060f6737eea8bcacc61e168cecd0b1dd0e925df96c2aa058fc3cfbdd04574cc98f5cb1c2dd0c41a096d58293a37fbc041699180770e40bffcf2e4e03fa85c8fe180cb0b6d5e67d2ff719bb55907d2be9714c9f526c198699a3a9af139ddcc2498effec6be8d7ab4f8a68257e77119046f224e069fae6e9a5b5e66c776f23372511e0880e7c7b219dedf025e981baee9beb14ff2ff35bb0e8084c76f5b2e73cd51ddd17a5f733e3258bc7bb3c32eaadfafdf421c95e993691decab273b9ed6c2a8209d36eb3b759e01c0ec8dcc9fd40a563570ff0610577dfb2755e62234bfd85d2e2169284b84dbe2cdc7cc64478be4485097d37425f574ffd43a1c50aa1477f71100688eed4ce43832951eb0d953a219d21e20291c59cd8c25413cc65bbf293d9e6e2697716f0b946eeca556e4de2301df190f0699e75cdc5c4cf0d0770174d41d262849c7680be75858fd2a9f120e7e920ee2faa074bd22f16f82eebdda502be3acfabe5ac8e8b31659d7ffba2ecfa6b0fd26b4f7814443cfd3d884e76c8f3efef3796f1645a9a73cf3e2e9bff4e5084c4ea3c2e4abbd3c2043621120f329e3acf9a6a52264914abc2b89bf3c4431608c82da0b0d4ae825d170ba73021e19806ed30959311d2636d3a2719bd39d4be91111cc8b7465fdf993fdbddb8e5bd38e712c86cb2ecd2fcb54b58c3c33eebe78b54090e3a0657560b8719aa1342670109a4068aa63c17b21824c7cbb2d468b4ba1b59b09cca345f5ce3caa12f33bccfe265efe57dbc025ea70f1905a721c43ff5dcdef9eab535aed05bb8f99ca3ca094989918b1fea0dedd47457dffcabe4e25fee097e51c69d72f5986e617e1f649d2e2b5b511547de92f6237c1b5be8cfcdd6fe258d6fb703449566d8b626ddab74ba99672fab09f022e3d7fffc8197b3c7f33dfa63403f862eb8375c8299110c9d5567c5fdeffcd29bda2f34b7f02f33957817aef373f77b75ce40000b72c1af6b5584846a172fc5f8b5fa4efeb5bdd5d1b8b06a9d6f5df24668eef16aae986dc8a1ae19dae419a3364d022ad181a69a5903215cabf3ceda708f94ae596408a743e64bec9644729079448146fae99c240cbe048d0e41dc9b21f2cb98339da0bd2e33e8426b42244682a993c5e58c0f638210c4903c058375b424ed146e24ccf79d5268b648cc863c40afd435cb167c8a6dc8f98e2171a8ce93c7532ccd7a6cd272452c6a7d5a27e2827f1d7c9edd2d6f1bbc4d902c6cd144a1cfa85aa0a99f0ab304751fa7e520738c7fce140d20b122987222fca5e49c8e096137a446f096b7589d673e3ae932583403012960f91dd3ab9065b2c115f40acca52621e9ef5a651493ae0710bb8d773b2a39933b712a230ed09f294787e39251c6f10da86e455316b7d826e008cbf9ccca911bbfb29aad536fca601094cdd8c0dcf8c9e2d824c327c5ade6178c9337ffa55396d88365d57b2a86fa1ebb9d8fd16f0eafe39cafed6b8b950c744cf6dae8ac5b896cca086bef61cfbbf65fbbd08522db2e1cafa03aa27bc0fde9d4955043ccec548b820ddd1df975b522b4576fe939305ebca28d88edbf3e212b3efa21c9247d377a1a93e0c68afca30a31dd0ccd801fd01c2a25aacf9da9e86f3b2a38985af09c39bfc4907513aaf0079b3f57c17c1c4205b1aa89be22acb698c1c4db14330cbcca7f691a1e7d5335f63ea23e4e2379b79c5e9e5cda094baa84894d550d6b30b2e5b0adce6173824020b3053f83c68430ce737555a1ced9c335233837c7a6bfb51e6541715b1a5d2bd2071c04e502e329095328f4b1ff271b23521d88ed2d6aaa081536e1357b6be92a67fad4eee1aa68ea64fe27e04b5820702baf1761207b11d7f7a27388d6ee78dd68b66a9995e702c928749a00d7d6f1e525b87f6a9697ec105aa612cff2bede207ad0fe03e966856df9f5fa0fc7573060c11f5de0ccbb6141d1bdf55299ccd10591ad782a80ab2fd6a0f2f9a33c28824835cd48c7d3da1e7ad6f51968ef8fec6b70bee7bbef831a67fc06d3baa05b912a42052d6cf205bfc14e8a02ab5562fa87debc3f954544c094d2c6af527b1bda21a1cd513975ada9f625dad1c5c482e48623f7f1a75fb1291040e1819489b7ed8b0707cb3ec72298982624b4132c6af1c1a57a626441dd9e01f8234a2f15d556428894feaaf4ab3fb3ce44c9fdc719b67ec9363afe05d922f69fb235bb9742df61b116c22dcf428513a213efe761ef3f0c41094b284e03c44b4009ce84e1e06ad0db78911e4416ccebacd69f334cc77551158cbfe9b13aa1493ef3debd51f126b862c71b9c373a81eb543a2d34c37af6c157dce1cbc970d980c321562634b0da63fa5d137a969e3bcb542670093f1b119d281acf31ffa81d44fc1029eae5177dae979901eae5609d690370430bdb26ab28c95befd53e38c4b83f2ab6168f5730ef88735ac807193e7a120c9efbcb03ee69e607f8d8705ca19da856bcf82fa66ca43c04ee4e48d2bb242193d96b5754112f45e6a0bc4cc2769d5d1453e4d744fde63f9944b1a2a4c7555aa7fe6338de1f7378b083ada99f1ea4476cc497ac79a0c427d03871a4936cfabfe624e410fe41834dea93c5c31cc7c1cc00066a2a7dfd85c92d677f1d611e2e58347845fc7c2ab6d7feb264b62b692225cce2452ce3ced7af3f32cfe062d331f5be67c1e988be5a560273aaef863241ea648ff153c3cfb65bddbd4d63c2839a84499ffaef95963eed3a252f656063165105f2f1534ab636971c9b96f964dfdaa0d7331a5c20e9a934773806b0f4979a7d9d5b0a1de6dbf7481cdce315e790f7572437ea36858ddb0f3d695541cf6529fe0e572a38727ec08d40eba62afe689111e4edc1a7ba259c2da816ff9d3b9ac8bc885f2e55facf1e98c481df304fd401ec7195af906d7d3bc5e8a9a28008bd0fa5446bf52622b25d2c40db8c1fe2d85fe215a76da2c3083e9a70f00c0274a315a6cd04b505052532e2d16baeaf1339d60b757bdaafdb8615248152a9bb5de322da9cd0d55b27204f17f578cf12cd0533c816390d9ddddc9a9373af8701f1e05202cee44fc4d0677242bc3a3cc9b2659bbfa314cbfd25a3f5ea3e2e1a814fe311f01b7d1b47d3ee687ef0774e396b038930b7a452a3e3fdc845ad3b1654ebae065fe527a666c1ec09fc746f0637ffedde76a391f863581178fa3a15f2bcd12a8301940608079c06a05c81016b6f2a7addbd3cae1acb3ea7fab1e1c310e5558c3c7b12b0e2d13673efc8ec2fcf4e9f9385312dc2ff87bafc22e887fedaa8ecdc6f0dbdff75b73f2e88fa5f026648afb2ca3faea2d0a6785f8e49c8064cb08c4811401545c38fe26e159f9f019af23befc9031bdd121d16f9464ed3b463d61d8090ead0f97e9b119d1adf94022fcb01fea02aafd10be5f472771aeeefc8b36dc2b084909ec304281af264b0b68635adc1e942c2432a7e35becd890a0c5da24a8bbc5950a5d75e34cfe7409310060c138248831e5254e3ff64733ed927f98146803f2e8318a33411b71a8e68548baa125ad86608466d1f3904ee1b04d8034681c27c31185e59445dea0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1854 花店橱窗布置 题解</title>
    <link href="/2022/lg1854-solution/"/>
    <url>/2022/lg1854-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>朴素的状态为 设 <span class="math inline">\(f_{i,j}\)</span> 为前<span class="math inline">\(i\)</span> 束花，放在前 <spanclass="math inline">\(j\)</span> 个花瓶的最大收益。</p><p>由题意得，如果把花的编号看作数值，它所在的花瓶编号为下标，那么是不允许逆序对的存在的。编号为<span class="math inline">\(i\)</span> 的花必须放在 <spanclass="math inline">\(i+1\)</span> 的左边。</p><span id="more"></span><p>也就是说，对于一个 <span class="math inline">\((i,j)\)</span>，前<span class="math inline">\(i-1\)</span> 束花只能在 <spanclass="math inline">\([1,j-1]\)</span>这个区间内放置，与后面怎么放无关，「无后效性」。于是我们只需要考虑第<span class="math inline">\(i\)</span> 束花要不要放在第 <spanclass="math inline">\(j\)</span> 个花瓶中。</p><p>所以转移的时候把放与不放两种决策比较一下就好了。 <spanclass="math display">\[f_{i,j} = \max{\{ f_{i-1,j-1}+c_{i,j},f_{i,j-1} \}}\]</span></p><p>具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span> </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>;<span class="hljs-keyword">int</span> n, m, c[N][N], f[N][N], pre[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(!x||!y) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(pre[x][y]) <span class="hljs-built_in">print</span>(x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,y);<span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(x,y<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0xcf</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-comment">// 初始化为-inf</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i][j]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 初值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=m;++j) &#123;        <span class="hljs-comment">// j从i到m，减少一些无用状态</span><span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i][j]&gt;f[i][j<span class="hljs-number">-1</span>]) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i][j], pre[i][j]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 放置在j</span><span class="hljs-keyword">else</span> f[i][j]=f[i][j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 不放</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<span class="hljs-built_in">print</span>(n,m); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#5</title>
    <link href="/2022/yume-5/"/>
    <url>/2022/yume-5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1d9321d07d6fe9f5387c2d22b674ea697d43dcc0d0f530899c38dfbe66c4b064">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8dd32136abaaba6d586108f11bfa944b1eaa032651aa057f25b706bd5dff36a7cfadcf4d236876d59ad082cad716341a12a323181e49aa42b9afe6821d2a5c658b833c533543bdda518686959eb7b785086a9bd0419d2c2735f7cff7d8f5bcf1709e8fbc27a5f1299a0c49de84ff31ce7fac69135f747a752d59dc99b7cb1b907d8ce8cefaaad05a5f65238418138e168ab0e51aa2e84042969f3232cba08269e1f1d244a649767173a7d7354baaf48a08158ba4f5782ceb08f18aac46b685ccc7bc25d53b737789222314d67be87fbfc084429e1a894e1f9ca82e6d1ae9b5adb29c84039f0896008d4998d70e8f63c7d2a9ef619a1210cefbec7aa80e089fcc40e16f6f6652270cdd285b9bfd9a02b8274c9b7e2352356248fa5ce4e077f920acc6d4c678f2cd21f6a329a2a38602f74036cef56250f55b1427c634f7454fc668c7bf594e2108ac2453dad73734f58602438376819865ee1e931a4a8dd3703e9c7d12a8b769d5ca09b6a9324d4c03a2c1a2dc2448caa90d85490565bfe6906bd321ce989de37f381a5321b24e45855dc337d1df01a1bab9af3c8d6d8994315de2b10647ea2378f22efaf9e7bdab5d5b0d2b8ef080036bdb96e1139e0c82fdbcde93d1aa7cc4ac20d55b4bc1b1c30a6d24d9bc132d3472c11906a7720cce38bb32efb83ae91109eb8e04071a4a2cd14575e841c269965a1a9fcca9048b01b09525a647c482d9f2fa83815bbbd5dbf9952133a6767befc33c2c8ace68eaae15e667dc05173170d0686afb0e403c73728bee3304abd9d5456efd030d043ccf6ab799fe01dc8d46fa4392e05c01ad47adab45cb8e76d7f1120906554f4af2757e1fe9eedf66edc6f82e8fe06e99ad64b50c90d52da28ac5674e0af9e6b2636571d4cb2fc0b99a5028393661b7475153353c91003ef9a876c8a5c74837223e214a2b514fc5cc3170c3e653e2f02ac203767727cdc1115aeb7326738880152f82bca8e07eec5b7826d5ef44c8c5905f7fcfaf6c4544fd47ca65e99cbb8ca1c97090d08b9a917af9b4abec73d0678cecf313f50a828bb30d7c1fba4a6d11a3c6e41b216844e1c29333376e4483534bdad6a190791d2141e09df0ba233cc6d7daed321197fa2c957a624a4ec0cf278a80b40364bcd8e2f1d8e289de4c456becd97ac72cef4b6cb1c7508d2127f74ea49ee5e1d13cee90de7472c835ab23a0c1b9615cfd2fe0552b67810d013cf093c5ab6014efa94b2f8245d6e94330025e82533c195aa6e76830ea9d27976d435eba6225e8e73636aba1eaefcc44364280bdb1218fa33f40d310ab846584d403af026758e441d4157ed72703b96eb5d28388cf611067f4061c9608102c139c890e975e3d7be91e60c059eb9a1476a86bae2258696a20537265bd85efbbc7a6c8446f10060fa0a9438bed2097f3f42fad60eca90db815d728e08aa05374cb69aa6ddb4ec5c6607d55c3e350ddd375732c72be6effac16bda44f4dab69d892e63947937f5a00cc362e247ac1e8e1e20e71ab94eaa01448f2d10cb5956e99584281c697e97b84966882463cd7f987ed78d7a5221630f1297485d9c902b2a04327298e26e8994d87b665ea30769c37a9cd81da4db3b944df01c60719b461c16c8ad500456594c6322fe3113102ae8a3af5a7e6c8043753d0b9c286de8e469dd48b5164eae0bae766d7fc26b33db32dfe6072e28a62eb3b55e9503e9060564f42859897272ce3c25424d6be2de51055fb26688ce6592d1ff9d3091b8b4fe33d873b3f65815305d5e038ba899eac86e5ffdfe59c256602b5a37ece4fdb2ef9b17ca38c94bbeef9348040ce194dbb1c5d7d6da017ae0221f63c7d2108d1ff7729e8265b308e4776cb7b1aee9c917abc5f75483f5fd4dd2b8bfb47ad67205fbf0704652ef362f25987496972fe914f18af9d009388f46f430d507a7a5072f772075c8c4e5f2f8e9b740895c6cf4a661ada5a3051e6b33e629fe3d1099722c5cccef5b2bc0b6b59e20c61276c0cbee4d0a6fc3c8c33a6f20ab7ee79c41b93359a2eced9b5f8b59bc8087ead255d82000e12dfb9254d89d7b37cb6845e1348efa6b1be86c30bb78112ae39dd019130ebbe59b17e22e6ad3d6fd81dbf978bd469ecdd569c7beb6849dbc56086e31c0704913e01912015c706fffc52cf4ab7ab8b07286b4ec0df72c614ea4f262d0817fa232e553ca99c32dfe953329deff3cfff25968718efcc89b48914d73b4eefda6fb03f60b3990f5047ff70b661b1cfe36d05e987c16cdf93a427a717b990b7d6ff671217dedf401201b3b9ccc7a80b12ebb4902f55e7a13f03004706c378372cc8e3832d9b6d3c1791a2b31377120398071553d9da046342d1cd18969e51da5e2672e3ed53ed3356aa6374b3aad0c82eef279cd05d7aa49c57e89b3376c7164e758baf24b4893cee78871fc2ca5e4823dbbccada09e187302147e964aba3f2f881b99214328d30c1523e980011f7c5b067c68f2d93eaf2592b29c4b396e6a98a4f890a80f9169d919fb946f3bb1ac94975056f959849803811761cd09d6820c84463e1569f2f5da886e4cf98daeb575d6cbe9ac924f8a6e1b059ed0a68888c4d3aa7dfbcc7361966d524a5641d470fee68751dd7ac1a472b523c4c4e2018a5b6e71029fad92da48f771bc52bc9d85f12e012001c8c9e3d36a9704a2de16abd3133e6f4079e0f95ff1a9dfcd2e7a60a862ef0f07b498867b6885c79a93ee98ddb301cbf1e739753388a35b0688bd5470b7a994c54f230ae8cc1d09770419646e13765baad9fd59c9bf024458cac843870da4a4f1ee8c5399cad7d1118b27a64251552b5ce88ae47e0d2edf50e37c3787f216253659e20fb6af53a6de645e3290b240a4a408e16012b1f8aa43d05f8127354254f1818fcda6aa6c4f435291e8594015bb516d25f58d754fad23cc7d8b03b8fd901f377baa11cc661f9890b3379c6894fe576433af4aa8b2a2f4beee2291c05a4673a5631dfeab22d1caf028c8b68ad20b76c7fa903e57625e8b04bd1b9fc00f8b3817119448201735874fa78ed8f1d62d2ffdbdf74ed535935e9f5b059abdf94dcda9de1d8dc644cdde6ba118144d262a7f13d726feae69d75e7dd01a5e7fccc66ad8f87dff6d789189dc66a1603150284519250f6a813257128606345b42c39df013d709308aa94f9921b016769ce0cbc4c4fd742283cb6dd67bf93b6324c0fdcb21c49dbfc868f17bfbc967ae93050eace98b68edbb04a3f3230d34185358df11f242370cbdaeb255c40c7626874756e0c10b7de7a3739ffd3d43e98188504da50e33f35d2469c7401d77ea082a2993afa29eeb509a6a29785f810ddc452d84a661c18c90f7d21d402b69cf47b7f738bd60386547a82a824d296f618f0589191999e0bb39ba77f2bcc370a86c33569784062c0c8165c046a2fa83e42990e002018989832af784bb645dcd55925a03fc486394b7c3481e3050d3e5e487442a7c72ad53d054954e3f6e5aa918d3efd24263ea5d6def2afdefa490a40f16e52067e4ee6aa57b838410e1abe27ea79c00511720af22d6459cee3fd541aa51302c3447f21c8cdf2bc86932d231ef9e3093dcd71cd845ce825f7f7aca27664deb826f4e1535c25bc15d2133da2c11f69830327643011c33320222b1ff41fe3fd2f139c79c9e8dc4633de97b013ba7cda939b8ca8c943ed5622a583d53275edea53bb968ae7da63c4d23ae785a176d7cc67a1fa49dd2c00b609073622b6a79f67387d26cb2c881c84acd78e49c68b8fc368df441265591bd5fefe198a0627939e0bd505d275a1cf56b379e0fec3b879e92251568d81997e18f4d40ec305fa39633c62b02756e62e352ae308a08fcc3c27510c94d6095ce273d8591b7db0590a20aabf545728ce23c1a4157afc50c06ea33416a969303d73beb45492cf38268c62a9dd076591093ceea9d61c3891546798d9f15fc58acdd99ea8854b27240ef82f9da6c173061a61b3d94c120f312cc1ea80bd587c99b3b8fe1a17c1c581abf63220d14a2b162ec839aad70952d45411c9814aecd8089a2f3b99a48c922f5db4bf7cd09c8119776d1c902b0af7d3a7976ff5a73f907ce7b71280d72df87d4f39f4491bc84244ba7d1d9a7653edb6c6e8e46183c3a6da81142274cf5ebc2ba6fa5b48070ea2b6d430a8befe6269b32c865a82317693c511ef44a1cbe5cedab3728a4f701e2f2b7681d7c4277cd5efed998825e3cc90fa4deda8d7690c7e8f3e3c08321ab99bd24856676323476ae535b3fd06b8bba21513efa70ad3062711fa9bd4a708bcac2a30b42643cce04262bf819bab55513a3e0d481c38b92a0f31b1dface223ea64369415347bb73af381b297b1b7c79a6d4a2681db6eba4c11b1ba1100a77cf770c7c1f73cf83d1a04166c6bc4dc554edea2bfa3c48adc72771450c0a576e6fc35ffe725c2005b198cbbea34105aec21d5460bd5caa5f7ad4e88ff548f4e07a9af9550ef18284be22570ec81b37e4614c360497d9b6ac7071cc8c235426cdda1d5a6b91f83081cd5fcd279423abde1e93542c26d26d2aedf5d01ec13ae5ec577da20f48ae2458fd57ac47fc25e8ea28210f705f8a98926339b388eb9808b9a21cbdcd51fa1aad739a833766bbd0c6512d74d6a7fd84b173411df838fe88c203f37088a9d49945bcd547ce791bbbf69abda4b9138164ce385cef1dc64ea53d9b538d3e07b21d0cf967c878453ddf2352138d86fc3058793e20564a224ade2c3e9b28f4bdbfee37ef13a8c7e9b826066a1bb034df74b7e604d9445042160be1869c68f61e0d0cbb019ab0609ec291e4c45c606276d769d18f5ba5272a95e817e3ffc2932fce19363192ea6da7db9a9745ff0580e6b1fa05e0a7dec1cd1a94211c3f08c21c224bb03ecc51c6a708c9176806dd3e07cb4eaa16b67d22eec03460ce6961519916d91b531a95503a18552746e5df755da91f2a30ca7886628d571e72266c3a870ffdd4e167a9f15e72cf43062d1d7f3a6bac1d50c6d2c8fdaf226e7376142d1c9c23be3500f43c56adaf6100e51d931df9f03407c992da38e4e78c46ca23c740b5520635be5bd9dc5b4c317159761471bf4ea09475e4950b55a0762e25199fdf0b1978af4948efbecc65e54730fa5f81f7bc107ce3ac045870bf1a32866b62896d7891af3620fc172c643f494690392e7a626c22cec4944f0f106020a32dddb7e474a9afbab683e202f86e998370181c0ceea4ecd7028026721d2cecd30a16145104e4d29fd2e957f3029f9be96a473df329ad1432588070feea5d31ca578bdba518f3084b42855d8433a1a549cafdb168439e9d10a980b3a2aadfbf547d729006e0c8bd42884e1522bb3c7e995012009f07ae0e58305495df0cb57c257f2d7e717d61ac6a0b627ec9a656a8b1d05d55c90658c818509317ac2586b8ff4d4af2da815f892a968bd1118db11b987a6f8108fc3da9dc727290084d9c63724acfcc1f7ea2241d6d2ebe670ec8952593a7a9d5f0f0785ecd0d776bbfbf44b2c916391875e0216c2aa001a886fae26dc0cfa7c0390ce83dadbe06f5930fd92d6a20d63b9fb89e545ddfe5cc0ff5e2004efaf1b13ae32ccd591b81999814606cabaa625477b725095f0409924e6cb5d10f355895dcdf165b034094ad07985462362efb27d422f4d1e78a62a1db34d1ea0f660833cfd1a17f8e93c3511022fdc29e20bd41f0a24721fabf46fb4a70313e72ad4d3a7670a0a480c95284999554ef8fb138df01b89d574bb20844a9ad5003d93e6bdc96e4741af53c873dc538c4f3fe05b36469b3eba18a917f4a35776d76b1946d2a9b04148efbe1119204202d1a1984287710e28b2db625c3065fb254a4d8edc22d74a15ab1cf36d15d413f1109f03c7d790ff35abc96cc3a661c6adcb827426faea8d09b6c4f7208ea8c2ae34540f82a5cc489c4c5e04215dbc84cbc07aa0322a5ce65763cef1b825613c51ca06b40be711a7035deb42a1a067ed2e5e33b08639c5b88cab105633fb2cdf253b6a859bf9d170be038c2aabb4a7b63cabfa57f027a058883297762d15f256f8f86b7b4df5d124ffa4b9cfca2d77419455b34bb393c0db2b29d74b6300d3efbbe4e824b68289e00fd95d4c330e6dc88c540b42d1412d7204c2ac0c428d76f3914687e17de787ee68b7e6c2cdff6c25b41a4ecb7f94b8e9765062545ddc248bad571946b80cf46b8068b08e9fa3363b7baad31a96cdede06455f90abdc94c642b1d36f7228634bc5d609a0c9296ae8229e6a9ccd712799e77ad84fbc86e68662c6fd04357ef183f8ba1d18c438690b00843cff5da69d9203b9f732dbb3c9dcbb09f7747faf165bddb4cc062e6c4c05bd337072f546e31d31fe8897a1df5360a74929af0b470b869edeb5bb8a36b2176c22aa685b5de76952281affb512ba71dc527a0b7648236a1717ff53ec38354b88c500e9c6cd2ebef7f93a1a85a412f691603f716d4351a00efb646f6b6639093cce1b65373515e95b6ecda5d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF449B Jzzhu and Cities 题解</title>
    <link href="/2022/cf449b-solution/"/>
    <url>/2022/cf449b-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(d(x)\)</span> 为 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 的最短路径长度，<spanclass="math inline">\(cnt(x)\)</span> 为最短路条数。</p><p>不难发现，对于一条特殊边 <span class="math inline">\((1 \rightarrowx)\)</span>，边权为 <spanclass="math inline">\(w\)</span>，它能被删除，当且仅当满足以下条件之一。</p><span id="more"></span><ul><li><span class="math inline">\(w &gt; d(x)\)</span></li><li><span class="math inline">\(w= d(x)\)</span> 并且 <spanclass="math inline">\(cnt(x) &gt; 1\)</span></li></ul><p>所以直接在图上跑 Dijkstra，求出最短路及其数量，最后判断就好了。</p><p>没啥难度，但是好像会卡掉常规 SPFA。</p><p>顺带一提样例 2 里面，2 个点 5 条边，稠密图警告。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;ll,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, k, ans, u[N], v[N], cnt[N];ll d[N];<span class="hljs-keyword">int</span> c, h[N], ver[M*<span class="hljs-number">4</span>], nxt[M*<span class="hljs-number">4</span>], w[M*<span class="hljs-number">4</span>];<span class="hljs-keyword">bool</span> vis[N];priority_queue&lt;PII &gt; q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(vis[x]) <span class="hljs-keyword">continue</span>;vis[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z, cnt[y]=<span class="hljs-number">1</span>;                <span class="hljs-comment">// 此时长度为d[x]+z的到达y的最短路只有1条</span>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[y]==d[x]+z) ++cnt[y]; <span class="hljs-comment">// 长度相等，另一条最短路。</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u[i],&amp;v[i]);<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,u[i],v[i]), <span class="hljs-built_in">add</span>(u[i],<span class="hljs-number">1</span>,v[i]);&#125;<span class="hljs-built_in">dijkstra</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-keyword">if</span>(d[u[i]]&lt;v[i]) ++ans; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u[i]]==v[i]&amp;&amp;cnt[u[i]]&gt;<span class="hljs-number">1</span>) ++ans, --cnt[u[i]];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#4</title>
    <link href="/2022/yume-4/"/>
    <url>/2022/yume-4/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d5638f95d200baf2b927b6e7d6f20c2e65d4499069d159d3d310abb4c1d895eb">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8dd32136abaaba6d586108f11bfa944b1eaa032651aa057f25b706bd5dff36a7cf6f4560ede8f6e78908bcc7153258e64a891bc671cba1a43958c5b25ecdae095d632fba14e083a14aacba6bbdd3c26cd14f2505b4963f561f85fcd43ace814108edd29387ef01c43a39fd5b523f868d42a47179eb9c7278e798a6a123c21a632f7b5f276895c7ba911d65b9b067e1fa6907f0180c16179722cf7d28a387e8ea8f078c803453e39e0bc5309243633a9689c791f49c57e7fbd2b0a61c11f5a4e072b81e651797a3f74e34d0a195507a5ef1323899da0d3f846256ee640705db60dfa65328a31f42aca748d6371b7458e28ac8e8924c3761ccf1f2c9040b02f534f261c1fa99d10ee34611c513d5f421cf4413e8b50c454962aa397dd0cc0684dbe80d9f23ee260c473d152d5f7696c65dc84665084d3d84b7a3543a6f9668de1f5d95c84ef58cfa71459ac8dfe4c08a8f7ae3de3d7c4b55b249d5caf104b4ad6438ac0bacab2d293e0f151a02156589f5c54947a10107e912d12be1e12925b9e2d781d4ba8d578241c7be81a3311f8ed7e57d7ce7bd719a9bfd8390c26ee8d5e4b32b25fb2e081b38928ce9741932c69d1c9a63dbc435aaa0c7fb34dbbf2666250872c498651b4c3923315266dee362a6f66636ed94edf15995248dd43db70dff961c2a75b3f04b89e2aca0019aae27cc6c9512149b3a8eef8152739f96f7d8111988f41352718d136a3333f60c095f412fd63450c5d1ad1c88f5c34c21e5a087485d574b2187fbd5067894f0dd21765b01383f95432eeb75a6208770a907063b633f55bea4f4edb939993a957594329bda8b91e1fd761b25ed9dc7d30491457db38662da2b1a4588b57cffa6894225666e8a16a8281182cff3934be730a0b7147826453a5efa2597d8c1fc425ddbcdc6081bdd0a4032e2a7c73c979fc2b9150638c9388793d8bb359803dd1640505c7dfea0629f330761af420527ddd137373a35d71c86d112bec3fb7190acf5a3908e31bb40f543e2cc8a2da09915795352718810c7517c56cce4c40c8c657bd498de86a0422297d6a466bc22796a5a042866a21a2a57ecb288641d2e8d1911af6bfac7f826bf52182e14bc2f25a70120aabd4d5aaa7c53e0672aa29013f1f921bb191b5b542dc8039a848d6e755ecbba943e8c692fb8b88923cd6c78d87381d381b625b5275383c9d5bb1438868033bae924262ed74f142259a99852c2062e35e5e094dd425b01870952e53470360c218bd197812cd774e3ea03cb6668e7066e39b143a10ab7ec91c563ed82691b4c6ae8f90fa29ae7f9dfec3e67b82a40090ea97988a3531e6544c87a5093bc45a3489fd38eeba767149c43151a2da4029884e550d9a78a63b5c623f03071f0a46060188e7e3ce1fe458371d04830e885be77334447aff83bdb863e3929b08298d8b1cad4f99fe35374dcc222112799e932301a2c9d8bb6b7843d1c60c8c9c3fbc79bae26f66b1328093ac4cd129c900a7371c13f0479d7c68a69a22145beed39068cc7f98224c063f5ee786ccfbd7f4174d3ebe7ac0238f11e55c09e2a0eef4e2d0b1e0f668aef60d073937f60134c2a5b1fe71e23ffb1ec38f466b569f6164f5cdcca0073952808636287eabeb97c62367a5ef554e3d6eb771b616065b3aaec694f445292745561e15d377eaa0183cbf3ed09c718066ef03b869c7fed784a30a37050f242f9fa5d043a63063b897569a11be906310a1253c0862d16bfa0a3932190fec1e2f18fb83929a7f5485c1af575692669c324ef576c42fbd26c7037ebdf33d392efb14cca77d21575b8728fffeb78bf30e2529c757b5327a3388daff825485a3563d4941a6e0fb15a589547aa96ab32b87497c2c8536aeda95b79a50a35737de872b67f722855fd0ee7c864c7b8be0a0864e99ec219deb5ed88fee65266ac73be5fa1cd784c042781975743c747be7e240e9c2891e1e9d08d534420a54ae8ba0e5161c086026cffcdff334d128a2472e2e39d16b02af33d75312a9aa95b7ae5a7d1e7b7dc241cb887010e6d9d5db2b2527be7ef752478f86d9c7ebe3209b3b5320889c2ec9fac6ba574417e7d4cc20cb9457cc5f4ce98107be6924e7cdfa0c0806df746242bf2db7f18f415fd3a6a50f3b98654b14fb83e6345c53751ef91116469918ee5c06fa09e7361623b57145062c65363b76d98d3d9c904f0dbb5609a863cf8fcb36d118ec25c786456fa5a051186cf37babd43538ecbbf66997593e5e390ae69985feee7721126778fe34230593cee9a9e86ec9e800bb36751194bc0002df6e9b3b39c300c858574f1ad82e83e13cd5701a53e29a5b12e30b1d361389765a905b8dccc6ba50236bb2ecccfa63a4b34cd30a4d6810e38ef6103753760fc871e5904d46db24a8818b6044ac1285fec9cf893d4add31e0ee3d419894c289c9c2e2d0fdb1da83762427626cee4eb183a82f39c5a65a703ab9b9d5624be7bc2962904a29ba9140f86cb9d7baf6b84b3b272fb2ca7099d911477a2c89a930d86f5ba8ab616fb9545387183493391ff43531353555179fa1f825d02738e6517025a9f003edaae227fa2f4a3540c0058b7834acb1ed47cfcba6ca51851229e52490e1dab11df4af4994a716d9eac48016d701e205e4c138901fe9e4ff2c1cb97eb4bb10f6ee610d957b08cb4323d0399dda387272c7522842374f99e1d6467ee0c04be91350393fd5544b43d9e0c968eb30153c2826bf4b635cc9e5de6220a5fbd8747ba84de242886e518be8242d04f597d32fd2fdf7dc0104dd59b15c1441e7f2ad1dac96b9fad31d79d2d667d6403ef42dadcd89fa099f4086d64b464fa4fe3497369eee380e26bda7f66589e9102da8fff49ac487c0bd9494193de9c61c90a915c3b17ac316dbbfa405fc920e77af8dcd74630d7fe42fe08c9e21b311233a3fee577dddb596d9ffd0e76faf7eaa87b6988836a7da0ff17305801648c9de58b3e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2350 外星人 题解</title>
    <link href="/2022/lg2350-solution/"/>
    <url>/2022/lg2350-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="闲话">闲话</h2><p>看到题面的第一眼 <span class="math display">\[\varphi^x(N) = 1\]</span> 地铁、老人、手机。</p><p>这到底是个啥？</p><span id="more"></span><p>难道是初中课本里说的那样写？ <span class="math display">\[\sin x^2 = \sin^2 x\]</span> 看样例，显然不是这样。难道是导数？高阶导数确实这么写，但是欧拉函数怎么求导？</p><p>最后发现结果是 <span class="math display">\[\varphi(\varphi(\ldots\varphi( N))) = 1\]</span> 套娃 <span class="math inline">\(x\)</span> 次。</p><p>这不就是迭代么？出题人写错了啊！正确写法加个括号。 <spanclass="math display">\[\varphi^{(x)} (N) = 1\]</span></p><h2 id="分析">分析</h2><p>出题人都把 <span class="math inline">\(N\)</span>的标准分解给你了，不从这里下手简直是浑身难受啊。</p><p>首先明确 <span class="math inline">\(\varphi(x) =1\)</span>，当且仅当 <span class="math inline">\(x = 1,2\)</span>。</p><p>然后 BZOJ 题面上有 这么个东西。 <span class="math display">\[\varphi\left( \prod_{i=1}^N {p_i}^{c_i} \right) = \prod_{i=1}^N (p_i-1)\cdot {p_i}^{c_i-1}\]</span></p><p>懒得证明，仔细看一下就能发现是显然的。</p><p>从中不难看出，每一次迭代，每个质因子的次数都在不断变小，也可能会产生新的质因子。而我们的目的就是最终把他变成1 或 2。</p><p>那么每一次迭代，最多能够将 1 个质因子变成2，所以我们就要求出每个质因子在整个过程中，能够产生的 2 的个数。</p><p>如果质因子中没有 2，才考虑变成1，否则就不划算了。不难发现只需要在上一步统计的基础上 +1 就行了。</p><p>那么怎么统计呢？</p><p>设 <span class="math inline">\(f(i)\)</span> 为 <spanclass="math inline">\(i\)</span> 能够产生的 2 的数量。考虑递推计算。</p><ul><li><span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(i-1\)</span> 互质，所以 <spanclass="math inline">\(f(i) = f(i-1)\)</span>。</li><li>若 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 互质，那么 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 在 <spanclass="math inline">\(ab\)</span> 中是相互独立的，互不影响，<spanclass="math inline">\(f(ab) = f(a)+ f(b)\)</span>。</li></ul><p>其他情况就不便于统计了。</p><p>这样用线性筛，就能在 <span class="math inline">\(O(n)\)</span>的时间内求出答案。</p><p>最后对于每一个质因子 <span class="math inline">\(p_i\)</span> 和次数<span class="math inline">\(c_i\)</span>，累加 <spanclass="math inline">\(f(p_i) \cdot c_i\)</span> 就好了。</p><h2 id="code">code</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, n, cnt, f[N], p[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e5</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) p[++cnt]=i, f[i]=f[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=<span class="hljs-number">1e5</span>;++j) &#123;v[i*p[j]]=<span class="hljs-number">1</span>;f[i*p[j]]=f[i]+f[p[j]];<span class="hljs-keyword">if</span>(!(i%p[j])) <span class="hljs-keyword">break</span>;&#125; &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">pre</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">int</span> x, y, ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) --ans;ans+=f[x]*y;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>欧拉函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3648 序列分割 题解</title>
    <link href="/2022/lg3648-solution/"/>
    <url>/2022/lg3648-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>根据小学学的乘法分配律，并且手算一下，能够发现，如果要把整个序列分成若干段，那么不同的分割顺序不会对最终得分产生影响。</p><p>比如样例的方法是<code>1 3 5</code>，如果我们按照<code>5 3 1</code>来分，答案也是一样的。</p><p>然后划分方法就没有后效性了，我们可以定义一个固定的划分顺序。按照习惯都是从左往右去分。</p><span id="more"></span><p>设 <span class="math inline">\(f_{i,k+1}\)</span> 为前 <spanclass="math inline">\(i\)</span> 个数字，划分成 <spanclass="math inline">\(k+1\)</span>段的最大得分。状态看起来是没有错的，但是怎么去转移呢？如果像样例一样做的话，不还要记录某一块区间的长度吗？看数据范围，如果加一维的话肯定是不行的。</p><p>不知道是因为我太弱还是太长时间不做 OI题了，我竟然连这么简单的问题都考虑很久……</p><p>后来想到，大可不必像样例一样分。</p><p>对于一个 <span class="math inline">\(f_{i,k+1}\)</span>，找到一个<span class="math inline">\(j\)</span>，满足 <spanclass="math inline">\(j &lt; i\)</span>，把从 <spanclass="math inline">\(j\)</span>分割开看作第一次划分，这样就能准确地计算对答案的贡献，也不用关心区间。再者，规定之后只能在<span class="math inline">\([1,j]\)</span>这个区间里划分。而这一部分就是 <spanclass="math inline">\(f_{j,k}\)</span>。这样就不需要记录划分的那个区间的长度了。</p><p>所以转移为 <span class="math display">\[f_{i,k+1} = \min _ {j \in [1,i)}{\{ f_{j,k} + s_j \cdot (s_i-s_j) \}}\]</span>其中右边那一项就是把这一次划分看作第一次划分产生的贡献，剩下的就由之前的状态转移过来。相当于把划分顺序颠倒了，而事实上根据开头的讨论，这是正确的。</p><p>复杂度 <span class="math inline">\(O(n^2k)\)</span>，显然不够。</p><p>然后就是斜率优化的套路了。</p><p>对于一个决策 <span class="math inline">\(j&#39;\)</span> 优于 <spanclass="math inline">\(j\)</span>，则有 <span class="math display">\[f_{j&#39;,k} + s_{j&#39;} \cdot (s_i-s_{j&#39;}) &lt; f_{j,k} + s_j\cdot (s_i-s_j)\]</span></p><p><span class="math display">\[f_{j&#39;,k} + s_is_{j&#39;} -s^2_{j&#39;} &lt; f_{j,k} + s_is_j - s_j^2\]</span></p><p><span class="math display">\[f_{j&#39;,k} - f_{j,k} + s_j^2 -s^2_{j&#39;} &lt; s_is_j - s_is_{j&#39;}\]</span></p><p><span class="math display">\[\frac{f_{j&#39;,k} - f_{j,k} + s_j^2 -s^2_{j&#39;}}{s_j - s_{j&#39;}}&lt; s_i\]</span></p><p>套路地去维护下凸包就好了。</p><p>内存不太足，滚动数组优化。开 long long。</p><p>复杂度 <span class="math inline">\(O(nk)\)</span>。</p><h2 id="code">code</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, K=<span class="hljs-number">205</span>;<span class="hljs-keyword">int</span> n, k_, p, l, r, a[N], q[N], ans[K][N];ll s[N], f[<span class="hljs-number">2</span>][N];<span class="hljs-function">ll <span class="hljs-title">squ</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x; &#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">return</span> s[j]!=s[k]? <span class="hljs-number">1.0</span>*(f[p^<span class="hljs-number">1</span>][k]-f[p^<span class="hljs-number">1</span>][j]-<span class="hljs-built_in">squ</span>(s[k])+<span class="hljs-built_in">squ</span>(s[j]))/(s[j]-s[k]):<span class="hljs-number">-1e18</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">solve</span>(ans[k<span class="hljs-number">-1</span>][x],k<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k_);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]), s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=k_;++k,p^=<span class="hljs-number">1</span>) &#123;q[l=r=<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[l],q[l+<span class="hljs-number">1</span>])&lt;s[i]) ++l;f[p][i]=f[p^<span class="hljs-number">1</span>][q[l]]+s[q[l]]*(s[i]-s[q[l]]);ans[k][i]=q[l];<span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[r],i)&lt;<span class="hljs-built_in">calc</span>(q[r<span class="hljs-number">-1</span>],q[r])) --r;q[++r]=i;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[p^<span class="hljs-number">1</span>][n]);<span class="hljs-built_in">solve</span>(ans[k_][n],k_);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>斜率优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#3</title>
    <link href="/2022/yume-3/"/>
    <url>/2022/yume-3/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c97eac704fffe8dae7558403eaf377fc74923b46c7b7407888f081d47d486984">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d6885a622fff197f9b1467e42d93fe922bfec58a2404b2f84c6d0aa8cfd7dcfe2f6670895b3120b8b43f6bd789f12a115333c631c7ee29700b3faa1808a2de28aac42a03b909e15c35c1bc7cbb15a9893c7e00d51b00afa29c7c4889f3a033496387994a2d5efc5326144502f6abe6bb29d02664f7dde0d693a68df73bb39c28fcc8fc056a3f138ab52afa946f957870444c6af8813d85c1ba52e4d7b05b1db1b60991a452376076d3794be847c8e474d06820aad93149c59b7d2ed73b8771de64f143a082e84d48ddd206e9e956b0445a209ab82aa1c66e97a323fe2ea64c753a6893bbd865f46d7cd300a40ce0ed8c222162f7eafb3c4653e5c477e0edc5b6c4c82111ff9c890dfaf81ff332638dd3d3d6ae2fc1c06a165b114c740c29e6e44d0fbd6f905b0e3f17ae147819af7c1586a0b24b43e209a5a7420f654c1cf920408f9bd24ef65c9af9db57db28564e0d25c9099231fb4b8347eabe01c5523bfe70d595dc0792a72584dc814fdd997815903d655da7dd2be317840d04d0a44de758cbd5346de5fd9c4b9475252e3a1e3acfb006b07c4f8c670a9ded48aed314724bbaecbd9134d0f6dc8f4ad201861a3a606ba0a76fc20678b0b4a7d539a8af372d9e181c9ceed9522fe1a3739dbd41e424096541174f443da48bb423d0a65b601e3ef7e5d7fee7b57dae46f83d6234db0b56b937054a5db6fc02cb834818327fe6bb5718bfb8dda38ed05c5c764afd9a62ace57a2e7ba44c311de8094a629c22a98c6ebb0cb94426bbba257ec0ffbc8a55910a8deb59acbea1e33b200515fabbc0a0bc5a54d6eb70783359fbb38ee0ac5ec92018bbcc5d8ad4d0638fa91890490ba289b79a5a54c664020d21462131abd95831ed9ac68c0e2557dab0a7b56d80d9c84afbad7cd58d9712ccf21a0bc7454731619da596a338669cd39447c9825ec3b8abc1c04031f52e01ac2f235af8b7ed71bbb0268b0a935b202a925f3a3605a493aaaffffd2eac23293341f0c03faf0592ef136bac7191072d8f37755cb92460c35d44c11179808b7be798663144065b3a3113ed6c71130eab657b88a50da42011c77dbad6dda37c6504ea6bec6bfac9c88edbc93e510af72776f050534e42eb671c2ecbfa11bc6df8ded7d0323313d020ff7c5aec8e6a2ffe64484470b8ebab51a585ff1ec09711ed8b7638443488b57dd7de878a7e9660fd4e6efdb813e92f1fe8cb59837b4769da2b90b3642c7b5831941d27f732f5cad33d98dde5c8522dd7c7a3e91580ff6b0f0fb9f270e81f088acc91079716158db972768b2232eb264acbe826dfcc553fba308b2fd24978315d78190e3b35ba5e5ed0eb011985eba7d36375ea7a244435fae19be742c877588002f3b198825fbf5ec661cda2911775ea761123f13d27829573794896e7ed2ed4f5fc1e03c23f79befe9e10b86532c19398c81a5a2b5ea455aba3fc5f6afaf18bb3bbc5c18ae094a80d19d7678519449cdf1d5b7ea25362e57c31ca85f6cef045614e61e700bf5220ebaa822e7d24ffefeceac228658790192138810bca6fcec879ec80b3c18a09dc958398169fd4db8abd5d6e55937735553f91925196a6024bc1a00fd0f4b788c15fb3065ec48a8425df8c2f041be788928faa9035caab6272d4d14f230e8458822f1c9267355ebabdcdc7e40033877344316a62cf053167203837e59b2897ef1ecf038edaf9e20f3e9907ca49642bce5f166c8379b7aec660666c742ab1af6ce5004722c30f6f30a912c45fdfb18bcb08720085763ccb886e9f87b374c380be5ceee6f8061ced840bb59e656d19a8e2b12fe62ac1c7470944e548e8db1f72923dcc8b5f074f161759980e57e119e63e7165ed2276864a6a1ad33e1e9fe2e221cdbe63bad7142e2b08044d83d600963848dc10aed52cc9e839649d854ac5e7b4677b4ff04eae4abf2f78f1c35bba23838d32722a0914d3d1614bd993b232199931b71fc4fc2aebc6644e23e0ed31957387b8431635617d0122a38c032976d83057709c85067473773f60838b0e5949cb4fc996abb23f924b937b88a26cd355c6fb57001ce61db579862bd2b30e760a46d0011c6a1f9913c1d50ce2086268d86a168490ed125164b68dabfef380605d2500d646550b47caec3b27eaa71dfa4d21c7eedc98228a23bfbfe6de28499d0a58fd4dc838a36819515c3d2e796ad959b94b7d938c461ff2ab7335ab3c68880fed2b3c10fa222fe2ceab55b2af8cf4644f956cb8816c9c8def73ca56d6fe7295282e167244bc7a173da5729dec391150ea3b831e58c64630f3220073156a4a284e2d0f29b4da73a032aa592474ba87254af3a7302f423db0960805a1752339e6eed06c5550b3273a186f5a54983e5122799ab649ddc04b2cc72fe52c1c40653112d4af1e153b0c13278b8101cf526ae5faa1c271ce120a146329472811a336fe5b8db155299200d1b0797d8b0400c8181a414ac49c6f360aff487b0dd026a998a66fe5d18e745f42350d7306940693a96917d0b71fab1f1150cfcdd78bb5c190149635b797223dab09580b3c301c49b6f0ed4b33028f912105b0a8a0eb35931ab7cc1758cd97f91f185811e95502b267fa63708c647719736aba8caea15efdd9c78710e5d751642a08fde7e5ca351ca0020f96c47619713a6a995f882615ea04310130ce6e8ba728ba1255af9e8b5dd5bd57ab2891c6d0ab9921643078f2e74c2b83b7ac53c8c2b02c84d0a277f91a58e74c0a20c6192e54fd0acc95a3ffec7189b03c582c85958aeb3dd6f4fb7b2b348648c1f094562992c4e75a8061a8c9e4cf208f33afe79276970681459040b2786b273a3cada639fc1c7af2e23de6a5443e54d597cdb4e9784d0d54e617f375ee0dc24bfc58831e6d27cfb7e9d17a43c38e4037561e667099340abad541b7973e8d8a7a7e62176597340a793c88a91b82dc87f3514fc27c3225ea7cf874976d926c5f0b3631856695eec4fdb088a4e955f0771a5091c9b88a89d64de00aeb7589f0ac7166bfb51c15ebdeae5f41b9feb3a2cc51f824fadb5f12ca2673c6677b88a099c428fc50fa9185ed62c73c93c5f197fcb8f9a550260524b1ea53b4ff493d9bcb695852c8e36601f95c219e1e086ee6f45c26d5fbb05ca090ee8e807f04dd3ab027ec353a9661a4571a7cbb0f06d24788aecd2bcda99f1052e13c8cbf403f783dfd14c2956f79b5d16528c943ccdb8a7dbc7c4ca82b24ca8d90d084e1df6dfc8756b39825645c04402b6399b219c109261ae4902c762d850c2990bf2444559bb47234d6e3ccd60c2acd5758799d721388bfca0d945daf30967d37caff305281bbccf91a301224f5009b29f5ab44cc861e694e691ee1d6ece92c9dc0f971a2fe1fdec5d6b16840fded1b9a55c9072464ba1d8930c2da64de3f518538514f2edf5c7ccd9f17b27b48724cfb0e25c14e4351f2a4be1896dcddef82ece2e11fd9a5928c0260f3d03f2fc02b43652ff304babbe6a37eb67e877ab56c2afe7ccdb5ace03b3a2ad32c650b5709d52164a5425a41d976250988133228a0154344ce45e736e17c539cd037c7fe98d1a575c055888795791d9bcc323ea9c344bfa21a8d3870d0d555ae0a99472104bb8467ee316064990566f8d617adf22dd36e72dead98217ce728e3f0cc3e67e3f6afe72dc91fcc3f60b7eda51b680eb5278d355a59de0ab3df0f05c8f37a09cb997183667210db5373ce178b26b9d90dba21064cdc0905e476321ac0920a4b3917ebb3ce8e8ca8713b4828d62a480f79000d70d96ec24cb837f57fa636c8b60fcb960e35390efe773bab75eeaabb12f2749aecd29469b65cfd3758c08f638d8d33184a8ae76621b3c38d7309defcac918737c043886520e06c9c722fbd802d5cb582c265ca50f9079c89108464c607d774d8c6eee69e3051ba7b6d08f7a652449adcaaf33af2fde7054273a3c8e59ee007bc622484cbabeffaf03c32bc8dc6be05650d9d52b6211ceabc35e0e2767f5fbc50dd80e3a5d164cff72ebc528cd8dfbee1a6a0a1bfab0c0fab5a37eff6ae81f32a05a0ce5685dae4f92dc1e9e1a66649de2aec50761995bb9c1fddc8fc8168e48cdd65028da53f5065abfa59a0fe3e43e0fa11324de2e9a84e25a291edc8dc1f0d90447ed183a8f549d3d63f08a3622cf9d4805928ba184c7bf91b3a5724e6171178be4dd71e9086b9855675e638da8fb3323045acb2929b84dd510923b23ce225def0a4dfb296b0f7e91abcac2f9cb1cc9fa9dead557409f9116a70a1a7dd2c49480b74fcb2d874fa57eaf0472afb12bb5becd56452670ce27e216c4da63c289b119341476698d3f4a0f1813e35df604cac30382ea83a076f6d8f6ce8b6c9dd67cb32a56a0f624fef146e2b6a9a542446dcdc671c9c8b7b67f398661db494638fa8fcee4576a1001ac257447a33fb230064373a58136910bbc63c2b6fdd1cf513b8c6300d19f39cc5aadf9ed7ea2d9c89281d338f680d065ab522b2737ca28ca8070881da343fa9ff4cfdf3c2a0c1613dbd357ae556cddf14c967acc803669bd8dd1224bcb59f87455d4af3a434381fb243dc224fe581d5894e1d2ac514b138055f56745b7f5309b17eac15423246bc7983eabd96238a6bcd9b8e30811ca35320ecd6010320bee17bce3f7eddd6fbeee4064e2985597ebaaf0f8c5f01a28b61445cd92a601950d46ddd553224e82477778198bc986f1d82fe3fa7aae8fe4686f782e29037c1e2198eebd4e38a0552cf5e5e5739333340f57082a99170fcd825eeed2a147aeae807bb990ead454e603c8e6c0d7ec73392642b42932877b137332cc65cc2c964f7d04eb6876dc40dd92bb085cd20a29ef3a6cdba8f4d98b80dc6ea32fc221b1ebef5a586e30a0426d244786210690e047e15b481f4eb36dcc223fb8d2b732504f0c1a6f0630f12e0393196f6dc82cf40063211ee18df5dbdc6632328926075a81f4c0e3f2de17c2be352d17a7f6e3d2dc4cb66f586e713fae02095b838851743e548c2e93a1660016fed7857fd98038ebfb9545af86b373ccb7e76526f20d1581f27985d785c50afeffc11d6a2bd1e569593a35e4df2bdbe0c1c547039aa572667c0e47e2b2609bdb65bbca6517399047ef2f9ccd5a4f0deecbf98fbb12eb8c6b714804b6f70d22e3f181775ddde91f03c862b699f1887308327c249a59faa3e080f02f3fb2986361d0ed3b16cff6e1a7000c7d30b93dae6ff5229469e7d01374ce78d37df73d1982cbbe3c1a2a65b83df3e3fa3f69c4ca819deaff28976b66bb11c4cfd01d63ebc51d4d4d0129b0e5177f35726e90a70ed02c998bbd0a499b8169e68f2a9048d6644a89465fe1a7adea403323cdfe652a64b04fb4e284a552cf8f1761a76bc6e94c93082002d2d105bfd5184384d546c7d03bfb30a1d79202234ec412aafc73ac4db42fd1f72a4d2f0b7b80f93f1a95f6a642f3c5ab0573dc073e88a60c95f2724e5af1cb75747a65e707916c04ae98802b29887aaab54b2e10dc55655a9f2fe0d224776323d1368bd651db7720beb5e030e11f5a474d234da69ea450bb3de1cb87796d61b88071868d726720d7d330e8c3645c57092c9ddc3b3ea71ee37ee2d5674ab3fe7f105c9cac7ba9ca80a3d85336ff675f85e342c66b01f7457f78211568a5e597adea659cddc60f9dbdde7480b684adb26cd7b78c9116a730750fd373c0bbe125d388a1111ae2655b0c9921b92f808119171ad6d802b0d962c4f2b5129dc65fb5b0eb6d5cbd48867dde2da18d12aec700b337a9a67b793fcf5b7375599882ec1cd8961606bd6c77860b843675e41e08451fa35084cb4cb7f9c03f66ad098e0acdc555ccd8055d4cd5d37f50a50d3b972821811f01b7330edb9b12e96209c9bf38088a1440921f836564a168e19fb4f57c17db9d4d6028a59e277bff2eceae63f9b9bde80ef4f1fbc5b6e5409a59e82da2339deffc81fca6804337472e35e078d298830fbd49533d4adac203152044be0eb2ab6b5cff5080c8ff569c45c7bb985ee2946d0b7644fdce00843562ea388f8b91af96377fa22ae763d4f8a84cb8877290b23c670f2968d48795e48bb753fe516d46f36756b34a57cfdd9812fcec7422a75d72c3ae85969ade9e97f8de001058811b26ae4e951149edff00183333abf90b208b00807e375d3ba8adaf7778ddf9a9419369e03ba143e9e33db54eaafb6aeb3e84f72954a3451e6239ca3595b8ba5b18f3ff959a5c161d2d9079ca221830fc492fb2690b3109f92b971bb1a82fadb80b6afb63efe8445ad6c0d91be43e87b7cc33436287e54b32399e689bec5f479e01230c0366a7678cb46031c1bd9b028957401cae76f5541bed14c31d35bf3578601f6e4ff8d72b3da3da08c965dd0d4d5f598dac8e709c3a3ab943a27be4986d23c0095d8b84ee1ab21dbb89430f94b5fcdf58a9fa5c3048861660870b9aa219692f0f08c1c3656767c64d9c7c8d370d9a25389fcc98c79ea7a96072002608acd00bcf70a8bf26143cf2649738b79152cd95088d55fa680c9a1e3364ad35bd42fc532106fefd338814511e485b96c501e712752e94975d266075c9f0909b3559852b1c4f51cd30a2d9f314b1d681ae87136be45799d5c939054d30c1e27836c510cf274e75d0b27ef716b50a38da3afaf5fe968ac45856f79567736a6eb28435a344c9287e0d3556cc686f76e7938d718db86560d7987b644c665619352a4b600fbd2a6e71d7338777a8e6f41dd863adb8a69d6b850a54fd50e6ab53d30b6107e1a8d1d39a2932e6de3de3ad43102330811bf72f760e5215d59a234b7adba6860a8066cbe58f9db7c217f1447470f36f84af7b783061916b74136a2971ad5e9cf66b114a1853cd5e9449999651079d23828cba275adf3f68b854088c889f4904365755c6fe9c66b3b4e516a123e2cbb3034172f123d34fb405c2d589d7d12f12ca6c60a646f0f7703b7368a85582ee1d0a9953ce45dc4c7e3d1a544fe2eca25ac48e238b2aecedc1dbc057b1f1d662797474baa2fc854894e1f0461ee297825501b688d60a2fe2b29dca21de8cf503dd45dc487f6419963ae654b2c343868fe0f0bb4abcdcf02bbeb243f5a7b7fc8af2766694ce4bb02b35ae8fa4b95ecb1477c81462ce1328bbe9de5f36d25c82ea5cbd2e3f5a7cea99a87bf57f81e281666d0f2cc2d8de721fdde2af925dbf6691d413856df23f0e8a4b90c669a198168595daf4ca69338b4c5ad3f1aa5345aa2ac9fe9cc21fa54c139fd3c6f94e5c92e06d8ae71e2ecd5b9c66ad02cf28c7066e057efda15aa774db06fb03f4ec395446d23b16d46f6032321bbaeeff7ce8768753b60be677c3f53ea7ec84f1f0ba5082b1439b62d81c5d599719ae6cdbd41f649eb0b9470bcae54263362889fd0c19c4c61f3d377fac1d52f7277f61a2f37768c57634487adbcda8e42dcc24df2d02cfcfe8bf2dd8ec7bb940e76e97e3c0563b096c63b2bb64c9cab8f4c0503e415f77f567c8b0ee49aa5ab294f37876b6b07bdcd9cea2c9da499ac47d7a3a5b40065a7bae4d42927fab7f2c478e9fb21a54decea85be1b662ee2c72b7ad6c12eb2f5f3dd44b122ed3f5eddb4f51a3b89d51004ade77cc5ed1338e006b58b225666f7773eb19749bab08bc70d9211d4a4a24dc9a94ed56727a6b1e4a2fcfa208ef9df40ab0e8a32d67af4be09c6ff43e9e12ce44e9753bc82a563aca43d3f0c138c664b451500e37480e9ba59b66ba536dfeedb47682f50697a5f95328a7cd558e8ebec3dcc234bdda16e51875ab79b3e5221b1438ede95e6fde3d46f8467b876a7013683b7076a9fe41d145e539d6abfe0ee113a23743e94f41252912979b37c8bb6d99b232612764ba735bbcaab03cc4b0026207f60bca80ce9d401c1b8b2a5c4aaac46521cdde882ae834673aded37da0a5aa3b02017e74d15922c040feb5a15acfd65cb2b3c2c063466b46536016240543bbba1f0b66e24dd9605bdd1926528a1e8f3b019ffe4f14b0848f82e60f484d4a6510fcb5998ff9f7fea3fabfd721a5897baca66d8eb72e119a0bec98bb7a36ffec6216879132ff16623468f391ab43df8f7f2b6dde0cfbcac5c6db7d47aa99a0d977d3e7942b0e0c87ff1ce52caf500502d7df5ebcb124ddc81e5644195dc82ab4a2113224ce08654ce1d4253a484a9d855c590ed157482837592b179ad1aac3207fdc2be003c61ce5c4aa2dca31eb79f17fa80f8bd2205a622290f3f4176b28065b99061145e5c2f70099</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#2</title>
    <link href="/2022/yume-2/"/>
    <url>/2022/yume-2/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="56c9c8c191c476bff00b721c464c39ddf7d7d7c0d5ae0e8a46a91e3303542f1a">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d2782dbc567f074762e13e446b52ab18c1855820d3d6a10dcf32eb9f82d2e719ea153f629223e8b8a9daeb1992e6d63e5c5344c57e66111beaf5165ab765ff2d088c671d326b26aba11896fd95c3b53d7bc9b8514c9b5181148dec04d3b0a0f74021f8c127d85dca4be2a0ae9bf554b173ab2998a47274cb738b32f4842836b9f3552e566fd15d8fa95c6ee8defe7155e82bff0460a28a0d6b309c1d8c6095abf3d74c89d4ed59cb0a172c983248e902823613f5eb24658c9bc0ffeca650aff3982b86ca3cd61e740f1d43567a8bc6bc57ed277888d58e3b95857c39b0f08a6fd4a591b0d81e6617f8de3da3e2dad761f89e6f092f654e500a36766b9df963215d886de0010c3d853214fe76de05832f370979a6d41992b0a69c1a626c3813a9542d3510b1c610f158617de808e4abe0fef0270f6542184d8889bec9588d552c1166dee2690342c7cd51fd49eafb87b617c8e7c620ec5d3c84c1b3ca5d4dd5af198701f5a777747e2ff03fbca64f95a7ef074d8493a6aa5a463e3086223b2b33e9324f8c48794dce6f67342be93a3a2817286fd79585a70122105f23e71fc71a68e2671dab6bdc88a20051ce5a05f1393881f78726adeef15808aa13acf0d97c09a1f882561410765dc060c7bda374463f2b67ca0e7981c2ea7cc2d15616dc707df8d93f3426c61f610307b22182724a8f935fd3ed93310476d3b4f3dec9eb93402e887e5859fb8d4914a0746689d19a8f64319e70a83871cb44692fe16912878b457cca88cae26d1316fcfe6ff7950e574ebd380c45bfe6a341fd6cedfae0d730bcd8f7bc6e43b506174845ed6fcfbf0072c94d550c7624633f096a1303059dd2602d24759974ae188eb99bcef9da676e60c89fbb1ef13c2b785025bbc99e9e3df8c01fc696104cfd79fb873ca552ea9cdd75fcdfd8ef85203b96d1d8295151645c5694f9bdf4e4a2dee5bc1e6b84de09c66d12370e32eb1268a458c8a7689e3e0cb60c7dd06b06db91e64388d4a906759b93d46bbe16a51f85a4254737b6b4d3e6e03c70a04a9dddfd1083d008a58e256b068cf46b694b2ac21aea6d36802f74961eb58133ebaaa7a124137683eb84c5ba869e5bdc31b1e027b2f3b07e3a3b503cf75a3ae5e2c529355987912044153ad769ccfc50779601db2ecf1d85e5469d71bc54255b15a6437be2689e4de6721d0b0f466abf30092d37057e1d9a9446fb9988aceced75a80ad14add2eb5b31bf8105bb59d32fc34d63fcffe32ba5edb51a9211a8ef437095906a6de363f0f1e6030c38bbbe31ffa80d392e54ce0496890cf3c4db051d11e06744b34d709442f4e4787e9f18f929c1f186d88eb4c705467bcc62e75b5e776614e39e38937c1d77a13ab175d6d8e47303ca387ab20284fb05bcbec8eb3695582f1e6fa88639026692e1f3b7726b37a6f2e3d12630cd9e6b10b6b399ba59f8e09b2cacc0a65642192319e417941c736bdbbdfe6515eaabba67bb0073d2891b1e7ae633259996d63a3e5170ad0afe0670939babe69246ec89b7d9a4693db1a32dc663f2a95436efe49cb45f265ca8e42ba7a93698341efa7975142f3f5e62daaf0799824a28ae5214704308f6d11972f5dec4396dfb1589dd906053a3701aa7300502cf0886a9dc646ce83ceab58f266163a79a23f8ba40c09da6d00e704bc476e6a23e41cfa3f1ca487c8af3d2daba89083f919b4481180d1b53a8edcf9a103dddf8b44503ce2e15d36b987c19f267d2dc5c3d3079e3de7fd36052a486e9aae3d0e855fc773293d19d7a665451b0bcede2d09b15be39a07add05f36e596cdaf644a6713e3c03c607ab2cc2cac8443cdaaa2892c4ee033a8f7cd766877e3a30e5855314a2cb5ef62349497fcf1e4e0470e201db88771de7b9c6a68894aed43c56ed2a6fc7e967f582380a39c1389dad09f69e402893c7697ebaeb65db065e745655b7b155d3b0768bcd858dd13cc1035fa3295c3411fb6b2ceb8332d58c2ec4617dcc06ea1a496f2bab1a0fe94f689aa1944a4d991532bfb9ba8daedd75afb6d3c486f067bd0bf05684e56929f26c04d1b69e50d959242940f2f0b878b7169ec7a50a5f14d04f60a08f198b4a3588f53f961965a884da6cb728a6d626b7d1f4c4010a6eb50fc4c0ab70b2ae9e81bf8661b7328b6a8a8b1cc82f53e7ea061112820fa43f70e57da8e38c67bd10c1208c1ea4143ae621bfef9a210c75079f39370fcd7af9d0a26306f356cab6c56effad1386b28044445f8450234f63f6796636298b1e750677df6216609651cb56b876aa48efb54a09cf86c5959853b2ea2fe3c2476f9fd7ef30d9656abf449e0628d3cea15eed623004c48c4f8ff9ada698e14d91557736a37bfebcb9e54876140e53bc330f0f08b353bd1ed9d3a60fca8eebee16e138e4c7d33d519a40dffb3595b0f337984ed6d4aac6a346744dbb0fcddd82003dc5b1883da2b170780604f62cb70b1d05b07d72ecd79e34c41e5aaa908bc268747303a25e84b22b264e97bf1a1087d55a33c507ef2fcafb1d0ae7b929a4a026e4349472c7281af4663306ad21c6592084fcf5f06e475903794ded6f20c2564990c48baa439e3081e1d2ae7c261f9a602337a51cfe224d2f0ff262bba244266ca36245c2f7184b9fa8f5386e779b17942fc31b5e83870b930d2080a8300ae62d47366acc32350f511b29b05ded7790cee42479383117c6e189d695a3ef0886086c293d3fd32058e291d497d54cfa7af5ded92adbea3cb2a6d94e4615b0b9dc0d0b8e024dc4a94fa1b84b42c74a3d6ca6f263b910bd5964a0ad5fbf876a5a7d8604e0aa9a4bdb1b86b7a2134fbf07c42a3586230f4a7e175e0fd5b230abaaff6a1df00e0813e4088ed1bb1cf73e22c7a2285057d201b6573d46aef351f6b6db6e818692f66904282fd0b8498a7899bcf2a29362408d6819254071ef43442ba21bc7db5d6ca83577fca1a84a65105691ac44dda557a36dee96ec59bed096d8cece73797bbd0bd0c69102c5e9694383e24bce0c2240bd326d9907ba7f4a80b1857524af66a9ab3807a5ec3abb47018e9aabc7a246224fdfce171966c4990e9dcc6a091c0953e5e6c80b22216e9f54ac91601709c2af1d676a809f5b9811a2a4ecb3814fb5190c440a68e53d46746666134a1d8a37e7e470182c1e13060dd152c9ac9efe73c718e0173a1d4c52485533fe859904288d1e521beca6153808faffcc69fca701fe2d9f500a6cce72f0afcc53beeb12e99fbbe97b882ecd344ee7903bf3d42c5b38e6cbf5e7b927a6c8c314bf75fda1e5a7339754a07213fb370e293cbbfebab6cf51c09245d3c1435a57f15383e97c5041562bd3a482d1d344ceb5bf7794a4d8ce7ed0446d58379b1304ba69657e526b52d161498bb4de7934559d4f78cf8d21b2fb2dc6f0aea205fd6d154d3ea85126645293ca06062b337d7036c40eb585102a34f5c8b9c3823e3307743361e7c2c3eaa1aef3f25ded5fd8c3e5ab8a30bdbf3dab00ddc8de6debb1257c005e529fe71c58e25b70d373d6b612d1187519c4b5ddffd6c2547cad28c718ed560956378b6f3871802105bef290c89388378df972490b1041e992ff068ed9f79d7c9c92513e0fae7ecdea64bb372b58ddc8f95984c9230c69caf3f1f974ec0cfe290a767f521ca3e084ca310594fc0d30eca877c342de4080523d2d8ec0ef78f1d58d3f21d4d7bca458474981f0bc196d8c5b310970bacd1168b2efc3bb7645a5f891ea19c24e898a9f9f92e4c3c25d979c05c58598c68756bd4922271fe0af6b123a03be781d24182bddaa848040f8f3913c3d7d427752ca7e62ca15921f5a53bcd226930be152ea09e213ef8b41c12e7d2e864d8eb4e251033bc8f8d441d6036c867f82bdb4cc2e95c9954aa8157d3d897cdcfdd5f9330acfaaf9df8d8fd292ff3fccaac7c18239d498073ead29380211391aec55d76fec911ba1378751e524d2481e4d60afe608ff2251f2319d20b9677e47874ffd0b4d8f8b304984157cb66f460a5ddbe341df7d5cc81117b7314da34d5856a54e7d787ffd7950ab9108b574c85619d0120dcc8e9856e7d4dc2fe455a75eb33ccd0544c7a6d0bf9933f2b3c62ba12c95972aee61980aaec2dd51c2a07d7b6e462c949b836e5a269a16abebacc72ed2181a77a371a494b44cdada7ebd4c1a20ee03edd5fe56d0fb9c0353bbfcbdc85a5b3bdf42c3a5339fd11f5a0b684ce3073f6ab7b919255c3389392acf4d8981be9ea4fdb81bd3a25be9301e2fe9a10792f4f1260a5a9441552c16306914bc51a4c2a616518eef90f06ec6a2f477ecd33a67461a8525ba04898b3cd474616e447152b3bc785832b10c4acf83c5d49762e47c93fa70bf2961af152fc4116be2040f2ec6981f9781a1b0b65a05c4f5a538df7c1b58130634dd7a37110fac2c1e072dbcf08db0a1c3cce32241da017191cef0eda2a8f9baf864b4edf8259d1f775370d7121beb88c76b6aef13f12da7c086f823eb5e0da17dc50b1dba86c23534d4bd0785c45fbbec4ffe12dd1baeef159737a2cc3cc93abe0244bc15c58045ca8cde378557cc436f7ca25a089382b0d5d5d1ca8709eac050ca6afaa0ecb9ccd1a07bd30e94e5919e87661319700a9a9467b95952ead98fd5da605b03f01082103bec3dafa8f7915886bbfa926cb49e31b9926d90eab0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA11600 Masud Rana 题解</title>
    <link href="/2022/uva11600-solution/"/>
    <url>/2022/uva11600-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>不经过有怪物的边到达的点，他们对答案产生的贡献是相同的。所以把能够不经过有怪物的边到达的点集分别缩成一个点。</p><p>问题就转化为了，期望走多少次，才能遍历缩点后的图。</p><span id="more"></span><p>设 <span class="math inline">\(f(S)\)</span> 为当前经过的点集为 <spanclass="math inline">\(S\)</span> 时，还需要的最小期望次数。</p><p>设当前集合 <span class="math inline">\(S\)</span> 中共有 <spanclass="math inline">\(sz_S\)</span> 个原图的点，点 <spanclass="math inline">\(j\)</span> 中有 <spanclass="math inline">\(sz_j\)</span> 个原图的点。称为这个点的大小。 <spanclass="math display">\[f(S) = \frac{sz_S-1}{n-1} \cdot \Big( f(S)+1 \Big) + \sum_{j \notin S}{\frac{sz_j}{n-1} \cdot \Big( f(S \cup \{j\}) + 1} \Big)\]</span> 选到 <span class="math inline">\(S\)</span> 内的点，概率为<spanclass="math inline">\(\frac{sz_S-1}{n-1}\)</span>，注意不能选到自己所在的点。那么就要在<span class="math inline">\(S\)</span> 里面多留一天，权值为 <spanclass="math inline">\(f(S)+1\)</span>。选到 <spanclass="math inline">\(S\)</span> 外的点 <spanclass="math inline">\(j\)</span>，由于点的大小不同，所以概率也不同，进而权值也不同。选到哪个点就将它加入集合中并呆上一天。</p><p>显然求不出来这个式子，化简。</p><p>令 <span class="math inline">\(P = \frac{sz_S-1}{n-1}\)</span>，<spanclass="math inline">\(p_j = \frac{sz_j}{n-1}\)</span>。</p><p>则 <span class="math display">\[f(S) = P \cdot \Big( f(S)+1 \Big) + \sum_{j \notin S} {p_j \cdot \Big(f(S \cup \{j\}) + 1} \Big)\]</span> <span class="math display">\[f(S) \cdot (1-P) = P + \sum_{j \notin S} {p_j \cdot \Big( f(S \cup\{j\}) + 1} \Big)\]</span></p><p><span class="math display">\[f(S) = \frac{ P + (n-sz_S) + \sum_{j \notin S} f(S \cup \{ j \}) } {1-P}\]</span></p><p>代入，得 <span class="math display">\[f(S) = \frac{n-1}{n-sz_S} + \sum_{j \notin S} { f(S \cup \{j\}) \cdot\frac{sz_j}{n-sz_s}}\]</span>转移是显式的拓扑序，可以记忆化搜索。但由于是无向图，所以不必考虑边的问题。答案是<span class="math inline">\(f(1)\)</span>。</p><p>复杂度 <span class="math inline">\(O(2^n)\)</span>，状态数量有 <spanclass="math inline">\(2^n\)</span> 个，数组开不下，可以用 map 存。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">35</span>;<span class="hljs-keyword">int</span> t, _, n, m, num, sz[N];<span class="hljs-comment">// num 缩点后点的个数，sz[i]缩点后第i个点的大小</span><span class="hljs-keyword">bool</span> v[N];vector&lt;<span class="hljs-keyword">int</span>&gt; w[N];<span class="hljs-comment">// 存没有怪物的边</span>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">double</span>&gt; f;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> sz=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;w[x].<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">int</span> y=w[x][i];<span class="hljs-keyword">if</span>(!v[y]) sz+=<span class="hljs-built_in">dfs</span>(y);&#125;<span class="hljs-keyword">return</span> sz;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<span class="hljs-keyword">if</span>(f[s]&gt;<span class="hljs-number">1e-9</span>) <span class="hljs-keyword">return</span> f[s];    <span class="hljs-comment">// 注意精度</span><span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;++i) <span class="hljs-keyword">if</span>(s&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) tot+=sz[i];    <span class="hljs-comment">// tot 集合s的节点个数</span><span class="hljs-keyword">if</span>(tot==n) <span class="hljs-keyword">return</span> f[s]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 已经遍历完整张图</span>f[s]=(n<span class="hljs-number">-1</span>)*<span class="hljs-number">1.0</span>/(n-tot);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;++i) <span class="hljs-keyword">if</span>(!(s&amp;(<span class="hljs-number">1</span>&lt;&lt;i))) &#123;f[s]+=<span class="hljs-built_in">dp</span>(s|(<span class="hljs-number">1</span>&lt;&lt;i))*sz[i]*<span class="hljs-number">1.0</span>/(n-tot);&#125;<span class="hljs-keyword">return</span> f[s];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;num=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);f.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) v[i]=sz[i]=<span class="hljs-number">0</span>, w[i].<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x, y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);w[x].<span class="hljs-built_in">pb</span>(y), w[y].<span class="hljs-built_in">pb</span>(x);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) sz[num++]=<span class="hljs-built_in">dfs</span>(i);    <span class="hljs-comment">// 预处理，缩点</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %lf\n&quot;</span>,++_,<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t); <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">sol</span>(); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「琐记」#1</title>
    <link href="/2022/yume-1/"/>
    <url>/2022/yume-1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be22c1a5c585dcb26b8ec8b55591c46330de9c6118b187630c3605c7f47e251e">5f1974e893b1a46ef420506509a2e5352193b1f47bdcef512568a83833fe437c18cc82d09d471d340d3cdd7b7111071b576a3a006d12cc9e0abb7aa483c7da5d2f0c8f11ed7127f48ddd2ec40fd006e821a372ef1e974987adc88515c505b836e9b90785a3565ce77323fa4661ba84230771ae20b2165bab8e0a104be69e5ee6237ce2e564012a2b8b04c38890deb17bdc32730675f244882a809cd602f106483c9bc4955cf426142742d3791a4369f11e1873d6307c0b90641ee7be7a504ee0524c9bd0f27f1c4551c160b41869a9912794ecbc4978e2d5ab9ac58deb15649bb1eec69787a74aa1e4b8b7d8451449169d2f9f9ec4dfdbd293d446c1d393cb16a8fb76ffa852bed25663ff6c02315cc0fddedcde366af0bb340ef62bc4bcd8dc95527c96c7107a2c106ee7e2ef15e44ecdaf405bd6eb2ba7862f2be3fd440751e29c512ac8cae40a8d6552fc2d0d18a573aa9656a41c7fb5795a4fa9cfe92f080bc87d43153b64494fe1a686c33af520c7e409fd7f76f6770577aa1f8c8d950939306754540b422ef07ea86a4f138d8d83c3a34e591c6f4db0a90c27fcfe5d4ded24aed4292f239493fc934f55781fba4b7086e3f0bc2fa21c2438c6848246e7e9dc1484dbfe793c3f371efec099b2e5937b3b4493d9bda3265b90908081e1ea3d655f2aba77398ff76773129f67463aa1d2bb8b842267fdc57990c66470d1f076c4f081e00bf75c6848e559efdc7b8c526b7a4723030a49b11da134996aa6f15284a6e456d5823ac9b16eb5c1f39964b6f346f13f785bfdf9dba654141507ec6855a09f2f77bd29d65dc964d03a0f32a90f95e09ce731aabec05d4f0c5b53a6061223ba4426bdddad437df28e37c7c820d0ed0b487688c233d0f03f13e73a17d0d36dc5c1f9fa3d442ebf7fa8a4521c8f099c2c7855524dffacef47e5e7953ea4ea0d7ab4bd3deb450a22da8ff19d42e2666bad173ab4333e835efee99502c251f0827b351f89c1b6aa8fb5f22b5dfb3e42746ad6607fcb1f7a8f444422f49a9200d7a61b0d003c59715d10261c36f36863682aee3fb3b94357cb30a55e35c5cc28dd563c4122dc748528a88dec7a506b75e01793e8380be8f93b703dc25cd4e95cd1fb025086173946bfce9e46c5a5d0bdfa4864cb5f82b5db863854c6c265ef9daa007c35adbd2c2cb4f4645506c14737df97a98dd1f21cdc48b7cfa2a219ada3f022c536ece44f1f77abe6ea309eddcfea38b8c06a3d3ea6d401e8152899cdc107918ebe7af80c8d40b735f3f9c44fdbd795fb65c7b7865430f016328a35153127b625a59140e50a53d50ec9780895e9fd27940d22f47fc79a53b44cb32062f9d8b152a8a8c6a6e32c0caee61301823b1acaad2316928624c802d871fea9ae28ccfa6536abdb74cb765173a12356203d5976136d3fa8613191cdbbffafc9e4ac753ce05a3005c02d3b71e5cbc3ad118e5f9281e15c414864845201ac3b58eda9b46b27d4fe61c729704dc03320bd0b73a8ae55646ff917398c266a63db1005bdd354aae9600eafb42664ce3078788ad93cb0725f3ff41d3b2deab34d323695a314fa992bdfe556fef17f91f056baed3931c4cf140ea2d47d9501a2a9be0e6bd5b536d189d5aa8f21e4166c6c7de6e25f83ab16e1b8c4d12d72d10cb3a069a023c739d2087d3318951a045cca719a72b9858e550c1a60b7b221045cbe2522b8b0c0eda25e5f358ed83c60034d6029bac7f6ee70fa5323e98b7ece5016c585b6978d296b12c3bfea2df0b2e48adcab7962df37a49e314f298a64e236bd9840502d6b29648c7124355ef38935c75eaa78b62004a86b447f7b9e44dc9d6c45ba002a5bdbb05698a028a1ffaf7784f32cbd4d8d5ea7e3bd29996b2b80a409e084fd4075d337a91b45c5fe2c698a5d697e511bb1a9ee83ea883373fe83e4369928a7daa483cb8d3e857f29510129d749128baa3bf9146c536277bc72fa92925fa172d01a9ca6436909b2532e4f07395534f5fda32a237349823c7ad524299dc4bbfe6da0a667a0b797ec8cad1345b7ae00fc8c422c400362161f8776cc66cb5e37f7f0e127c345057d1e5722b32d6e135e2e4724c6f23befeb50be9da527826a7fcaca41757fcbfd42c3cfad26b50309d335a3795d781d846b58d83aaea182db98da27ad9cafebb05450da7b568641cc9cc8f758245664f816a10bec52f0715a205885af7b959ec75c5ce94716d06442ddd2eb14bbb87dc0298c1f65d0f5b8c7c21ec5ed9d438efa1fe5b30086d23a93868f3d0c0568ef218cc5032408d1d72f80709df598273890501fd74252cf24360c1899505e5aac2696491c538ff43f3e3537870842abb1332c07814c0a6ac5ed4795395907955a19c70bc7a8e3e103ef6e505090dd5b9187471e368a1c4a606e4436e976cb68d6b63ee3450ed9f6cbbe3715a552f71e651a9e6189cdf3cd7fa4fb22255a6b73d363e32b2e9bb8e40a3e6bfba0a5672a4de8303ea5f17a36ef16ff9ac9ffca1467541872c0d9861b4e58931c78e92cf2af65f4d676d6d1407b9d6e9fe969aa118303b1e34eaee47596e005020673bf85eee056b31c9bf6ec347a9f6cf3b5f46f496bad4384967976bc1fa6edb625d8cc593f524ed18d377afcad235f13c639ceafaa9e9d8518419ba39020a6087b8fdca765e6f8b58087a553176473fc4b6d5058bffe5dba6408bc343016c1553a3abf22ae6b097e715bd5b7b1bac4b101c3a8e9d176fa396117127f7085686a9c506242a2afc85e196aba97454fdb705d3cbbdd9b3ab577cb309981d56735216e3028320c2cfaeb9b190abea37beabd1083f9e82400b1f553b2b4f6dcb816964ae1353654dcff6425104837c70a6eb9a1223025a2854633329fa02ff4b092c2dff71456f14f339e520b3aef3f760c1afdf19b0190bb20ba4aef54085ab925294908fdbf250e4ac53a6c826eddb5a3c95c91c808926e25b8acd5d38ffc208c7fd09cb98641f023ec02d46df09da8f199c10b5a1973f9e5fb5087998046fa246a57ae3ee110db5231628c8ab77127ca8da8599fc73d574b9f2f5de1eb6f784c81253272689fc0f724d82a32d41852859cdc745a1e8c82a9776e14d5b973ba838946fd5fb78b1031b278526ba813eb3b0ddd7fbbb6a7250e0a9af20581625bf0eb9ca4582a56542210bd4cacecaffe6fd3fa31897e07bcf1e6c33583e6a67f697d2cee4e42038b8a9361e4dffaafd4e976f242f4fb8ece66fec23bda90c1587bf3d8530dfdb97b4c260a9e75247e2678f5924eea16e7ba0aa8dc0df5704a43e2ba4d82146f89083838d329f80f98462e8da77b503d38cf62fb13d5b315166835f95ff256e76bca265ea480dffaaa6cf297763061d12032b81565a357d8d16d38720b63897d65fc800a4013ac2bcc36159a97b1b7d09ad40d2cf9818bc52cd32438e831f8fd8a01a60aefa05a7bc3e0ec17b91cf0e492fca5dc6b1ceac58f42cc4f0c0e028a25c54787073b811278e5fb3cf1504761223055922e5cf0eb10ec247fbce3fbb339635224812696e4375fc26ee722c7f3d93b69a5f3cb4eeade98115d6d047a3f39fbd86f552ff2c9f7921eceead976dddbab1da1bc9f78b76721d99946a0f27fe94acffdad0b59a843f755c959806ac0dd6a85eea9805f60a0a2ed1b7b6922189b81cf376fc5c9a79a3db286dbc8715a4e9fb07ab154b47772a5e255e8976a525012a039c991e0fcb896e1ee823087fb51bddae16e4abeac619b1c8c039211198149e01d680da44a836bf67e4820054a1223b0baf2122362b085e1978a93bb891c1ec98240876cbd30b14915dfb4613c9416d0bb8d0739ce70424a5a8bae2369523261769fae239a65b5a831db40934d221061896618d302da9a521e84b12f8268e6e13d8047d8cab60824614729ccd70e0e93982cb9adf0d83bec593ee61f7e389c50ef336180909c0ca168af29ff5ddb788b3e3ad93b90f6d7de43cb353340c8622befcafc2199d4cc1168f52ff0459d4f833241243d6923efabf0ffec181f16106806e6edea31946e912c0a361050c01f206cbf6206efc865ff978d9e2683de9fcb69d709326f98c5de3abdd68fbe3073f00c5272b1ee28bf02d18b60aaa3d22bc7b54ce8c78cd337a86e6f03263b41e2e5cc48818b8e009a1c3942a198e6c0e771fc8d3f8a75fd23170a02bfff3d29fb89318a7f48911ab9dad9ac257e46025d07f252e6c78aa8c6a4fc09ee3a675c7119b728fa0f99479f0d5ebd9153cddde4b5ee5942bbb86b868e56a32fb09b08ae0f361f36509dd6945ce04a3fcd810990ca830178f98f737e4874b4ccf7a18f3fb3d07a65579a6f470b0f861bfb94c4814dd1ae4b98cae290dfd6fb1474ace4d968a68b13dedc7c3575cf7bccd7021a3e0c30c57d4538fbee1a8e240a934677f2c6bef6f2e1e645b239e1f3703c6b896218a38f9de1314cebc1315bc38f2adc21c6fcee9f8d3daf45c58844622248c03f508884c2d83a35f184cb2042cfe1733e6bbbe9ff913b93a8f567e40d59c3e01d64cee4a0310f8b57ed6f744a0d22f7138e4f927104de7018225ecb7f2aa24abbdb02f3d807becbe28f579e1064555a4ecba67fe232b8085767b103a2d06ec6b88ccf45fc98b5915cd98e32be7cf805fde13711208df7bc92d6b6391761a6683c7061b7bc6fb1191b12a96d8ccda41dcd60cb028636df2b98948bd89c3132daf19f0477659e33ef24e8cd0675cdd4d7d6cd2483770771a5aed7f48865b14e5da3875f806f2c7ace9b42bed8cf9f3c72d20983da65702c7af5a43e6cdbee3d2004cdbfa65aa5ade2e75be06105f24129f55f820f4dd109ceda31f3daeb5683abdb6c5b1b910ecaa94991909c52abf0c208b94761448bf063fe87487a515bd43db1a9411486305b0f755a129a80ed100e85c542356629b4327d5c20dc243d4aadc8c7512befebe29005422c8412f2ed7d1207bc5c8aeea853f9adcaf5afdb9892377bda75c0ddeb1640afe43a647eaecfbbb36bf965d84e66a1881ab57f8ea166dc45c9c995bc792ec6ead3528b3d113aa0529a13b24163ba6bb6d8f3febddd2aa4fdf4cd65d9fad9fe00c86fa0546e2075e1af35c8549f24d7e7eb81283bc9280f5e7e70e987323f0ecaf02ccaa6a5e7ec2e315d0488390bb47d2664f68cd3761675b783660e25691592bddd5e0cf38b654c30d5a4e29572f2c5757290f43509d18fd6871207653011726d84178705735405bfd611012e25951e81eb1bbb1ec7c77706e80c2eccd91f84f9996368cae57823348300e5092c734f3c775632d7f18361a76d34e7e5d9a46c7f451a15004cf6bc526221b38ffc612a334212a1953566980fb99bf7291542c14938328a78a8dfc25edef2f42b73829a23192468feb3cf1cd1a2c0f85b4b70dbbbf17cf069a433482003712536875deeecad0da2008ff749d0425e0d3ffa418d5af96789a78a4250d6b223e659b2214362eff457400a7af76e8e581cb305f6a3be1f3f60d14cac9c08cfa2297d4d42ac093680a078b3489a2904ad642673c1a991d668d39bd59c9dbeed5a82f12804068f322b82e97f5ede08ced7546e12b182d12a46dce5ff29947117b5bc085c89a571c9fa5858568a01c8b427e3c28145ec3e91788fcd08c7fccbf698ad061253195375853b123e3eaadff518f6c7fa31c6fcf13998e2a41a04dae3a7fe9930d8810cb8a84aadb785a1a4439c3aa1ab9638bce68baf6a694b4ced2656fc8a17ff902ce39182f9053a7e844b87d810862d85d098f44e8442b2c51f8d5be02774fdf2a81f218cebacc4267c66afc0600f98cf7d2b9f5ba884f104549798302459a4b105b78c7e03f440d373e0c00750104eb4eef9ae2060e6ddf545ec18bd4a2cf21b7080cd762e76d16dc0ce7fe98869ccba20cb07e2114fbe877567789c940dc3700df056b31b52f8245c7e90125852613b1cebbaa8cb58a15120f3d1df7d92264ae5760e499b699106831cca3189df4d4458f31abb937c812ea2d6ddea8b7afc3b74eb105d563b736ca72e69875412043b98cf98b59f711815c1cec09a71907e02683c27731bb6aeefbf22a9922bca3b9c54d0eb17f0b09d45a1217520d468f73b3e7d055c38b03a293cd428a43907c7ad03ff3801d94d46ed3fce652053284418e0c8c2b41f5c8dfb9f8a8ff3138ed3c955008c32cc2e7644bd3d05c10c8219f3a3e8e221565d516a30adc8247d72a2c9d49daf98f6d7e0399d327a5611fdeffa6866e1bb359de40d303ab6c68e7a5ce944137655a5b54ee3dfcbc11dd0bdcac876d32f35fe7270816f91de7f364c0bc525d556f6fe1d6e4859ea02e6e86dc3c2f4e3018e3363fc37ae5e015fd6dbff5c7b6a415aab89921694b7fae2fe9910605c443dac5bdb8f87c2274d1e862271d0ad7706fd3ccdd911486a9af031d8e3e9a92eaad375beab376d60bb3836297ae876db7ef30c4bd32f55f31a2aa29aabc145ebc514e0d31924cc24a9e18ddfdd1e8da79b37de48794970dea19eba105082a9e94a08ade867df215370f2311e4d7bb98b822e2a0368cc5270ccb99954b2e9d00d4982c55d7be2278911a1fd437ffb15e9461a0b3f35ab82fadb75acf0127f8c52b22669e87d7a6bb6ebc2f91e4855497d73d2e72b774f5c520fc7bc611f3c8b47eb639b8261a0feb60c9f9b4f4bf3cc7f2c0e24cd891a2ab4de28fb8d4e6af85938b5b59cfe7ced24d5fd6c470c28fdba55ea730b7418603681bb55329b1e52f6a08e0e8f539878837aaa1eb71df2911bb46357f0ceab024cd05af8db2620394acedd63cc24bacc2bca456e8bcbd8218015bf545d5f90281fa9cfca899decfbedc6ba3d53d3074a2af1f9a214dd953e8b3a13de9b8de2a808af16079eab5f0da666acf1ed3f387fa35d5ecee0069726771d8610b487f6b80f64c431d1444ba1bf24bfa5b05c466c189a54d612055c6acadd55c1a3eaa22715bc3a4d3d9f603d0c55488bce9ab6b0d68b6cf43542d2c2a8fdf4f208aef76fb1b1b516171f3d5eb3645a6cd44c51150d074d9b03dd65d27be8b16bc4e908cadd6c06b569af8914a22bac93ad26169f17fce6faa7ca0f7e6ab67ef6084d92dc0fb45fa34e0186b9ff0532b687e118a696ce1a8fd5c5e14e3ba155c3b915a681f8be4a2564acd60a80385196b5d2ba24ecc1979facf7201f2e2fb344e6bbf89d630d69581c6063b7075c4801d2a1693a14191ed4938d3c6c94edbd1a7d7c590da0c2b2b937fd82d910c96901e5ab18362b87aab576b216eed3fbddd928832842e1440a2713a81ee729ba25aebe8e5452da38728c733ed6c467746ff35f1252ca2055b7e7fdbf7748926034a25b388cff34f2219b21ae494350cd41f6b62ae27a96f3d8e3466892d03037d0c1e0e507997f062a55be25d9b139a014e43626f815a0763f8c60ee896e4a5115b5c1975ec85a1a37442dc49ba3712198ddd0116d3c134a489e1e1f4a450562ab7aad05a1c068373e6ba16780aad1a291e1f04ee5a28335a5fac4e0924ef33a8da1baf07b5b035256f70525f18a124b2e1e62da5d25dc600382494163a3d1df5757f53363be10fa967d5602ee7224d8b718163f15adcdfcd7a3fbce0928efc145813cf825ccf48d95d020a031cb6a58087971a836fd1ebff029485263b486524cd3b133ae37e77f5385369abf315362e5b69b17a0388ad0ec0fff0e6080d96f058c8e86b714c4e5aabdb9227aa580ab986c078bdfbec54ac83f5268b5e2030f9d0b43350b542dc2ddc9721f875fe751efab8958253f5dbb04648120bfb16b67c32e4e548cafa8ab0832d5bedc28fc9f5c4653bd5b1a3e3ff92e39975735bc05266fcb338083ee31ce04dc1e8ce9f1996949f920320cd2473ab9223e4bc05e8eea6f630809b48df61933fa819dfb09152c769ac4b0edafc3c552bce60141d28d9f2df8bd496a86f5cdf26760f1ff14295ba4e773b6eafa821baddf1ef56994adad377530c73e6fe6fb1b16d05809696995fb32ad96477ac3e1e95ff11f04a0b0d6d39b5705da925e6f92f56248d36505a5cad697cb500e7560ddeaf88e6486a3a801b1da065fa0dfc73c54a212ef39bbbd11e04fbb4914cab4857389185c660324536296b22ad2ca287d9cb6bf47a0cef4e9ea4145ddd6ce6b89999da9c6c3af1b9682fd0a25d69c9f7a208f3da9b4df1d0d55397e0663c67848af14c0f303cdaa4b26e0163ae61377ab15fdb403ef7f5a6233fb68efde255b00bb254ad32bd55a73018303f5221a5cc0ba4e9ea8cdd01c9d24cb801ee6fa32c560c42bb624e793b3a813286fa1c31f0de20c9e73b01bdd863bff8fcbafeed546296fcf916874e92c2551c8ce6131f0e964cf19845e6017103ccc612a5128832e3c0fc7bc07784838e8f215f7335747a33f0bb3d6f915c2be1829a1185bd6db1a6b295f45f8643b74e6fdc261925140797cf966c5ae811fb101ede6bf2640e888e1c8fbc9143a7a1a8877546e68415c3a985da589858d70bb769353ce6cc2d33fdfb32c70558817e9c7c038f812d83b560ce9a0e7ea31eb092ad5675a2e12822283e6c2e43a8ace4bd7a988a983a23b16e528fdfa5d3993ddcb271f67e9e15a1f3fde510fa97e5cc94eb7d109a3e4732bf068ffddeba7db56052b4306526b635f2a5298b55ca800cc134fd075381ac07b0950222f88687b7e2fa3ba427091dc96dedcc70870fabf15438ad6ab782ca402d4f8d94a56b0bb6bc2a265482c7651269e163b4b98596e336bbc6b6809a3a53314de1e266c1e1002d03b6b02ec8e88d387bcbe48eb58f1af992b92c8727f826e30436eb4441ef123cdb8e27593507d9c89d614ced258d74b5adbad6adcd387387be7039c9f08061428d10d6bb3b85d38bafd37e8f9beebaea68daeeff213854f974a6262e7c21d6f65ac17b2c468da219fd7801025dd35a57ed02a35ed9bd68b48312d916988f44c854285bfe416dd1f2d3210bb2912bf63f1ace96f83b78623f1863d73104e3f14ba540283bce643b2176e35ece024bc7b01dc72b958815fbe04197d8246c777926730153e514f18189cf7862c7865aea590daf4536c41da2f1098fd9981c27381c52c6d5a8160073168b962279c4fbdafc8d75d988b1c8267fd60351c34c52baba1272734891c062a32218ced2bbd72f7b261216161ea39445c2102148702d3cd251e1eae0654bf16d369c07c888b0eda1bb002f34579baeab201095780c9d510f9b8ec63f5e15d52abd0034e00d7cdffe8c21a900a04237fbabc6a0af9ed3c3a3b55b4848864adbb7b17b8a3240f11640051bf1ea01b0a04a4c3a1f863fe2df7f15c2134b9edb5f38350b2235c84f2ca1cba02472ae81d5f5d1d0696a1aca29714031e0aa5ba096aced94f3df460957855d8f028cb4aeeb43c0371189ae23dfccbc5a58791ac8e26261966c2e452f65de357afea6cbdc3d9c03479f782ebed4130ce009dab213241f96602562be04bdd14251d532ed9ff8e9bf2631a2a14762bfb3d15abf0bec9c1dd08a83329d30a4d054ee4c77fc16aca7b44cfd63d67fff3abc5f33ac81ff01681d4c6d43e995331176d511fcf4bb37756185c4e06a68c06da329cefc2221b9f77de5a3f136bcfccd242941c079ff7b8c178a2115e5d21bbef8c4f7048fcdd9db6f98616b40cb93140952256eeee3fccd60e033b6b5df49db915646fe923a189f3f4d6142adb6dcb707280b1966543d8193eb6c507f5d1585295f8d708d4fd86d5485e7eb57a280a0318f47d13d2c691356488fc914d279e253c423c4c49eef7c968ae9436fc86e7c4694989feb6804049415afa9ae54c5b11c2df1907722e0c8efe84fa637013be8875a98f634c84ab17de06bfb45f87439321007af9a46c38ec0f6c11bf9202f6bfc2726ed2801de1e2034455048fad324dbbf55100b2e18b5b17a2d1cfdec4abe8d3b4a90751c2186d18c1be8dd84eb220d487223bdb5ae6d4b17e05a5419be6f8deb94fa894bfbcc95b16e086b0fe0d1680dd0ce70ba0d73e337fe07dd5e9a85be7be33c3df4bd174a609515da06124661887376943a55ac5ccc1525566160b6522eb08af8c97b9c7901308d49c182daaf0c5a9aab077979b13df5bb9ee6a108ad543219915b4915ca1d5c378187e83f04dff6df46a3b68425afb0afac3df36420d70d8215fae51baee6ca38c0e57b2780103bb8a9a693fa061ae2d361905d7f7b19c584c6266cf4316962e4aabdacda5c4357815da3819ac7446316766d88d71a7c4fb218113340be7a76baa3929bcbed44e88bf0f15ae445ebf7a4b71695ca9239d6be852d1126ce13dc80db313dc9372a37932ba1a1e448472b948c93cc2841d4aa11d0a954e0ce6f375bdd3791fe989983ccf73c49f6cacd4b10635602b8feff8fc8bbd799f07383de31e741ffded83860d5eabd2e50ca113fcbce81a3b3661b93a88250f141b043f61f5c82b734bab1eb14da7a928f75e230a39babc5752f1c7a407da0295d02a764d9f64678c8a86264cd96c6eec5edddd6ff4c62a465adcd266c22eb068dc3a8c038544e924f1cee7497005941c0a78be4f6f97ee387647a6e8358877ba724df41c77a32e1cf8d5e22482173524da65e8c59613ae7b1b36e153c95c47aff9486903b33c249ca6e48b173024d4f206b32750fb2206237250eea615ff7080322598c00aa65e61d2ba85634a5b8fcbf803ce3ea3d27b2c8cc449a869b9ec4e5844dae2fd211af3e320e559291749c8bb51bdf7562e35abf313ab4a8695448d6dbc413325fc7c953b5bf6e189f300179daeac8e229cc51aab3f655bfb3a467678d7058f782efa8f75c244821a3a07e63726b7838811946c1d4f30bcde3512a927a56b62e5191919f2c6ecaf67e57d6cf09ed93c69c351a1509747987383af3a6650e6d2bd0f68abb81b4b51fc528553f79796931867b09b0983efda188e2cffd5d07408e84d55da9a5c69bff58dbc0200b45f42cfcc05ce2f961a891580385731ec2758dfcceaa25784b3ef9403de6ca44ff8c6b2b1b666b5ed9d64fa4ae63a41dfdd09b80948a7c1f13e7e52c14abd75d91c7e0f97ae50fc0eac3797c284e4e3c4a83470ab4ffdc57c7415d60d4c940ff53bc28cdc05b4f840702d6b06937998df7c3c1256e93b8b0735d309e1a73e7f9d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>琐记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA11762 Race to 1 题解</title>
    <link href="/2022/uva11762-solution/"/>
    <url>/2022/uva11762-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>设 <span class="math inline">\(f(x)\)</span> 为 <spanclass="math inline">\(x\)</span> 变成 1 需要的最小期望次数。</p><p>对于 <span class="math inline">\(x\)</span> 选到的质数 <spanclass="math inline">\(y\)</span>，只有两种决策：</p><ol type="1"><li><span class="math inline">\(y \mid x\)</span>，那么转移到 <spanclass="math inline">\(f(\frac{x}{y})\)</span>。</li><li><span class="math inline">\(y \nmid x\)</span>，那么有转移到 <spanclass="math inline">\(f(x)\)</span>。</li></ol><span id="more"></span><p><del>是一张有向有自环的图</del>。</p><p>所以设 <span class="math inline">\(P_x\)</span> 为 <spanclass="math inline">\(x\)</span> 的质约数集合，<spanclass="math inline">\(p(x)\)</span> 为小于 <spanclass="math inline">\(x\)</span> 的质数个数，其中有 <spanclass="math inline">\(g(x)\)</span> 个 <spanclass="math inline">\(x\)</span> 的约数。</p><p>由全期望公式得到转移 <span class="math display">\[f(x) = 1 + f(x) \cdot (1-\frac{g(x)}{p(x)}) + \sum _{y \in P_x} {f(\frac{x}{y}) \cdot \frac{1}{p(x)} }\]</span> 1 表示要变化 <span class="math inline">\(x\)</span>一次，第二项是要转移到 <span class="math inline">\(f(x)\)</span>的概率乘相应的期望，第三项是转移到 <spanclass="math inline">\(x\)</span>的不同约数，分别乘它们的概率，最后加起来。这三项的和就是答案。</p><p>但是实际用记忆化搜索实现时容易死循环，要化简它。</p><p>展开它 <span class="math display">\[f(x) = 1 + f(x) \cdot 1-\frac{f(x)g(x)}{p(x)} +  \frac{\sum _{y \in P_x}{ f(\frac{x}{y})}} {p(x)}\]</span> 移项 <span class="math display">\[\frac{f(x)g(x)}{p(x)} = 1 + \frac{\sum _{y \in P_x} { f(\frac{x}{y})}}{p(x)}\]</span> 同乘 <span class="math inline">\(p(x)\)</span>，再移项 <spanclass="math display">\[f(x) = \frac{\sum _{y \in P_x} { f(\frac{x}{y})} + p(x)} {g(x)}\]</span> 这样就可以记忆化搜索了。</p><p>注意要预处理范围内的所有质数。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t, _, l, n, pr[N];<span class="hljs-keyword">double</span> f[N];<span class="hljs-keyword">bool</span> v[N], vis[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">primes</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e6</span>;++i) &#123;<span class="hljs-keyword">if</span>(!v[i]) pr[++l]=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=l&amp;&amp;i*pr[j]&lt;=<span class="hljs-number">1e6</span>;++j) &#123;v[i*pr[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(!(i%pr[j])) <span class="hljs-keyword">break</span>;&#125;&#125;    <span class="hljs-comment">// 线性筛预处理[1,10^6]之间的质数</span>&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(vis[x]) <span class="hljs-keyword">return</span> f[x];    <span class="hljs-comment">// vis[]与f[]不必清空，因为对于同样的x，对应的f[x]肯定是一样的</span>    <span class="hljs-comment">// 相当于“跨数据记忆化”</span>vis[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> g=<span class="hljs-number">0</span>, p=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=l&amp;&amp;pr[i]&lt;=x;++i) &#123;++p;<span class="hljs-keyword">if</span>(!(x%pr[i])) ++g, f[x]+=<span class="hljs-built_in">dp</span>(x/pr[i]);&#125;<span class="hljs-keyword">return</span> f[x]=(f[x]+p)/g;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %.10lf\n&quot;</span>,++_,<span class="hljs-built_in">dp</span>(n));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">primes</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">sol</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA10529 Dumb Bones 题解</title>
    <link href="/2022/uva10529-solution/"/>
    <url>/2022/uva10529-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>由于只要区间长度相同，它们的期望是一样的，所以只要记录区间长度即可。</p><p>设 <span class="math inline">\(f(i)\)</span> 为放 <spanclass="math inline">\(i\)</span> 个骨牌的期望次数。</p><span id="more"></span><p>有一个定理：对于事件 <span class="math inline">\(A\)</span>，有 <spanclass="math inline">\(P(A)=p\)</span>，那么发生 <spanclass="math inline">\(A\)</span> 的期望次数 <spanclass="math inline">\(E(A)= \frac{1}{p}\)</span>。</p><p>对于一张骨牌 <spanclass="math inline">\(i\)</span>，它既不左倒，也不右倒的概率为 <spanclass="math inline">\(\frac{1-pl-pr}{1}\)</span>，那么期望次数就是 <spanclass="math inline">\(\frac{1}{1-pl-pr}\)</span>。所以之前的期望次数为<span class="math inline">\(\frac{1}{1-pl-pr} -1 =\frac{pl+pr}{1-pl-pr}\)</span>。</p><p>那么往左倒和往右倒的期望次数分别为 <spanclass="math inline">\(\frac{pl}{1-pl-pr}\)</span>，<spanclass="math inline">\(\frac{pr}{1-pl-pr}\)</span>。</p><p>但是这样还没完，如果倒了，那么就要把倒下的那些重新放置起来。设倒下为<span class="math inline">\(A\)</span>，重新放置为 <spanclass="math inline">\(B\)</span>，这两件事是要同时发生的，所以它们的总期望<span class="math inline">\(E(A \cap B) = E(A) \cdotE(B)\)</span>。具体就是上面两个式子分别乘上对应骨牌个数的期望值。</p><p>最后该怎么办？倒或不倒是互相独立的事件，所以它们的总期望是它们的和。设<span class="math inline">\(A,B,C\)</span>分别为向左倒，向右倒，不倒，那么 <span class="math inline">\(E(A \cup B\cup C) = E(A) + E(B) + E(C)\)</span>。</p><p>对于一个 <span class="math inline">\(f(i)\)</span>，尝试所有 <spanclass="math inline">\(j \in[1,i]\)</span>，把最后一个骨牌放在这个位置，计算出三种状态的期望并求和。这样就有了状态转移方程<span class="math display">\[f(i) = \frac{pl}{1-pl-pr} \cdot f(j-1) + \frac{pr}{1-pl-pr} \cdot f(i-j)+ \frac{1}{1-pl-pr}\]</span> 复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="优化">优化</h2><p>warning：本人数学水平有限，无法提供严格证明，千万不要较真，如果看不明白就去看别人的吧w，欢迎指出错误。</p><p>不难发现，在枚举 <span class="math inline">\(j\)</span>的时候，方程第一项单调增，第二项单调减，第三项为常数，那么它一定是单峰的。<del>感性理解</del>，还是凹函数，有最小值。并且在有用的区间内，<spanclass="math inline">\(f\)</span> 单调增。</p><p>由于 <span class="math inline">\(i\)</span> 是不断增大的，那么当<span class="math inline">\(f(i)\)</span> 与 <spanclass="math inline">\(f(i+1)\)</span> 选择同一个 <spanclass="math inline">\(j\)</span> 时，它们只有第二项不同，且 <spanclass="math inline">\(i+1-j&gt;i-j\)</span>，所以 <spanclass="math inline">\(f(i+1-j)&gt;f(i-j)\)</span>。</p><p>这说明了设 <span class="math inline">\(i&#39; &gt; i\)</span>，<spanclass="math inline">\(f(i)\)</span> 最优的 <spanclass="math inline">\(j\)</span> 肯定小于 <spanclass="math inline">\(f(i&#39;)\)</span> 最优的 <spanclass="math inline">\(j&#39;\)</span>。想象一下，凹函数的顶点 <spanclass="math inline">\(j\)</span> 向右移动到 <spanclass="math inline">\(j&#39;\)</span>，左边的肯定更不优，只能在 <spanclass="math inline">\(j\)</span> 的位置向右找 <spanclass="math inline">\(j&#39;\)</span>。(<del>如果说错了就当没有这句话</del>)</p><p>所以我们记录每一个每个最优决策点，它一定是单调增的。在 <spanclass="math inline">\(j\)</span> 的合法区间内查找最优的那一个，复杂度<span class="math inline">\(O(n)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1010</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">double</span> pl, pr, f[N];<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (f[j<span class="hljs-number">-1</span>]*(<span class="hljs-number">1</span>-pr)+f[i-j]*(<span class="hljs-number">1</span>-pl)+<span class="hljs-number">1</span>)/(<span class="hljs-number">1</span>-pl-pr); &#125;<span class="hljs-comment">// 这个东西可不是单调的，但是有最小值，所以下面要选择calc(i,j)最小的j</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;pl,&amp;pr);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">while</span>(j&lt;i&amp;&amp;<span class="hljs-built_in">calc</span>(i,j)&gt;<span class="hljs-built_in">calc</span>(i,j+<span class="hljs-number">1</span>)) ++j;f[i]=<span class="hljs-built_in">calc</span>(i,j);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,f[n]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n) <span class="hljs-built_in">sol</span>(); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
      <tag>决策单调性优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1291 百事世界杯之旅 题解</title>
    <link href="/2022/lg1291-solution/"/>
    <url>/2022/lg1291-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>有一个显然的结论：设当前已经获得的名字个数为 <spanclass="math inline">\(k\)</span>，那么再获得其他名字的概率为 <spanclass="math inline">\(\frac{n-k}{n}\)</span>。也就是说，平均买 <spanclass="math inline">\(n\)</span> 次有 <spanclass="math inline">\(n-k\)</span>个其他的名字，那么再获得一个平均次数为 <spanclass="math inline">\(\frac{n}{n-k}\)</span>。</p><span id="more"></span><p><del>感性理解一下</del>。</p><p>事实上有这个定理，对于事件 <span class="math inline">\(A\)</span>，有<span class="math inline">\(P(A)=p\)</span>，那么发生 <spanclass="math inline">\(A\)</span> 的期望次数 <spanclass="math inline">\(E(A)= \frac{1}{p}\)</span>。</p><p>回到题目，就是要求 <span class="math inline">\(\sum_{i=1}^n\frac{n}{i}\)</span>。要输出为分数形式，那么分别计算分子与分母，最后判断输出就行了。细节见代码。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">int</span> n;ll p, q, r;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);p=<span class="hljs-number">0</span>, q=<span class="hljs-number">1</span>;    <span class="hljs-comment">// p是分子，q是分母</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;p=p*i+q*n, q*=i;        <span class="hljs-comment">// 模拟分数加法，可以自己验证一下</span>ll d=<span class="hljs-built_in">gcd</span>(p,q);        <span class="hljs-comment">// 及时化简分子分母</span>p/=d, q/=d;&#125;r=p/q, p%=q;    <span class="hljs-comment">// r是整数部分，p要去掉r*q这部分</span><span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,r);    <span class="hljs-comment">// 分子是0，表示r是整数</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> d=<span class="hljs-built_in">log10</span>(r)+<span class="hljs-number">1</span>;        <span class="hljs-comment">// 整数x的位数=log10(x)+1</span><span class="hljs-keyword">while</span>(d--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,p);d=<span class="hljs-built_in">log10</span>(q)+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(r) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,r);        <span class="hljs-comment">// 如果有带分数整数部分，就输出</span><span class="hljs-keyword">while</span>(d--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);d=<span class="hljs-built_in">log10</span>(r)+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(d--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,q);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1623 神龙喝水 题解</title>
    <link href="/2022/uva1623-solution/"/>
    <url>/2022/uva1623-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>贪心。</p><p>维护一个集合 <spanclass="math inline">\(S\)</span>，保存不下雨的日期。设 <spanclass="math inline">\(g(x)\)</span> 为第 <spanclass="math inline">\(x\)</span> 个湖上一次下雨是第 <spanclass="math inline">\(g(x)\)</span> 天，起初全部为 0。</p><span id="more"></span><ol type="1"><li><p>对于一个 <span class="math inline">\(a_i = 0\)</span>，直接把<span class="math inline">\(i\)</span> 加入 <spanclass="math inline">\(S\)</span>。</p></li><li><p>对于一个 <span class="math inline">\(a_i &gt; 0\)</span>，设<span class="math inline">\(d=a_i\)</span>，在集合中查找不小于 <spanclass="math inline">\(g(d)\)</span>的最小的日期。如果没有，无解。否则更新 <spanclass="math inline">\(g(d)=i\)</span> ，记录答案，并在 <spanclass="math inline">\(S\)</span> 中删去找到的日期。</p></li></ol><p>正确性？如果一天下雨的时候，下雨的那个湖不能在那一天之前，最后一次下雨之后喝干，那么肯定就溢出。否则就一定不会溢出。</p><p>最优性？由于是按照时间顺序处理的，选择最小的喝水日期一定不劣，不选择最小的喝水日期一定不优。</p><p>就像下面，第 <span class="math inline">\(u\)</span> 天 <spanclass="math inline">\(i\)</span> 要下雨，如果选择 4，那么 <spanclass="math inline">\(v\)</span> 天 <spanclass="math inline">\(j\)</span>要下雨的时候就没得选了。如果按照上面的贪心，则是有解的。</p><div class="code-wrapper"><pre><code class="hljs cpp">S=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;g[i]=<span class="hljs-number">1</span>, g[j]=<span class="hljs-number">5</span>a[u]=i, a[v]=j  u&lt;v</code></pre></div><p>就氵吧。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> iter set<span class="hljs-meta-string">&lt;int&gt;</span>::iterator</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> t, n, m, a[N], f[N], g[N];set&lt;<span class="hljs-keyword">int</span>&gt; s;iter p;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g)), <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    s.<span class="hljs-built_in">clear</span>();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">bool</span> fg=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">if</span>(!a[i]) s.<span class="hljs-built_in">insert</span>(i);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> d=a[i];            p=s.<span class="hljs-built_in">lower_bound</span>(g[d]);            <span class="hljs-keyword">if</span>(p==s.<span class="hljs-built_in">end</span>()) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;            <span class="hljs-keyword">else</span> g[d]=i, f[*p]=a[i], s.<span class="hljs-built_in">erase</span>(p);        &#125;    &#125;    <span class="hljs-keyword">if</span>(!fg) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(!a[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,f[i]);        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);t--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#2 2-SAT 问题 (1)</title>
    <link href="/2022/notes-graph-2-1/"/>
    <url>/2022/notes-graph-2-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="sat">2-SAT</h2><p>2-SAT 属于 k-SAT 问题的一种。不幸的是，对于 <spanclass="math inline">\(k &gt; 2\)</span>，都是 NPC 问题。</p><span id="more"></span><p>给定 <span class="math inline">\(n\)</span> 个变量，每个变量 <spanclass="math inline">\(A_i \in \{0,1\}\)</span>。接着给定 <spanclass="math inline">\(m\)</span> 个条件，每个条件形如 <spanclass="math display">\[A_i=0/1 \text{ or } A_j=0/1\]</span> 求 <span class="math inline">\(n\)</span>个变量的合法赋值，满足全部 <span class="math inline">\(m\)</span>个条件。</p><h2 id="求解">求解</h2><p>将条件转化为：若 <span class="math inline">\(A_i=p\)</span>，则 <spanclass="math inline">\(A_j=q\)</span>，其中 <spanclass="math inline">\(p,q \in \{0,1\}\)</span>。</p><p>举个例子，条件是 <span class="math inline">\(A_1 = 1\)</span> 或者<span class="math inline">\(A_3 = 0\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(A_1 = 0\)</span>，则 <spanclass="math inline">\(A_3\)</span> 必定为 0。</li><li>如果 <span class="math inline">\(A_3 = 1\)</span>，那么 <spanclass="math inline">\(A_1\)</span> 一定为 1。</li></ol><p>所以把 <span class="math inline">\(n\)</span> 个节点拆成 <spanclass="math inline">\(2n\)</span> 个节点，使 <spanclass="math inline">\(A_i\)</span> 对应节点为 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+n\)</span>，分别对应以上两种限制条件。</p><p>具体做法是，从 <span class="math inline">\(i+p \cdot n\)</span> 向<span class="math inline">\(j + q \cdot n\)</span> 连一条有向边，从<span class="math inline">\(j + (1-p) \cdot n\)</span> 向 <spanclass="math inline">\(i+(1-q) \cdot n\)</span> 连一条有向边。注意 <spanclass="math inline">\(p,q\)</span>都是把<strong>条件中的值取反</strong>。</p><p>前者是原命题，后者是它的逆否命题。</p><h3 id="dfs">DFS</h3><p>这个 DFS 的算法，代码短的同时还容易构造字典序最小解，但是复杂度为<span class="math inline">\(O(n \cdot (n+m))\)</span>，过高。</p><p><del>所以为什么在洛谷模板题，DFS比Tarjan还快</del></p><p>具体流程</p><ol type="1"><li>对于每个当前不确定的变量 <spanclass="math inline">\(A_i\)</span>，令 <spanclass="math inline">\(A_i=0\)</span>，然后 DFS 访问相连的点。</li><li>检查如果会导致一个 <span class="math inline">\(j\)</span> 与 <spanclass="math inline">\(j&#39;\)</span> 都被选，那么撤销操作，执行过程3。否则令 <span class="math inline">\(A_i=0\)</span>。</li><li>令 <span class="math inline">\(A_i=1\)</span>，重复过程2，如果还不行，就无解。</li><li>继续考虑下一个不确定的变量</li></ol><p>代码略。</p><h3 id="tarjan">Tarjan</h3><p>用 Tarjan 算法求出图中所有 SCC。如果存在 <spanclass="math inline">\(i \in [1,n]\)</span>，满足 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(i+n\)</span> 在同一个 SCC 里面，那么表明 <spanclass="math inline">\(A_i\)</span> 必须赋值为 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(1-p\)</span>，这显然是矛盾的，无解。</p><p>还可以构造出解。对于一个 <spanclass="math inline">\(i\)</span>，选择拓扑序较大的状态更优。</p><p>由于 SCC 编号的顺序就是逆拓扑序，所以我们判断 SCC 编号 <spanclass="math inline">\(c_i\)</span> 与 <spanclass="math inline">\(c_{i+n}\)</span> 的大小。令 <spanclass="math inline">\(f(i) = c_i &gt; c_{i+n}\)</span>。如果 <spanclass="math inline">\(f(i)=1\)</span>，那么说明 <spanclass="math inline">\(i+n\)</span>的状态更优，对应到上面讨论的连边方法，就是令 <spanclass="math inline">\(A_i\)</span> 为条件中的值。否则说明 <spanclass="math inline">\(i\)</span> 状态更优，就是令 <spanclass="math inline">\(\ \neg A_i\)</span>，与条件状态取反。</p><p>然后 <span class="math inline">\(f(i)\)</span> 就是解中 <spanclass="math inline">\(A_i\)</span> 的取值了。</p><p>复杂度 <span class="math inline">\(O(n+m)\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n, m, scc, top, num, c[N], dfn[N], low[N], stk[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N], nxt[N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> xv,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> yv)</span> </span>&#123;    <span class="hljs-comment">// xv,yv是条件中x,y的值</span><span class="hljs-built_in">add</span>(x+!xv*n,y+yv*n), <span class="hljs-built_in">add</span>(y+!yv*n,x+xv*n);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;++scc;<span class="hljs-keyword">int</span> y;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]==c[i+n]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i]&gt;c[i+n]);&#125;</code></pre></div><h2 id="题目">题目</h2><p><a href="https://www.luogu.com.cn/problem/P4171">满汉全席</a></p><p>板子。</p><p>汉式看作取值为 1，满式看作取值为 0。判断 2-SAT 是否有解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">2005</span>;<span class="hljs-keyword">int</span> T, n, m, num, top, scc, stk[N], dfn[N], low[N], c[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[M], nxt[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> xv,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> yv)</span> </span>&#123;<span class="hljs-built_in">add</span>(x+!xv*n,y+yv*n), <span class="hljs-built_in">add</span>(y+!yv*n,x+xv*n); &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-keyword">int</span> y;++scc;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;cnt=top=scc=num=<span class="hljs-number">0</span>;<span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(dfn,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(low,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">int</span>&amp; b)</span> </span>&#123;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;h&#x27;</span>&amp;&amp;c!=<span class="hljs-string">&#x27;m&#x27;</span>) c=<span class="hljs-built_in">getchar</span>();b=(c==<span class="hljs-string">&#x27;h&#x27;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]==c[i+n]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x, xv, y, yv;<span class="hljs-built_in">get</span>(x,xv), <span class="hljs-built_in">get</span>(y,yv);<span class="hljs-built_in">addedge</span>(x,xv,y,yv);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-built_in">puts</span>(<span class="hljs-built_in">check</span>()? <span class="hljs-string">&quot;GOOD&quot;</span>:<span class="hljs-string">&quot;BAD&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">solve</span>()); &#125;</code></pre></div><p> </p><p><a href="https://www.luogu.com.cn/problem/UVA11294">Wedding</a></p><p>翻译（复制的）</p><blockquote><p>有N-1对夫妻参加一个婚宴，所有人都坐在一个长长的餐桌左侧或者右侧，新郎和新娘面做面坐在桌子的两侧。</p><p>由于新娘的头饰很复杂，她无法看到和她坐在同一侧餐桌的人，只能看到对面餐桌的人。</p><p>任意一对夫妻不能坐在桌子的同侧，另外有m对人有通奸关系，而新娘不希望看到两个有通奸关系人坐在他的对面，问如何安排这些座位</p></blockquote><p>假设所有妻子和新娘坐在一侧，所有丈夫和新郎坐在一侧，如果没有通奸关系的限制，显然是合法的。</p><p>如果两人 <span class="math inline">\((A,B)\)</span>有通奸关系，那么令 w 为 1，表示和新娘同侧，h 为 2，表示和新郎同侧。<spanclass="math inline">\(i \in [1,n]\)</span> 为妻子，<spanclass="math inline">\(i&#39; \in [n+1,2n]\)</span> 为丈夫。</p><p>如果 <span class="math inline">\(A\)</span> 在新娘一侧，那么 <spanclass="math inline">\(B\)</span> 一定在新郎一侧，从而 <spanclass="math inline">\(B\)</span>的配偶一定在新娘一侧，反之亦然。这样通奸关系就转化成了条件，可以直接根据这个连边，表示一定在同侧的人。然后跑2-SAT。</p><p>一开始本人也想不太明白，最好举几个例子。</p><p>最后要注意编号从 0 开始。新娘要和新郎连边。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">8e5</span>+<span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> n, m, top, scc, num, c[N], dfn[N], low[N], stk[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N], nxt[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> xv,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> yv)</span> </span>&#123;<span class="hljs-built_in">add</span>(x+!xv*n,y+yv*n), <span class="hljs-built_in">add</span>(y+!yv*n,x+xv*n);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]); &#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-keyword">int</span> y;++scc;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc; <span class="hljs-keyword">while</span>(x!=y);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">int</span>&amp; b)</span> </span>&#123;<span class="hljs-keyword">char</span> c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,&amp;a,&amp;c), ++a;b=(c==<span class="hljs-string">&#x27;w&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;cnt=scc=num=top=<span class="hljs-number">0</span>;<span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(c,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(dfn,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(low,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x, y, xv, yv;<span class="hljs-built_in">get</span>(x,xv), <span class="hljs-built_in">get</span>(y,yv);<span class="hljs-built_in">addedge</span>(x,xv,y,yv);&#125;<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>+n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]==c[i+n]) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;bad luck&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(c[i]&gt;c[i+n]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dw &quot;</span>,i<span class="hljs-number">-1</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dh &quot;</span>,i<span class="hljs-number">-1</span>);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) <span class="hljs-built_in">sol</span>(); &#125;</code></pre></div><h2 id="to-be-continued">To Be Continued</h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>2-SAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「图论学习笔记」#1 最小树型图</title>
    <link href="/2022/notes-graph-1/"/>
    <url>/2022/notes-graph-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="最小树型图">最小树型图</h2><p>最小树形图，也可以理解为有向图的最小生成树。</p><span id="more"></span><p>更学术地说，在一张有向带权图 <span class="math inline">\(G\)</span>中，找出一棵以 <span class="math inline">\(root\)</span>为根，权值和最小的有向生成树，满足：</p><ul><li><span class="math inline">\(root\)</span> 入度为 0，其余节入度为1</li><li>任意两点 <span class="math inline">\((u,v)\)</span> 间，有且仅有 1条简单路径</li></ul><h2 id="朱刘算法">朱刘算法</h2><h3 id="理论">理论</h3><p>朱刘算法是一个能在 <span class="math inline">\(O(nm)\)</span>的时间内验证有向带权图是否有最小树型图，并且能求出此图。</p><p>首先保证图没有自环且连通。</p><p>接着就是算法的过程：</p><ol type="1"><li>对于每一个点，分别找到它们的最小入边，构成一张新图。</li><li>如果新图没有环且连通，那么此时就是所求的最小树形图。</li><li>否则将一个环缩成一个点，建立新图，重新计算边权，重复以上过程。</li></ol><p>严格证明？不会。</p><p>但也是类似于 Kruskal 的贪心，只是多了缩点。</p><p><del>感性理解一下，显然是对的</del>。</p><h3 id="实现">实现</h3><p>如何去实现呢？前两步显然不难，最大的问题在于缩点后的边权怎么计算。</p><p>对于一个环，最终一定是将它断成一条链，那么就必须舍弃一条边。贪心删除最大的边？显然不可以，如果向下图一样删边，那么如果A 只有一条权值巨大的入边呢？这个贪心就 fAKe 了。</p><figure><img src="https://s2.loli.net/2022/02/11/GyauMAeoQZYNLCI.png" srcset="/img/loading.gif" lazyloadalt="断环为链" /><figcaption aria-hidden="true">断环为链</figcaption></figure><p>所以我们不能直接破坏这个环。</p><p>将环缩成一个点 <span class="math inline">\(u\)</span> 之后，<spanclass="math inline">\(u\)</span>继承了<strong>所有环内节点的所有环外入边</strong>。而建立新图后只会选择一条最小入边。且选择对于一个环内节点<span class="math inline">\(v\)</span>，选择 <spanclass="math inline">\(v\)</span> 的环外入边只会被动地删掉 <spanclass="math inline">\(v\)</span> 的环内入边。</p><p>所以如果我们先把环内所有边的权值统计入答案，再把每条环外入边的权值减去相对应的环内入边的权值，则无论选择那条环外入边，最终都不影响答案。</p><p>如下图，<span class="math inline">\((Y \rightarrow B)\)</span>早在第一个阶段就被 pass 掉。<span class="math inline">\((X \rightarrowB)\)</span> 是 <span class="math inline">\(B\)</span>的一条环外入边，那么如果把 <span class="math inline">\(X\)</span> 的权值<span class="math inline">\(x\)</span> 减去 <spanclass="math inline">\(B\)</span> 的环内入边的权值 <spanclass="math inline">\(3\)</span>，即直接累加 <spanclass="math inline">\(x-3\)</span> 的话，就相当于删去了 <spanclass="math inline">\((A \rightarrow B)\)</span>这条边。且对于其他的环外入边，这种方案都是可行的。</p><p><img src="https://s2.loli.net/2022/02/11/OQeAHkhruwdRNc6.png" srcset="/img/loading.gif" lazyload /></p><p>于是这个问题就解决了，具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n, m, root, in[N], pre[N], v[N], id[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> u, v, w; &#125; e[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">zhuliu</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">// 环的数量</span><span class="hljs-built_in">memset</span>(in,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(in));        <span class="hljs-comment">// in[x]=x的最小入边边权, pre[x]=in[x]对应的点</span><span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));        <span class="hljs-comment">// v[x]=在新图中，能从哪一个点访问到x</span><span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(id));        <span class="hljs-comment">// 标记所属的环（或者点）</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])in[e[i].v]=e[i].w, pre[e[i].v]=e[i].u;        <span class="hljs-comment">// 寻找最小边权</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==inf&amp;&amp;i!=r) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 不连通，不存在最小树型图</span>in[root]=<span class="hljs-number">0</span>;        <span class="hljs-comment">// 根没有入边</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans+=in[i];            <span class="hljs-comment">// 直接累计边权</span><span class="hljs-keyword">int</span> x=i;<span class="hljs-keyword">while</span>(v[x]!=i&amp;&amp;!id[x]&amp;&amp;x!=root) v[x]=i, x=pre[x];            <span class="hljs-comment">// 标记能够访问到的点，如果访问回来了，那么就找到环了</span><span class="hljs-keyword">if</span>(x!=root&amp;&amp;!id[x]) &#123;id[x]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=pre[x];y!=x;y=pre[y]) id[y]=cnt;                <span class="hljs-comment">// 所有换上节点标记为第几个环</span>&#125;&#125;<span class="hljs-keyword">if</span>(!cnt) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 没有环，直接结束</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!id[i]) id[i]=++cnt;        <span class="hljs-comment">// 不在环中的点，自成一个“环”，便于统计</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> u=e[i].u, v=e[i].v;e[i].u=id[e[i].u], e[i].v=id[e[i].v];            <span class="hljs-comment">// 缩点，将每条边的两个端点改为它们所属的环编号</span><span class="hljs-keyword">if</span>(u!=v) e[i].w-=in[v];            <span class="hljs-comment">// 不是自环，进行减权操作</span>&#125;n=cnt, root=id[root];        <span class="hljs-comment">// 修改信息</span>&#125;<span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回答案</span>&#125;</code></pre></div><h2 id="题目">题目</h2><p><a href="https://www.luogu.com.cn/problem/UVA11865">UVA11865 StreamMy Contest</a></p><p>二分答案。</p><p>二分最小带宽 <spanclass="math inline">\(mid\)</span>，判断是否能用带宽不小于 <spanclass="math inline">\(mid\)</span> 的边构成一棵花费不超过 <spanclass="math inline">\(cost\)</span> 的最小树型图。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100</span>, M=<span class="hljs-number">10005</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> T, n, m, len, tot, cost, root, in[N], pre[N], v[N], id[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> u, v, w, b; &#125; t[M], e[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">zhuliu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) in[i]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])in[e[i].v]=e[i].w, pre[e[i].v]=e[i].u;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==inf&amp;&amp;i!=root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));<span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(id));in[root]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans+=in[i];<span class="hljs-keyword">if</span>(ans&gt;cost) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> x=i;<span class="hljs-keyword">while</span>(v[x]!=i&amp;&amp;!id[x]&amp;&amp;x!=root) v[x]=i, x=pre[x];<span class="hljs-keyword">if</span>(x!=root&amp;&amp;!id[x]) &#123;id[x]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=pre[x];y!=x;y=pre[y]) id[y]=cnt;&#125;&#125;<span class="hljs-keyword">if</span>(!cnt) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!id[i]) id[i]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> u=e[i].u, v=e[i].v;e[i].u=id[e[i].u], e[i].v=id[e[i].v];<span class="hljs-keyword">if</span>(u!=v) e[i].w-=in[v];&#125;n=cnt, root=id[root];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;tot=n, len=<span class="hljs-number">0</span>, root=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(t[i].b&gt;=x) e[++len]=t[i];ll ans=<span class="hljs-built_in">zhuliu</span>(tot,len);<span class="hljs-keyword">return</span> ans&lt;=cost&amp;&amp;ans!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> l=inf, r=<span class="hljs-number">0</span>, mid;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;cost);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;t[i].u,&amp;t[i].v,&amp;t[i].b,&amp;t[i].w);++t[i].u, ++t[i].v;l=<span class="hljs-built_in">min</span>(l,t[i].b), r=<span class="hljs-built_in">max</span>(r,t[i].b);&#125;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(l)) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;streaming not possible.\n&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">while</span>(l&lt;r) &#123;mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d kbps\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div><p> </p><p><a href="https://www.luogu.com.cn/problem/P2792">小店购物</a></p><p>如果把所有要买的物品都买一次，那么剩下的物品就都能用最小价格买了。所以目标就是计算所有物品都买一次的花费。</p><p>如果买 <span class="math inline">\(u\)</span> 能把 <spanclass="math inline">\(v\)</span> 优惠到花费 <spanclass="math inline">\(w\)</span> 元，那么连一条 <spanclass="math inline">\((u \rightarrow v)\)</span>，权值为 <spanclass="math inline">\(w\)</span> 的边。同时将虚拟节点 <spanclass="math inline">\(n+1\)</span> 与每个物品连一条权值为原价 <spanclass="math inline">\(c_i\)</span> 的边。</p><p>虚拟节点目的是让图连通并符合题意，注意这里不能是0，因为在朱刘算法中，多个数组的 0 是未计算的状态。</p><p>这里的 <span class="math inline">\(n\)</span>是要买的商品总数，连完边后就多了一个虚拟节点，<spanclass="math inline">\(n\)</span> 要 变成 <spanclass="math inline">\(n+1\)</span>。边数 <spanclass="math inline">\(m\)</span> 就是要买的商品数与优惠的数量之和。</p><p>建完图后跑最小树型图，最后在加上剩下的物品就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">60</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, root, mp[N], c[N], pre[N], id[N], v[N];<span class="hljs-keyword">double</span> ans, a[N], in[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span> <span class="hljs-keyword">int</span> u, v; <span class="hljs-keyword">double</span> w; &#125; e[N*N];<span class="hljs-function"><span class="hljs-keyword">inline</span> edge <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">double</span> w)</span> </span>&#123;edge e;e.u=u, e.v=v, e.w=w;<span class="hljs-keyword">return</span> e;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">zhuliu</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) in[i]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])in[e[i].v]=e[i].w, pre[e[i].v]=e[i].u;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==inf&amp;&amp;i!=root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));<span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(id));in[root]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;ans+=in[i];<span class="hljs-keyword">int</span> x=i;<span class="hljs-keyword">while</span>(v[x]!=i&amp;&amp;!id[x]&amp;&amp;x!=root) v[x]=i, x=pre[x];<span class="hljs-keyword">if</span>(x!=root&amp;&amp;!id[x]) &#123;id[x]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=pre[x];y!=x;y=pre[y]) id[y]=cnt;&#125;&#125;<span class="hljs-keyword">if</span>(!cnt) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!id[i]) id[i]=++cnt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> u=e[i].u, v=e[i].v;e[i].u=id[e[i].u], e[i].v=id[e[i].v];<span class="hljs-keyword">if</span>(u!=v) e[i].w-=in[v];&#125;n=cnt, root=id[root];&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> t1, t2;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t1);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t1;++i) &#123;<span class="hljs-keyword">double</span> x; <span class="hljs-keyword">int</span> y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-keyword">if</span>(y) mp[i]=++n, a[n]=x, c[n]=y;&#125;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t2);m=n+t2;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) e[t2+i]=<span class="hljs-built_in">trans</span>(n+<span class="hljs-number">1</span>,i,a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t2;++i) &#123;<span class="hljs-keyword">int</span> u, v; <span class="hljs-keyword">double</span> w;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lf&quot;</span>,&amp;u,&amp;v,&amp;w);u=mp[u], v=mp[v];<span class="hljs-keyword">if</span>(!u||!v) <span class="hljs-keyword">continue</span>;a[v]=<span class="hljs-built_in">min</span>(a[v],w);e[i]=<span class="hljs-built_in">trans</span>(u,v,w);&#125;++n, root=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans+=a[i]*(c[i]? c[i]<span class="hljs-number">-1</span>:<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,<span class="hljs-built_in">zhuliu</span>());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最小树型图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3489 WIE-Hexer 题解</title>
    <link href="/2022/lg3489-solution/"/>
    <url>/2022/lg3489-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>预处理出每个铁匠能够打造的剑能够打败的怪物集合 <spanclass="math inline">\(s(x)\)</span> 与每条道路上的怪物集合 <spanclass="math inline">\(u(x)\)</span>。还是正常连边。</p><p>设 <span class="math inline">\(f(i,S)\)</span> 为从起点到节点 <spanclass="math inline">\(i\)</span>，能够打败的怪物集合为 <spanclass="math inline">\(S\)</span> 时，花费的最小时间。状态是一张图，用Dijkstra 算法转移。</p><span id="more"></span><p>边界自然是 <span class="math inline">\(f(1,s(1)=0)\)</span>。考虑<span class="math inline">\(x\)</span> 的子节点 <spanclass="math inline">\(y\)</span>，<span class="math inline">\(i\)</span>为 <span class="math inline">\(x \rightarrow y\)</span> 的边。如果 <spanclass="math inline">\(u(i)\)</span> 中包含 <spanclass="math inline">\(S_x \cup s(x)\)</span> 中不包含的元素，那么在<span class="math inline">\(x\)</span>打造的剑和之前的剑就不能打败路上的怪物，不能转移。更数学一点，若 <spanclass="math inline">\(S_0 =S_x \cup s(x)\)</span>，<spanclass="math inline">\(S_0 \cup u(i) \neqS_0\)</span>，那么不能转移。然后就是板子了。</p><p>答案：第一次到达 <span class="math inline">\(n\)</span>时的最小时间。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>, M=<span class="hljs-number">6005</span>, O=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">13</span>)+<span class="hljs-number">5</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, p, k, ans=inf, d[N][O], s[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[M], nxt[M], w[M], u[M];<span class="hljs-keyword">bool</span> v[N][O];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <span class="hljs-keyword">int</span> x, y, z; &#125;;<span class="hljs-comment">// 节点编号，集合，最小时间</span><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b) &#123; <span class="hljs-keyword">return</span> a.z&gt;b.z; &#125;priority_queue&lt;node&gt; q;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z,<span class="hljs-keyword">int</span> s0)</span> </span>&#123;    ver[++cnt]=y, w[cnt]=z, u[cnt]=s0, nxt[cnt]=h[x], h[x]=cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    d[<span class="hljs-number">1</span>][s[<span class="hljs-number">1</span>]]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>((node)&#123;<span class="hljs-number">1</span>,s[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>&#125;);    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>().x, s0=q.<span class="hljs-built_in">top</span>().y;        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(x==n) &#123; ans=d[x][s0]; <span class="hljs-keyword">break</span>; &#125;        <span class="hljs-comment">// 答案</span>        <span class="hljs-keyword">if</span>(v[x][s0]) <span class="hljs-keyword">continue</span>;        v[x][s0]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> S=s0|s[x];        <span class="hljs-comment">// 造完剑后的集合</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;            <span class="hljs-keyword">int</span> y=ver[i], z=w[i];            <span class="hljs-keyword">if</span>(v[y][S]||(S|u[i])!=S) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 已经到达或不合法</span>            <span class="hljs-keyword">if</span>(d[y][S]&gt;d[x][s0]+z) &#123;                d[y][S]=d[x][s0]+z;                q.<span class="hljs-built_in">push</span>((node)&#123;y,S,d[y][S]&#125;);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;p,&amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;        <span class="hljs-keyword">int</span> u, v, w;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);        <span class="hljs-keyword">while</span>(v--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w), s[u]|=<span class="hljs-number">1</span>&lt;&lt;(w<span class="hljs-number">-1</span>);        <span class="hljs-comment">// 预处理一定要-1</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-keyword">int</span> x, y, z, u, v, w=<span class="hljs-number">0</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;u);        <span class="hljs-keyword">while</span>(u--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v), w|=<span class="hljs-number">1</span>&lt;&lt;(v<span class="hljs-number">-1</span>);        <span class="hljs-built_in">add</span>(x,y,z,w), <span class="hljs-built_in">add</span>(y,x,z,w);    &#125;    <span class="hljs-built_in">dijkstra</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans!=inf? ans:<span class="hljs-number">-1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>最短路</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2403 所驼门王的宝藏 题解</title>
    <link href="/2022/lg2403-solution/"/>
    <url>/2022/lg2403-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>把能够到达的宫室连边。</p><span id="more"></span><p>具体地，对于一个横天门，将它与同一行中的普通点连单向边，横天门连双向边。对于一个纵寰门，将它与同一列中的普通点连单向边，纵寰门连双向边。对于一个任意门，向周围的8 个点连单向边（前提是不越界）。</p><p>由于只要到达一个强连通分量里，周围的点都能到达，所以求出所有强连通分量，缩点。点权为改强连通分量中点的个数。然后DP 最长路就行了。</p><p>这题主要是实现麻烦。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;, dy[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">int</span> k, n, m, num, top, scc, ans, x[N], y[N], op[N], dfn[N], low[N], stk[N], c[N], ccnt[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[M], nxt[M];<span class="hljs-keyword">bool</span> v[N];map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp[N];vector&lt;<span class="hljs-keyword">int</span>&gt; a[M], b[M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=a[i].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(op[a[i][j]]==<span class="hljs-number">1</span>) &#123; x=a[i][j]; <span class="hljs-keyword">break</span>; &#125;        <span class="hljs-comment">// 找到了一个横天门</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(x!=a[i][j]) &#123; <span class="hljs-built_in">add</span>(x,a[i][j]); <span class="hljs-keyword">if</span>(op[a[i][j]]==<span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(a[i][j],x); &#125;        <span class="hljs-comment">// 连边</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, len=b[i].<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(op[b[i][j]]==<span class="hljs-number">2</span>) &#123; x=b[i][j]; <span class="hljs-keyword">break</span>; &#125;        <span class="hljs-comment">// 找到了一个纵寰门</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j) <span class="hljs-keyword">if</span>(x!=b[i][j]) &#123; <span class="hljs-built_in">add</span>(x,b[i][j]); <span class="hljs-keyword">if</span>(op[b[i][j]]==<span class="hljs-number">2</span>) <span class="hljs-built_in">add</span>(b[i][j],x); &#125;&#125;        <span class="hljs-comment">// 同上</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-keyword">if</span>(op[i]==<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;++j) &#123;<span class="hljs-keyword">if</span>(mp[x[i]+dx[j]].<span class="hljs-built_in">find</span>(y[i]+dy[j])!=mp[x[i]+dx[j]].<span class="hljs-built_in">end</span>())<span class="hljs-built_in">add</span>(i,mp[x[i]+dx[j]][y[i]+dy[j]]);    <span class="hljs-comment">// 如果是任意门，那么找有没有对应的位置，有的话连边</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;dfn[x]=low[x]=++num, stk[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;++scc; <span class="hljs-keyword">int</span> y;<span class="hljs-keyword">do</span> y=stk[top--], c[y]=scc, ++ccnt[scc]; <span class="hljs-keyword">while</span>(x!=y);        <span class="hljs-comment">// c[x]: x属于哪个强连通分量</span>        <span class="hljs-comment">// ccnt[x]: x这个强连通分量有多少个节点</span> &#125;&#125;<span class="hljs-keyword">int</span> tc, hc[N], vc[M], nc[M];<span class="hljs-keyword">int</span> f[N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suodian</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=k;++x) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i];<span class="hljs-keyword">if</span>(c[x]!=c[y]) <span class="hljs-built_in">addc</span>(c[x],c[y]);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=scc;x;--x) &#123;f[x]+=ccnt[x];ans=<span class="hljs-built_in">max</span>(f[x],ans);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=hc[x];i;i=nc[i]) &#123;    <span class="hljs-keyword">int</span> y=vc[i];f[y]=<span class="hljs-built_in">max</span>(f[x],f[y]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x[i],&amp;y[i],&amp;op[i]);a[x[i]].<span class="hljs-built_in">push_back</span>(i), b[y[i]].<span class="hljs-built_in">push_back</span>(i);        <span class="hljs-comment">// a为同一行，b为同一列。</span>mp[x[i]][y[i]]=i;        <span class="hljs-comment">// map记录(x,y)的节点编号</span>&#125;<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-built_in">suodian</span>();    <span class="hljs-built_in">dp</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>强连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4766 Outer space invaders 题解</title>
    <link href="/2022/lg4766-solution/"/>
    <url>/2022/lg4766-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>满足 <span class="math inline">\(n \in [1,300]\)</span> 和 <spanclass="math inline">\(a_i,b_i \in[1,10000]\)</span>，这都不离散化，那还是人么（）。</p><p>没有明显的线性更新顺序，「时间」则是一个天然的序，且区间信息可以合并，所以设<span class="math inline">\(f(l,r)\)</span> 为在时间 <spanclass="math inline">\([l,r]\)</span> 内，消灭所有aliens，所需要的最小代价。</p><span id="more"></span><p>将时间离散化，数组就能开的下了。此时设所有不重复的 <spanclass="math inline">\(a_i\)</span> 与 <spanclass="math inline">\(b_i\)</span> 将总时间划分成 <spanclass="math inline">\(m\)</span> 段（也即是离散化后 <spanclass="math inline">\(a_i\)</span> 与 <spanclass="math inline">\(b_i\)</span> 的总数）。</p><p>边界 <span class="math inline">\(f(i,j) = \inf\)</span>。</p><p>答案 <span class="math inline">\(f(1,m)\)</span>。</p><p>由于一次会消灭所有距离 <span class="math inline">\(R\)</span> 以内的aliens，所以优先攻击最远的。对于区间 <spanclass="math inline">\([i,j]\)</span>，找到区间内距离最大的 <spanclass="math inline">\(x\)</span>。如果没有，那么 <spanclass="math inline">\(f(i,j) = 0\)</span>。如果有的话，那么我们可在<span class="math inline">\([a_x,b_x]\)</span>任意一个时刻消灭它，可以取最小值。</p><p>转移 <span class="math display">\[f(i,j) = \min { \{  f(i,k-1)+f(k+1,j)+d_x\} }\]</span> 要注意枚举元区间长时应从 1开始，因为不能直接处理这部分信息。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">605</span>, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> T, n, m, t[N], a[N], b[N], d[N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i],&amp;b[i],&amp;d[i]);        t[++m]=a[i], t[++m]=b[i];        f[i][i<span class="hljs-number">-1</span>]=f[i+<span class="hljs-number">1</span>][i]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">sort</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>);    m=<span class="hljs-built_in">unique</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>)-t<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,a[i])-t;        b[i]=<span class="hljs-built_in">lower_bound</span>(t+<span class="hljs-number">1</span>,t+m+<span class="hljs-number">1</span>,b[i])-t;        <span class="hljs-comment">// 直接预处理下标</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=m;++l) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span>&lt;=m;++i) &#123;    <span class="hljs-comment">// 从l=1开始</span>        <span class="hljs-keyword">int</span> j=i+l<span class="hljs-number">-1</span>, x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k)            <span class="hljs-keyword">if</span>(a[k]&gt;=i&amp;&amp;b[k]&lt;=j&amp;&amp;d[k]&gt;d[x]) x=k;        <span class="hljs-keyword">if</span>(!x||a[x]==b[x]) &#123; f[i][j]=<span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-comment">// a[x]==b[x]的情况不会出现，但是强迫症还是特判一下</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=a[x];k&lt;=b[x];++k)            f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i][k<span class="hljs-number">-1</span>]+f[k+<span class="hljs-number">1</span>][j]+d[x]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">1</span>][m]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);T--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA12170 Easy Climb 题解</title>
    <link href="/2022/uva12170-solution/"/>
    <url>/2022/uva12170-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="分析">分析</h2><p>老样子，先判断无解情况。</p><p>我们假设 <span class="math inline">\(h_n\)</span> 无限高于或者低于<span class="math inline">\(h_1\)</span>，那么中间的那些都必须尽力去逼近<spanclass="math inline">\(h_n\)</span>，一定是递增或递减的。但由于相邻的两堆石头高度差不能超过<span class="math inline">\(d\)</span>，所以递增或递减的最大长度为 <spanclass="math inline">\((n-1) \cdot d\)</span>。如果 <spanclass="math inline">\(|h_n-h_1| &gt; (n-1) \cdotd\)</span>，那么肯定是无解。反过来想，如果不大于，那么一定存在合法的构造方法，即一定有解。</p><span id="more"></span><p>手算以下不难发现，对于每一个 <spanclass="math inline">\(i\)</span>，都有 <span class="math display">\[h_i&#39; \in [\max{(h_{i-1},h_{i+1})-d,\min{(h_{i-1},h_{i+1})+d}}]\]</span> 那么如果 <span class="math inline">\(h_i\)</span>不在区间内，将其变为距离它最近的区间边界是最优的，因为差值最小。</p><p>如果 <span class="math inline">\(h_i\)</span>在区间内，那么可以让它不变，这样贡献为 0。</p><p>如果这样去做了，那么对于每个 <span class="math inline">\(h_i&#39;\)</span>，都能写成 <span class="math inline">\(h_x+kd \quad (x \in[1,n],k \in [-n,n])\)</span> 的形式。</p><p>感性证明一下，如果改变 <span class="math inline">\(h_i\)</span>的值，那么一定是在某个现有的 <span class="math inline">\(h_i\)</span> 或<span class="math inline">\(h_i&#39;\)</span> 的基础加上过减去 <spanclass="math inline">\(d\)</span>；如果不改变，令 <spanclass="math inline">\(k=0\)</span>即成立。严格证明可以用归纳法，这里不再赘述。</p><p>所以所有可能的值的个数为 <spanclass="math inline">\(2n^2\)</span>，记为 <spanclass="math inline">\(a\)</span>。</p><p>设 <span class="math inline">\(f(i,j)\)</span> 表示前 <spanclass="math inline">\(i\)</span> 堆石头，第 <spanclass="math inline">\(i\)</span> 堆的高度为 <spanclass="math inline">\(j\)</span> 时，所需要的最小代价。</p><p>边界</p><p><span class="math display">\[f(i,j) = \begin{cases}0 &amp; i=0,j=h_1\\\inf &amp; \text{otherwise}\end{cases}\]</span></p><p>转移</p><p><span class="math display">\[f(i,j) = \min \limits_{j-d \le k \le j+d} { \{ f(i-1,k)+ |a_i-j| \} }\]</span></p><p><span class="math display">\[f(i,j) = \min \limits_{j-d \le k \le j+d} { \{ f(i-1,k) \} } + |a_i - j|\]</span></p><p>滚动数组+单调队列优化即可。</p><p>最终答案 <span class="math display">\[ans= \max{\{ f(n-1,i) \}} \quad |h_n-i| \le d\]</span></p><p><strong>由于 <span class="math inline">\(j\)</span>这一维值域过大，具体实现时可以离散化，这一维存下标。</strong></p><p>状态数 <span class="math inline">\(n^2\)</span> 个，决策 <spanclass="math inline">\(n\)</span> 个，转移 <spanclass="math inline">\(O(1)\)</span>，总复杂度 <spanclass="math inline">\(O(n^3)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">105</span>, M=N*N*<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> t, n, m, d, h[N], q[M];ll ans, a[M], f[<span class="hljs-number">2</span>][M];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=-n;j&lt;=n;++j) <span class="hljs-keyword">if</span>(h[i]+j*d&gt;=<span class="hljs-number">0</span>) <span class="hljs-comment">// 高度不会小于0</span>            a[++m]=h[i]+j*d;    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>);    m=<span class="hljs-built_in">unique</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>)-a<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) h[i]=<span class="hljs-built_in">lower_bound</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>,h[i])-a;    <span class="hljs-comment">// 离散化去重，现在和h[i]存的是原来h[i]在a中的位置。</span>&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    m=<span class="hljs-number">0</span>, ans=<span class="hljs-number">1e15</span>;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;h[i]);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(h[<span class="hljs-number">1</span>]-h[n])&gt;(n<span class="hljs-number">-1</span>)*d) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// 无解</span>    <span class="hljs-built_in">init</span>();    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;    f[<span class="hljs-number">0</span>][h[<span class="hljs-number">1</span>]]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>, l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;a[q[l]]&lt;a[j]-d) ++l;            <span class="hljs-comment">// 排除不合法（越界）的决策。</span>            <span class="hljs-keyword">while</span>(k&lt;=m&amp;&amp;a[k+<span class="hljs-number">1</span>]&lt;=a[j]+d) &#123;                ++k;                <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[p^<span class="hljs-number">1</span>][q[r]]&gt;=f[p^<span class="hljs-number">1</span>][k]) --r;                <span class="hljs-comment">// 维护决策单调增</span>                q[++r]=k;            &#125;            <span class="hljs-keyword">if</span>(l&lt;=r) f[p][j]=f[p^<span class="hljs-number">1</span>][q[l]]+<span class="hljs-built_in">abs</span>(a[h[i]]-a[j]);            <span class="hljs-comment">// 队头即使最优决策。</span>        &#125;        p^=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[h[n]]-a[i])&lt;=d)        ans=<span class="hljs-built_in">min</span>(ans,f[p^<span class="hljs-number">1</span>][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);t--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1336 修缮长城 题解</title>
    <link href="/2022/uva1336-solution/"/>
    <url>/2022/uva1336-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>水一篇题解</p><span id="more"></span><h2 id="分析">分析</h2><p>将多游修理点按照位置递增排序。由于经过一个点便会立即修复它，所以每次被修复的点一定是一个连续的区间。由于修完一个区间后处于左右端点有后效性，要加进状态里。这样状态就出来了。</p><p>不难发现，最终答案能转化为每个点立即修复的花费+增长的花费。我们只计算后者就好了。</p><p>设 <span class="math inline">\(f(i,j,p)\)</span> 为修完区间 <spanclass="math inline">\([i,j]\)</span>，处于 <spanclass="math inline">\(p\)</span> 时增长的最小花费。<spanclass="math inline">\(p=0\)</span> 时在 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(p=1\)</span> 时在 <spanclass="math inline">\(j\)</span>。</p><p>对于要修理的区间 <span class="math inline">\([i,j]\)</span>，<spanclass="math inline">\([1,i-1] \cup [j+1,n]\)</span> 都会增长 <spanclass="math inline">\(\frac{|x_j-x_j|}{v}\)</span> 个 <spanclass="math inline">\(\Delta\)</span>。所以我们将 <spanclass="math inline">\(\Delta\)</span> 求出前缀和数组 <spanclass="math inline">\(g\)</span>，这样就可以快速计算这个区间外增长的量。即<span class="math display">\[F(x_i,x_j,i,j) = \frac{|x_i-x_j|}{v} \cdot g(n) - [g(j)-g(i-1)]\ \quad i\le j\]</span> 特别地，当 <span class="math inline">\(i=j=0\)</span> 时 <spanclass="math display">\[F(x_i,x_j,0,0) = \frac{|x_i-x_j|}{v} \cdot g(n)\]</span> 转移显然有两种，对于区间 <spanclass="math inline">\([i,j]\)</span>，一是转移到 <spanclass="math inline">\([i-1,j]\)</span>，二是转移到 <spanclass="math inline">\([i,j+1]\)</span>。再加上分别增长的量就好了。下面定义当<span class="math inline">\(p=0\)</span> 时，<spanclass="math inline">\(P=x_i\)</span>，反之 <spanclass="math inline">\(P=x_j\)</span>。 <span class="math display">\[f(i,j,p) = \min \begin{cases} f(i-1,j,0)+F(P,x_{i-1},i,j)\\f(i,j+1,1)+F(P,x_{j+1},i,j)\end{cases}\]</span> 开始先找到 <span class="math inline">\(X\)</span>左右的两个点，分别转移到这两个点上，取最小值就是答案了。</p><p>转移的时候注意判断边界。</p><p>最后看代码吧。</p><p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1006</span>, inf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>);<span class="hljs-keyword">int</span> t, n;<span class="hljs-keyword">double</span> v, x, sum, ans, f[N][N][<span class="hljs-number">2</span>], g[N];<span class="hljs-keyword">bool</span> vis[N][N][<span class="hljs-number">2</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">O</span> &#123;</span> <span class="hljs-keyword">double</span> x, c, d; &#125; s[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(O a,O b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x1,<span class="hljs-keyword">double</span> x2,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> dlt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;j&gt;<span class="hljs-number">0</span>) dlt+=g[j]-g[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">return</span> (g[n]-dlt)*<span class="hljs-built_in">fabs</span>(x2-x1)/v;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>&amp;&amp;j==n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span>&amp; w=f[i][j][p];    <span class="hljs-keyword">if</span>(vis[i][j][p]) <span class="hljs-keyword">return</span> w;    vis[i][j][p]=<span class="hljs-number">1</span>, w=inf;    <span class="hljs-keyword">double</span> x=(p? s[j].x:s[i].x);    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>) w=<span class="hljs-built_in">min</span>(w,<span class="hljs-built_in">dp</span>(i<span class="hljs-number">-1</span>,j,<span class="hljs-number">0</span>)+<span class="hljs-built_in">F</span>(x,s[i<span class="hljs-number">-1</span>].x,i,j));    <span class="hljs-keyword">if</span>(j&lt;n) w=<span class="hljs-built_in">min</span>(w,<span class="hljs-built_in">dp</span>(i,j+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)+<span class="hljs-built_in">F</span>(x,s[j+<span class="hljs-number">1</span>].x,i,j));    <span class="hljs-keyword">return</span> w;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    sum=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf&quot;</span>,&amp;s[i].x,&amp;s[i].c,&amp;s[i].d);        sum+=s[i].c;    &#125;    <span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) g[i]=g[i<span class="hljs-number">-1</span>]+s[i].d;    s[<span class="hljs-number">0</span>].x=-inf, s[n+<span class="hljs-number">1</span>].x=ans=inf;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(x&gt;s[i<span class="hljs-number">-1</span>].x&amp;&amp;x&lt;s[i].x) &#123;        ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">dp</span>(i<span class="hljs-number">-1</span>,i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+<span class="hljs-built_in">F</span>(x,s[i<span class="hljs-number">-1</span>].x,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));        ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">dp</span>(i,i,<span class="hljs-number">0</span>)+<span class="hljs-built_in">F</span>(x,s[i].x,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(<span class="hljs-keyword">int</span>)(ans+sum));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf%lf&quot;</span>,&amp;n,&amp;v,&amp;x)&amp;&amp;n;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA10559 方块消除 题解</title>
    <link href="/2022/uva10559-solution/"/>
    <url>/2022/uva10559-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="题面">题面</h2><p>共有 <span class="math inline">\(t \, (1 \le t \le 15)\)</span>组数据。</p><p>有 <span class="math inline">\(n \, (1 \le n \le 200)\)</span>个带有颜色的方块，没消除一段长度为 <spanclass="math inline">\(x\)</span> 的连续的相同颜色的方块可以得到 <spanclass="math inline">\(x^2\)</span>的分数，让你用一种最优的顺序消除所有方块使得得分最多。</p><span id="more"></span><h2 id="分析">分析</h2><p>显然是个区间 DP，但状态并不好表示。设 <spanclass="math inline">\(f(l,r)\)</span> 表示区间 <spanclass="math inline">\([l,r]\)</span>的最大得分？看样例就能知道，全局最优解不能单纯地用局部最优解拼凑成，不满足最优子结构性质。</p><p>那么就暴力一发，设 <spanclass="math inline">\(f(l,r,k_1,k_2)\)</span> 表示区间 <spanclass="math inline">\([l,r]\)</span>，其中 <spanclass="math inline">\(l\)</span> 的左边有连续 <spanclass="math inline">\(k_1\)</span> 个与它同色的方块，<spanclass="math inline">\(r\)</span> 的右边有连续 <spanclass="math inline">\(k_2\)</span>个与它同色的方块，所能得到的最大得分。这样状态总数就有 <spanclass="math inline">\(200^4\)</span>个，虽然有很多状态不存在（或者达不到），但是这样连数组都开不下。</p><p>我以前在某篇题解中看到过一句话：「当你发现了一个 fake的思路时，先想想它为什么是 fake的」。我们设计的这个状态缺点在于无用的状态太多，我们着手优化这个状态。显然，瓶颈在于<span class="math inline">\(k_1\)</span> 与 <spanclass="math inline">\(k_2\)</span> 那两维。仔细观察不难发现，对于区间<span class="math inline">\([l,r]\)</span>，统计 <spanclass="math inline">\(k_1\)</span>是很盲目的，因为如果我们只考虑每个区间的右边，那么 <spanclass="math inline">\(k_1\)</span> 的贡献会产生在区间 <spanclass="math inline">\([1,l-1]\)</span>中，不会影响当前区间信息计算的同时，我们还能够将区间信息「拼凑」起来。这不就是区间DP 的条件吗？</p><p> </p><p>所以我们设 <span class="math inline">\(f(l,r,k)\)</span> 为区间 <spanclass="math inline">\([l,r]\)</span>，其中 <spanclass="math inline">\(r\)</span> 的右边有连续 <spanclass="math inline">\(k\)</span> 个与 <spanclass="math inline">\(r\)</span> 同色的方块。</p><p>转移的过程中，我们找到一个方块 <spanclass="math inline">\(p\)</span>，满足 <span class="math inline">\(p \in[l,r]\)</span> 且 <span class="math inline">\([p,r]\)</span>均为同色方块，则右端一共有 <span class="math inline">\(r-p+k+1\)</span>个同色方块。</p><ul><li><p>直接消去最右端的一部分，<spanclass="math inline">\(f(l,r,k)=f(l,p-1,0)+(r-p+k+1)^2\)</span>。</p></li><li><p>找到一点 <span class="math inline">\(q\)</span>，满足 <spanclass="math inline">\(q\)</span> 与 <spanclass="math inline">\(q+1\)</span> 不同色且 <spanclass="math inline">\(q\)</span> 与 <spanclass="math inline">\(r\)</span> 同色，单独处理 <spanclass="math inline">\([q+1,p-1]\)</span>这一段（想象一下拿走这一段），然后 <spanclass="math inline">\([l,q]\)</span> 就挨着 <spanclass="math inline">\(r-p+k+1\)</span>个同色方块了。下图问号是要求出的部分，斜杠代表同色，注意 <spanclass="math inline">\(q\)</span> 也是。</p></li></ul><p><span class="math display">\[  f(l,r,k) = \max{ \{ f(l,q,r-p+k+1) + f(q+1,p-1,0) \} }\]</span></p><figure><img src="https://s2.loli.net/2022/01/30/Bmb4Pgf5zvhu6sM.png" srcset="/img/loading.gif" lazyloadalt="第二种转移" /><figcaption aria-hidden="true">第二种转移</figcaption></figure><p>这样就完成了区间的分割与拼接，这两种决策取个最大值就是答案了。最终答案<span class="math inline">\(f(1,n,0)\)</span>。</p><p> </p><p>时间复杂度 <spanclass="math inline">\(O(n^4)\)</span>，实际上远远到达不了这个规模。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>;<span class="hljs-keyword">int</span> t, _, n, a[N], f[N][N][N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">squ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x*x; &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span>(f[l][r][k]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[l][r][k];    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> <span class="hljs-built_in">squ</span>(k+<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span>&amp; x=f[l][r][k];    <span class="hljs-keyword">int</span> p=r;    <span class="hljs-keyword">while</span>(p&gt;=l&amp;&amp;a[p]==a[r]) --p;    ++p; <span class="hljs-comment">// 注意这里</span>    x=<span class="hljs-built_in">dp</span>(l,p<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)+<span class="hljs-built_in">squ</span>(r-p+k+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=l;q&lt;r;++q) <span class="hljs-keyword">if</span>(a[q]==a[r]&amp;&amp;a[q]!=a[q+<span class="hljs-number">1</span>]) x=<span class="hljs-built_in">max</span>(x,<span class="hljs-built_in">dp</span>(l,q,r-p+k+<span class="hljs-number">1</span>)+<span class="hljs-built_in">dp</span>(q+<span class="hljs-number">1</span>,p<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-comment">// f[l][r][k]=-1代表未计算</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %d\n&quot;</span>,++_,<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 不爆int，好评</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);t--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa1443 Garlands 题解</title>
    <link href="/2022/uva1443-solution/"/>
    <url>/2022/uva1443-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>先判断无解的情况。</p><p>由于每一段都要非 0 的偶数朵花，那么当 <spanclass="math inline">\(n\)</span> 为奇数时显然无解。</p><p>用 <span class="math inline">\(m\)</span> 个点固定，就是分成了 <spanclass="math inline">\(m-1\)</span> 段。每个半段不能超过 <spanclass="math inline">\(d\)</span> 朵，那么总数最多为 <spanclass="math inline">\(2 d \cdot (m-1)\)</span>，最少为 <spanclass="math inline">\(2 \cdot m\)</span>。所以当 <spanclass="math inline">\(n\)</span> 大于最大值，小于最小值时，无解。</p><span id="more"></span><p> </p><p>题目要求最小的半段重量的最大值，可以二分答案。我们定义 <spanclass="math inline">\(check(x)\)</span> 为半段重量最大为 <spanclass="math inline">\(x\)</span> 时，能否划分成 <spanclass="math inline">\(m-1\)</span> 段。</p><p>可以用 DP 来判断。设 <span class="math inline">\(f_i\)</span> 为前<span class="math inline">\(i\)</span>朵花在满足限制的情况下最少分成多少段？不行。不难发现，奇数段只能从偶数段转移而来，偶数段只能从奇数段转移而来。不记录奇偶性的话会产生后效性。</p><p>所以设 <span class="math inline">\(f_{i,j}\)</span> 为前 <spanclass="math inline">\(i\)</span>朵花在满足限制的情况下最少分成多少段，且段数奇数或偶数。当 <spanclass="math inline">\(j=0\)</span> 时为偶数，<spanclass="math inline">\(j=1\)</span> 时为奇数。</p><p>边界 <span class="math display">\[f_{i,j} = \begin{cases}0 &amp; i = j = 0 \\\inf &amp; otherwise\end{cases}\]</span> 转移。这个就比较显然了。 <span class="math display">\[\begin{cases}f_{i,0} = \min{ \{ f_{j,1} + 1 \} }\\f_{i,1} = \min{ \{ f_{j,0} + 1 \} }\end{cases}\]</span> 其中 <span class="math inline">\([j+1,i]\)</span>这一段有偶数朵花且不超过 <span class="math inline">\(2d\)</span>。</p><p>如果 <span class="math inline">\(m\)</span>是奇数，最终一定有偶数段，如果 <span class="math inline">\(m\)</span>是偶数，最终一定有奇数段。所以答案为 <spanclass="math inline">\(f_{n,(m-1) \% 2}\)</span>。</p><p>具体实现中要考虑半段的变化，最好结合 pdf 里的图看看。</p><p>复杂度 <span class="math inline">\(O(n^2 \log_2 n)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">4e4</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> t, n, m, d, s[N], f[N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i+=<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;(j&lt;=d)&amp;&amp;(j&lt;=i/<span class="hljs-number">2</span>);++j) &#123;    <span class="hljs-comment">// 保证i是偶数。 j是半段长度，保证它不超过d与i/2</span>        <span class="hljs-keyword">if</span>(s[i]-s[i-j]&gt;x) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 靠后的半段超重了，随着j的增加它的重量单调增</span>        <span class="hljs-comment">// 所有的j都不能满足条件了，所以直接跳过这个i</span>        <span class="hljs-keyword">if</span>(s[i-j]-s[i<span class="hljs-number">-2</span>*j]&gt;x) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 长度为j的半段超重了，但随着j的增加它会整体向后移动</span>        <span class="hljs-comment">// 可能还有满足条件的半段，直接往后找</span>        f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(f[i][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-2</span>*j][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);        f[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(f[i][<span class="hljs-number">1</span>],f[i<span class="hljs-number">-2</span>*j][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> f[n][(m<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]&lt;=m<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    s[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;d);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,w;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w);        s[i]=s[i<span class="hljs-number">-1</span>]+w;    &#125;    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>||n&gt;<span class="hljs-number">2</span>*d*(m<span class="hljs-number">-1</span>)||n&lt;<span class="hljs-number">2</span>*(m<span class="hljs-number">-1</span>)) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;BAD&quot;</span>); <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=s[n], mid;    <span class="hljs-keyword">while</span>(l&lt;r) &#123;        mid=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);t--;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3959 宝藏 题解</title>
    <link href="/2022/lg3959-solution/"/>
    <url>/2022/lg3959-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h3 id="这题我只想称之为神">这题我只想称之为神</h3><p>最优解中，开凿的道路一定联通，且一定是一棵树。这是因为如果最终不连通，那么显然不符合题意；如果最后不是一棵树，那么删去若干一条边后，不仅仍然可能连通，而且会减少代价。</p><p>暴搜显然不合适，那就考虑状压 DP。</p><span id="more"></span><p>DP 需要一定的顺序。和树形 DP一样设子树信息为状态？不行，一开始并不是一棵树，直接 pass掉。节点编号？也不行，根本转移不动。考虑到最后求出的实际上是一棵生成树，那么可以用生成树高度作为顺序，将免费打通的节点看作根。</p><p>于是就有了状态。设 <span class="math inline">\(f(i,S)\)</span>为联通的节点集合为 <spanclass="math inline">\(S\)</span>，当前生成树高度为 <spanclass="math inline">\(i\)</span>时，需要的最小代价。由于可以免费打通一个点，不难想到边界为 <spanclass="math display">\[f(i,S) = \begin{cases}0 &amp; i=1, |S|=1 \\\infty &amp; \text{otherwise}\end{cases}\]</span> 设全集为 <span class="math inline">\(U\)</span>，答案为 <spanclass="math inline">\(\min \limits_{i \in [1,n]}{ \{ f(i,U) \}}\)</span></p><p> </p><p>接下来就是转移了。显然，设 <span class="math inline">\(S_0 \subseteqS\)</span>，一定能从 <span class="math inline">\(f(i-1,S_0)\)</span>转移到 <span class="math inline">\(f(i,S)\)</span>。</p><p>因为不管高度为 <span class="math inline">\(S_0\)</span>的这一棵树是怎么打通的，只要打通 <spanclass="math inline">\(S-S_0\)</span> 中的所有点，就一定能够达到 <spanclass="math inline">\(S\)</span> 这个状态。我们可以枚举每一个子集 <spanclass="math inline">\(S_0\)</span>，然后将这个状态加上转移所需要的最小代价，满足最优子结构性，这样一定是正确的。</p><p>代价怎么计算呢？道路长度可以贪心地选择最小的。由于是按照树高由低到高的顺序计算，所以经过的节点数就是<code>i-1</code>。那么所有新打通的边的<span class="math inline">\(K\)</span> 都是相同的（就是题目中的 <spanclass="math inline">\(K\)</span>）。所以设 <spanclass="math inline">\(d(i,j)\)</span> 为状态 <spanclass="math inline">\(i\)</span> 转移到状态 <spanclass="math inline">\(j\)</span> 的最小边权和。</p><p>转移为 <span class="math display">\[f(i,j) = \min \limits_{k \subseteq j} { \{ f(i-1,k)+ (i-1) \cdot d(k,j)\} }\]</span> <span class="math inline">\(d(i,j)\)</span>可以直接预处理，参考下面代码。</p><h3 id="复杂度分析">复杂度分析</h3><p>预处理要枚举子集，枚举能够打通的点，复杂度为 <spanclass="math inline">\(O(n^23^n)\)</span>。</p><p>DP 时要枚举树高，枚举子集，复杂度为 <spanclass="math inline">\(O(n3^n)\)</span>。</p><p>总复杂度为 <span class="math inline">\(O(n^23^n)\)</span>。</p><p>当然你也可以用 预处理完一个 <spanclass="math inline">\(d(i,j)\)</span> 后马上转移 来降低常数。</p><p>不过这也完全足够了，而且看着思路很清晰。</p><p>关于如下枚举子集的两个循环复杂度为何是 <spanclass="math inline">\(3^n\)</span>，这里不做赘述。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j;j=(j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>)</code></pre></div><h3 id="code">code</h3><p>这题实现并不显然，注意代码，具体看注释。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">13</span>, M=<span class="hljs-number">1</span>&lt;&lt;N, inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n, m, U, ans=inf, a[N][N], f[N][M], d[M][M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;    <span class="hljs-built_in">SET</span>(a,<span class="hljs-number">0x3f</span>), <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0x3f</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        a[x][y]=a[y][x]=<span class="hljs-built_in">min</span>(a[x][y],z);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=U;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j;j=(j<span class="hljs-number">-1</span>)&amp;i) &#123;        <span class="hljs-keyword">int</span> fg=<span class="hljs-number">1</span>, u=i^j;        <span class="hljs-comment">// j这个循环意思是枚举i的所有子集</span>        <span class="hljs-comment">// u是j关于i的补集，就是j-&gt;i要打通的节点集</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k) <span class="hljs-keyword">if</span>((u&gt;&gt;k)&amp;<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 枚举u的每一位，如果是1的话就找到达这个节点的最短边</span>            <span class="hljs-comment">// 这个点记为a</span>            <span class="hljs-keyword">int</span> t=inf;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> o=<span class="hljs-number">0</span>;o&lt;n;++o) <span class="hljs-keyword">if</span>((j&gt;&gt;o)&amp;<span class="hljs-number">1</span>)            <span class="hljs-comment">// 枚举j的每一位，如果是1的话，就记录这个点到达p的边权</span>            <span class="hljs-comment">// 记为b，取b-&gt;a的最小值</span>                t=<span class="hljs-built_in">min</span>(t,a[o+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>]);            <span class="hljs-comment">// 注意这里o和k都是要+1的，因为上面枚举的是二进制位。</span>            <span class="hljs-keyword">if</span>(t==inf) &#123; fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;            <span class="hljs-comment">// t=inf 不存在b-&gt;a的边</span>            d[j][i]+=t;            <span class="hljs-comment">//直接累加</span>        &#125;        <span class="hljs-keyword">if</span>(!fg) d[j][i]=inf;        <span class="hljs-comment">// 不存在的话，自然是inf了</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">init</span>(), <span class="hljs-built_in">pre</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>&lt;&lt;i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 预处理</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=U;++j)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j;k;k=(k<span class="hljs-number">-1</span>)&amp;j)        <span class="hljs-comment">// 枚举树高，状态以及它的子集</span>            <span class="hljs-keyword">if</span>(d[k][j]!=inf) f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][k]+(i<span class="hljs-number">-1</span>)*d[k][j]);    <span class="hljs-comment">// d[k][j]!=inf 可以转移</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,f[i][U]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans); <span class="hljs-comment">// 很友好，不会爆int</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3092 No Change 题解</title>
    <link href="/2022/lg3092-solution/"/>
    <url>/2022/lg3092-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>直接设状态为花费的钱数是不行的，硬币的使用顺序与购买顺序都会影响答案，复杂度爆炸。</p><p>设 <span class="math inline">\(f(S)\)</span> 为使用的硬币为 <spanclass="math inline">\(S\)</span> 时，最多能买的物品个数。</p><p>对于 <span class="math inline">\(S_0 \subseteqS\)</span>，显然能够转移，但方程并不是一个简单的多项式。</p><p>不难发现，枚举 <span class="math inline">\(S\)</span>的子集是不行的，不能直接转移，且复杂度过高。那就考虑枚举硬币。</p><span id="more"></span><p>对于一个集合 <spanclass="math inline">\(S\)</span>，枚举枚举其中每一个硬币用或不用。设<span class="math inline">\(S_0\)</span> 与 <spanclass="math inline">\(S\)</span> 中只相差 <spanclass="math inline">\(j\)</span> 这个硬币，那么 <spanclass="math inline">\(S_0 = S \text{ xor } 2^{j-1}\)</span>，余出来的<span class="math inline">\(c_j\)</span> 的钱就可以继续往后买。设 <spanclass="math inline">\(t(i,j)\)</span> 为用 <spanclass="math inline">\(j\)</span> 的钱，从 <spanclass="math inline">\(i\)</span>开始往后买，最多能买到第几个物品。所以转移为 <spanclass="math display">\[f(S) = \max{ \{ f(S),t(f(S_0),c_j) \} }\]</span> 用前缀和搞一下物品数组，显然 <spanclass="math inline">\(t(i,j)\)</span> 是可以二分的。</p><p>这一部分复杂度为 <span class="math inline">\(O(2^k \cdot k \log_2n)\)</span></p><p>还是可以的（</p><p> </p><p>考虑如何计算答案。</p><p>设 <span class="math inline">\(g(S)\)</span> 为使用的硬币为 <spanclass="math inline">\(S\)</span>时的最小花费。显然可以采用与上面差不多的转移方式。</p><p>注意到 <span class="math inline">\(lowbit(x)\)</span> 可以提取出<span class="math inline">\(x\)</span> 的二进制表示中最后一个 1以及后面的 0。</p><p>举个例子</p><blockquote><p><span class="math inline">\((x)_2 = 011010\)</span></p><p><span class="math inline">\(lowbit(x) = (10)_2 = 2\)</span></p></blockquote><p>这正好对应了「去掉最后一个硬币」。由于不找零，所以能够直接暴力累加钱数。且因为我们设计了这样的状态，一个状态最多买多少物品是一定的，只需要计算出这些目标状态需要的钱数（也就是<span class="math inline">\(f\)</span> 的限制）。故可以从 <spanclass="math inline">\(g(S-lowbit(S))\)</span> 转移到 <spanclass="math inline">\(g(S)\)</span>。</p><p>由于 <span class="math inline">\(lowbits\)</span> 运算只能得到 2的整数次幂，那么我们可以将每个硬币与一个二进制位建立映射关系。</p><p>不难想到转移为 <span class="math display">\[g(S)=g(S-lowbit(S))+c_{lowbit(S)}\]</span> 最终答案为 <span class="math display">\[ans = \max{\{ sum_c - g(i) \}} \quad f(i) = m\]</span></p><p>注意实现。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">17</span>;<span class="hljs-keyword">int</span> n, m, orz, U, ans=<span class="hljs-number">-1</span>, c[N], sum[<span class="hljs-number">100010</span>], f[<span class="hljs-number">1</span>&lt;&lt;N], g[<span class="hljs-number">1</span>&lt;&lt;N], p[<span class="hljs-number">1</span>&lt;&lt;N];<span class="hljs-comment">// ans要初始化为-1</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lb</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x&amp;(-x); &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">erfen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">int</span> l=s, r=m, mid, pos=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(l&lt;=r) &#123;        mid=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(sum[mid]-sum[s]&lt;=v) pos=mid, l=mid+<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> pos;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c[i]), orz+=c[i], p[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)]=i;    <span class="hljs-comment">// p建立的映射为: c[1]-&gt;二进制最低位，c[2]-&gt;二进制倒数第二位，以此类推</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x), sum[i]=sum[i<span class="hljs-number">-1</span>]+x;    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=U;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)&amp;i) &#123;        <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">erfen</span>(f[i^(<span class="hljs-number">1</span>&lt;&lt;j)],c[j+<span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span>(t!=<span class="hljs-number">-1</span>) f[i]=<span class="hljs-built_in">max</span>(f[i],t);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=U;++i) &#123;        g[i]=g[i^<span class="hljs-built_in">lb</span>(i)]+c[p[<span class="hljs-built_in">lb</span>(i)]];        <span class="hljs-keyword">if</span>(f[i]==m) ans=<span class="hljs-built_in">max</span>(ans,orz-g[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa1099 Sharing Chocolate 题解</title>
    <link href="/2022/uva1099-solution/"/>
    <url>/2022/uva1099-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>设 <span class="math inline">\(f(x,y,S) = 0/1\)</span>为当前巧克力长为 <span class="math inline">\(x\)</span>，宽为 <spanclass="math inline">\(y\)</span>，选出的 <spanclass="math inline">\(a_i\)</span> 集合为 <spanclass="math inline">\(S\)</span> 时，能否成功分割。</p><p>这样状态数有 <span class="math inline">\(xy \cdot 2^n\)</span>个，过多。</p><p>设集合 <span class="math inline">\(S\)</span> 中元素的面积和为 <spanclass="math inline">\(sum_S\)</span>。仔细观察不难发现：能够分割成功，当且仅当<span class="math inline">\(sum_S = xy\)</span>。</p><p>所以我们就可以只计算满足以上条件的状态。并且在满足以上条件的状态中，知道<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 其中一个就能直接计算出另一个。</p><p>所以设 <span class="math inline">\(f(x,S) = 0/1\)</span>为当前巧克力较短（较长也可以）边长为 <spanclass="math inline">\(x\)</span>，选出的 <spanclass="math inline">\(a_i\)</span> 集合为 <spanclass="math inline">\(S\)</span> 时，能否成功分割。</p><span id="more"></span><p> </p><p>先考虑特殊情况。</p><p>设全集为 <span class="math inline">\(U\)</span>，集合 <spanclass="math inline">\(S\)</span> 中面积的和为 <spanclass="math inline">\(sum_S\)</span>。若 <spanclass="math inline">\(sum_U \neq xy\)</span>，那么无解。</p><p>如果在有解的情况下，集合 <span class="math inline">\(S\)</span>中只有一个元素，那么一定有解。</p><p>  再考虑转移。</p><p>设 <span class="math inline">\(S_0 \subseteq S\)</span>。</p><p>考虑到如果 <span class="math inline">\(S\)</span> 有解，那么 <spanclass="math inline">\(S_0\)</span> 一定有解，并且 <spanclass="math inline">\(S - S_0\)</span> 也一定优解。</p><p>那么转移的方法就呼之欲出了。</p><p>枚举 <span class="math inline">\(S\)</span> 的所有子集，设 <spanclass="math inline">\(x_0= \min{ \{ x,sum_{S_0}/x\} }\)</span>，<spanclass="math inline">\(x_1 = \min{ \{ x,sum_{S_1}/x\} }\)</span>。</p><p>这里进行一下数学分析……</p><blockquote><p>已知 <span class="math inline">\(sum_S =sum_{S_0}+sum_{S_1}\)</span>，<span class="math inline">\(sum_s =xy\)</span>，显然 <span class="math inline">\(x \midsum_S\)</span>。</p><p>但 <span class="math inline">\(x\)</span> 不一定都整除 <spanclass="math inline">\(sum_{s_0}\)</span> 和 <spanclass="math inline">\(sum_{s_1}\)</span>。举个例子：</p><p><span class="math inline">\(x=2, y=5\)</span></p><p><span class="math inline">\(xy = 5+5=10\)</span></p><p><span class="math inline">\(x \nmid 5\)</span></p><p>这样就会转移到错误状态。</p><p>可以通过「切一刀后有一条边长不变」来理解。</p></blockquote><p>所以为了达到正确的状态，求出 <span class="math inline">\(y= sum_S /x\)</span>，<span class="math inline">\(y_0,y_1\)</span> 同上。</p><p><span class="math display">\[f(x,S) = \begin{cases}1 &amp; f(x_0/y_0,S_0) = f(x_1/y_1,S_1)=1 \\0 &amp; \text{otherwise}\end{cases}\]</span></p><p>这里的斜杠是“或”的意思。</p><p>最终答案即为 <span class="math inline">\(f(\min{\{x,y\}},U)\)</span>，直接记忆化搜索就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">16</span>, M=<span class="hljs-number">105</span>;<span class="hljs-keyword">int</span> _, n, x, y, U, a[N], sum[<span class="hljs-number">1</span>&lt;&lt;N], f[M][<span class="hljs-number">1</span>&lt;&lt;N];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x) a+=(x&amp;<span class="hljs-number">1</span>), x&gt;&gt;=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> s)</span> </span>&#123;    <span class="hljs-keyword">if</span>(f[x][s]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][s];    <span class="hljs-comment">// f[x][s]=-1 表示未计算</span>    <span class="hljs-keyword">int</span>&amp; dlt=f[x][s];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cnt</span>(s)==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 特判只有一个元素的集合</span>    <span class="hljs-keyword">int</span> y=sum[s]/x;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s0=(s<span class="hljs-number">-1</span>)&amp;s;s0;s0=(s0<span class="hljs-number">-1</span>)&amp;s) &#123;        <span class="hljs-keyword">int</span> s1=s^s0;        <span class="hljs-keyword">if</span>(!(sum[s0]%x)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(x,sum[s0]/x),s0)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(x,sum[s1]/x),s1)) <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!(sum[s0]%y)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(y,sum[s0]/y),s0)&amp;&amp;<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(y,sum[s1]/y),s1)) <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 被x或y整除才去计算这个状态</span>    &#125;    <span class="hljs-keyword">return</span> dlt=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f)), <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sum));    U=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>;s&lt;=U;++s) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>(s&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) sum[s]+=a[i+<span class="hljs-number">1</span>];    <span class="hljs-comment">// 预处理所有集合的sum</span>    <span class="hljs-keyword">bool</span> fg;    <span class="hljs-keyword">if</span>(sum[U]!=x*y) fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> fg=<span class="hljs-built_in">dp</span>(<span class="hljs-built_in">min</span>(x,y),U);    <span class="hljs-comment">// 特判</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %s\n&quot;</span>,++_,fg? <span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n;<span class="hljs-built_in">sol</span>()); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5858 Golden Sword 题解</title>
    <link href="/2022/lg5858-solution/"/>
    <url>/2022/lg5858-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>设 <span class="math inline">\(f_{i,j}\)</span> 为放入第 <spanclass="math inline">\(i\)</span> 个原料，炼金锅中共有 <spanclass="math inline">\(j\)</span> 个原料时的耐久度之和。</p><span id="more"></span><p>边界 <span class="math display">\[f_{i,j}= \begin{cases}0 &amp;  i=0,j=0 \\-\inf &amp; \text{otherwise}\end{cases}\]</span> 考虑 <span class="math inline">\(j\)</span>的取值范围。因为最少一个也不拿走，最多拿走 <spanclass="math inline">\(s\)</span> 个，锅中最多有 <spanclass="math inline">\(w\)</span> 个原料，所以对于状态 <spanclass="math inline">\(f_{i,j}\)</span> 的一个决策 <spanclass="math inline">\(k\)</span> <span class="math display">\[j-1 \le k \le \min{\{w,j-1+s\}}\]</span> 转移为 <span class="math display">\[f_{i,j}=\max{\{ f_{i-1,k} + a_i \times j\}}\]</span> 答案为 <span class="math inline">\(\max{\{ f_{n,i} \}} \quad i\in [1,w]\)</span></p><p>交上去，光荣地 TLE 了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e3</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, w, s;ll ans=<span class="hljs-number">-1e15</span>, a[N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;w,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=w;++j) f[i][j]=<span class="hljs-number">-1e15</span>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=w;++j) &#123;        <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">min</span>(w,j<span class="hljs-number">-1</span>+s);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j<span class="hljs-number">-1</span>;k&lt;=t;++k) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][k]+a[i]*j);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=w;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div><p>考虑优化。</p><p>注意原转移方程中，<span class="math inline">\(a_i\times j\)</span>是个定值，将其提出后，我们要做的就是快速查找 <spanclass="math inline">\(\max{\{ f_{i-1,k} \}}\)</span></p><p>使用单调队列维护 <span class="math inline">\(f_{i-1,k}\)</span>单调减，队首即为最优决策。用 <span class="math inline">\(q_l\)</span>表示队首，则转移方程为 <span class="math display">\[f_{i,j}=\max_{j \in [1,\min(i,w)]}{\{ f_{i-1,j-1},f_{i-1,q_l} \}}\]</span> 前者为「不拿走」，后者为「拿就拿波大的」</p><p>注意，为了保证队列中的决策都是 <spanclass="math inline">\(f_{i-1,j}\)</span> 时状态， <spanclass="math inline">\(j\)</span> 这一维必须倒序循环。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e3</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, w, s, l, r, q[N];ll ans=<span class="hljs-number">-1e15</span>, a[N], f[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;w,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=w;++j) f[i][j]=<span class="hljs-number">-1e15</span>;    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-built_in">min</span>(i,w);j;--j) &#123;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;j<span class="hljs-number">-1</span>+s&lt;q[l]) ++l;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[i<span class="hljs-number">-1</span>][q[r]]&lt;f[i<span class="hljs-number">-1</span>][j]) --r;            q[++r]=j;            f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][q[l]])+a[i]*j;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=w;++i) ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022.1.1</title>
    <link href="/2022/mz/"/>
    <url>/2022/mz/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="165672bbe410c71c9db3e30c4df896ec8b844285c7e03bfe8daf0a32c96a485e">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e1aa6f2baea33d88d75a842a5edcca7ae066fc8e0e3a75811a3810817123eda05810ec4acf438cc18bcb0c521f603d7a1e4a14574189d8e6dab4798ca64029a3ea5f3fcd40ad6cf81a77b7c769acb6b2b96bbff03e4c0d6aea54ab099e553664f0caaeb6b61555bf132853461e3953ee8f2dd2a5983a67cdcc6f619cb1108b83aa635263c8b77dfc2b2d80c73bceaeb2e562601894bbff19c56a570c0973e0ebf8a23b0e23d7e1ea544f09b9821a5690d4b6bb0d0b9b589280bc91e0b641851e9c95be1470d8f02e874180079a5595d1ec4d3224fa394c58fc1481b94d44620b731fd03aba31ded4463faba7d795139b470d0a3b16b30e80f06298286701dcd99f50f852f321c7be3ed0bd770ef5297b31e95825616db8ecfd6da3d6e2f94690e25fcfcc87003d36c4c030f3f33c6f7a38d6e3e588d6576e68f7feef7f32bdaa330048e32fbf5c8c4ffd5e4626cea02a01dc9f75105c6ecddaaf7ad4946d7c610233b16724fe5407a709759e42d9c25389c80d9018886450399e8e5401c12162f498da5e3f5482a6c1da05bb00d913247d8b3521a94eec98fbdc666cd541b78e66d6d4d0b1d15c8f51961d34e7ab3b91ea4b7814ef8bcabf91c997a171f82ea824584364e8c2d017b7a1e13106d0d3cd8c4495abbc7e7f89f4d1f4ec2e7526037f81b02a5ceb6a15cfcb2a17939ccb0235654592e5e4c19d66d6536046f8ab2046168e0a6360ccdf9eaca4b8a3eb1714dcb1ce37238df72db449c9fd914428cf79cbf87bb0be6a6ce6345895e61337b9b15ae562d9cea55508bef1f8e77f8202f8ccb3356d66976208030f1338471d946cfe233ea307139cdb4d9ef0650af286f92236b4b9fe1bddc00efbb71bd9c8860956aaae5e46d87edae2916ad23d71cc937c5dca5bf66296f15a0e84536c5bad66c4c9ba9daa0d3534ae35f7ce6497a4704d394b78feb9c9d68432d1b133fe868950d4252cf020ba116b512830031c6095d180e3b4dd54732c431e314cb6356b326c10b6c2007fa0fc0534411cbae13478a4078b2c94e37b1970f7ac70d4c63c62ce4eccc4ea69fc644f8641f93aafb5af669076b2f3fcd71b7239807eb6ccb5423afb3aa01621b9f6fa76840a314a9adabe1b6a38c12400a36a24ba7dcf0b6d19784d540fc421a267015c714aadd7bf2361491abd63893e30ff9f4d4eff1e49517d479aad7237dc5df683c0a8dd990d24b0b8e02e31d6c150235cb606e0e937dea6c5bff56327b84ab7937b637f027deda6f91292b118c3e7bd69d1d9e95686a13095dbc5fc6daec3b7275e713959cc31d6a307dde0860e274bdf48cf16ad11f0b8befd15e6a20fd2b3706afa5709a7a47f525c7630ba851e9e0b9b44b0325458545fd8dee9c09148e85387d652a6f075cb31fd23a1343bffff3db6ef9d33e4a8c1053f8a3b4bd8a307200428d92cf22d79c159fd9c8fb65944491408d0e6b510576f41e57dc21ea0883b3a325d2427d2348bbcec4267a7a74947d9945216d825d0c73a50ed87c81647a1b5ee8ed67cac0745893eaec2fd6b4d1829dfd4e78f4e57e3fc77760f68a1e96fd640690cabff0e428a241969b644e7f63981ad79dbe2b54a76f7f1eadeffc623637b77a14df669bf89f46a3b31ee847c4a87a064d443fcc0c0217a0e5e75ca1225993cdd1f8585cca046940af85ca493e40a70e65ca1fe5c0c5ae6930403be9876e370688cd59884e76935133ebd916bb5181ef942c4fd8762864498e1678c0245743014b977a3ad0e495c2ab70a16a99e29aa229f3631c192877d1acf712093fa2beb2df259863bca38b1a184dd2a1292d39fc9a0807ad10c5d132c91e65724e7e2aecd0ed4269f0c942c19f1941f6de4d2b7886c08f0d580fcbed2521c6d768b97344566ba33e758b66167f5f20a4d1678adef0d7b45d9b1febcc3c214f39a008137ae66ef0b3be69d9a52acfb078d67d14f46c1ba36041bbfe5d34aa3d0bc2ebcb960f1e6ecce5149c5c546b5c18923fb62a76189e3f2a46b7d1e9445dd0fdd0002bd84f1aebd3c6c28a2e81562ed5d92b49dd487ef5f401e4f8e904daf254554ea8ef518da0a689b97220b01bd1db992c7d5ec5f93dea03aa6e8fcf79d220c64ac42bd0f506914cd860c6902b95304908b355ceb2dd82bd947829abf93b72b1cec0e648a1104ab7c09592bf85b4c0560a399574aadcda6a65ceeca30ba292f6938357bd6217c65549ad4bfcb81aef555cc14b465c0562c82efe2313108e320a5872316d617b97c33820021af1aa54e70149337b054c2f5d99c46229dadcd7ae51b4b9d26c696f9f774d4a4b728c7b9a85493a23bcdec2ef0977430384bba12d0121c120b32c5aa577b23dc5ccdfc4e2d99a560e344dbdb814ce44b3115520c39e01458a44ea1260f32b4a918912c54366b6cb2c95ccf6674577dd03b9b9609c80c11ab9a6029bcb34bcc1cd5ef9c37763070ff15953f7435bace530e55a2f2e927511d6236d3fea90a9ecfd46d8cb3b8a33d4588d8d348e7b247adfddd28560e6d4f550db811ffa82da387999bbd8fd696121841d8a9b41ba7f022d46dbdc60a1d9372616291ca82395f7a16fbfe947e0661e90c672f8432ed7b127a6333984a0b4799d8ef7efe675ee7a7556a30d69e247ea095982649f0b8f916109e287f36c43f44c316be4e8e80a4b207f7a9bb4910223857bec62a41deacd08ef8fe1af7febc6e7bbcb3aeb6a65d6846806bbb0ab6a802ace71ebd0d8705ebad6712c3b46fb2c4bc2a80c101627d642ae0615b281044e19a4fafc1eef5f665b245f5dd539af520f9cb3fa5a1c90f7eaecd51b6a350083a8cf8de964fe8ad4f18254dd3c575b697b9be27392289ef672ab0682ac4adc6091b15c2fe9a2ac898fb812b7e9d396920e0b58fb577543142b0068fefa19f4c2955a5d153e30ec7011d61fc0afa66b86a38feedaaada331703263f59ca950fa7f66a580b5ec3368bbdd292b5055d6e5e2d247f9f6bf5d0cc614dc8a98a814a4fadca03e84154d8318603dfab2753dcbaf9a7131695c7b133dad9b4ee2d9dc85212a9828b5dac5483e10c72f59f5ad611ef24c307d5dbe96d701f9ece838d557436c61959c8f8d5b26aeecca1057abc56ad67b3a55af9d308a73ab5e55c5c89abdb20c515db0baf54847c66b56a1ad119acd8a29d8c3369930648f172b77806393c48dfe22e383119e171f7b6a034b83cd03474a36fb1afb47cfe759ac4f8062b24760e0fb02473ae25c260814420b53c75b24a1601746c6bb9c52c5ff19f62b74da26b00002f6ef5e7d105676187414da53d21248b7d4a4c67735666219f5d6383f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dec. 4th Sat 2021</title>
    <link href="/2021/dec4th/"/>
    <url>/2021/dec4th/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>Dec. 4th Sat 2021</p><p>20:xx</p><p>好无聊</p><p>没什么可做的事了</p><p>没什么有意义的事了</p><span id="more"></span><p>打开游戏便是心乱如麻</p><p>更拿不起笔去写作业</p><p>在摸鱼与应付中考间循环往复的单调生活</p><p>真是让人疲于应对啊</p><p> </p><p>赶紧结束吧</p>]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雨き声残響</title>
    <link href="/2021/ame-koe/"/>
    <url>/2021/ame-koe/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center><p>自分より下手くそな人</p><p>寻找比自己更没用的人</p><p>探して浸るの優越感</p><p>沉浸于这般的优越感之中</p><p>でもその度ちょっと自分を嫌って</p><p>但每当这样做就会有点变得讨厌自己</p><p>次元遡って現実逃避</p><p>回遡次元逃避现实</p><p>でも良いんじゃない？</p><p>但这样也不错吧？</p><p>別に良いんじゃない？</p><p>就这样不就好了吗？</p><p>無理に強がらなくても良いんじゃない？</p><p>即使不勉强去逞强也可以吧？</p><p>下を見て強くなれるのも</p><p>向下望就能变得坚强</p><p>また人だからさ。</p><p>因为我也不过是人啊</p><p> </p><p>五月蠅い もううざい くらいにCryを掻き消す様な</p><p>吵死了 真的麻烦死了 如此 将哭泣声 消抹掉似的</p><p>世界なら 抗ってたいのに</p><p>这般的世界 我明明就想要去与之抵抗</p><p>降り出した空の泣き声は透明で</p><p>降雨的天空的 哭泣声却是透明的</p><p>「わかんない、もうわかんないよ！」を何遍も。</p><p>「我不懂啊,我不管了啊!」无数次这样说到。</p><p> </p><p>僕達は存在証明に 毎日一生懸命で</p><p>我们为了存在的证明 每天都拼命过活</p><p>こんな素晴らしい世界で まだ生きる意味を探してる</p><p>在如此美妙的世界 继续去探求活着的意义</p><p>そりゃそうだろだって人間は 希望無しでは生きられないからさ</p><p>因为说着「那是理所当然的吧」的人们 没有了希望就活不下去了啊</p><p>みんな 心のどっかで 来世を</p><p>大家在心裹某处 都是</p><p>信じてる。</p><p>深信着来世的</p><p>昨日の僕守る為に 笑うくらいなら</p><p>若然欢笑 只是为了守护昨天的我</p><p>泣いたっていいだろ？ ねぇ</p><p>那即使我哭了也没关系吧？ 呐</p><p>止まないの雨が 夏空を鮮明に描いたって</p><p>不止的雨 即使鲜明地描绘出夏日的天空</p><p>僕達は不完全で</p><p>我们亦是不完美而</p><p> </p><p>未完成 な</p><p>不成熟的呢</p><center/>]]></content>
    
    
    <categories>
      
      <category>Music</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VOCALOID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于OI，不知所言</title>
    <link href="/2021/oi/"/>
    <url>/2021/oi/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f962a3b349f7278f9cfe69d14e71fa9dba1fc07aeb029727c43838b851cf8b9e">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e16fd5063bf482bdeb27b17ba7739f697af1a700f4a4ab801eb200645f8174f29658dd316f6282d6119702404e07601140e155f9572e303398668ee9c3f399d72d30b365abca45ad5c5e0a76349a5161bdb7a028f77f52edea17dd63818a82d4c56b7ea04f5fad7138dfe52cd3a476a05af61f59e4cfd63c6d2f25c22570b8946e7ee472296a1762e3c548e2d0a180525a348f507980270d4df4004ce6070835fc7bb600208165d0d62005f478c50c4d4f9f076510845b54b9b577cef451a9ffbaa8731dc07b4612cc04548116a11af86a92ccffe40f19b015d9f4a1970854bba655216f1a9894af7ed6f91961c35fea0cec0e0d294e469b58b0f3ec90f3c95b40e5347ff8d47642b26d99ed4e0e7f79534815f60ceb0599c5eeb57d49fa33f54787d04797f6336444eeb221cc1cb881de1720b2fe55fe19d2084f41ae490c8a86b70d6fe3aee4e0d5a030c9be542e2ff16a338b776441faf9ebac2dcdd5e875cd7b7ee4584c5ee1e4383d936a5fa73d7dcc98fa4c4d974fb42e2356085de9f235325a54dae76872e8004c25e99ca772ceac15041df496d632bfb3b58d8f23450f06898f00373f4930ad6128a14dc58a81d36e25223d176814c83239d04c10174365b42cf79383ed8038c2d3204cad34c9d85cc9b3e5f0759ef6a127bad4bdd39cbf2eb0fa4d7c05cb69e72bfb266955b4c2b5ba405c422ec801f8fac1cbc9ff09004ea804daf702b24206676f067820d5c7a4be45e844a13f1c875ac55a0e4dd3629ce7bcbd59057327fe71c7ff3e1004e51a48c2544f7b57d54af4dcca2b0a34dd307184715401e128f61db8987f319aa57924d0e64513dd9bdf6a69e90c79e0ef93c20ccdbcd0a9e925199e0247005071bcd4108ce57359f86e4fbdf42e2294020be9f521a06305e351f1c1a2d3e9e9377351b1963df8fb4fc178091d62ea74e7a98b1277df69b80f6b9760387953879dc36ebac2393cabb915a7ecccba9f939276cd9bd9666ab0fa690fcae20579b0a5c4f2812753cb2c92854a2eb9cc43a71b620386951241325257f3bc7bb1e4c36da2f52296d8ff99f3391512c910fb391808144474c35bbc8bff1c7d68bcee6b7d6f764b4979d7d68a2f54d5c9e983be13475f5c7751c96b5fa36eec76c041f0d2b5b39a636063e8f32d9ebc7e9a19a40b0d4bb86ef9520fc97d7444d563a6ff1e8a9b0c6648d8d87880d6a173d8c4698795f1a5d0b58a55da724d8e300a590e0fb75369132b886f6c9aca7aa8e33b5cea0a36b0a4f39483e84adff2632b1b25ae6d034a94894882c3d330d1d57de7d1852dfc5c40cef37aea95900a9693921078e864f0723a77aa01711a57c1ac7a7a45bed891029788eac523399dd9e3b90562230fd8a52dce804d501942962af8de7bcab9b213300eb477678b518c15afc3097450e84a36bcc1de4020956dd8cb664d3314c03a09c3f0486506e5913dd60087a4c6143f6e6e7797977606e25b6cf1217b5feb55cf269fcf3bfda9df20872a5ae7a4662f1bbda896e9bf34710d2b50f09a8af746a171a59f0dda8dafbd50735ce6c3e9d61b9e1a8ecea850335ec53b8f9d1c1b04cdf1d59a9e4a3251d7b93014d8d16bf8000f3759abed6f4d218c8e172e2a9c0394c85e0787de02de997741e180e0270c5ffc8687e49350baa16c7bac4115250023d0a3f6ffeda13bddf0043a65cbd63e824e9fd555d6c011c317ea17d0de66f7c42988cf3f221e3f6a30fc3f4bcd0a3149f0ba74a5fa73fec57298ba950bf36d2921d008a17d28613848fc2101a795ba6eaf2cd8bc5f28bede00b8fe8549391cc988cf39297c19a2af2186676064fe0eb1fd37c6695804bf8fe3e2b7a7007b915e7f4df373b54c2c99f9572f72d91afa5d5422e0a78edbc906d29b9fafd658b84fe4d326e0fd12735d47f6dc232e592216c15ab3b0f1477e83f91c8ef2c820d12d05f5c4951a5f5bc4e9fda234a8f48293f27465573fc264586125303998c85be8b6a8661d44b208d2d445ef2998a33a023466d4ac08fa45872d8c583bec236ba75b98d968908ac12a72dab22000c8d30862651f9d3301d063bd8c6d3fa08fbb575689c181216a389b5551c29737a5eaaae90f05abde1b91e1168a68298c5214606244bd43ee4ba157f55e8d300aa621258f05cca99429459fde6a3164e2c13e1b96241284853f632b71c1e05379a33c98b87d238035aefb81af1836fefdc518f1bfa91c1c110ebfbb14eddcbe35805bab80d948a6c5f76a0f4df3ae1ec1960f81a7a2b5d2de3d2a8e1e3dda1a11d8ea8e5ae186138a8ef1b429e44d05f73f7e72ded5e1b3ba7bf02f83565d29cf7032c03afb2fe94015b7ebf83eb6a8cb671453245e6aac2a4fd5f100861626ed2c557e3fa87065dcb4576dbf29dd5c200b504eba78d3a16f48407f6f7b4142182e782d95ead0056aa0c4dcaabc09ee16f058784f0114a028d8aad88cb58192699e1bb1d53ea9363f7ab1c46fa4bb36c0e109ea365b5a8d19946504c82106f610284ff2abf9d74c7991ef9b2fb2a7ce2405b107082ff6cfba13fa6844cb3dd2320f09aebc1e5d4dcf9a110a60a98f7c648afab4edba921948043c2e7b40290a5cb3e461fe589f7a52786afc9f25430857ab9b606ef11c18804ab698ee956baf8bb27f0a575715e0b991a726d10b5b4f68ed56caf6704a10a84e8ec1eb7d25b09124b9d62a21da782826670c6e0b1887ec12df01be6be59164e5b535e0d2b17acc895031f0e9e16ce36091b2a5554b58f7d87da0644ae9c9f72cf11fcac4d89d154ec0a576f1e52b33a6573efd387a8f82db890975ed1bdba1ac979b4c1f435b1f7f940fb295672dc1f3d9d3ca4abcb613d9a2f40d99be501acce3554a44a4fb016a5af6a7070ef14f93838e269a4702259fc3b447c6375e83b7ee79ef3b00cc2e2d1c2392dc60221b915628c75421e98d8ad7e684c00c820f682c2adfd739ac7ed919c0566eb01842c99991d1da2aee4ba7107f8f03049962e37f50e2b40c29e78e05adadf8b6963a89724e190cd4938d4bd3a0d710749d72c7801a1fa6809186e4fb5f11f3f83d778eee9fc2060fbac209f6a9ee2fe21c63d24d8ce157d1a93b197a39b507cd106c82b8492d731c5a3431e8b9c89739ee2fbadd0defe6c6f29058796d6fb85892dba728e57ea85e14065da12a8607afde5632146033c723aefbc67bff690862baf179266373b4fd879c5624f94e4506cea4aa84cb49e49fcc62635309b835bb2fe01e8ae1e546d21fcd5edda1322312978319dbe970f036f6239b837bd06b539296df36ca5e1a3c88f08b0373ffdd1a69c0141c7b5240063c23df7bf525bcb8b1c81ffb5a7dd71a2c1a2cf08280a8bcc2a3ea441d57b265b330fcf232d32aab834ffadfc302590875cb773971843177dcc1a850cfe9e03743a5fa4b23c8a4f7fe10b622786822c2f95e44cd9c5301ad4389e8256b8b546ff5596973fb7d35d0a125b3d37dc56ca1b7be921bec9af6b3130d74da19e0fa747d1cc2e2ce0b59d717af04e978ad0f7b6964ed81968da0a244cd12bc2075df24c43673069f3e92c051935363870c2d8f1cecf9890adfad659815606d7945d76c79d0af15f100b4cc5cc30a8a94c883ed52f865318d988ddaa270f8a4681eee2b7b39b5d0126fe8afe5697d11b8943c9c197760e3319e5cb381719d91432a637c1108a48763ddc2a2315da5c26f59bdb2f0044142c4f8e4fdcbba98b51261aec7b03719dddc4b401ffec4d6dd63211ebad6596ca242488f4179a9698f862ea8da3de01a51d901f9f8650d230e1383732c36313e63862cca9f87ec703c1d63a37256b025842e6c7dab56fd835ef85cf06c447ded25058b6c972c5060c5708114543270a60ed09439a1866314af9f3578e72f281255b9bd2093f847c5f1de63f6d97b835451a881455beb254dfde6132f0f6627e77ca4253834745d928259ca1e2c502ca548ec0e769508f8bc6f374dd894922c52b23057990702f89cf7d41608629410248391489f818ae3e0ee54cb08d7f0cfb3deb2104baceaae4ad0d55e158322db00e07d3d724625a66d209dd7a6de5315e2c9f8b8948c336002867cd4e886373309b72df028ae91d4275c4899ece668796a8d673c0ee90fe10279885df76fad5c8c98caf4065aba2bca41785909cdfeedf007bb13040fd9475fca23715c5633e7c38eb0376a7fe130c6004eb348b3d1c53a0bb53e73badbf1873f6b7c2bd9d9e7d161f52ad1b1b081134a8c551eefd3f4775a7e85a28c68f87555b7fa5f3260e0a783c2799eadbacc17b70d6712e84d0377492885f2107f7228dceb4acc7fd96db467e7374f7870026fc57727fe251626be33bc563aa1fac8b549de5389e5e911d016a6173629b9480a32aa50b829e9bb67e85c49d2a0186dfd0d026ca54e3f53c9f90d25d30987b03ec012a58e4613692948b4ee42df5aa584ceb0c8a939c772112887a1d2bafa679990bf75aed988d317b7a4b23bcd86a4d18d6c2f71f8885d9e3e08f9e90b4837178b4e5eebfa8468622339c6a5164e05b39dc674ec441938fb34e2fc3f00be720661a75e3139d77afd0f26bd283e883b7f7ab01eb731b04d67f812df1e1196807eb85437786401fdc2343db726a466a266f3567767dee1f68c2fd032d713a7ec1a3132377b64291f49368c5eb675bbe0c00ca53e6ddcfd4831e15672377ef0f634e4e093f124734c2a7b289e9ade178ec60490abb949aacd2408941df8dd76de2c047aee84355db6bfd651c802e3108d0fd9612fcb7bbfc094d7b007c62dcc85bbe8094443f08860384290cffb91b4fe723ef8a7c31d5ebb1dda473052bc7b025caccbdd36e9e1d390066d5b3612817d20495fa1986051a477051a4af4baaff3d075034e8352d10dcdaa7cf6c8802675c84e43b0dfdb57fc5d00b220d6c1fc7556b72e666ca84ef342cca231acae7b7d61c4bed6b37cb74b8ba4113aa6348fc6ce0cf6b791754b706293641ea89d9d684babda50a44111f6890e0a5593c25c92d6e970af3678d841f0c6aac3fbe50307c1e0e2d128436ad525fd63cf1cadfffd33bb23554cbe53cf11b89e2b79193f5ca8972a0f765ac5719e931fec0e66ffb43f9f56db409ba4b1330b07515e2a7ee511dfdbb0a23ea5a48d9a6c5d26f18ee3ef05354096e1f6762a680281f7a9abc2ee14a4bdf7ad42c6f24fdc285c8fe984a788c36f39cc2080b0e0edc2f37d0a9ca149361163ce44d666664c8488d77a6191517a6c03eccafd51a93f3fa1df15c1ad9e4acf47b9e3d8c9eecb2cdd504473cae7c860c565f86d4e011571e73b2201b284ec94fc0655f7283020e20bc49d02a9e374e6d72c3b5cbad85b3ab2146abe724d3cf17d465e98965e717664b28dc16b165427652b645b4f17dc06f04c67605844f2676158aa969f8feaecbd36d120ca4fd0b1c268900b95a8e0bc434703d78fbed70db3ac16cb1f422042492b64ed8fa2814c119c323b36d2b4fe6e792c5bb884c13e548778fd7c1d88f335f78a92cc69519683e167b3cd480d02c7439806c37a4b6ef7cb3a6c2d898c5057faa289123815d3ae9e757104d7984a95e42eb6d3036f9f4d38b5303c84dba36890dfc7200d7e5e553c6f9ac3bf9ac9d160c266aa5370a30d70d9c92477cfe6ddeb0dfdb3c4e2c9fd80c4a2eef27c8a43613523ff081849504679df1d8699712c105940ae5dc2266a39cc473ebe97e9262b71d9130cb08faa2f3d24e43f3864c7243a864b82179eae2ca25d13a22b38b1c91cac443eff9dd3315e3f595dc5363f5df4a0c39f16cd610c66e82c940fff4099dce73303ee15c47575e610fedc9639046f5660aa9896bcfde3fd0c505985fc86f9ed5cfa4551f5206f3a700bb4096b861fc88a2e426a64a2a2e884c01581a73c57ec6e349b4b3f5768e430fc7226589faaa8012c6cb3f9c6946088bd05241fcc0e364bacc19c144264266cd2be6119174bda7efc0bf97e6adf6ab093200d2fda2e8ed88ed3893658e08c864dd5228051a1c448f26bd506dc90dcdb6b94973b99673b9eccb2373ccf5e70b0e856c112e888e5831ac4951ad23430b2ffdeae8d492d75e0d6af15cd760693466ea25bbb7faa8a1f6bbcd9fe905af5681aeb9e3ebb4766494366e30105b6a81d0f10d1a1e8c7a96727c5d5f550ac107ea950dfe4ab3977da010ecf3788a4de1f03d81d50541e302aae38a82b9b5c62243cd6c7656617bacc95bb759b48de038805bfdb140f4cddf117592ac3db02e4bb7b509b1fc287bbd7804e8a31e437bc6ae746987dfb315e0dc928945642f9975f9f677632145ebdce78aeb7ae144ab6618844188aca188cf5a5fd73907092e7b98b379652da57342765b1115c56dd893298e5f7c947d86feb9fe008b91cac5f96da64d96d17118e7b3b6854aa220083c4e5502825bd819e65afd184ba93445b860936e11d6d3b4cee59dd30c65843cc20bf5091762980fc8b16b4f8e2d25083c2e0ba23870073e1a8cfe0e35d0e95ae30f5f06303fdf1c6b6dbccbb5e25c965e1f20a985cdf681f9a9ffd1386e61431e3eaa3c4579516044087a10f717d5113b0e795d1b5bc48b7c65a210176b6d7b205a95d08c7373aaa731a5a96e3bbc36c6fa807057d55b1b158bee4c8b156a5f3cc58d7aed0167ab5fc678e3dfb93ace4812e12523b6013d0da31d0f243162fc5328bbe646dcf0d5f793acaea03e0de24c15c4c5e04317c2ca05ed33adb577c4c516bc9d88b593f9aed4eb2a770e374985544ff64d077fe5f6613b9055c2952cd278952536111f6dbb7950cc4c7a45d3bc4acf320cdfdc9f3a3a117b396cf633b0e8da3e8ef2010063690935bc1aa8cdb50603fffe9a8c48046f291f35cf1a65ee50fbf1340c3c1842c484f8c37b9ca7f78dd4b70360f89cd608dc616f5f8d00274eaa3b76c82672ab217603ce673ba43bc9e6c932a4ce4d9448e5235f733fa5ed7bc153c6259bf9d265819e5df3315195189f34029680f2c83c0660f890497d48742de0f788a15e6c1208dc3c84ff6e8480db1bd13db6c59035590837c4f863e932b7fe3556c391463443d4c5d63ab663d5d4f5f5d84bb739c422437a4a05e9347e31a90cd1e5b7ad83a08364b4b59a442a253542361e56affc06a040e04fa067727d6515001d0542430b099927e8a2421021f6e524ebed7035e1719cde36f6199d6cdf2b27a7ddc58df1984f1a014a1bc10646f6201d4b3d35804bcb578b09a903ab9fc1501906496cb43b1fc1a49f7fee0c6c9bb0929d930dbd9e2ba558ef8204ff0e788b108d8c6fbd9b74119583a71c62fab5e2cc3cef07bd63b6afdc584539f8786cac7c4ae91d750a49fb956da5991f8752ccaed934085df91aa41e8b947f26a4aa8a698ad0412a7265f0933c2002e02547bad89cc908008dcbc7b86b56a90d40b75c5839489b7612a69b49cff636b825fcf4acfadf224a32d262bd471f0b02eafcd0aba6095c4abb19e72dd44eda14beeee79fac824a3452700b1de75be9428d42672dd2d999fc8d0470ab18377ca0abb6478fe0e3533baa2bb6d53df73d8988b5f3c56bd7345517397c31d198ffdd67bead1eb8037f2752c415fce25c11c374d92b332ea12ca34b594f37d8c2c6d1f01d600d37b7021cbe24bbd9ba7655e365f347f19baa531283470a810b4e50390c0c54ff55b466546ae8ebf4d41634c8c95467d898307efd4b6a600c4ede1fd0e2d5b8bc7412407b8acc186696b770c530c5cff57e9a689feb744da85e00e7fe1907c35f4058be9e046e5ee9fe828cc20698b6662af514863701cbb97cafb68fb9f473bf58904b08f1f36ebadd37f3511b31b4f833248c49ee1462a3c55c748f5ed02b7109859ddac6ccca12d5d815b0dc3a87b2301ac729c21f4749d38979149391e5e78b2c7d77b5531e19f6c8d9fd60cf73f65cea3a947ad25e7f6fc35422456f89c8d7fc35ce51ea3b7e7f20dde6696937e66ed507f2fae610350becc80799ebfd675779fd22196cd55e2d14ce7e6b9565d75fd0cab585f5e80eec2934d4135297f90a66a633721380d1dcda6a2eb424e61cf9042945a562c6dbc3165e9450dd96d91a49ce8fd04e7498c4e2485e36969305833a99bb0b17586235b287126ae3de9a39553b891372b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3349 小星星 题解</title>
    <link href="/2021/lg3349-solution/"/>
    <url>/2021/lg3349-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>设 <span class="math inline">\(f_{x,i}\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中，节点 <spanclass="math inline">\(x\)</span> 映射到图中节点 <spanclass="math inline">\(i\)</span> 的方案数。</p><p>转移 <span class="math display">\[f_{x,i} = \prod_{y \in son(x)} \sum_{j \in G}{f_{y,j}}\]</span> 答案为 <span class="math inline">\(\sum_{i \in [1,n]}f_{1,i}\)</span></p><p>复杂度是 <span class="math inline">\(O(3^n n)\)</span>的，考虑优化。</p><p>题目给出了两条限制</p><ol type="1"><li>每条树边都要在图中出现</li><li>每个编号仅出现 1 次</li></ol><p>不难发现，DP 枚举点的过程已经满足了条件 <spanclass="math inline">\(1\)</span>。</p><p>考虑第二个条件。如果有编号出现不止一次，那么一定有编号没有出现，等价于有点没有被选到。我们无法直接求出答案，但可以构造容斥。<spanclass="math inline">\(0\)</span> 个点没有被选的方案数-至少 <spanclass="math inline">\(1\)</span> 个点没有被选的方案数+至少 <spanclass="math inline">\(2\)</span> 个节点没有被选的方案数……</p><p>枚举每个点被选的情况，容斥一下，最后就是正确答案了。</p><p>复杂度 <span class="math inline">\(O(2^n n^3)\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">20</span>;<span class="hljs-keyword">int</span> n, m, s, tot;<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> tc, hc[N], vc[N*N], nc[N*N];ll ans, dlt, f[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j, k, y;    <span class="hljs-keyword">bool</span> fg=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i];        <span class="hljs-built_in">dp</span>(y,x), fg=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(!fg) &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!((s&gt;&gt;(i<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>)) f[x][i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 特判</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!((s&gt;&gt;(i<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>)) &#123;        f[x][i]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(j=h[x];j;j=nxt[j]) <span class="hljs-keyword">if</span>(ver[j]!=fr) &#123;            y=ver[j];            ll o=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(k=hc[i];k;k=nc[k]) o+=f[y][vc[k]];            f[x][i]*=o;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, x, y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), <span class="hljs-built_in">addc</span>(x,y), <span class="hljs-built_in">addc</span>(y,x);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    <span class="hljs-keyword">for</span>(s=<span class="hljs-number">0</span>;s&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++s) &#123;        tot=dlt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>((s&gt;&gt;i)&amp;<span class="hljs-number">1</span>) ++tot;        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));        <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) dlt+=f[<span class="hljs-number">1</span>][i];        <span class="hljs-keyword">if</span>(tot&amp;<span class="hljs-number">1</span>) ans-=dlt; <span class="hljs-keyword">else</span> ans+=dlt;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>容斥原理</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3267 侦察守卫 题解</title>
    <link href="/2021/lg3267-solution/"/>
    <url>/2021/lg3267-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>本题难点，在于设计「互补」的状态。</p><p>每个守卫覆盖的 <span class="math inline">\(d\)</span>的方向是任意的，不能再像传统树形 DP 那样状态单单表示子树信息。</p><span id="more"></span><p>定义「上方」为向根的方向，「下方」为子树内。</p><p>设 <span class="math inline">\(f_{x,i}\)</span> 为覆盖 <spanclass="math inline">\(x\)</span>下方的关键点，并且<strong>能够</strong>向上方覆盖 <spanclass="math inline">\(i\)</span> 范围内的关键点，所需要的最小代价。</p><p>设 <span class="math inline">\(g_{x,i}\)</span> 为覆盖 <spanclass="math inline">\(x\)</span> 下方 <spanclass="math inline">\([i,d]\)</span>范围内的关键点，所需要的最小代价。</p><p>这样， <span class="math inline">\(f\)</span> 与 <spanclass="math inline">\(g\)</span> 就能拼凑出正确的答案。</p><p> </p><p>边界 <span class="math display">\[g_{x,i}=w_x, g_{x,d+1}=\inf \quad i \in [1,d]\]</span> 考虑转移。 <span class="math display">\[g_{x,i} = \min_{y \in son(x)}{ \{ f_{y,i}+g_{x,i},f_{x,i+1}+g_{y,i+1}\}  }\]</span></p><p>因为 <span class="math inline">\([i,d]\)</span> 的代价一定能够覆盖<span class="math inline">\([i-1,d]\)</span>，所以</p><p><span class="math display">\[g_{x,i} = \min_{i \in [0,d]} { \{  g_{x,i+1}\} }\]</span></p><p>接着不难想到 <span class="math display">\[f_{x,0}=g_{x,0}\]</span></p><p><span class="math display">\[f_{x,i}=\sum_{y \in son(x)} {f_{y,i-1}} \quad i \in [1,d+1]\]</span> 向上覆盖 <span class="math inline">\(i+1\)</span>的代价，一定能够覆盖 <span class="math inline">\(i\)</span>，所以 <spanclass="math display">\[f_{x,i}=\min_{i \in [1,d+1]}{ \{ f_{x,i-1} \} }\]</span> 答案 <span class="math inline">\(f_{1,0}\)</span></p><p>复杂度 <span class="math inline">\(O(nd)\)</span></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, m, d, w[N], f[N][<span class="hljs-number">20</span>], g[N][<span class="hljs-number">20</span>];<span class="hljs-keyword">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++c]=y, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j, y;    <span class="hljs-keyword">if</span>(v[x]) f[x][<span class="hljs-number">0</span>]=g[x][<span class="hljs-number">0</span>]=w[x];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=d;++i) g[x][i]=w[x]; g[x][d+<span class="hljs-number">1</span>]=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>);    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i], <span class="hljs-built_in">dp</span>(y,x);        <span class="hljs-keyword">for</span>(j=d;j&gt;=<span class="hljs-number">0</span>;--j) g[x][j]=<span class="hljs-built_in">min</span>(g[x][j]+f[y][j],g[y][j+<span class="hljs-number">1</span>]+f[x][j+<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(j=d;j&gt;=<span class="hljs-number">0</span>;--j) g[x][j]=<span class="hljs-built_in">min</span>(g[x][j],g[x][j+<span class="hljs-number">1</span>]);        f[x][<span class="hljs-number">0</span>]=g[x][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=d+<span class="hljs-number">1</span>;++j) f[x][j]+=f[y][j<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=d+<span class="hljs-number">1</span>;++j) f[x][j]=<span class="hljs-built_in">min</span>(f[x][j],f[x][j<span class="hljs-number">-1</span>]);        <span class="hljs-comment">// 注意转移的循环顺序</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, x, y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x), v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3225 矿场搭建  题解</title>
    <link href="/2021/lg3225-solution/"/>
    <url>/2021/lg3225-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>本题思路还是比较清晰的。</p><p>显然的，求出 v-DCC 并缩点，然后判断方案数。</p><span id="more"></span><p>在本题中，可以只用 Tarjan 算法求出割点。标记割点，从其他的点依次DFS，统计每颗搜索树上割点的数量（不重复统计）。</p><p>若图中没有割点，那么图中任选两个节点都能满足条件，答案 $(2,C_n^2)$</p><p>若搜索树上割点为1，则由于树上两点之间有且仅有一条简单路径，所以这颗搜索树中一定至少选一个点，累加答案，累乘方案数。</p><p>若割点多于 1，那么对答案是没有贡献的。</p><p>因为无论哪一个点被破坏，该搜索树都会分裂成为上述两种情况。</p><p>这种做法实现细节较多。</p><p>姑且算是 $ O(n^2)$？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">505</span>;<span class="hljs-keyword">int</span> t, n, m, num, cnt, fg, ans1, dfn[N], low[N], v[N], w[N];<span class="hljs-keyword">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans2;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++c]=y, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y;    dfn[x]=low[x]=++num, v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;        y=ver[i];        <span class="hljs-comment">// v数组在一定程度上起到了dfn数组的作用，可以少清空一个数组</span>        <span class="hljs-keyword">if</span>(!v[y]) &#123;            <span class="hljs-built_in">tarjan</span>(y);            low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);            <span class="hljs-keyword">if</span>(dfn[x]&lt;=low[y]) ++v[x];        &#125; <span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);    &#125;    <span class="hljs-keyword">if</span>((x==<span class="hljs-number">1</span>&amp;&amp;v[x]&gt;<span class="hljs-number">2</span>)||(x&gt;<span class="hljs-number">1</span>&amp;&amp;v[x]&gt;<span class="hljs-number">1</span>)) v[x]=<span class="hljs-number">2</span>;    <span class="hljs-comment">// 1为普通点，2为割点。注意v[x]在上面已经初始化为1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y;    v[x]=<span class="hljs-number">114514</span>, ++cnt;    <span class="hljs-comment">// 放置重复搜索，统计节点数</span>    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;        y=ver[i];        <span class="hljs-keyword">if</span>(v[y]==<span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(y,z);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[y]==<span class="hljs-number">2</span>&amp;&amp;w[y]!=z) ++fg, w[y]=z;        <span class="hljs-comment">// 防止搜索成环</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">SET</span>(v,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(w,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>);    c=ans1=n=<span class="hljs-number">0</span>, ans2=<span class="hljs-number">1ll</span>;    R <span class="hljs-keyword">int</span> i, x, y;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);        n=<span class="hljs-built_in">max</span>(n,<span class="hljs-built_in">max</span>(x,y));    &#125;    <span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// luogu给出的数据是联通的</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>,num=<span class="hljs-number">0</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(v[i]==<span class="hljs-number">1</span>) &#123;        fg=cnt=<span class="hljs-number">0</span>, ++num;        <span class="hljs-built_in">dfs</span>(i,num);        <span class="hljs-keyword">if</span>(fg==<span class="hljs-number">1</span>)  ++ans1, ans2*=cnt;        <span class="hljs-comment">// 从非割点搜索</span>    &#125;    <span class="hljs-keyword">if</span>(!ans1) ans1=<span class="hljs-number">2</span>, ans2=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %d %lld\n&quot;</span>,++t,ans1,ans2);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m)&amp;&amp;m) <span class="hljs-built_in">sol</span>(); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1967 货车运输 题解</title>
    <link href="/2021/lg1967-solution/"/>
    <url>/2021/lg1967-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>题目要求不超过限重，不难想到因该最大化每条路的限重。所以在原图上求出最大生成树。</p><p>对于点 <span class="math inline">\((x,y)\)</span>，如果在并查集中<span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 不在同一个集合，则 <spanclass="math inline">\(x\)</span> 不能到达 <spanclass="math inline">\(y\)</span></p><span id="more"></span><p>接下来就是每辆车最多运送的货物，不难想到最多运送的货物就是 $ (x y)$路径上权值最小的边。</p><p>如果用朴素的算法去求最小的边权，那么复杂度会上天，<spanclass="math inline">\(O(n)\)</span>。</p><p>联系我们对求 LCA的倍增优化，可以对求路径上最小的边权进行倍增优化。</p><p>设 <span class="math inline">\(d(x,k)\)</span> 为节点 x$ 到它的 <spanclass="math inline">\(2^k\)</span> 辈祖先这条路径上最小的边权。</p><p>接着不难想到转移 <span class="math display">\[d(x,k)=\min_{k \le \log_2n}{ \{ d(x,k-1),d(f(x,k-1),k-1) \} }\]</span> 可以在求 $ f$ 数组的同时求出。</p><p>所以，在求 LCA 的过程中不断维护路径上最小的 $ d(x,k)$。</p><p>这题毒瘤数据，给出的图不一定联通。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>, M=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, m, q, t, o;<span class="hljs-keyword">int</span> fr[N], f[N][<span class="hljs-number">20</span>], d[N][<span class="hljs-number">20</span>], dep[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], g[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt</span> &#123;</span> <span class="hljs-keyword">int</span> u, v, w; &#125; a[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++cnt]=y, g[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fr[x]? x:fr[x]=<span class="hljs-built_in">get</span>(fr[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pt a,pt b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.w&gt;b.w; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+m+<span class="hljs-number">1</span>,cmp);    R <span class="hljs-keyword">int</span> i, x, y;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        x=<span class="hljs-built_in">get</span>(a[i].u), y=<span class="hljs-built_in">get</span>(a[i].v);        <span class="hljs-keyword">if</span>(x!=y) &#123;            fr[x]=y;            <span class="hljs-built_in">add</span>(a[i].u,a[i].v,a[i].w), <span class="hljs-built_in">add</span>(a[i].v,a[i].u,a[i].w);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> pre)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y;    dep[x]=dep[pre]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">17</span>;++i) &#123;        f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];        d[x][i]=<span class="hljs-built_in">min</span>(d[x][i<span class="hljs-number">-1</span>],d[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=pre) &#123;        y=ver[i];        f[y][<span class="hljs-number">0</span>]=x, d[y][<span class="hljs-number">0</span>]=g[i], <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, res=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x)!=<span class="hljs-built_in">get</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;        <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) res=<span class="hljs-built_in">min</span>(res,d[x][i]), x=f[x][i];        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) &#123;        res=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(res,d[x][i]),d[y][i]);        x=f[x][i], y=f[y][i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(res,d[x][<span class="hljs-number">0</span>]),d[y][<span class="hljs-number">0</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, x, y;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) fr[i]=i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i].u,&amp;a[i].v,&amp;a[i].w);    <span class="hljs-built_in">kruskal</span>();    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!dep[i]) <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">lca</span>(x,y));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最近公共祖先</tag>
      
      <tag>生成树</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF372C Watching Fireworks is Fun 题解</title>
    <link href="/2021/cf372c-solution/"/>
    <url>/2021/cf372c-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="题外话">题外话</h2><p>前天英语考试，作文是</p><blockquote><p>假如你是李华，你的美国朋友 Jack对中国传统文化很感兴趣，他写信希望你能够告诉他有关春节的事情，请你写一封回信给他。开头和结尾已经给出，不计入总词数……</p></blockquote><p>然后因为做过这道题，我就记住了 Firework这个词，在这篇作文中竟然用上了（</p><span id="more"></span><h2 id="solution">solution</h2><p>设 <span class="math inline">\(f_{i,j}\)</span> 为第 <spanclass="math inline">\(i\)</span> 个烟花 <spanclass="math inline">\(blooms\)</span> 时，在第 <spanclass="math inline">\(j\)</span> 个位置所能得到的最大开心值。</p><p>边界 <span class="math inline">\(f_{0,i}=0 \quad i \in[1,n]\)</span>。</p><p>转移是显然的（好像这类题的朴素转移都挺显然的） <spanclass="math display">\[f_{i,j} = \min_{1 \le k \le n} { \{ f_{i-1,k} + b_i - \left| a_i-j\right| \} }\]</span> 然后得到了一个喜人的复杂度 <spanclass="math inline">\(O(mn^2)\)</span></p><p>考虑优化，期望复杂度 <span class="math inline">\(O(mn)\)</span>。</p><p>首先是 <span class="math inline">\(n \le 1.5 \times 10^5,m \le300\)</span>，空间不能承受，并且阶段 $ i$ 只与阶段 <spanclass="math inline">\(i-1\)</span> 有关，滚动数组优化即可。</p><p>优化后只有两维，设当前维度为 $ w$，另一维为 <spanclass="math inline">\(w \text{ xor } 1\)</span>。</p><p>不难发现转移的瓶颈在于枚举 <spanclass="math inline">\(k\)</span>，且状态符合 1D/1D模型，考虑单调队列优化。</p><p>设 $ i-1$ 阶段，位置在 <span class="math inline">\(k\)</span>。对于 $(i,j)$，能够向右移动到为区间为 <span class="math display">\[[k, \min \big( j+ d \cdot (t_i-t_{i-1}) \big) ]\]</span> 枚举每个合法的 <spanclass="math inline">\(k\)</span>，在单调队列中维护 <spanclass="math inline">\(f_{w \text{ xor } 1,j}\)</span> 单调减。</p><p>能够向左到达的区间为 <span class="math display">\[[ \max \big( 1,j- d \cdot (t_i-t_{i-1}) \big), k ]\]</span> 排除掉队首小于左边界的决策即可。</p><p>设队首为 $ k$。</p><p>最終の轉移！ <span class="math display">\[f_{w,j} = f_{w \text{ xor } 1,k}+b_i- \left| a_i-j \right|\]</span> 虽然有枚举合法区间内的决策，但无伤大雅，可以看作常数。</p><p>复杂度 <span class="math inline">\(O(mn)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">150005</span>, M=<span class="hljs-number">305</span>;<span class="hljs-keyword">int</span> n, m, d, l, r, w=<span class="hljs-number">1</span>, q[N];ll a[M], b[M], t[M], f[<span class="hljs-number">2</span>][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, j, k, o, u;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        l=k=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;            o=<span class="hljs-built_in">min</span>(<span class="hljs-number">1ll</span>*n,j+d*(t[i]-t[i<span class="hljs-number">-1</span>]));            u=<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,j-d*(t[i]-t[i<span class="hljs-number">-1</span>]));            <span class="hljs-keyword">for</span>(;k&lt;=o;++k) &#123;                <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;f[w^<span class="hljs-number">1</span>][q[r]]&lt;=f[w^<span class="hljs-number">1</span>][k]) --r;                q[++r]=k;            &#125;            <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;u) ++l;            f[w][j]=f[w^<span class="hljs-number">1</span>][q[l]]-<span class="hljs-built_in">abs</span>(a[i]-j)+b[i];        &#125;        w^=<span class="hljs-number">1</span>;       &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i;    R ll ans=-(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;d);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;a[i],&amp;b[i],&amp;t[i]);    <span class="hljs-built_in">sol</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[w^<span class="hljs-number">1</span>][i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2680 运输计划 题解</title>
    <link href="/2021/lg2680-solution/"/>
    <url>/2021/lg2680-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>最小化完成所有任务的时间，考虑二分答案。</p><p>用 <span class="math inline">\(lca\)</span>算法预处理每个计划的距离，设第 <span class="math inline">\(i\)</span>个计划的距离为 <span class="math inline">\(W_i\)</span></p><span id="more"></span><p>如何判断完成任务的时间 <span class="math inline">\(t\)</span>是否可行呢？</p><p>不难想到，有以下两种情况。</p><ol type="1"><li>$ _{1 i m}{ { W_i }} t$。</li><li>将一条边权 为 <span class="math inline">\(dlt\)</span> 的边改为0（虫洞）后，$ _{1 i m}{ { W_i - dlt }} t$。</li></ol><p>第一种情况很容易判断。</p><p>对于第二种情况，不难发现：将一条边权为 <spanclass="math inline">\(len\)</span> 的边改为 0 后能使所有距离大于 <spanclass="math inline">\(t\)</span> 的计划距离都变成不大于<spanclass="math inline">\(t\)</span>，当且仅当这些计划交于此边，且 $ len _{1i m}{ { W_i - t }}$</p><p>这是显然的，证明略。</p><p>明确这个之后，问题仅仅在于，如何快速统计每条边被计划经过的次数和权。</p><p>边权不难求，用倍增 <span class="math inline">\(lca\)</span> 的 <spanclass="math inline">\(f\)</span> 与 <spanclass="math inline">\(dis\)</span> 数组即可。设 <spanclass="math inline">\((x \rightarrow f(x,0))\)</span> 边权为 <spanclass="math inline">\(d_x\)</span>，到根的距离为 <spanclass="math inline">\(dis_x\)</span></p><p>则 $ d_x=dis_x-dis(f(x,0)) $</p><p>考虑统计经过次数。</p><p>如果朴素地去统计，复杂度是 $ O(n)$ 的。可以用树上差分。</p><p>用一个计数数组 $ K$ 记录差分，计划 $ (x y)$，令 <spanclass="math display">\[K(x)+1,K(y+1),K(z)-2 \quad z=lca(x,y)\]</span>然而这个不像一般树上差分一样，统计子树信息。而且上述做法是边权差分，需要转化成点。</p><p>考虑每个计划路径是一条链，所以只需要统计每条链的信息就行了。</p><p>我们记录搜索树中每次访问到的点，即为 $ idf$。因为搜索树是一个DAG，所以这个东西倒序就是逆拓扑序。</p><p>按照这个顺序令 $ K(f(idf(x),0))+K(idf(x))$就能自底向上统计出每个点的信息。</p><p>然后判断上述两种情况就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m, cnt, d[N], dis[N], f[N][<span class="hljs-number">18</span>], k[N], idf[N];<span class="hljs-keyword">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span> <span class="hljs-keyword">int</span> x, y, z, w; &#125; g[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=(a&lt;&lt;<span class="hljs-number">1</span>)+(a&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, y, z;    idf[++cnt]=x, d[x]=d[fr]+<span class="hljs-number">1</span>, f[x][<span class="hljs-number">0</span>]=fr;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;d[x];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i], z=w[i];        dis[y]=dis[x]+z, <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=d[x]-d[y];j;++i,j&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) x=f[x][i];    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, tot=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(k,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(k));    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">if</span>(g[i].w&gt;x) &#123;        ++k[g[i].x], ++k[g[i].y], k[g[i].z]-=<span class="hljs-number">2</span>;        ans=<span class="hljs-built_in">max</span>(ans,g[i].w-x), ++tot;    &#125;    <span class="hljs-keyword">if</span>(!tot) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=n;i;--i) k[f[idf[i]][<span class="hljs-number">0</span>]]+=k[idf[i]];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(k[i]==tot&amp;&amp;dis[i]-dis[f[i][<span class="hljs-number">0</span>]]&gt;=ans) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, x, y, z, l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, mid;    n=<span class="hljs-built_in">r_</span>(), m=<span class="hljs-built_in">r_</span>();    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), z=<span class="hljs-built_in">r_</span>();        r+=z, <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), z=<span class="hljs-built_in">lca</span>(x,y);        g[i].x=x, g[i].y=y, g[i].z=z;        g[i].w=dis[x]+dis[y]-(dis[z]&lt;&lt;<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">while</span>(l&lt;r) &#123;        mid=l+r&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(mid)) r=mid; <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分答案</tag>
      
      <tag>最近公共祖先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2446 大陆争霸 题解</title>
    <link href="/2021/lg2446-solution/"/>
    <url>/2021/lg2446-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>每个点都必须在到到达所有保护它的点后才能进入，我们用一种类似拓扑排序的方式求解。</p><span id="more"></span><p>设 <span class="math inline">\(p(x)\)</span> 为能够到达节点 <spanclass="math inline">\(x\)</span> 最早的时间，<spanclass="math inline">\(q(x)\)</span> 为能够进入节点 <spanclass="math inline">\(x\)</span> 最早的时间，<spanclass="math inline">\(d(x)\)</span> 为摧毁 <spanclass="math inline">\(x\)</span> 最早的时间。</p><p>设 <span class="math inline">\(ind(x)\)</span> 为保护节点 <spanclass="math inline">\(x\)</span> 的点的个数。</p><p>显然 <span class="math inline">\(p(x)\)</span>可以直接用最短路算法求出。</p><p>设 <span class="math inline">\((x \rightarrow y)\)</span>，则 <spanclass="math display">\[q(y)= \max{\{d(x)\}}\]</span> <span class="math inline">\(x\)</span> 被摧毁后自然能够到达<span class="math inline">\(y\)</span>。</p><p>当保护节点 <span class="math inline">\(x\)</span>的点处理完之后，就能进行 <span class="math inline">\(d(x)\)</span>的转移。</p><p>因为有无限多的机器人，所以节点 <span class="math inline">\(x\)</span>能够到达的那一刻就能够被摧毁。 <span class="math display">\[d(x)= \max{\{ p(x),q(x) \}}\]</span> 具体细节看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">10</span>, M=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m, d[N], p[N], q[N], ind[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[M&lt;&lt;<span class="hljs-number">1</span>], nxt[M&lt;&lt;<span class="hljs-number">1</span>], w[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> tc, hc[N], vc[M&lt;&lt;<span class="hljs-number">1</span>], nc[M&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">()</span> </span>&#123;R <span class="hljs-keyword">int</span> i, x, y, z;R priority_queue&lt;PII &gt; pq;<span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d)), <span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p));d[<span class="hljs-number">1</span>]=p[<span class="hljs-number">1</span>]=q[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">size</span>()) &#123;x=pq.<span class="hljs-built_in">top</span>().second, pq.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(p[y]&gt;d[x]+z) &#123;p[y]=d[x]+z;<span class="hljs-keyword">if</span>(!ind[y]) d[y]=<span class="hljs-built_in">max</span>(p[y],q[y]), pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;&#125;<span class="hljs-keyword">for</span>(i=hc[x];i;i=nc[i]) &#123;y=vc[i], q[y]=<span class="hljs-built_in">max</span>(q[y],d[x]);<span class="hljs-keyword">if</span>(--ind[y]==<span class="hljs-number">0</span>) &#123;d[y]=<span class="hljs-built_in">max</span>(p[y],q[y]);pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;R <span class="hljs-keyword">int</span> i, j, x, y, z;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z), <span class="hljs-built_in">add</span>(x,y,z);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-keyword">while</span>(x--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y), ++ind[i], <span class="hljs-built_in">addc</span>(y,i);&#125;<span class="hljs-built_in">dijk</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,d[n]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3953 逛公园 题解</title>
    <link href="/2021/lg3953-solution/"/>
    <url>/2021/lg3953-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>首先跑最短路，本题并不卡那个死掉的算法。</p><p>求出 1 号节点到每个点的最短路 <spanclass="math inline">\(d\)</span>。</p><p>然后考虑计数。</p><span id="more"></span><p>计数可以考虑 DP，但是必须满足无后效性。</p><p>设计一个类似于分层图的状态。</p><p><span class="math inline">\(f(x,k)\)</span> 为 1 号节点到 <spanclass="math inline">\(x\)</span> 号节点，距离为 <spanclass="math inline">\(d(x)+k\)</span> 的方案数。</p><p>考虑转移，假定 <span class="math inline">\(f(y,k_2)\)</span> 能转移到<span class="math inline">\(f(x,k_1)\)</span>。</p><p>设 <span class="math inline">\((x \rightarrow y)\)</span> 边权为<span class="math inline">\(z\)</span>，则有 <spanclass="math display">\[d(y)+z+k_2=d(x)+k_1\]</span> <span class="math display">\[k_2=d(x)-d(y)-z+k_1\]</span></p><p>转移为 <span class="math display">\[f(x,k)= \sum_{x \rightarrow y} {f(y,d(x)-d(y)+k-z)}\]</span> 对于 <span class="math inline">\((x \rightarrowy)\)</span>，关于 <span class="math inline">\(x\)</span>的状态反而依赖关于 <span class="math inline">\(y\)</span>的状态。那么必定是建反图，然后记忆化搜索。</p><p>边界 <span class="math inline">\(f(1,0)=1\)</span></p><p>答案 <span class="math display">\[\sum_{0 \le i \le K} f(n,i)\]</span>  </p><p>考虑无解的情况。</p><p>题目描述中告诉我们有 0 边。</p><p>我们发现，有无穷多条合法路径，当且仅当有边权为 0的环。又因为没有负边权，所以 0 环一定由若干 0 边构成。</p><p>如何找出 0 环呢？</p><p>观察我们的转移，不难想到，在 0 边上，<spanclass="math inline">\(k=d(x)-d(y)+k-z\)</span>，即会递归到 <spanclass="math inline">\(f(y,k)\)</span></p><p>如果有 0 环，那么一定又会再次访问到 <spanclass="math inline">\(f(x,k)\)</span>。</p><p>所以对于每个 <span class="math inline">\(f(x,k)\)</span>，用 <spanclass="math inline">\(v(x,k)\)</span>来记录访问情况。每访问到一个状态，将其记为 1，访问完之后就改回0。如果访问到 1 的状态，就证明有 0 环，无解。</p><p>这也恰好说明了，这个状态是“无环”的。并不是真的不可能存在环，但是如果访问一圈回到<spanclass="math inline">\(f(x,k)\)</span>，说明存在环，也就直接无解了，不需要再考虑别的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SET(x,y) memset(x,y,sizeof(x))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> t, n, m, K, P, ans, QwQ, f[N][<span class="hljs-number">66</span>], d[N], fa[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> cnt2, h2[N], ver2[N&lt;&lt;<span class="hljs-number">1</span>], nxt2[N&lt;&lt;<span class="hljs-number">1</span>], w2[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N], vis[N][<span class="hljs-number">66</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=(a&lt;&lt;<span class="hljs-number">1</span>)+(a&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver2[++cnt2]=y, w2[cnt2]=z, nxt2[cnt2]=h2[x], h2[x]=cnt2; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">()</span> </span>&#123;priority_queue&lt;PII &gt; q;<span class="hljs-built_in">SET</span>(d,<span class="hljs-number">0x3f</span>);d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">int</span> x=q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z) &#123;d[y]=d[x]+z;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">mp</span>(-d[y],y));&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span>(k&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(vis[x][k]) &#123; QwQ=<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">if</span>(f[x][k]) <span class="hljs-keyword">return</span> f[x][k];<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;vis[x][k]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h2[x];i;i=nxt2[i]) &#123;<span class="hljs-keyword">int</span> y=ver2[i], z=w2[i];(ans+=<span class="hljs-built_in">dp</span>(y,d[x]-d[y]+k-z))%=P;<span class="hljs-keyword">if</span>(QwQ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;vis[x][k]=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> f[x][k]=ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-built_in">r_</span>();t--;) &#123;n=<span class="hljs-built_in">r_</span>(), m=<span class="hljs-built_in">r_</span>(), K=<span class="hljs-built_in">r_</span>(), P=<span class="hljs-built_in">r_</span>();<span class="hljs-keyword">while</span>(m--) &#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), z=<span class="hljs-built_in">r_</span>();<span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add2</span>(y,x,z);&#125;<span class="hljs-built_in">dijk</span>();<span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>, ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;++i) ans=(ans+<span class="hljs-built_in">dp</span>(n,i))%P;<span class="hljs-keyword">if</span>(QwQ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);QwQ=cnt=cnt2=<span class="hljs-number">0</span>;        <span class="hljs-built_in">SET</span>(v,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(vis,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(h,<span class="hljs-number">0</span>), <span class="hljs-built_in">SET</span>(h2,<span class="hljs-number">0</span>);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu1600 天天爱跑步 题解</title>
    <link href="/2021/lg1600-solution/"/>
    <url>/2021/lg1600-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>经典树上差分。</p><span id="more"></span><p>考虑能观察到玩家的条件，不难发现，对于每个观察员 <spanclass="math inline">\(x\)</span>，能观察到玩家 <spanclass="math inline">\(i\)</span>，当且仅当满足</p><ol type="1"><li>$ d(s_i)-d(x)=w_x$</li><li>$ d(s_i)+d(x)-2 d(lca(s_i,t_i))=w_x$</li></ol><p>上述两式可化为 <span class="math display">\[d(s_i)=w_x+d(x)\]</span> <span class="math display">\[d(s_i)-2 \times d(lca(s_i,t_i))=w_x-d(x)\]</span></p><p>观察员可以看作点。</p><p>对于一条 <span class="math inline">\((s_i \rightarrow t_i)\)</span>的路径，由于玩家会经过路径上的每一个点，等号左边是个定值，所以问题可以转化为</p><blockquote><p>对于每条路径，将路径上每一个点都加上两个权值为等号左边的物品。询问每个点权值等于等号右边的物品的个数，两种物品分别计数。</p></blockquote><p> </p><p>显然是树上差分。</p><p>对于每个玩家 $ (x,y)$，求出 $ z=lca(x,y)$，令 <spanclass="math display">\[x+d(x), \, father(z)-d(x)\]</span> <span class="math display">\[y+d(x)+2 \times d(z), \, z-(d(x)+2 \times  d(z))\]</span></p><p>然后考虑计数。</p><p>用 <span class="math inline">\(a1,a2\)</span> 记录两种加法操作，用 $b1,b2$ 记录两种减法操作。</p><p>用值域数组 <span class="math inline">\(c1,c2\)</span>，分别记录两种操作的物品个数。</p><p>则要对应着差分来计数，对于每个点的操作，令对应位置加 1 或减 1。</p><p>设计数前 <span class="math inline">\(p=c1(d(x)+w_x), \,q=c2(w_x-d(x))\)</span>。</p><p>计数后集合得到答案 <span class="math display">\[ans(x)=c1(d(x)+w_x)-p+c2(w_x-d(x))-q\]</span> 注意 $ w_x-d(x)$ 可能为负，平移一下下标就好了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sz size</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m, d[N], f[N][<span class="hljs-number">18</span>], w[N], c1[N&lt;&lt;<span class="hljs-number">1</span>], c2[N&lt;&lt;<span class="hljs-number">1</span>], ans[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];vector&lt;<span class="hljs-keyword">int</span>&gt; a1[N], a2[N], b1[N], b2[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, y;    d[x]=d[fr]+<span class="hljs-number">1</span>, f[x][<span class="hljs-number">0</span>]=fr;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;d[x];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i])        <span class="hljs-keyword">if</span>(ver[i]!=fr) y=ver[i], <span class="hljs-built_in">dfs</span>(y,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=d[x]-d[y];j;++i,j&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) x=f[x][i];    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">17</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kawaii</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, y, p=c1[w[x]+d[x]], q=c2[w[x]-d[x]+n];    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(!v[ver[i]]) y=ver[i], <span class="hljs-built_in">kawaii</span>(y);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;a1[x].<span class="hljs-built_in">sz</span>();++i) ++c1[a1[x][i]];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;b1[x].<span class="hljs-built_in">sz</span>();++i) --c1[b1[x][i]];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;a2[x].<span class="hljs-built_in">sz</span>();++i) ++c2[a2[x][i]+n];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;b2[x].<span class="hljs-built_in">sz</span>();++i) --c2[b2[x][i]+n];    ans[x]+=c1[d[x]+w[x]]-p+c2[w[x]-d[x]+n]-q;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, x, y, z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x);    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(m--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), z=<span class="hljs-built_in">lca</span>(x,y);        a1[x].<span class="hljs-built_in">pb</span>(d[x]), b1[f[z][<span class="hljs-number">0</span>]].<span class="hljs-built_in">pb</span>(d[x]);        a2[y].<span class="hljs-built_in">pb</span>(d[x]<span class="hljs-number">-2</span>*d[z]), b2[z].<span class="hljs-built_in">pb</span>(d[x]<span class="hljs-number">-2</span>*d[z]);    &#125;    <span class="hljs-built_in">kawaii</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树上差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4381 Island 题解</title>
    <link href="/2021/lg4381-solution/"/>
    <url>/2021/lg4381-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>不难发现，给出的是一个基环树森林。</p><p>渡船的使用条件，实际上是：离开一颗基环树后，就不能再回来。</p><p>题目要求走过的路最长，不难想到是基环树的直径。</p><span id="more"></span><p>显然基环树的直径有两种可能</p><ol type="1"><li>在去掉环后的某棵子树中（若有负边权）</li><li>两端在在去掉环后的两颗子树中 / 把环断开后，树的直径</li></ol><p>（但在本题中只有第二种就是了）</p><p>最终答案为每颗基环树直径的和。</p><p>对于第一种情况，找到环后，以环上的每个节点为根，在它的子树中跑 DP求最长链就行了。</p><p>设以环上节点 $ x$ 为根，不经过换上节点，能够到达的最远距离为 <spanclass="math inline">\(d(x)\)</span>，两点间距离为 <spanclass="math inline">\(dis(x,y)\)</span>。</p><p>第二种情况仅仅是：选择两个环上的点 $ (i,j)$，最大化 <spanclass="math inline">\(d(i)+d(j)+dis(i,j)\)</span>。</p><p>考虑环形 DP的处理方案，我们将环断开并复制一倍，用单调队列优化点的枚举。</p><p>用前缀和处理两点间的距离，设其为 <spanclass="math inline">\(S\)</span>。</p><p>设环为 $ u$。</p><p>在队头维护：满足 <spanclass="math inline">\(d(u_i)+d(u_j)+S(u_j)-S(u_i)\)</span> 的最大的 $u_j$。</p><p>在队尾维护：$ d(u_r)-S(u_r)$ 单调减。</p><p>环上两点有顺时针和逆时针两个距离，本题无负权，所以其中一个距离一定大于另一个。</p><p>若环上有 $ p$ 个节点，则在队头排除距离小于 $ i-p$ 的决策。</p><p>实现时注意细节。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n, num, p, cnt;<span class="hljs-keyword">int</span> dfn[N], fr[N], s[N&lt;&lt;<span class="hljs-number">1</span>], q[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> h[N], nxt[N&lt;&lt;<span class="hljs-number">1</span>], ver[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];ll ans, ANS;ll d[N], st[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], w[cnt]=z, h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> x, y, z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>;x&lt;=n;++x) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;y,&amp;z), <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i;    st[<span class="hljs-number">1</span>]=z;    <span class="hljs-keyword">while</span>(x!=y) s[++p]=y, st[p+<span class="hljs-number">1</span>]=w[fr[y]], y=ver[fr[y]^<span class="hljs-number">1</span>];    s[++p]=x;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=p;++i) v[s[i]]=<span class="hljs-number">1</span>, s[p+i]=s[i], st[p+i]=st[i];    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=p&lt;&lt;<span class="hljs-number">2</span>;++i) st[i]+=st[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y;    dfn[x]=++num;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;        y=ver[i];        <span class="hljs-keyword">if</span>(!dfn[y]) fr[y]=i, <span class="hljs-built_in">dfs</span>(y);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((i^<span class="hljs-number">1</span>)!=fr[x]&amp;&amp;dfn[y]&gt;dfn[x]) <span class="hljs-built_in">fc</span>(x,y,w[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DP</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y, z;    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i];        <span class="hljs-built_in">DP</span>(y);        ans=<span class="hljs-built_in">max</span>(ans,d[x]+d[y]+z), d[x]=<span class="hljs-built_in">max</span>(d[x],d[y]+z);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">korekara</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i;    p=ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs</span>(x);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=p;++i) <span class="hljs-built_in">DP</span>(s[i]);    R <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=p&lt;&lt;<span class="hljs-number">1</span>;++i) &#123;        <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;=i-p) ++l;        ans=<span class="hljs-built_in">max</span>(ans,d[s[i]]+d[s[q[l]]]+st[i]-st[q[l]]);        <span class="hljs-keyword">while</span>(l&lt;=r&amp;&amp;d[s[q[r]]]-st[q[r]]&lt;=d[s[i]]-st[i]) --r;        q[++r]=i;    &#125;    ANS+=ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cnt=<span class="hljs-number">1</span>;    <span class="hljs-built_in">init</span>();    <span class="hljs-keyword">for</span>(R <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">korekara</span>(i);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ANS);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基环树</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2491 消防 题解</title>
    <link href="/2021/lg2491-solution/"/>
    <url>/2021/lg2491-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>实际上就是 <ahref="https://www.luogu.com.cn/problem/P1099">树网的核</a>的数据加强版。</p><span id="more"></span><p>原题暴力枚举即可，本题也可以用复杂度为 <spanclass="math inline">\(O(n\log SUM)\)</span>的二分答案，这里只讲述单调队列的 <spanclass="math inline">\(O(n)\)</span> 算法。</p><p>题意：在树的直径上选择两个距离不超过 <spanclass="math inline">\(s\)</span> 的点，最小化「偏心距」。</p><p>「偏心距」：树中距离直径最远的节点到直径的距离。</p><p>显然，可以用单调队列维护。</p><p>设直径为 <span class="math inline">\(u\)</span>，其节点数为 <spanclass="math inline">\(o\)</span>，直径上两点为 <spanclass="math inline">\((u_i,u_j)\)</span>，<spanclass="math inline">\(f(x)\)</span> 为从 <spanclass="math inline">\(x\)</span>出发，不经过直径上的其他点，能够到达的最远距离。<spanclass="math inline">\(dis(x,y)\)</span> 为 <spanclass="math inline">\((x,y)\)</span> 之间的距离。</p><p>不难想到此时偏心距为 <span class="math display">\[\max_{dis(i,j)\in [1,s]} {\{\max_{i \le k \le j} { \{ f(k)\},dis(u_1,u_i),dis(u_j,u_s) \} } }\]</span> 仔细观察不难发现，<span class="math inline">\(f(k)\)</span>的定义域为 <spanclass="math inline">\([1,s]\)</span>，而无论如何选择两个点，最终一定取到<span class="math inline">\(\max_{k \in [1,s]} { \{f(s)\}}\)</span>。</p><p>所以上式可化为 <span class="math display">\[\max_{dis(i,j) \in [1,s]} { \{ \max_{k \in [1,s]}{\{ f(k)\}},dis(u_1,u_i),dis(u_j,u_o) \} }\]</span> 而 <span class="math inline">\(\max_{k \in [1,s]} { \{f(s)\}}\)</span> 是一个定值，设其为 <spanclass="math inline">\(K\)</span>。</p><p>求出 <span class="math inline">\(u\)</span> 上节点距离的前缀和数组<span class="math inline">\(S\)</span>。</p><p>则 <span class="math display">\[\max_{dis(i,j) \in [1,s]}{ \{ K, \max ( S(i),S(o)-S(j) )  \} }\]</span> 用单调队列维护队头为 满足 <spanclass="math inline">\(S(j)-S(i) \le s\)</span> 的最大的 <spanclass="math inline">\(j\)</span> 即可。</p><p>写的很麻烦……</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, s, t, mx, o, d[N], f[N], sum[N], a[N], b[N];<span class="hljs-keyword">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;    <span class="hljs-comment">// 这个是用来找直径的</span>f[x]=fa;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa) &#123;        <span class="hljs-keyword">int</span> y=ver[i], z=w[i];d[y]=d[x]+z;        <span class="hljs-keyword">if</span>(d[y]&gt;mx) mx=d[y], o=y;        <span class="hljs-built_in">DFS</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(!v[ver[i]]) &#123;        <span class="hljs-comment">// 不经过直径上的点</span>        <span class="hljs-keyword">int</span> y=ver[i], z=w[i];        <span class="hljs-built_in">dfs</span>(y);        f[x]=<span class="hljs-built_in">max</span>(f[x],f[y]+z);    &#125;    <span class="hljs-comment">// 找距离</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ddfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;<span class="hljs-keyword">int</span> y=ver[i], z=w[i];<span class="hljs-keyword">if</span>(v[y]&amp;&amp;y!=fa) a[++t]=x, b[t]=z, <span class="hljs-built_in">ddfs</span>(y,x);&#125;    <span class="hljs-comment">// a[]存直径节点编号，b[]存边权</span>    <span class="hljs-comment">// 这种做法会漏掉直径最后一个点，不过不影响</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>, ans=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">int</span> x, y, z; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-keyword">int</span> p, q;    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), p=o, mx=d[o]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">DFS</span>(p,<span class="hljs-number">0</span>), q=o;    <span class="hljs-comment">// 这时候f[x]表示x的父亲</span>    <span class="hljs-keyword">while</span>(p!=q) v[q]=<span class="hljs-number">1</span>, q=f[q];    <span class="hljs-comment">// 标记直径上的点</span>    <span class="hljs-built_in">ddfs</span>(q,<span class="hljs-number">0</span>);    <span class="hljs-comment">// 累加直径上的边</span>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;++i) &#123;        <span class="hljs-built_in">dfs</span>(a[i]);        <span class="hljs-comment">// 这时候f[]表示能到达的最远距离</span>        k=<span class="hljs-built_in">max</span>(k,f[a[i]]);        sum[i]=sum[i<span class="hljs-number">-1</span>]+b[i];    &#125;    <span class="hljs-keyword">int</span> l, r, qq;    <span class="hljs-comment">// qq记录到直径最远的距离</span>    <span class="hljs-keyword">for</span>(l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;l&lt;=t;++l) &#123;        <span class="hljs-keyword">while</span>(r&lt;t&amp;&amp;sum[r+<span class="hljs-number">1</span>]-sum[l]&lt;=s) ++r;        qq=<span class="hljs-built_in">max</span>(k,<span class="hljs-built_in">max</span>(sum[l],sum[t]-sum[r]));        ans=<span class="hljs-built_in">min</span>(ans,qq);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调队列</tag>
      
      <tag>树的直径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3304 直径 题解</title>
    <link href="/2021/lg3304-solution/"/>
    <url>/2021/lg3304-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>两次 DFS 求出树的直径。</p><p>显然多条直径必定交于至少一点，且包含它们的中点。</p><span id="more"></span><p>则若舍去他们交点之外的边，剩下的边即为所求。</p><p>设直径左右端点为 $ l, r$。</p><p>在第二次 DFS 时能够求出 $ l$ 到直径每个节点的距离，所以从 $ r$ 向 $l$ 遍历。</p><p>对于直径上的每个点 <spanclass="math inline">\(i\)</span>，分别求出在不经过直径上其他点的情况的，所能达到的最远距离，记作<span class="math inline">\(d\)</span>。设它到直径左端点距离为 $ld$，到右端点距离为 $ rd$。</p><p>若 $ d=rd$，则令 $ r=i$。</p><p>若 <span class="math inline">\(d=ld\)</span>，则令 <spanclass="math inline">\(l=i\)</span>，且只会进行一次，这是因为我们的遍历顺序是从右到左。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, f[N];<span class="hljs-keyword">int</span> c, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];ll p, mxd, d[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span> </span>&#123; ver[++c]=y, w[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;    f[x]=fa;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa) &#123;        <span class="hljs-keyword">int</span> y=ver[i], z=w[i];        d[y]=d[x]+z;        <span class="hljs-keyword">if</span>(d[y]&gt;mxd) &#123; mxd=d[y], p=y; &#125;        <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kawaii</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa&amp;&amp;!v[ver[i]]) &#123;        <span class="hljs-keyword">int</span> y=ver[i], z=w[i];        d[y]=d[x]+z;        <span class="hljs-keyword">if</span>(d[y]&gt;mxd) mxd=d[y];        <span class="hljs-built_in">kawaii</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ans, l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, fg=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        <span class="hljs-keyword">int</span> x, y, z; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), l=p, mxd=d[p]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs</span>(p,<span class="hljs-number">0</span>), r=p;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mxd);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i;i=f[i]) v[i]=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 直径上的点打标记</span>    <span class="hljs-keyword">int</span> l_=l, r_=r;    <span class="hljs-keyword">for</span>(i=f[r_];i!=l_;i=f[i]) &#123;        <span class="hljs-keyword">int</span> ld=d[i], rd=d[r_]-d[i];        <span class="hljs-comment">// </span>        mxd=d[i]=<span class="hljs-number">0</span>;        <span class="hljs-built_in">kawaii</span>(i,<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(mxd==rd) r=i;        <span class="hljs-keyword">if</span>(mxd==ld&amp;&amp;!fg) fg=<span class="hljs-number">1</span>, l=i;    &#125;    <span class="hljs-keyword">for</span>(i=f[r];i!=l;i=f[i]) ++ans;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树的直径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1083E The Fair Nut and Rectangles 题解</title>
    <link href="/2021/cf1083e-solution/"/>
    <url>/2021/cf1083e-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>考虑 DP。</p><p>DP需要一定的顺序。因为给出的矩形没有包含的关系，所以我们按照每个矩形右上角点的横坐标<span class="math inline">\(x\)</span> 递增排序，那么纵坐标 $ y$一定是递减排序的。</p><span id="more"></span><p>设 <span class="math inline">\(S_i = x_i \times y_i\)</span>。</p><p>因为每个矩形都有选与不选两种选择，所以设 $ f(i)$ 为在排序后的 <spanclass="math inline">\([1,i]\)</span> 中，必须选择第 <spanclass="math inline">\(i\)</span>个矩形获得的最大收益，也就是选出的矩形面积之并减去代价。</p><p>初始值为 <span class="math inline">\(f(i) = S_i-a_i\)</span>。</p><p>因为状态中只限制了选择第 <span class="math inline">\(i\)</span>个，而矩形的选择是没有限制的。所以转移时找到 <spanclass="math inline">\(j \in [1,i)\)</span>，用选择 <spanclass="math inline">\(j\)</span> 的最大收益 <spanclass="math inline">\(f(j)\)</span> 选择 <spanclass="math inline">\(i\)</span> 的初始收益并且减去二者之交。或者说是<span class="math inline">\(f(j)\)</span> 加上 <spanclass="math inline">\(S_i \cup S_j\)</span> 减去代价。 <spanclass="math display">\[f(i)=\max_{j \in [1,i)}{ \{ f(j)+ S_i - a_i - S_i \cap S_j \} }\]</span> 有一个问题是，难道 <span class="math inline">\(i\)</span>不会和之前选择的一些矩形有重叠部分吗？在下图中，设宽为黑色的是 <spanclass="math inline">\(k\)</span>，红色的是 <spanclass="math inline">\(j\)</span>，蓝色的是 <spanclass="math inline">\(i\)</span>，满足 <span class="math inline">\(k&lt; j &lt; i\)</span>。那么计算 <spanclass="math inline">\(f(j)\)</span> 的时候必然已经减去了 <spanclass="math inline">\(S_j \cap S_k\)</span>，得到了 <spanclass="math inline">\(S_j \cup S_k\)</span>。排序后，<spanclass="math inline">\(S_i \cap S_j\)</span> 一定包含了 <spanclass="math inline">\(S_i \cap S_k\)</span>，也就是 <spanclass="math inline">\(S_i \cap S_j = S_i \cap (S_j \cupS_k)\)</span>，从而 <span class="math inline">\(S_i\)</span> 与 <spanclass="math inline">\(f(j)\)</span> 中选出的矩形面积之并就等于 <spanclass="math inline">\(f(j)+S_i - S_i \capS_j\)</span>。也就是不会出现这种问题。</p><p><img src="https://s2.loli.net/2022/06/28/vlLTqKgW8mos6nf.png" srcset="/img/loading.gif" lazyload /></p><p>答案为</p><p><span class="math display">\[\max_{1 \le i \le n}\{ f(i)  \}\]</span></p><p>复杂度为 $ O(n^2)$。</p><p>复杂度过高，考虑优化。</p><p>由于我们已经将矩形排序，所以</p><p><span class="math display">\[\forall j \le i \quad x_i \ge x_j,y_i \le y_j\]</span></p><p>即</p><p><span class="math display">\[S_i \cup S_j = x_j \times y_i\]</span></p><p>所以原方程可化简为 <span class="math display">\[f(i) = \max_{ 1 \le j &lt; i } { \{ f(j)+ x_iy_i - a_i -x_jy_i \} }\]</span> 按照套路去掉 <span class="math inline">\(\large \max\)</span>函数，移项得 <span class="math display">\[f(j)=y_ix_j +f(i) - x_iy_i + a_i\]</span> 即</p><p><span class="math display">\[\begin{cases}y=f(j) \\k=y_i \\x=x_j \\b= f(i)-x_iy_i+a_i\end{cases}\]</span></p><p>对应到坐标系里即为：</p><p>每个决策点为 $ (x_j,f(j))$，其斜率 $ y_i$单调递减，所以要维护一个上凸壳。</p><p>由于斜率 <span class="math inline">\(y_i\)</span> 单调递减，所以合法决策的斜率一定小于 <spanclass="math inline">\(y_i\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X(y) (w[y].x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y(x) (f[x])</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">6</span>;ll n, ans, q[N], f[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Squ</span> &#123;</span> ll x, y, z; &#125; w[N];<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Squ a,Squ b) &#123; <span class="hljs-keyword">return</span> a.y&gt;b.y; &#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>(x)!=<span class="hljs-built_in">X</span>(y)? <span class="hljs-number">1.0</span>*(<span class="hljs-built_in">Y</span>(x)-<span class="hljs-built_in">Y</span>(y))/(<span class="hljs-built_in">X</span>(x)-<span class="hljs-built_in">X</span>(y)):<span class="hljs-number">1e9</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;w[i].x,&amp;w[i].y,&amp;w[i].z);    <span class="hljs-built_in">sort</span>(w+<span class="hljs-number">1</span>,w+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        f[i]=w[i].x*w[i].y-w[i].z;        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[l],q[l+<span class="hljs-number">1</span>])&gt;=w[i].y) ++l;        f[i]=<span class="hljs-built_in">max</span>(f[i],f[q[l]]+(w[i].x-w[q[l]].x)*w[i].y-w[i].z);        ans=<span class="hljs-built_in">max</span>(ans,f[i]);        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;<span class="hljs-built_in">calc</span>(q[r<span class="hljs-number">-1</span>],q[r])&lt;=<span class="hljs-built_in">calc</span>(q[r],i)) --r;        q[++r]=i;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>斜率优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu5008 锦鲤抄 题解</title>
    <link href="/2021/lg5008-solution/"/>
    <url>/2021/lg5008-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="update-2022.6.28-修改了证明部分">update 2022.6.28修改了证明部分</h2><p>在 DAG 中，必然有入度为 0的点，这些点是不能选择的。而其他的点则可以选择。</p><p>用 Tarjan 算法缩点，得到一个 DAG。</p><span id="more"></span><p>讨论每个 SCC 内部的选择。</p><p>若存在入度为不为 0 的 SCC，设其为 <spanclass="math inline">\(x\)</span>。</p><p>那么 <span class="math inline">\(x\)</span> 内的点可以随便选。</p><p>证明：</p><blockquote><p>如果 <span class="math inline">\(x\)</span> 的入度不为0，分以下情况讨论。</p><p>对于 <span class="math inline">\(x\)</span> 中只有 1个点的情况，显然成立。</p><p>否则，<span class="math inline">\(x\)</span>至少由一个简单环构成，且一定存在入度 <span class="math inline">\(\ge2\)</span> 的点，设其为 <span class="math inline">\(u\)</span>。</p><p>对于 <span class="math inline">\(x\)</span>中的每个简单环，设其入度最大的点为 $ u$，则至少可以删去 1 条 <spanclass="math inline">\(u\)</span> 的入边，断开这个简单环。而只要 <spanclass="math inline">\(u\)</span> 的入度不为0，就不会影响到点的选择。最终可以得到一个多了若干条入边的 DAG。</p><p>因为 <span class="math inline">\(x\)</span> 入度不为 0，所以这个 DAG不存在入度为 0 的点，那么都可以删去，命题得证。</p></blockquote><p> </p><p>考虑入度为 0 的 SCC，设其为 <spanclass="math inline">\(y\)</span>。</p><blockquote><p>仿照上述证明思路，我们仍以 <span class="math inline">\(y\)</span>内每个简单环删去若干边为代价，得到一个 DAG。</p><p>它是一个普通 DAG，而我们不能选择删去一个入度为 0 的点，设其为 <spanclass="math inline">\(v\)</span>。</p><p>通过不同的修改简单环能够让不同的节点入度为 0，所以最优解让入度为 0的节点权值最小，除了它其他的都能删掉。</p><p>更进一步地说，以上关于 SCC 的删边策略，最终得到的都是 SCC的搜索树，搜索树一定是 DAG。</p><p>不同的是前者没有入度为 0 的点，后者有且仅有一个。</p></blockquote><p>所以我们按照上述操作之后，把能够选择的点集（决策集合）排个序，取前<span class="math inline">\(k\)</span> 大就可以。</p><h2 id="code">CODE</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">6</span>, M=<span class="hljs-number">2e6</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, m, k, num, tp, dfn[N], low[N], st[N];<span class="hljs-keyword">int</span> scc, o, c[N], w[N], deg[N], f[N], ans[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[M], nxt[M];vector&lt;<span class="hljs-keyword">int</span>&gt; p[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    dfn[x]=low[x]=++num, st[++tp]=x;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=ver[i];        <span class="hljs-keyword">if</span>(!dfn[y]) &#123;            <span class="hljs-built_in">tarjan</span>(y);            low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);    &#125;    <span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;        ++scc;        <span class="hljs-keyword">int</span> y;        <span class="hljs-keyword">do</span> &#123;y=st[tp--], c[y]=scc, f[scc]=<span class="hljs-built_in">min</span>(f[scc],w[y]);            <span class="hljs-comment">// f[scc]表示scc里面最小的点权</span>            p[scc].<span class="hljs-built_in">push_back</span>(y);        &#125; <span class="hljs-keyword">while</span>(x!=y);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=ver[i];        <span class="hljs-keyword">if</span>(c[x]!=c[y]) ++deg[c[y]];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=scc;++x) &#123;        <span class="hljs-keyword">bool</span> fg=(deg[x]==<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();++i) &#123;            <span class="hljs-keyword">int</span> y=p[x][i];            <span class="hljs-keyword">if</span>(w[y]==f[x]&amp;&amp;fg) fg=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> ans[++o]=w[y];            <span class="hljs-comment">// 当w[y]==f[x]且fg==1，保留入度为0的点y，因为它的点权最小</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> Ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), <span class="hljs-built_in">add</span>(x,y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);    <span class="hljs-built_in">sol</span>();    <span class="hljs-keyword">if</span>(o&lt;=k) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=o;++i) Ans+=ans[i];    <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">sort</span>(ans+<span class="hljs-number">1</span>,ans+o+<span class="hljs-number">1</span>); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=o-k+<span class="hljs-number">1</span>;i&lt;=o;++i) Ans+=ans[i]; &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,Ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DAG</tag>
      
      <tag>强连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2195 HXY造公园 题解</title>
    <link href="/2021/lg2195-solution/"/>
    <url>/2021/lg2195-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>我最喜欢的紫色水题（</p><span id="more"></span><p>给出一个森林，有两种操作。</p><ol type="1"><li>询问某个点所在的树的直径</li><li>在两个点所在的两棵树间连一条边，最小化其直径</li></ol><p>显然的，对于第一种操作，DP / DFS / BFS预处理直径，并查集维护每棵树的点就行了。</p><p>问题在于高效维护第二种操作。</p><p>不难想到，两棵树之间连一条边，相当于合并两个集合。</p><p>而最小化新树的直径，显然要在两树直径的中点处连边。</p><p>证明：</p><blockquote><p>反证法。若最优点不是直径中点，由于 直径有两个端点 且树上两点有且仅有一条简单路径，若在非直径中点的 <spanclass="math inline">\(x\)</span>点连边，则当其接近直径一端时，直径另一端到达它的距离就大于到达直径中点的距离，反之则显然。这与假设不符，故原命题正确。</p></blockquote><p>设从 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 之间连边，<spanclass="math inline">\(l(t)\)</span> 为点 <spanclass="math inline">\(t\)</span> 所在的树的直径。</p><p>则新树的直径只有三种可能。</p><ol type="1"><li>$ l(x)$</li><li><span class="math inline">\(l(y)\)</span></li><li>$ + + 1$</li></ol><p>合并后求最大值就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, m, q, ans, f[N], d[N], c[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);a=(a&lt;&lt;<span class="hljs-number">1</span>)+(a&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>());    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==f[x]? x:f[x]=<span class="hljs-built_in">get</span>(f[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fr)</span> </span>&#123;    <span class="hljs-keyword">int</span> i, y;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fr) &#123;        y=ver[i], <span class="hljs-built_in">dp</span>(y,x);        ans=<span class="hljs-built_in">max</span>(ans,d[x]+d[y]+<span class="hljs-number">1</span>), d[x]=<span class="hljs-built_in">max</span>(d[x],d[y]+<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">miku</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; ans=<span class="hljs-number">0</span>, <span class="hljs-built_in">dp</span>(x,<span class="hljs-number">0</span>), c[x]=ans; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n=<span class="hljs-built_in">r_</span>(), m=<span class="hljs-built_in">r_</span>(), q=<span class="hljs-built_in">r_</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[i]=i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;++i) x=<span class="hljs-built_in">r_</span>(), y=<span class="hljs-built_in">r_</span>(), <span class="hljs-built_in">add</span>(x,y), <span class="hljs-built_in">add</span>(y,x), f[<span class="hljs-built_in">get</span>(x)]=<span class="hljs-built_in">get</span>(y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(f[i]==i) <span class="hljs-built_in">miku</span>(i);    <span class="hljs-keyword">while</span>(q --&gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> op=<span class="hljs-built_in">r_</span>(), x=<span class="hljs-built_in">r_</span>();        <span class="hljs-keyword">if</span>(op&amp;<span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,c[<span class="hljs-built_in">get</span>(x)]); <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-keyword">int</span> y=<span class="hljs-built_in">r_</span>();        x=<span class="hljs-built_in">get</span>(x), y=<span class="hljs-built_in">get</span>(y);        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">continue</span>;        c[x]=<span class="hljs-built_in">max</span>((c[x]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+(c[y]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">max</span>(c[x],c[y]));        f[y]=x;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树的直径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4819 杀人游戏 题解</title>
    <link href="/2021/lg4819-solution/"/>
    <url>/2021/lg4819-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="update-2022.2.9-修改了代码">update 2022.2.9 修改了代码</h2><p>不妨假设平民为白点，杀手为黑点，认识的关系为一条有向边。</p><p>求不访问黑点并且知道黑点的最小代价。</p><p>若有 <span class="math inline">\(n\)</span>个点，显然每个点为黑的概率为 <spanclass="math inline">\(\frac{1}{n}\)</span>。</p><p>而每访问一个白点，都能得知与它出边相连的点的颜色。</p><p>考虑强连通分量。</p><span id="more"></span><p>不难发现，对于每个强连通分量，只要以概率增加 <spanclass="math inline">\(\frac{1}{n}\)</span>为代价访问其中一个点，就能得知整个强连通分量的颜色情况。。</p><p>所以求出强连通分量后进行缩点，我们就得到了一个 DAG。</p><p>为了减少总访问次数，访问入度不为 0 的 SCC 是不划算的。</p><p>简单证明：设缩点后存在 <span class="math inline">\((x \rightarrowy)\)</span> 的边，则访问完 <span class="math inline">\(x\)</span>中所有的点后，必定能知道 <span class="math inline">\(y\)</span>中一个点的信息，所以对于 <spanclass="math inline">\(y\)</span>，不需要增加 <spanclass="math inline">\(\frac{1}{n}\)</span> 的访问代价。</p><p>所以设缩点后入度为 0 的点的数量为 <spanclass="math inline">\(s\)</span>，则访问到黑点的概率为 <spanclass="math inline">\(\frac{s}{n}\)</span>，答案为 $ $。</p><p> </p><p>考虑只含一个点的 SCC，设其为 <spanclass="math inline">\(c\)</span>，若其入度为0，且其能够到达的点的入度均大于 1，那么若最后访问 <spanclass="math inline">\(c\)</span>，整张图的情况已经被确定了。若未找到黑点，则$ c$ 为黑点。如果包含超过 1个节点，那么必须再访问它再能确定黑点。这样可以减少一次访问，且对于任意图，能且仅能减少一次。</p><p>所以若存在 <span class="math inline">\(c\)</span>，令 <spanclass="math inline">\(s-1\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> n, m, k, num, ans, dfn[N], low[N], st[N];<span class="hljs-keyword">int</span> scc, c[N], deg[N], sz[N];<span class="hljs-keyword">int</span> cnt, h[N], ver[<span class="hljs-number">3</span>*N], nxt[<span class="hljs-number">3</span>*N];<span class="hljs-keyword">int</span> tc, hc[N], vc[<span class="hljs-number">3</span>*N], nc[<span class="hljs-number">3</span>*N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; ver[++cnt]=y, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123; vc[++tc]=y, nc[tc]=hc[x], hc[x]=tc; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    dfn[x]=low[x]=++num, st[++k]=x;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=ver[i];        <span class="hljs-keyword">if</span>(!dfn[y]) &#123;            <span class="hljs-built_in">tarjan</span>(y);            low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);    &#125;    <span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;        ++scc;        <span class="hljs-keyword">do</span> y=st[k--], c[y]=scc, ++sz[scc]; <span class="hljs-keyword">while</span>(x!=y);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(deg[x]||sz[x]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=hc[x];i;i=nc[i]) <span class="hljs-keyword">if</span>(deg[vc[i]]==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;=m;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y), <span class="hljs-built_in">add</span>(x,y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;++x) &#123;    <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) &#123;        <span class="hljs-keyword">int</span> y=ver[i];        <span class="hljs-keyword">if</span>(c[x]!=c[y]&amp;&amp;!v[c[y]]) &#123;v[c[y]]=<span class="hljs-number">1</span>, ++deg[c[y]], <span class="hljs-built_in">adc</span>(c[x],c[y]);&#125;&#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=scc;++i) <span class="hljs-keyword">if</span>(!deg[i]) ++ans;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=scc;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(i)) &#123; --ans; <span class="hljs-keyword">break</span>; &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf\n&quot;</span>,<span class="hljs-number">1.0</span>*(n-ans)/n);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DAG</tag>
      
      <tag>强连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>夢よ未来へ   前往未来的梦啊</title>
    <link href="/2021/Miku-14th/"/>
    <url>/2021/Miku-14th/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f99a23cf52541207ad46a87d590ba5b5e381e03c9fd6a1d295ac9dd27201de71">cd0b72e3a34d6d89f67f670cb3b1975749bac138ea16746f3180bb27880240103bc8172e6d1b89b2a4bb281a909c1ce65544057218161c79107e9f4dfb37f83571d0850dc4c3af14417b33a91d3fda5e6b1544a16ca5325cce935e4cbf64c82ccdfeb0c6278d21332ec35c2608476826ea3e0b75de7b19d3e6015afe5b517338f6d55e9dc9c7ecbe724e151ef213af76c642767f7eedce515e5a23342e60adb4ebab78c7d1ec43c1a968ca13e188fd0b9544b666803d90b2307ce25949d30048187a15c2287d8e6c737c7ce65b9b94597c9712e95954b026907ffe0ebd00653a722fb77fd438b9f362cc22600bd18738a4d0cec92d216144c50af890492944d16595fbe8f7d59aa5b0960cab362e7a5b4b6b4dbb7e8202cadb9bd9eb237dc3dc6bc0f40f4d1e22c36bb3aa43bd90afaf40de3a8094c9f44dee088a327a71167fad88cffab03a54572d740d9647b23cf62ff5e4cb548e6ddb85ae752a65dc9858e4037c79ac4b86885f2b9160c7d12dad33fc0f4db46af5a454d4f278c5108a25d6deab547738c05e20283c9f6a6b024009e65402eca718e40c7482844bbfee910208b0dd6a7e0068c3bb1cdc451642f92890aa4d0e6df50ed0e30d77aeebf092d5446a1f0bc3e73b2c950c519c7accc039b3cb5802f7e4989277a12e82bf4271b3427433d8a1d9f3f10ae6ca35f522c0bdb2c4f8fb9bd80c77fdc59a91ab79c9d38a391eeef3c615ddac1f73c8c0d2ed62d607163f0e1d916d3c86fabf15c6296a55182351e28c0776cb5e6a8ece06e33248130497446b6b0c160e055eb0410d4e2465bdfd71a89ad5259224f8300c78e54dadca0a4f2492b1b0cce0449c231ed5f82f3a50f23bbed9be72ea99e3c61b2501ed6964500c18829fd7612502c747db77708512c3d679076ba0d3314ee507abe641d391b7441c5913bd6eef1c1d9bc3f9d7692c389ff8b54a952164942bbd453dc60ba34737bb25b59fe8c12985c21135951c19cff82170c3909dac6e9db17c4f3dbedd41357df819f2b00e3797f448a5b3389611067953e6664d87e26eeec7e1f27430a8f96a68be0a423aa43362e8e8f985c02e18dc3c3cae6ff2c5210dffd10c2ff7a7863cce72d89bcad04ecfee7f826a1eabbda0f541c52fa658fbe3ff387f4a74edec2c66075f00f02366ccf4659e09a6905b9c1d0de0151431a1d7b6e0b6c63694d3fd16530a14eaf0dc2f1115a8c5b51555f61e4e919ee3ede9eea0bf527b9c02a4c17cf3f551078d80fcd442931cfa5901eec5487ac35023ba5bef76be00eee28ad579547b7aa8d7433aa1d68d61f3ad1ec62142a52970205ffe5a4106bb3b426f38972c197ab19da6173b628522755d9de69fa2f797888d549ac6d60c8e2eb0c92fd41275036286cb2a4eb49f9003789a31bc7cc920d74abdbb939dc6c556cf89e235dd382aebdd9aec1c2824e33cfd63d3f5b11cb3aba7b2f0dae3941637bee8b2475ae456e2ffacd0b190262be17daa2c327fe937743ee7749cd8e14b30d59ed2492655c3dd67166ea348645bdf4247352f5ccc833ea1285dda78d02faa8a91b39b7fdb09860504ea8fefdeb3d7b3d0b4bab273b5a03d37e1a44843f522293af1521eb7ff8644cbdb9655e0a1b94d9e169b51657a0fb83accad80da10c66e12dab195ef771a871cc8138697a5150148b2c868bab4b33a3f849041c08d4ccdc62b97cf3c9b142a0e14981d2bd1e0d5718ab9bb9a4e8d574dc6c593c38e7189db1e198b14f6c4c3605f0eba1bb3feec38fcace60d2d44db74e0db032b94eae18bc24b72d2ecba81a837cd8d7d8d1a9de1d7e6f65725a9f41d703412407b194cfe1afa8c2c2c503c3d1d38e00cf6255e92af4053029578ed0367eb6e68a6983d702d8ddf3c49f9325dd9d1fe49b9d91307a64a96520d059aa764139b71a97b2562ed9b9e4703ce48066968bdbe14f579f3ee4d0870b3de274ca17ee46833d0ccf159a10621dab743b2f9fd79f730441ce299089cfe4168b0ddb8e955ccf8393324b835b46c95610df668929a5c2009ef5a8d82267c234fc13ce18832c7abecf28a5818a6e4da4a2d9c52c6eda8faa3eaf6784266a95c4406ab12b34347883a6b44db7aca98d1f0b76264530655f6653aa2be1ed13216d14561bf05fbfe01e1fe7b9daafb5050b76c970af5860a08180cf200430706f01732b4371a366a8262d3d89738137117c8c50c1ab1ea10b27108b8df268a81429323bae0f95faaf630cdf31c89e96c1d0e1890a8e87eae75d5c53a3f6bf7db00e104e7962132d24bdb6d9b19ecbe825e8bd1adc68f0ae9164a4e9bf8d4845159a496790f7f85128762aa7ff9ed917dfe4e77b80017a701a9f0511ed2f9b4fe596891a306fafebea22ddeaa31b6f19d49d0a57dcb05958ca3e4dd5a4ca105e07b74925855292049455590251f7c8f0794ef70d92a10fb5888c52294299251388e0104ecbf4fe1094816e0763b84abca138f3a2884e850c783458c3f72f1973c426411521cac95116f4cb34cccb6ea96d63942d3dad9376df2b1492ec46b440bd82c88a264b4834bbaee321fd40e5dd1b8414685df61d2b59637821dd1815c6933f05dbd8d53d6fb2cbcdab0d3e7a400f2e287b445e1eed4dac3fc11d0963ee212143c248e5bae2977a8d597e7cea8e4a3497c97cf20c4513e3da13fc69717adaa4728ee30f72c69d727966b29013e85ffa47cb8cc16e847ec9e47bebb38723398c9c45854ee22e4dbbcfe42eadd62628cad9b6a0a6591dc6dbee91dd5c2a95b25e452a2a18b655bd29eba33176f333511893dff8ea2b3a618ec29a5b1b84b4fffa4f096b76b3110b12bfb3e9afab3147875a9e1d1362427b636b5e758b5d28d97cc2505b05239d51f0baf8ff339f24dfa4509df635eb9079d9819a4c43f595e866ace019c9aa2c1dbfb4575aa9da64adbcad4ad3a766375e79865fdcb039e6e367f40d4f78f22c83ac2259f9c11545154d3f11e199a58d14156b84d9f5b9f9a8dc4536df8520f21a93420ab4fba25e5b99107c182e7dde9c42dfcda397aee50c63ead68ca4c19bb6a10ad02fa6facc38cd1dca7a1dc8050cd4d83250f0de63fd5e6135d56d8c1b20e0925f4fb70cedab975ef1b62ac869d4c13d7e8cb6ae8cf85f4f5a2a357ad476b1927adb4e38e3c6c019d4d08d962c339df4058d0329d93b6dc9a67f2f316929a0e39109eca45ace35046582b21f151c99a9900de254d7002639fe5f7fd0e80582852d57ef49ef6d6a406adcd2da8599f261042179ccddd07c056a4ee44ec3d75a79609dadf8ca41ed3a0045c6292168164f7274ef42067fb04df8729fa35c4b6255d6273a1f12ca798a8639c9ac055f3e3a72e82c11c561003b54601dbc61397397e4d34236f5e494b6ae7f526afb9c08833f3a80fb4c432c828a5176552ba13272352d57f66ebd9e2e59a4d1cabcbfc114e32a02df8c93fae46a92db93abf4adbe3e5f1c9cae0d4e36ba10034ab3f7fe176b1df390dadc59f1e987beda0daca9fdd4a42edf7945171c575ef5cf889f462666469ed6afa5dba73af3ea126857ccc9406e505bf9698e5f48cadb7cc8ec801faea3ea211f38cd2bd040cb8a2b489e2337541dab0286a13461047aa0a973904c3d902833c793f635a9241e742cea6244770ded26b3af038442c07f7e7a5a669c894f6d792b9782aa1c5839c8a4f040961563932093082b30f53e372cdbc2fde49e9b577cea4e4ad9b7ac32784cd7758cf0358aa9e515255def2d05604ff1d6f2e8ccf126c71f0d36fd8bd8fa6ebd59bdbcbd912e7f31682c574e597be501aa2390e4901f2c25d10df952fcf1d8b61364fa07eb81adb79f5ff033dfa87c52f3827cc9fbbd9b9badb0c2c3a0218334b6c4919d68f32ca4c2fa5d0270d4d4f5bf249c2ae4ccdb932dfc241da1c42d27b9b22c8b97d154a4d694976f19104fcb6f36601f990e9f8df12ad74a7dc681685274aa77c11edf517dcfb35ffccef6c167b6cf81359ada55448bcb2b7d75d4e9eb968ac99adb03f86cf87db81feb14c4de6ff54ccf69912c639c9c3eab7c28f477e96585675581447f26c1c9f8fdfda83d2ecb7f228021fbc222c54a31b66b34cb391dc01b291457cd076fa881337fc8917ae8a7ed5b3a657c56a823ba9a00507cdeabc7b725812d35bbc30edae5554ca11446b96b69e6f9eccdd4fd6ac00022657130099f26be2289f318c4c992b7d7673c9649e0e06acf48911bea69266cc7a2a8e88975c6aaf574455d57bb368ca73c1c575a53762b4420d856e48dea5bbbd6153b9869b5d65520b9d06ae73976d1c4606bacdb8d91740ba2cc76f51d1407dfa293b329ddc566b327ee6f52b2365fceee9801901205ba514ba47f86794533d8a2d240d3dea863991ecda20dfad47d90a708df65eadf3858d2f68dd8089420e8e907e247181be31f3f1a7154971cbe679904a33bc91433c5ceb4873b223abba0dea2826a74b4b0a2e374fc9dbf4513c64def0fc40c5c849d3f097ace6d674430c52f485d2a7f6c96d39ee87bfd17bc5968ead2d6e03b5188b4a7c93fd6496f82f7e5afeae28fdf6857f832de449d16e6a155433b5cbb7510eca649fab4e609c72223ee0ec3c1541f69aae492bf0c6fcce7fb5b45d151bbbad327672963ff993f727c97751083d71361e762c9532d23dfe84ef054defaa3066dcb4cd4bceb47bfacb5f74a5e8f27afac80a48f8b71ad296422ae6e82657561240f5c4c7147f3bc0fe311fa6280111ff5d0c98146469ac5e6b648e33f5658f22e22981d6dfff7b46c8c172d84f8776ee806a835d6b30709645fe4160f54fdbd42ac9b79aefbc25a693976846ae5d5550c03c2e857fe9f660374484a6ce32a961d65b027856c9caa0d581d36f7953a33bf58c7fa97ebed74bdbbc31183e8c851e95226231218f96158736e42f074f3ed337f1cc3b6db7c4ebb745b70bcda7ef3865de495bca5356090ed940ad9ceb4e7568e6ac0ad4f23c2f4511acb1e3bff96417cda11a6185e40c67648597d05bfcfd8fc60188fb29f30f0dd7695b646ec6b7af4c68713bb8e819183653131574dea6bcb2cf0f837b9818ca9ee6bd964c6184258495518e2d3c4b64e7838e5d8f97736a04d7128401be477a94dc62d2309c97ef54baf1dd44ecc651235a4736e7f0dda7fa01d61cf8e27b5dc3e42c0ce0f0b7eb3fbd1e43f943cb6585eac50cfd7b59f597b5b896320bd2ea8c3b41043b557a3ed207c5cf400b0da269e864825eb31c4ddd1b2dc903318a72bb77f311787461a34c4afb1696c7130b2c46fc5796b873913640b646ff752169a7cdc1de9076195f1c2cf94d9dad6800d01220db09cd071d1c2c6849a7c693acbc799ceef254e5be3fe3ce070631042e5f45901d9661f23373134703bb10435e2425a52d18731314d533b252245b846e65b4ad1b874b76f1d283467760140fdeef0c4cca800cf58e6a38195ce6149c21f16560d41cceba027157c1c6f5d418a18f1cf77204ad4c35b8b624efa397c42387510bc41d4291a9b3f7d562dee140af8daf0930f0cf75bdf76b5790072c26e7a92d6d452176ab698bfa6fe0232f73fe3b952962658b4a0c4086fe6fbfaa31612045ed3425be72e5d8b735efceb63085d8392dc02b1ad7d587ece0bcc3a43eff0d87820a97e914281ba5fc9a787df66596fec482d5c7b9879b52c8decff6f5719dc3ca1dba08224dafdab84a47efc33a2773be14c18fd0d3e00392d9000908882dd70bcf8dc0babf47eccbe03eff25b59979dd14cf9bf23d2d85836d9d1c1c969352ce13bbb24751f6eba025db06ccbfe70d8c433a52df61aeaf55c713d973db888c520d95d89c56b3b5cb63d0faede347af7a3602ab2374bb5923522e6b555d7b247c9931f34bb1c33482c20a68ee59b72f0a54a56a55eb3175311375f107ffafbe8c4e5d5c82295d3b9d827611735019ac9db53fda4a01f09f05b6d401cc4595d47fa18048b52ea73264c58801a0b975b6cbab769af4b18981ceeeac750019338b10748f0b39a01204e061a01aacc11ea6ab81ceeb98b6c3d6ddf0df5213b2cd08fb040e14dd86dc65307f5d6e877909f5a42cea6172f47d98be87e04842353fa744c676245dbf94e6362c18ecb0a379b16d6cd7f0d88953744d8ba4235ee0fb2739f75c875eba0adf00b83a644b4ca281da3d1fb5c8a62fd2bb1ff79320b58c54bbe21433d25cd03d26b862f6c0c8250556b157dda629228e6cbfbe67ebea5aee805c57db30cd09a3f1cc1a203aa26cca5e2e657202ed41e481efde0b1dd3b24f78fb9563c41067cb6e9dc3d5ac8047a28c13fcf3b49da4378faf8e8a64b9c47931ae10cd57ce6acbee7ec891637d455be6a5346283a27703c7595f3b6d2db356b1cb7ce22da1eaa6c6e614c0df2acebec799181b0b26bf485f8858acbe73e1136a69992aa48ce534fca689ab6a98de923046a63708c921c430cb2953e565d1a19cb09df93c8ae677bc8585e7f869a8fa036b81507d21e27731d9f08853403ab0aa2764bfcafbe78584638daa3371e556312607b16ef2eb905727eaee3890f5586a3ccc88ad9e6fc5c4e315370e7dcfde7a655a69a4f4e39abf5fabb0a2609e461573b013a7177a7b6c3aedcb97991ae4d4cfaaf045ff0b6199c80ffbb5d97932a0d7ef0b37f9642a9b69835e5367e1ab1b2db00e0d8eaa87aa8170c1cefdc5be9aacca5b60daa7719d7a332a5cda113fa1ba4d0af5b48c22576decce0715b87ac1b9e262f1fd91f957fa2309de73c70feae4758245ddb0a8d1e865a1bd76682867d349db4a781d6deab0a82ae19328e978dbf0a38ee5995291a32e4c3128110c7b9604763129ba94913c25d79a10d54b534e95ee2c8af1af50ddb1316c3dd2c076d2bb1facb51f84a830571bdf4d2aae1f1685c62f5269e8a69024c60c8fbef0e6fe019616dc12e4b42c0e82218edef517edcfe76090b1c8410d5c331f7d0ef40390fb09217ddca89ba5683b0dc1521e5e61a1ca1bb6d62422d2991bc7add3d0b0c1b17a5bc913b2dd2dbb552043e68ec3b8d07ad43cfeedf9265f2bfe61c1f3c9a924b8751e575f7ca9da1effa2bc3bab43a683852bd4480a2f3c710ecbb21459be09029c6cceee3ecd48f5a4d7a826a0fd7ee18fc2b619698107d85a70dd25a1af0fe0e49d37098bb37f53eb521f863b0c1128edd43383b6527ab374896ee81fb007fb83f1b37e57eec930885e5802218a9e73df518566a1dadb17dbe92efaec23818f9b093e1eca68c0990adf538e8914950f9b83776f1dcf9a17b8246f5b7c89b8ca2cac55729988e34cb589d4dabb5063290f281718dcc12908da3d4136ab05b7b141ebc70cd44c824bf82c7f7e8a771d5d9f165b9ee9a10ce206f3443bc2fc3d3f6f253edec5599b7ce83a6ebb5affb56d959788fa1f369e26335f9ceaa3e481d2d13ac586874408a5572d37cb62d4ef8b67b12a33cf1c8ddfa8d20e5bcb884826055ccecf65919cb3c36ac692d76fdc83cc7a0b09b0de590c6917fc3998b13a5e2b2f696b2767d886de836fe9eaa143a592e448e3932560ecb92f70bd43831d4f09c1ecc1f689b7e7194ec93efaf3fd284b4a45d65d840885b03452317b9afcf4d57afa74c8d04ff80c876d16f465e5ebe1ec20757b3723fb41d83d1c6c4580d59dc15c36f31c3da5e557ca28505048dec57727dc1703e6e591e08f67ff23fc523afce6939c20bf0024ddf3bd5f04ad97d5d2550f05e91df3a0a1d23ce2f4fd344efb4c21a7ae12792e472318258542b0f57bbc7821f492440be7205f4cc7fb3dbcbf91b3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Miku</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回忆一夏</title>
    <link href="/2021/recollect-summer2021/"/>
    <url>/2021/recollect-summer2021/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3e249d0b9dff654310145433ee8a4477be403d6a5a28f40eec30378e2fd4d045">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e1cf67ffd8b0c6d72a9063df66fef18331b51dcc9caab977be30dde672f0fb997719a57e075457dadd75c73ccc8542437bda712050a40284cc9cb7dec5a4d377195ee806216b93ee0938991e6c683a404128655c911ca772b333f10e40c4f3ad899a988c73667fd6f6599afa8b312ea2a287dd1b60650c6e9172e0f9a90f9c99e00d6b47231ff84774429f3de9b3055a5a22a920502d0b95c75b526fddad3c0d24d3e5dbd723f0c2813c2670741ec804bb3351a419c59cb82a603c9cc0dbe3e2e9b17fd7412a07187944ccd76c02035f59c67483ee9843df631df9f75bafbdcf8abae6b89283814f219d4381ca9a482dd8510932974608d9a3b397f7fe1902e428d6d26ea8eb9a3d4a549d7f69314ac867b1a1f5618583c37bbbf12c4f29abda98a0176e9667e59c0b77186628e6a48bad50bee21915f459cfa75b238afa1b446162d5dbbbe8086c7ba869bd61d2ab8be07d98614c2186ae2251eeef77ffe6a5dc1360b4a072d623b9c7c2c1e49d4994d2406119751a528f63a938f697736c2d719e223a5c0b1312eb60018f9aed3d060be38c3a721465fa992478695b49677f720fb057a7682e97d02ac428179a9e7baa3728fc6da8908d00acf607cf9831c26ed83d9a488bd50c3da5ba831efeabb6caa75b13265b109531e736469bad20e931b6a525239d5971b3903749bcea8c9a687f3c0b680875644b3ef3fd5948b6d7c55919709ffae748cfe5e6d3d850622a19505c119c3602ba21db62531c59836819616968807e496b5246fae2ddee9b001d9f0ce973c9de6803c11363a9973c30bad282e8e9abb60abd631c622281e4e8d10cab16a256080198038e1ca9f36cb151bfc74c2ba774f5d9f4f3a8fee3ff2ef228fdee2969ff5b1a0651db8e95ef0d3c89a2682c02e752edcad9410a68bcdc51e451cdaa066398e8812856c883d500943891b36f184a4b14f663a624015b1afd79fe08b48af15cfe27dd0692a6a271a91a53640bfd3f0d3f974e780768b58ccf8d27834dea7a9514c5e347c98756ea2891784b73eb1dc4ec799601a3e135ec328a0f03328351da23a7cb88ee4e38f9140abf760ce7335f381ecf6667d27548953cd0c8cce1272c9f6aeb6a7058ecd4c40f0458e444b84f2dd8d6a45dace30a70f9a4d2390ef558bbbd1fec3b2978e13690175d9f2a91683284dc027705c94e497e6462d7fde199aa4a2a75ffb2867619caca208e6f2c66abb09f3ebb999c05057ed680f144afac6482da863c0a3d93e4f1348b5f5a8bcb8c0d345405341d1b6ab1ad57b6acb2a548ee615597967062ea0671fe9b7d4ce78c7dfc530dfae86749da8ab5c0b4bbbae9adc2ee905085b9d84aa1facca3fe54fa6a6fc27a8bdc91d1255cc48ee46a47c1adb88be6ccb1599d0ae92ffd8ab059dd557449767b6ad8428701ca34451a3f995f4a0542e81f6207bf3ea503eee7d915af165248b3a32f9a44333c76c52e8f98bec3bec339629e585290cb4fd4fa63de5fe8c5e4881e53b873d7287d11c3c0d583fec1dab3b3025000284c22269458af148b7141870152fdcc881490837ce5280de0f48d6d359476877fb12e457f1d2c33cdedbea37cc6ed84a4655884d35d22a65dea328b846f4c71f31ec908711f5fca0254da54bdc71a589b740f51cf82fa37566e1d281492d44b370fce6a6166328451239b9f497b6cb774135383171e0839f5625dd3a179cbe618d604fa57584deda1f8b2814c3b062f0fe9f7b94d193c40eb7d3c5a9af39aa736b141a9a17423f1e190b010c784d822b84c05cf052cdf14fd6c4bb43ec04c79e5dc0c6f73165486fe03d6426aea4c0fb5e0f0ad5e016138478bdaa470a171592fb2d9f5de09de0d5aff22157a65e227303f96b78e7c805f1f5799e3aa45c7f3dd4633a103f95349254459e4be62dd2fb426dc729fc97b2537531ba057aa92be0cbac08c74daa0d9ac6131f7aa2020162bf8d7d8255471f1e18bfcc3085762b4cbc8aba2e28aac62d3255a975b9f041bbd9e251f939865553da580c035bf9a01c10bb5a4a5cc51aac7f54249fa7863d4374dd22d26036ccf879c75baf0fa2916b0e0a648b98b90d95f2397094ca1b361324e9cc3a7c7010ae28ac85df07efa9af0f2c40e46fb7ee9a9d3729093e8580a0f461c300fbac09baef80018e42caeb5aae607003b220ca588f932739b7003e675a0630e4934435f9445a7d9ec0603b4cd3eeea43485fa6c45bcd75a6784f8fd51674e422bbd5069241b8c54a39d3be43b772ed080800e20fcc7e0089cf9cd21af47f6d57885220f9786b4e0f7ea760daef6032553e7add46d376d5109f9cedcea87077a6b2d1f2604f5353e387192a2b3f1864dec4cd985561ef93583d0313cc91b0897794ec0459ed470720118e1f2f7a43525cb5f99d2ee3ea834e3a59f4c17b0e2009876cf6bb1b66e95dd835f7da0b9dd5c0a15b02d64b937c6f3772cca2d380bf96ecfe55c2b158d61e82b2968f37d6873fe42047bb66b5f5edeb26051d1677e5d0fb1fde5ef2bced491ab88cf48c302266786b1b64d4c2b0a037c26f1fbe203b8e5d465b758ac5840abbe05d2ca1bba255826e471f3177206563adb4a3701137147b228808b4ce6cddc36a52bccecd1d770041748687d53706d05689c89ec50bae32663a8dc0fdf058a098b1c6725e1088f4d66a17d7c6f82b1c5b70336258fcaf337cb55a5b704d73974c6210776f158c6d83792010926e4a529e2347785e2b9af930dc1bf37c561ffd587e9bd9ce10426abfb1f3e4a83ffa7c0fb33415bdd0b9806b6d952d8de7c1302c269844f9a80819a54bb4b11c990b4b97652b72bb60f730c96329c11dca25eb887e3d74f3e18ebca31ea94e20c0f0d50a3e7b1369d152dd68f74c461474377660b2b25dfaf6f6dab3ccf050db96b092f1b698bb2743cd0924638a190c14525eb30bb9c85d871c3dac5d1334bcc063209f4cbdd17a545b5de6e0e7b9e2cd116473dfe31dc729bdde67ffed36fb181b25d9d7940019aaa37ce2492e58c010672b559e547fd9a49667d47c1615ccaa109734ae1e3250d5f753a97ad6c821c5d3eee80e86a0d9dc7efbfeaad937fcfa5b0ada197c8b0575b9b754f39fc2885652f45a0ec05a62426923abd43ffde147d6a36f6f00755955ad3fb6eb0155c385720c00896a5b5cd34c90d26f8a40c3d37f1298b29a8fb3e57faa0d356c8a0eb203b5ec55a529dcdc239664ec7800ee8c358bd94d12cd82b78f8593a664ed90bfa6c89a357c62a686d8eb96cc117b85ed1f57bb56cbbe2a039b5a39cfd5bbc1bbff0dca75074cc816dee4688dd03f983f2dd16b48107ec1dfe0b236a6bc859999748289a746ad70538066d5c94f0fbea793dabb588bc1c81fda2781f8fdcafbb60acce3567acc3df9d0ec7b4891f8ebcae4d2f82ecd69e18236d48f7c4e20e830b1ace47e4cd7d4655243515d6f03f7394d57261a58a1ae3c7c57a6d9ddc30e01a9251fe440d01bab5f62a6b463d5695a540c35fb2a0f299bbcb732f0d8c93e149b905d5b6c0195c59d275410d913cceacad0421b45d1beee032f0d3042a2e74f3c33bff1b282a55e8080ec406a232dc7a69a5d7e34081363cf5f92a613579f5ba9cae2188a958cfd5ef902f41fa7daca8279f698adc42c65b330114521f88304393c2dc92b432b8a5a0d4b3516fe79e2313635d8dc60399a30ef9d08b5621b06bec4e8a4b494e37e46897a1d30e13c9109ea51d458710394d71a810f275069cfb8e835a497dcbf8f18eb012a8250627c0c9e8d8b75e6b30bf09cf92c9ba920d38736a4f4aa365d02801aa06d2fc75a964fad2edcb087a0e0f1e0daa49882302e7c22073605a784587174d6796b3dbfb4a77dbf7b9fe2ac47b83cbdce82b0a317ef20769119e30cdfba6e85e0b50df3e2eee1a2c2c6a112bb132191ec72aa64c30eb9879a7ab665bef4e33123012e19958499cc8c99709660a8b268df6fb4fa38145df995b898397d12ead42fa5c7d291735ac61209f8a362fe88fac2a096100e8b116065b77cc92f85978e7ac7f0d2e50b65d3c6275d8c683555406191722a629f1f06d5e7158df3cc5d476d6afef2a6d00bf74ed074df707c85243e1e082e36810d0968de098a34719a78a1103654c1389d50a111a58bb8a1d4c2197ffb972d69984c2216ea0ade7242d64393d09fab8ae872e2958629b9e3cd4144ac58375fab7a02804da81bd81f0332e89907fa0f5749fa53bcbacd2a41e4e14e84d9a1bbaecc841e841d2563a6588a10ab424725dcd2e8136d4da4b3186df67e984f1044466005db49978d0a121d2daac0f74664d588eef72052c4c09768502e633ea1ba7de4b6423c7558c5559a919ab07d56988d5af1cd04cf582984a842b04377c7f62c284af0fe02c1a45a26e34ec882a279e6bcd49c9c7190fa73a1e797d0d3fed79d831b47c6f68350cbdd001649982f2f5432149ba006fa488c57cfd0b7aa26e27572d8d137f1dc3c0971bb12e7cab2cef0ea9eb41a5b2cd38d11550ce41872d8a653f98abddb8a541e590ca2caad8d887bf0ef52d125800aa45711ac71221cdd9317fa73cf9c82b1fd7ccddcba30bfaee6901516c78891dca8831e60675fdf3a8b617f6b8712aea1c41cad7c4865f6559bacb9fa498694914caf780c8543325d11b5c10d05639b50ba7b2e222214d4a03c4db2ceccb2523414dc2c1e2248d7f86789f87f5f36f60aaf959803342223bc50babeb26011b19da16990ffb6df7495ce59695c3fa087a6b6e6e0a806ca3adaa90ecbb17829842c22e9b85b1ba96288be53da6c201bfdbc8f33a81561b5168451c6b130334da723fa2fb80c98817f8c42be6e92f5c29ccfddf74ce54e347532396045b27a96c1949a5c3ce87d8adeb2d69df21d6509d91879849f2259b2704e6ce7e524ce3875fd46a093290dc6374b2a138cb134729f8190241c4550b195964e85a8b837da6cde32cdb77a3a82c3a34d19c79248d2e4d9ab751b1d4fd6bcf54facd529847e08ee7fd2b1d927364d2ae3bec0d6420b7a32de846ddc77a5a055db91b7e1184e42148a6a13ec1101bfeb35f6cd2abea758899b26ec5837acbeb31c3cb62d8465d8d571a7e2f45e21344f34c682d8e9c7da2b6d477d8f279515aee9442e562a48193383d83f4d3fca17630e6365bda7163cddf79a56593d2d17732d62ebc9cf0b52f090f94cbc0deda3b3f07b7e558df81d84c69b713457ebe2ab72a5d15a63058b3a9c5cef66f6df10e6f1208c1dccbe70fcf62fb19193a8ec5fa185c877f0e11d9563346c0e346d3b6d5a76bf5fd188216fc567a630628032ea5f1ff378f4c543192aa1cc38133a5eef1d10ad8f830ac0362ac60a0fa7390503e5149ca4244eff0ee9c06a33ba4f190d1da21d4c08a328a91b7b2de9b72082be35be488c123ccadfbe27f29bcc0c8dd19a934181ee7d4d776fc5475a1d9190e930f84eaecbdae32f9cdccb78895504c763c6346ecf5224408b4dcd301e4bd3ff1e5a881fef048945a4d2adbb618d65a4f7b5a00946a4d82b4716c17ff005f6f6caa085ad9f3d4a9edbafdb373dd896e17a1d8285b0e166b2eb412e12fc55f926b50c853a0dda1e71e24e1280bcb6edc566e27a0d5733f6798d6b4dd84359c6413bd4d1c0da4941d0c65247ca1f5826597dc6da421c7a37564cc434bdcace7c9ee88ae619ff296da43044dea46fcde8b1d6452bccadff85fd4d926731e5dac7149b5e648d62e3b2d83a94d60705e62dacd6f3634f6f5375fb02f1908ab6c886accdfd44eeae48884acc39aafe5a5f8c4504c8ced92764829d43deee3d760c8fa1ba54753bfca8cc85f9cd87fd5438b7ec1ae2b7cd43a89673d70a96983126e50583033d0f74736f3bd4ed0db67080a2dbeebe817f3148bfb128ef16c3b289184250a490f8b9d86d962cfa001f49ba8a8ae0bc26e31c9d4a557965ba0748cdef5d40da8e1311e9c940b500c9e5842f55896ef85e6f4030e81d6993802b30af1ed17d5823870cbaa0c2933db01b82cfaa090559f5d5ab5eb59d63bbca10229e7c2c21aea6ddf45600c4088c0191262ab35da4f4fc3f56464d8e67f390c9839741cb6475723c96dc11fbe0af4c058a58034d520d1c58431d64192c8ec4ace61f0cf0c2e742fe9866187773bb6b41c57c5a5f2426c53e4a5dfd888e0a3e656752d04d4bf7619c49f3369ffc36e80b9002df24ce9bbda66763cd594f34741215bea1b145f36007e597a6062a0698fa0b0ad067d43b71a4609ecf83fe83efc9b5e619e3fafaa11fe8187d8d9c8b7092c016bf11fba4dd5986d08fb5e6e26a48c8a52b6f88065ceb8b4f9c822753fa152d768be634bf004449ef816201003b4dccd9f7cdea30911a00330b72c1c306f5cd7a6d1baa85b4cfc9b3b1351a2390c4dda8845d05cad2775e9d45f2b756add75048c31f427f59062dbf7057d79a9516c033e392691ffce2b5c49cd433a3810f237bbde4988498031fb3b5d775b8927a8f60f35e523898d23c7cd3c1a54e2c5f706ef24a3fd61d5c861c618919ffae2a6be63892a3aea59ab98633031ec3c804475272be837ccf1b1d8624a5236b8e8e910bffa6d6ce3be6d8ab576c42f2e8893e8c9a407b382686acbaa08659ec0d44ce338dcbc1295ed31fe3c4e3ca9ea8f2fa67c5fefcfa45f69d0e5150f1809ee0e956ebc213e0d0e0dc20863aa0c25da54ed2e7a003901b829f88b420996391b6399991c73202dce70bd74a38a3f759ca0a16cfe7c495f06c90acf3e7809e4145de679be2785b5818d2b96c186b2c91729039276482662fe94eca11c6889cb7ffb0edaa44636e59d241fad5519688bcf9952e3f57ad587be7cd25f94943e3536dc9f4dfff4d6d3a1f541e2d343ede1e64aaf919e54895685ad5cbd558294e1dfd554547145ea25e0e359f117e3605f0826aa6b16fd8f5d0388ed86118562449ff9058bf1a1a5daa1acb0a398fe284a79e00b829dc1f22abbf8ed4e2384290d2d16001d4fdcbb1b48d84edf169b7c4e718b8123c28bcde0fe88250659a15809fd2d0e0e493fc715583247e6d6497f95c5c3338900df03f6a060811354e521320c39a0bb43ce14f118ae91434bd2854e16cdf2cc8c5c9be8c8603f34c9344860bf0577b6fab170c4aa8fb60857a956f7ab93d0d2dd30a491d88092be9d92d0d6d7dbce33d9b638e252ecc611c2ced29f2dee7450ff876074bf03150ae405fce623a17e2806b889739d89de4f61c543d6ae0f2549a26cb6bfceea9013bdf9b1fd0224592c73003c5e0d5694e436bae36976867e22e0b167aa127a27808b9d4718d7228a3849f1ea4cef2011c27698cc3617af1b5db266f571265c535868226bb37b226341f686dc16530f0e803d5fd99f943478177d82306cc9e0c9b5dd711ec7622e09850fc48bf5d35d41363a8226d6253f291f0dcfd114683fbf5b6ba0a09a0949c745b2772c9abda0953969d20c51698237e3fe9ef1ae5e46bc456e90b7e67de1f95404e244a31b8ea1c6acce0dbcf463c25ece7567892f4c164e2d0c696244eced515a53455f16d908922af2f2d51f9f4f3c994e26b2b4221a1b9a8799b0b3a75684c392f128fd934767609d00997b61cec9def7e42a24a3f5773e528ba9e5369648f33cbe6ba33a0872173532cd121ce16dcca0c9f39c812930320e1f6d7cde652f8e4f6d821da83a2d91585dafbd55f6893270b9e9c121b5d171a04c09717ee0724040d3d8d24cca1be5d85393b473bf7994596ac60426b4a1221610756112023ab43ee95996f4502a5b0d429b35c34cc7c40ea0fed13c9ccd344e4add99100d336f81fa0d5fc8ff9b5081c315437bf604721045f7bcf4569c7027f4f11fa3ef8e812b0939806817bc534e4a0e2660be1dd05c62034e47cdce054fb068d970a361ce7dd70b5244c63a9172a5a47979caba70a4aefdc627df600bd7b08fd84327e2cd8f3148b25b3d5d05d857bd5ec7c738e00abd5580c0269598af7af299d6d821be4485bea2906852a17e13f4aaae6bba69443559c55c8e4295f5d24e0671615fde403f24db7fc52afffc80abab91ba9c3b2f7e928ef4b5d20863748738ab39079a8fe068bff394df087b28d34c8eeb0b1195c1d7baca3eb5644a8041cb10d949f8781234d8325cba67997ee4d51a49720e069a42fe2297f6114df3bccf12d431a6537ba903feb87bdae1d07e9258cfa76e77d48661eceb60f1860bf7f5fc2e9e3c57bdc406eef6294fe7c3db6ae7657dd3c248ef512cdb3ab8bf4a943635b618db5bbb2065b9a224d61a5d0652f3c77961fb6848f9c159c79d55f9955fe22a3b995985a18fe89511d75501a5214439128962b76c0107720a9ceb37551b9d72cea740568d75bfcf5e8e44e60a07f040eca583a01139ce05699ef0d54da1bc785dd640410a03b44340903c60e610ee5b60f174f8982a9b4ca8d9d0a5c82ee81f230c4e69d63b0b5c59555769280171b711b6238806d2f531102ddd6748218f16cc9fd2860e47f84168fe6a3dc5286f5cc13da12749141468bd5152828f3c05dacd965f01473fdc84083a4dc1c143e1aeba50b6e925bfc1e13bc1586d916761f96c87e99c5f273d7b6e55e9dd9a93068aee041d8777cae54844f7773a9fea8f3f935379a5909f8f87ba2e5bdef974d794bdc63bb2d41d14c83cef89720ad607ac66396177434f141e91ce71f533eb03b2ce1387f5d6af932fa5c74919a9cef5b4de5666840f035e0a762df8b7d7e6a44411f6095cfd878bca79794269051408d536277d5c6e86d54fa9f5a996e9ddee5d185418bfcaa049b03fd6c96272392c91d9f9cb9dd0794cbf6af736b84bae2270abf6937cf2a6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的夏天</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bzoj2863 愤怒的元首 题解</title>
    <link href="/2021/bzoj2863-solution/"/>
    <url>/2021/bzoj2863-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://darkbzoj.tk/problem/2863">link</a></p><p>看到题目，就想起各种空耳了，<del>我到河北省来</del>（</p><p>大概意思是计算节点数为 <span class="math inline">\(n\)</span> 的 DAG数量。</p><span id="more"></span><p>考虑</p><ul><li><p>DAG 有入度为 0 的点。</p></li><li><p>若一张图是 DAG，那么去除入度为 0 的节点后，它仍然是DAG。</p></li></ul><p>设 <span class="math inline">\(f(i)\)</span> 为有 <spanclass="math inline">\(i\)</span> 个节点的 DAG 的数量，<spanclass="math inline">\(g(i,j)\)</span> 表示为有 <spanclass="math inline">\(i\)</span> 个节点的 DAG，<strong>至少</strong>有<span class="math inline">\(j\)</span> 个入度为 0 的节点的方案数。</p><p>为什么是「至少」?</p><p>因为准确个数的方案难以计算，且这样可以构造容斥。</p><p>$ C_i^j$ 表示 有 <span class="math inline">\(i\)</span> 个点的DAG，任选 <span class="math inline">\(j\)</span> 个点，令其入度数是 0的方案数。</p><p>这 <span class="math inline">\(j\)</span> 个点又可以向剩下 $ i-j$个点连边。</p><p>方案数 <span class="math inline">\(j \times (i-j)\)</span>。</p><p>题目描述中又有这样一句话。</p><blockquote><p>Hint：基图不连通也是合法方案</p></blockquote><p>说明也可以不连边。</p><p>方案数 $2^{j (i-j)} $。</p><p>又因为乘法原理，所以还要乘 $ f(i-j)$。 <span class="math display">\[g(i,j)=C_i^j \times 2^{j \times (i-j)} \times f(i-j)\]</span> 将其累加就能求出 <span class="math inline">\(f\)</span>数组了吗？</p><p>显然不行的，前面提到了「至少」构造的容斥。</p><p>不难想到，如果 <span class="math inline">\(j\)</span>个点有不连边的情况，那么可能会增加入度为 0节点个数，而这些是被「强行」计算了的。</p><p>即 入度为 0 节点个数大于 $ j$ 的方案数在 <spanclass="math inline">\(g(i,j)\)</span> 中会被重复计算 <spanclass="math inline">\(C^j_i\)</span> 次。</p><p>可以容斥。 <span class="math display">\[f(i)=\sum_{j=1}^i{(-1)^{j-1} \times g(i,j) }\]</span></p><p><span class="math display">\[f(i)=\sum_{j=1}^i{(-1)^{j-1} \times C_i^j \times 2^{j \times (i-j)}\times f(i-j)}\]</span></p><p>实现的时候可以用 <span class="math inline">\(O(n)\)</span>的时间预处理阶乘、逆元和 2 的整数次幂。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3006</span>;<span class="hljs-keyword">const</span> ll p=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;ll n, i, j, f[N], fac[N], inv[N], pw[N*N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    fac[<span class="hljs-number">1</span>]=inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%p;        inv[i]=(p-p/i)*inv[p%i]%p;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) (inv[i]*=inv[i<span class="hljs-number">-1</span>])%=p;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*n;++i) pw[i]=(pw[i<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-number">1</span>)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> fac[n]*inv[m]%p*inv[n-m]%p; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);    <span class="hljs-built_in">init</span>();    f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i;++j)        (f[i]+=(j&amp;<span class="hljs-number">1</span>? <span class="hljs-number">1ll</span>:<span class="hljs-number">-1ll</span>)*<span class="hljs-built_in">C</span>(i,j)*pw[j*(i-j)]%p*f[i-j]%p)%=p;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(f[n]+p)%p);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DAG</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2155 沙拉公主的困惑 题解</title>
    <link href="/2021/lg2155-solution/"/>
    <url>/2021/lg2155-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P2155">link</a></p><p>由于 <span class="math inline">\(\gcd(x,y) = \gcd(x +y,y)\)</span>，<span class="math inline">\(m! \mid n!\)</span></p><p>所以答案即为 <span class="math inline">\(\frac{n!}{m!} \cdot\varphi(m!)\)</span></p><span id="more"></span><p>设 <span class="math inline">\(\gcd(a,m!)=1\)</span>，那么 <spanclass="math inline">\(\gcd(a+m!,m!)=1\)</span>，<spanclass="math inline">\(\gcd(a+m!+m!,m!)=1\)</span>，最多重复这个过程<span class="math inline">\(\frac{n!}{m!}\)</span> 次。</p><p>简单地说，每找到一个与 <span class="math inline">\(m!\)</span>互质的数，就有 <span class="math inline">\(\frac{n!}{m!}\)</span> 个与<span class="math inline">\(m!\)</span> 互质的数。</p><p>所以计算上式就可以了。</p><p><span class="math inline">\(O(n)\)</span>求阶乘和线性筛求欧拉函数。</p><p><span class="math inline">\(O( \log_2 y!)\)</span>用快速幂和费马小定理求逆元并回答询问。</p><p>实测这种筛法可过加强后的数据。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> t, p, n, m, cnt, pr[N], v[N];<span class="hljs-keyword">int</span> f[N], phi[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=(ll)x*x%p,y&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) z=(ll)z*x%p;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j;    f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1e7</span>;++i) &#123;        <span class="hljs-comment">// 这里的phi[i]实际上是 phi[1]*phi[2]*...phi[i]</span>        <span class="hljs-comment">// 也就是phi[i!]。</span>        <span class="hljs-keyword">if</span>(i!=p) f[i]=(ll)f[i<span class="hljs-number">-1</span>]*i%p; <span class="hljs-keyword">else</span> f[i]=f[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(!v[i]) v[i]=i, pr[++cnt]=i, phi[i]=(ll)phi[i<span class="hljs-number">-1</span>]*(i<span class="hljs-number">-1</span>)%p;        <span class="hljs-keyword">else</span> phi[i]=(ll)phi[i<span class="hljs-number">-1</span>]*i%p;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=cnt;++j) &#123;            <span class="hljs-keyword">if</span>(pr[j]&gt;v[i]||pr[j]*i&gt;<span class="hljs-number">1e7</span>) <span class="hljs-keyword">break</span> ;            v[pr[j]*i]=pr[j];        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x, y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t,&amp;p);    <span class="hljs-built_in">init</span>();    <span class="hljs-keyword">while</span>(t--) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<span class="hljs-keyword">if</span>(x&gt;=p&amp;&amp;y&lt;p) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ll)f[x]*phi[y]%p*<span class="hljs-built_in">fp</span>(f[y],p<span class="hljs-number">-2</span>)%p);&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4139 上帝与集合的正确用法 题解</title>
    <link href="/2021/lg4139-solution/"/>
    <url>/2021/lg4139-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P4139">link</a></p><p>设 <span class="math inline">\(S=2^{2^{2 \cdots}}\)</span></p><p>由扩展欧拉定理得欧拉降幂公式</p><p><span class="math display">\[\forall k &gt; \varphi(p) \quad a^k \equiv a^{k \, \bmod \, \varphi (p)+ \varphi (p)} \, (\bmod p)\]</span></p><p>对于本题</p><p><span class="math display">\[2^S \equiv 2^{S \, \bmod \, \varphi (p) + \varphi (p)} \, (\bmod p)\]</span></p><span id="more"></span><p>仔细观察不难发现</p><p><span class="math inline">\(S \bmod \varphi(p)\)</span></p><p>实际上又是一个这样的式子，我们采用递归的方法求解。</p><p>在不断递归的过程中，要膜的欧拉函数是越来越小的，并且最多递归 <spanclass="math inline">\(\log_2p\)</span> 次。</p><p>不要傻乎乎地去预处理欧拉函数（确信</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span>ll t, p;<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y,ll p)</span> </span>&#123;    ll z=<span class="hljs-number">1ll</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%p,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) z=z*x%p;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">ll <span class="hljs-title">phi</span><span class="hljs-params">(ll x)</span> </span>&#123;    ll y=x;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;        y/=i, y*=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>) x/=i;    &#125;    <span class="hljs-keyword">if</span>(x^<span class="hljs-number">1</span>) y/=x, y*=x<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> y;&#125;<span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0ll</span>;    ll y=<span class="hljs-built_in">phi</span>(x);    <span class="hljs-keyword">return</span> x!=<span class="hljs-number">1ll</span>? <span class="hljs-built_in">fp</span>(<span class="hljs-number">2ll</span>,<span class="hljs-built_in">f</span>(y)+y,x):<span class="hljs-number">0ll</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t --&gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;p), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">f</span>(p));&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>欧拉函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3166 数三角形 题解</title>
    <link href="/2021/lg3166-solution/"/>
    <url>/2021/lg3166-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P3166">link</a></p><p>显然的，在 <span class="math inline">\(N \times M\)</span>的网格中任选三点的方案数为 <span class="math display">\[C^3_{n+m} = \frac{(n+m)!}{3! \cdot (n+m-3)!} = \frac{(n+m) \cdot (n+m-1)\cdot (n+m-2)}{6}\]</span> 还要减去三点共线的情况。</p><span id="more"></span><p>三点共线且沿矩形边的方案数 <span class="math display">\[C_n^3 = \frac{n!}{3! \cdot (n-3)!} = \frac{n \cdot (n-1) \cdot (n-2)}{6}\]</span></p><p><span class="math display">\[C^3_m= \frac{m!}{3! \cdot (m-3)!} = \frac{m \cdot (m-1) \cdot (m-2)}{6}\]</span></p><p>三点共线且不沿矩形边的方案数</p><p>设斜线 $ (0,0) (x,y)$，则其经过点数为 $ (x,y)+1$。</p><p>又因为是三点共线，所以有 $ (x,y)-1$ 种可能。</p><p>该斜线可以左右平移 $ (n-x)$ 次，上下平移 $ (m-y)$次，还有正反两种可能。</p><p>乘法原理。</p><p>实现的时候将 $ n$ 与 $ m $ 都加1，因为这是坐标，而组合数计算的是点数，并且计算斜边时也要注意边界的变化。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span>ll n, m, x, y, z;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123; <span class="hljs-keyword">return</span> y? <span class="hljs-built_in">gcd</span>(y,x%y):x; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m), ++n, ++m;    z=n*m*(n*m<span class="hljs-number">-1</span>)*(n*m<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>;    x=n*(n<span class="hljs-number">-1</span>)*(n<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>*m;    y=m*(m<span class="hljs-number">-1</span>)*(m<span class="hljs-number">-2</span>)/<span class="hljs-number">6</span>*n;    z=z-x-y;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;m;++j) z-=(n-i)*(m-j)*(<span class="hljs-built_in">gcd</span>(i,j)<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,z);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu4778 Counting swaps 题解</title>
    <link href="/2021/solution-lg4778/"/>
    <url>/2021/solution-lg4778/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P4778">link</a></p><p>将给定的排列 <span class="math inline">\(P=\{p_1,p_2, \dotsp_k\}\)</span> 中 <span class="math inline">\(i\)</span> 与 <spanclass="math inline">\(p_i\)</span>连一条边，这样就构成了由若干个环构成的图。</p><p>而要求的就是把这张图变成 <span class="math inline">\(k\)</span>个自环最少需要的操作次数。</p><span id="more"></span><p>设 <span class="math inline">\(f(n)\)</span> 为长度为 <spanclass="math inline">\(n\)</span>的环变成若干个自环的最少需要的操作次数。</p><p>设 <span class="math inline">\(g(n,x,y)\)</span> 为长度为 <spanclass="math inline">\(n\)</span> 的环变成长度为 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 的两个环的方案数。</p><p>不难发现 <span class="math display">\[g(n,x,y)=\begin{cases}\frac{n}{2} \quad \text{$n$ 是偶数且 $x=y$} \\n \quad \text{ $n$ 是奇数或 $x \neq y$}\end{cases}\]</span> 而 <span class="math display">\[f(n)=\sum_{x+y=n}{g(n,x,y) \times f(x) \times f(y) \times\frac{(n-2)!}{(x-1)!(y-1)!}}\]</span> 上式实际是 <span class="math display">\[\large \text{累加（方案数 $\times$ 操作方法数 $\times$ 多重集全排列）}\]</span> 通过奇怪的手段可以发现通项公式 $ f_n=n^{n-2}$ 。</p><p>这样我们就不必计算上式了。</p><p>设排列 <span class="math inline">\(P\)</span> 由长度为 <spanclass="math inline">\(l_1,l_2,\dots l_k\)</span> 的 <spanclass="math inline">\(\large k\)</span> 个环组成，那么答案为 <spanclass="math display">\[(\prod_{1\le i \le k} {f(l_i)}) \times \frac{(n-k)!}{\prod_{1 \le i \lek}{(l_i-1)!}}\]</span> 后面的东西还是多重集全排列。</p><p>然后注意实现的细节就可以了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100010</span>, P=<span class="hljs-number">1e9</span>+<span class="hljs-number">9</span>;ll n, t, p[N], fac[N]=&#123;<span class="hljs-number">1ll</span>&#125;;<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;    ll z=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%P,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) z=z*x%P;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ll i, j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1e5</span>;++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%P;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;t);    <span class="hljs-keyword">while</span>(t --&gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;p[i]), v[i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;        ll ans=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;            v[i]=<span class="hljs-number">1</span>;            ll dlt=<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(j=p[i];j!=i;j=p[j]) v[j]=<span class="hljs-number">1</span>, ++dlt;            ++k;            (ans*=(dlt==<span class="hljs-number">1</span>? <span class="hljs-number">1</span>:<span class="hljs-built_in">fp</span>(dlt,dlt<span class="hljs-number">-2</span>)))%=P;            (ans*=<span class="hljs-built_in">fp</span>(fac[dlt<span class="hljs-number">-1</span>],P<span class="hljs-number">-2</span>))%=P;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans*fac[n-k]%P);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ2652 Zap 题解</title>
    <link href="/2021/loj2652-solution/"/>
    <url>/2021/loj2652-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://loj.ac/p/2652">link</a></p><p>题目要求等价于求满足 $ x a/k, y b/k$ 并且 <spanclass="math inline">\(\gcd(x,y)=1\)</span> 的二元组 <spanclass="math inline">\((x,y)\)</span> 的数量。</p><span id="more"></span><p>设 <span class="math inline">\(g(a,b,k)\)</span> 为满足 $ xa, yb$ 且<span class="math inline">\(k \mid \gcd(x,y)\)</span> 的二元组 $ (x,y)$的数量，不难想到 <span class="math display">\[g(a,b,k)=(\lfloor a/k \rfloor ) \times (\lfloor b/k \rfloor)\]</span> 由容斥原理，得由于 $ g(a,b,1)=a b$，比真正的答案多了 $ (x,y)$是 <span class="math inline">\(2,3,5 \dots\)</span>的倍数的个数，所以要减去它们，即 $ g(a,b,2)$ 与 <spanclass="math inline">\(g(a,b,3)\)</span>。</p><p>而减去后多减了 $ (x,y)$ 既是 <span class="math inline">\(2\)</span>的倍数，又是 <span class="math inline">\(3\)</span> 的倍数的个数，即<spanclass="math inline">\(g(a,b,6)\)</span>，又要加上。以此类推，我们发现加减的关系正是$ k$ 的莫比乌斯函数。</p><p>$ Mobios(x)$ 记为 (x)$ 。</p><p>所以答案为 <span class="math display">\[f(a,b) = \sum_{i=1}^{\min{(a,b)}} \mu(i) \times g(a,b,i)\]</span> 由于 <span class="math display">\[\forall i \in \left[ x, \min(a/\lfloor a/x \rfloor \rfloor ,\lfloor b/\lfloor b/x \rfloor  \rfloor)\right]\]</span></p><p><span class="math display">\[g(a,b,i)=(\lfloor a/i \rfloor ) \times (\lfloor b/i \rfloor) \text{都相同}\]</span></p><p>所以实现的时候求出 $ (x)$ 的前缀和，直接处理一个区间的信息。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, a, b, k, Mobius[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sol</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x, gx, ans=<span class="hljs-number">0</span>;    a/=k, b/=k;    <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);    <span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>;x&lt;=a;x=gx+<span class="hljs-number">1</span>) &#123;        gx=<span class="hljs-built_in">min</span>(a/(a/x),b/(b/x));        ans+=(Mobius[gx]-Mobius[x<span class="hljs-number">-1</span>])*(a/x)*(b/x);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5e4</span>;++i) Mobius[i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">5e4</span>;++i) <span class="hljs-keyword">if</span>(!v[i]) &#123;        Mobius[i]=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(j=(i&lt;&lt;<span class="hljs-number">1</span>);j&lt;=<span class="hljs-number">5e4</span>;j+=i) &#123;            v[j]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(j/i%i==<span class="hljs-number">0</span>) Mobius[j]=<span class="hljs-number">0</span>; <span class="hljs-keyword">else</span> Mobius[j]*=<span class="hljs-number">-1</span>;        &#125;     &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5e4</span>;++i) Mobius[i]+=Mobius[i<span class="hljs-number">-1</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">while</span>(n --&gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;k);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">sol</span>());    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>莫比乌斯函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2568 GCD 题解</title>
    <link href="/2021/lg2568-solution/"/>
    <url>/2021/lg2568-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P2568">link</a></p><p>设 <span class="math inline">\(p\)</span> 为质数且 <spanclass="math inline">\(p \le n\)</span>。</p><p>显然的，若 <span class="math inline">\(\gcd(x,y)=1\)</span>，则 <spanclass="math inline">\(\gcd(x \times p,y \times p)=p\)</span>。</p><p>问题转化为求互质的数对 <span class="math inline">\((x,y)\)</span>的个数。</p><span id="more"></span><p>这时候就要用上大毒瘤欧拉的欧拉函数了！</p><p>由于欧拉函数是与一个数互质，那么用前缀和。</p><p>由于 <span class="math inline">\((x,y)\)</span> 与 <spanclass="math inline">\((y,x)\)</span>算两种，所以计数时要乘2，但是会多加一次 <spanclass="math inline">\(\varphi(1)\)</span>，减去就好了。</p><p>设 <span class="math inline">\(m\)</span> 为 <spanclass="math inline">\(n\)</span> 的约数个数，<spanclass="math inline">\(p_i\)</span> 为 <spanclass="math inline">\(n\)</span> 的第 <spanclass="math inline">\(i\)</span> 个约数。</p><p>则答案为 <span class="math display">\[\sum_{i=1}^m{2 \times \varphi(\frac{n}{p_i})-\varphi(1)}\]</span></p><p><span class="math display">\[2 \times  \sum_{i=1}^m{\varphi(\frac{n}{p_i})-1}\]</span></p><p><span class="math display">\[2 \times  (\sum_{i=1}^m{\varphi(\frac{n}{p_i})}) - m\]</span></p><p>实现的时候用欧拉筛，<del>更加毒瘤了</del></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">6</span>;ll n, m, ans, v[N], p[N], phi[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">if</span>(!v[i]) v[i]=i, p[++m]=i, phi[i]=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;            <span class="hljs-keyword">if</span>(p[j]&gt;v[i]||p[j]*i&gt;n) <span class="hljs-keyword">break</span> ;            v[p[j]*i]=p[j];            phi[p[j]*i]=phi[i]*(i%p[j]?p[j]<span class="hljs-number">-1</span>:p[j]);        &#125;        phi[i]+=phi[i<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) ans+=phi[n/p[i]];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans&lt;&lt;<span class="hljs-number">1</span>)-m);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>欧拉函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF451E Devu and Flowers 题解</title>
    <link href="/2021/solution-cf451e/"/>
    <url>/2021/solution-cf451e/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/CF451E">link</a></p><p>根据容斥原理，得到多重集的组合数。</p><p>从 $ S={n_1 a_1,n_k a_k}$ 任取 $ r (r_{i=1}^k n_i)$个元素组成一个多重集的方案数为 <span class="math display">\[C^{k-1}_{k+r-1}-\sum_{i=1}^k{C^{k-1}_{k+r-n_i-2}}+\sum_{1\le i&lt;j \lek}{C^{k-1}_{k+r-n_i-n_j-3}}- \cdots + (-1)^kC^{k-1}_{k+r-\sum_{i=1}^k{n_i-(k+1)}}\]</span> 好长啊c</p><span id="more"></span><p>本题套进去就行了。</p><p>本题重点在实现。</p><p>上式一共 <span class="math inline">\(2^k\)</span>项，我们可以将它压缩成一个整数。</p><p>题目中的 $ s$ 较大，我们可以用 $ lucas$ 定理搞一下。</p><p>由于 <span class="math display">\[C^{n-1}_{n+m-1}= \frac{P^{n-1}_{n+m-1}}{(n-1)!}\]</span> 所以可先计算上式，然后用逆元搞一下，<spanclass="math inline">\(\large n\)</span> 很小，可以直接递推。</p><p>实现的时候注意每一项减去的值就行了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> ll p=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;ll n, m, ans, f[<span class="hljs-number">22</span>], inv[<span class="hljs-number">22</span>];<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll y,ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(y&lt;<span class="hljs-number">0</span>||x&lt;<span class="hljs-number">0</span>||y&lt;x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    y%=p;    <span class="hljs-keyword">if</span>(!y||!x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    ll i, z=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;x;++i) (z*=(y-i))%=p;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=x;++i) (z*=inv[i])%=p;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i, x;    inv[<span class="hljs-number">0</span>]=inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">20</span>;++i) inv[i]=((p-p/i))*inv[p%i]%p;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;f[i]);    <span class="hljs-keyword">for</span>(x=<span class="hljs-number">0</span>;x&lt;<span class="hljs-number">1</span>&lt;&lt;n;++x) &#123;        <span class="hljs-keyword">if</span>(!x) (ans+=<span class="hljs-built_in">C</span>(n+m<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>))%=p;        <span class="hljs-keyword">else</span> &#123;            ll y=n+m, z=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-keyword">if</span>((x&gt;&gt;i)&amp;<span class="hljs-number">1</span>) ++z, y-=f[i+<span class="hljs-number">1</span>];            y-=z+<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(z&amp;<span class="hljs-number">1ll</span>) (ans-=<span class="hljs-built_in">C</span>(y,n<span class="hljs-number">-1</span>))%=p; <span class="hljs-keyword">else</span> (ans+=<span class="hljs-built_in">C</span>(y,n<span class="hljs-number">-1</span>))%=p;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans+p)%p);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2480 古代猪文 题解</title>
    <link href="/2021/lg2480-solution/"/>
    <url>/2021/lg2480-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P2480">link</a></p><p>求 <span class="math display">\[g^{\sum_{k \mid n}C_n^k} \bmod 9999911659\]</span> 显然的，那一长串的东西是质数。</p><p>设它为 $ p$ 好了。</p><span id="more"></span><p>则有 $ =1$</p><p>由欧拉定理的推论 <span class="math display">\[a^b \equiv a^{b \, \bmod \, \varphi(p)} \quad ( \bmod p)\]</span> 其中 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(p\)</span> 互质，且 <spanclass="math inline">\(b\)</span> 为任意整数。</p><p>可得 <span class="math display">\[g^{\sum_{k \mid n}{C_n^k}}  \equiv g^{\sum_{k \mid n}{C_n^k \, \bmod \,p-1}} \quad (\bmod \, p)\]</span> 所以本题就变成了求右边的那个东西。</p><p>$ p-1$ 显然不是个质数。</p><p>不难发现<del>但很难算出</del> <span class="math display">\[p-1=2 \times 3 \times 4679 \times 35617\]</span> 可以用 $ O()$ 的时间枚举 $ n$ 的约数。</p><p>考虑到 <span class="math inline">\(n,g \le 10^9\)</span>，我们用 $lucas$ 定理求出 $ _{kn}{C_n^k}$，并记录它们对上述四个因子取模的结果，这样就得到了一个线性同余方程组。<span class="math display">\[\begin{cases}x \equiv 2  \quad (\bmod a_1) \\x \equiv 3  \quad (\bmod a_2) \\x \equiv 4679  \quad (\bmod a_3) \\x \equiv 35617  \quad (\bmod a_4) \\\end{cases}\]</span> 然后用中国剩余定理求出满足上述条件的最小的 <spanclass="math inline">\(x\)</span>，用快速幂求 <spanclass="math inline">\(g^x\)</span> 即可。</p><p>注意代码细节。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> ll a[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4679</span>,<span class="hljs-number">35617</span>&#125;;ll n, g, ans, p=<span class="hljs-number">999911658ll</span>, b[<span class="hljs-number">4</span>], fac[<span class="hljs-number">36000</span>]=&#123;<span class="hljs-number">1</span>&#125;;<span class="hljs-function">ll <span class="hljs-title">fp</span><span class="hljs-params">(ll x,ll y)</span> </span>&#123;    R ll z=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(;y;x=x*x%p,y&gt;&gt;=<span class="hljs-number">1ll</span>) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1ll</span>) z=z*x%p;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b,ll&amp; x,ll&amp; y)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> ; &#125;    <span class="hljs-built_in">exgcd</span>(b,a%b,y,x), y-=a/b*x;&#125;<span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a,ll p)</span> </span>&#123;    ll x, y;    <span class="hljs-built_in">exgcd</span>(a,p,x,y);    <span class="hljs-keyword">return</span> (x%p+p)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll x,ll p)</span> </span>&#123;    ll z=<span class="hljs-number">1</span>, y=n;    <span class="hljs-keyword">for</span>(;x;x/=p,y/=p) &#123;        ll a=x%p, b=y%p;        z=z*fac[b]%p*<span class="hljs-built_in">inv</span>(fac[a],p)%p*<span class="hljs-built_in">inv</span>(b&lt;a?<span class="hljs-number">0</span>:fac[b-a],p)%p;    &#125;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;g), g%=p+<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(!g) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=a[<span class="hljs-number">3</span>];++i) fac[i]=fac[i<span class="hljs-number">-1</span>]*i%p;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;++i) <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j) b[j]=(b[j]+<span class="hljs-built_in">C</span>(i,a[j]))%a[j];        <span class="hljs-keyword">if</span>(i*i!=n) <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j) b[j]=(b[j]+<span class="hljs-built_in">C</span>(n/i,a[j]))%a[j];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;        ll x, y;        <span class="hljs-built_in">exgcd</span>(p/a[i],a[i],x,y);        ans=(ans+x*(p/a[i])%p*b[i])%p;    &#125;    ans=(ans+p)%p, ++p;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">fp</span>(g,ans));&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数学</tag>
      
      <tag>中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷2862 Corral the Cows 题解</title>
    <link href="/2021/lg2862-solution/"/>
    <url>/2021/lg2862-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P2862">link</a></p><p>几个月前写的题解，来水了……</p><span id="more"></span><p>最小化满足条件的正方形边长，正方形边长具有单调性，显然二分答案。</p><p>坐标范围为 <spanclass="math inline">\([1,10000]\)</span>，明显开不下这么大的二维数组。并且<span class="math inline">\(n\)</span>很小，不离散化简直是浑身难受啊。</p><p>先对读入的数据进行离散化，然后求出二维前缀和。</p><p>最后二分一个 <span class="math inline">\(mid\)</span>表示正方形边长为 <span class="math inline">\(mid\)</span>是否能满足条件。</p><p>判断的时候枚举目标点的横纵坐标，用二维前缀和减去不在正方形内的部分，判断是否大于等于<span class="math inline">\(c\)</span> 即可。</p><p>一定要注意枚举正方形时的边界问题，具体细节看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1010</span>;<span class="hljs-keyword">int</span> c, n, m, cnt, b[N], s[N][N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt</span> &#123;</span> <span class="hljs-keyword">int</span> x, y; &#125; a[<span class="hljs-number">510</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>,b+m+<span class="hljs-number">1</span>,x)-b; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">c_</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, j, t;    <span class="hljs-keyword">for</span>(R <span class="hljs-keyword">int</span> x1=<span class="hljs-number">1</span>,x2=<span class="hljs-number">1</span>;x1&lt;=m;++x1) &#123;        <span class="hljs-keyword">for</span>(;b[x2]-b[x1]+<span class="hljs-number">1</span>&lt;=w &amp;&amp; x2&lt;=m;++x2);        --x2;        <span class="hljs-keyword">for</span>(R <span class="hljs-keyword">int</span> y1=<span class="hljs-number">1</span>,y2=<span class="hljs-number">1</span>;y1&lt;=m;++y1) &#123;            <span class="hljs-keyword">for</span>(;b[y2]-b[y1]+<span class="hljs-number">1</span>&lt;=w &amp;&amp; y2&lt;=m;++y2);            --y2;            t=s[x2][y2]-s[x1<span class="hljs-number">-1</span>][y2]-s[x2][y1<span class="hljs-number">-1</span>]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>];            <span class="hljs-keyword">if</span>(t&gt;=c) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, j, x, y;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;c,&amp;n),i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        a[i]=(pt)&#123;x,y&#125;, b[++cnt]=x, b[++cnt]=y;    &#125;    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+cnt+<span class="hljs-number">1</span>);    m=<span class="hljs-built_in">unique</span>(b+<span class="hljs-number">1</span>,b+cnt+<span class="hljs-number">1</span>)-b<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        ++s[<span class="hljs-built_in">f</span>(a[i].x)][<span class="hljs-built_in">f</span>(a[i].y)];    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;++j)        s[i][j]+=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];       R <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">1e4</span>, h;    <span class="hljs-keyword">while</span>(l&lt;r) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">c_</span>(h=l+r&gt;&gt;<span class="hljs-number">1</span>)) r=h; <span class="hljs-keyword">else</span> l=h+<span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2986 Great Cow Gathering 题解</title>
    <link href="/2021/lg2986-solution/"/>
    <url>/2021/lg2986-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P2986">link</a></p><p>设 <span class="math inline">\(d(x)\)</span> 为以 <spanclass="math inline">\(x\)</span> 为根的子树中所有的牛到达 <spanclass="math inline">\(x\)</span> 的代价，设 <spanclass="math inline">\(V_x\)</span> 为 <spanclass="math inline">\(x\)</span> 的子节点集。</p><p>称 <span class="math inline">\(y \in V_x\)</span>，当且仅当有 <spanclass="math inline">\((x \rightarrow y)\)</span> 的路径。</p><p>不妨将每个点的奶牛总数称为点权。</p><p>设 <span class="math inline">\(ct(y)\)</span> 为以 <spanclass="math inline">\(y\)</span> 为根的子树的点权和，<spanclass="math inline">\(z\)</span> 为 <span class="math inline">\((x\rightarrow y)\)</span> 的长度。</p><span id="more"></span><p>转移是显然的 <span class="math display">\[d(x)=\sum_{y \in V_x} d(y)+z \times ct(y)\]</span> 然后考虑换根 DP。</p><p>设 <span class="math inline">\(f(x)\)</span> 为选择 <spanclass="math inline">\(x\)</span> 点的最小代价，令 <spanclass="math inline">\(f(1)=d(1)\)</span>。</p><p>设 <span class="math inline">\(S\)</span> 为整棵树的点权和。</p><p>显然有 <span class="math display">\[f(y)=f(x)-ct(y) \times z + (S-ct(y)) \times z\]</span></p><p><span class="math display">\[f(y)=f(x)-(2 \times ct(y) \times z)+S \times z\]</span></p><p>最后取 <span class="math display">\[\min_{1 \le x \le n}{\{ f(x) \}}\]</span> 实现上的问题只有子树的点权和无法方便计算，可以用一个变量记录<span class="math inline">\((x \rightarrow y)\)</span> 的每个 <spanclass="math inline">\(y\)</span>子树点权和，再用另一个变量将它们累加，最后在遍历子节点后加上自身的点权就能求出完整的<span class="math inline">\(ct\)</span> 数组。</p><p>具体看代码。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;ll n, s, c[N];ll ans=(<span class="hljs-number">1ll</span>&lt;&lt;<span class="hljs-number">60</span>), ct[N], d[N], f[N];ll cnt, h[N], ver[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], w[N&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y,ll z)</span> </span>&#123; ver[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; &#125;<span class="hljs-function">ll <span class="hljs-title">dp</span><span class="hljs-params">(ll x,ll fa)</span> </span>&#123;    ll res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa) &#123;       ll y=ver[i], z=w[i];       ll o=<span class="hljs-built_in">dp</span>(y,x);       d[x]+=d[y]+z*o, res+=o;    &#125;    <span class="hljs-keyword">return</span> ct[x]=res+c[x];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x,ll fa)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[x];i;i=nxt[i]) <span class="hljs-keyword">if</span>(ver[i]!=fa) &#123;        y=ver[i], z=w[i];        f[y]=f[x]-((ct[y]*z)&lt;&lt;<span class="hljs-number">1ll</span>)+s*z;        <span class="hljs-built_in">dfs</span>(y,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// freopen(&quot;data_\\P2986_8.in&quot;,&quot;r&quot;,stdin);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;c[i]), s+=c[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;        ll x, y, z; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,z), <span class="hljs-built_in">add</span>(y,x,z);    &#125;    <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    f[<span class="hljs-number">1</span>]=d[<span class="hljs-number">1</span>];    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,f[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ2691 Rendezvous 题解</title>
    <link href="/2021/loj2691-solution/"/>
    <url>/2021/loj2691-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://loj.ac/p/2691">link</a></p><p>给出的是一个内向基环树森林。</p><p>很容易想到，如果两个点不在同一颗基环树中，则不存在合法的 <spanclass="math inline">\((x,y)\)</span>。</p><span id="more"></span><p>但是怎么处理在同一颗树中的点呢？</p><p>我有一个大胆的想法。</p><p>无法直接处理 lca，是因为基环树有一个环。</p><p>但是如果 $ (a,b)$两点在同一颗子树中，且该子树没有环上的边，则不影响求出 $ LCA(a,b)$。所以，该子树应含不超过1个的环上的点。若含有，则一定是根。</p><p>更进一步地说，把每个环上的点看作「根」，它的子树中节点可以直接求lca，这要我们求出它子树中每个节点的「深度」。</p><p>所以，如果 $ (a,b)$ 两点的「根」是同一个节点，那么只需要求出 <spanclass="math inline">\(c=LCA(a,b)\)</span>，答案即为 <spanclass="math inline">\(dep(a)-dep(c)\)</span> 与 <spanclass="math inline">\(dep(b)-dep(c)\)</span>。</p><p>若 <span class="math inline">\((a,b)\)</span>的「根」不同，那么该怎么处理呢？</p><p>仔细分析不难发现，在合法的解中，一定有它们与「根」的距离，即 <spanclass="math inline">\(dep(a)-1\)</span> 与 $ dep(b)-1$ ，记为 $(p,q)$</p><p>而剩下的部分，就是它们的「根」在环中互相到达的距离。</p><p>我们设 $ ord(x)$ 为环上节点 <span class="math inline">\(x\)</span>在环上的顺序编号， $ s(x)$ 为基环树 <spanclass="math inline">\(x\)</span> 环上的节点数量。</p><p>设 <span class="math inline">\((x,y)\)</span> 为 <spanclass="math inline">\((a,b)\)</span> 两点分别的「根」，<spanclass="math inline">\(z\)</span> 为它们所属的基环树编号。</p><p>不难发现，有两种情况。</p><p><span class="math inline">\((x \rightarrow y)\)</span> 距离为 <spanclass="math inline">\(( ord(y)-ord(x)+s(z)) \bmod s(z)\)</span>。</p><p><span class="math inline">\((y \rightarrow x)\)</span> 距离为 <spanclass="math inline">\((ord(x)-ord(y)+s(z)) \bmod s(z)\)</span>。</p><p>最后检查 $ (p+(x y),q)$ 与 <span class="math inline">\(( p,q+(y\rightarrow x))\)</span>，选取合法解。</p><p> </p><p>那么如何实现呢？</p><p>先找环，每个环对应着每颗基环树。</p><p>标记环上的点并将其深度置为1，记录它所在的基环树编号、此树环上节点个数、环上节点的编号、将其根标记为自己。</p><p>$ c(x)$ 用来判断环，$ d(x)$ 记录深度，$ bel(x)$记录所属基环树编号，<span class="math inline">\(root(x)\)</span>记录环上的「根」。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_circle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> y=x;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span>(c[x]==y) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 找到了环</span>        <span class="hljs-keyword">if</span>(c[x]) <span class="hljs-keyword">return</span> ;        <span class="hljs-comment">// 找到了已经访问过却不是环上节点的点</span>        <span class="hljs-comment">// 直接结束，因为这个循环一定找不到环了，不加这句TLE</span>        c[x]=y, x=to[x];    &#125;    ++num;    <span class="hljs-keyword">while</span>(!root[x]) d[x]=<span class="hljs-number">1</span>, ord[x]=++s[num], bel[x]=num, root[x]=x, x=to[x];&#125;</code></pre></div><p>在倍增求 lca 的时候，不断更新 <spanclass="math inline">\(root(x)\)</span>，其他的就是模板。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(d[x]) <span class="hljs-keyword">return</span> ;    <span class="hljs-built_in">dfs</span>(to[x]);    <span class="hljs-comment">// 内向树只有一条出边</span>    f[x][<span class="hljs-number">0</span>]=to[x], d[x]=d[to[x]]+<span class="hljs-number">1</span>, root[x]=root[to[x]];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;d[x];++i) f[x][i]=f[f[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-comment">// 转移树上倍增</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=d[x]-d[y];j;j&gt;&gt;=<span class="hljs-number">1</span>,++i) <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) x=f[x][i];    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lg[d[x]];i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>]; &#125;</code></pre></div><p>我这里与处理了一下 $ _2x$。</p><p>剩下的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, k, num, d[N], f[N][<span class="hljs-number">20</span>], to[N], lg[N], bel[N];<span class="hljs-keyword">int</span> root[N], s[N], ord[N], c[N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ck</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1,<span class="hljs-keyword">int</span> x2,<span class="hljs-keyword">int</span> y2)</span> </span>&#123;    <span class="hljs-keyword">int</span> P=<span class="hljs-built_in">max</span>(x1,y1), Q=<span class="hljs-built_in">max</span>(x2,y2), p=<span class="hljs-built_in">min</span>(x1,y1), q=<span class="hljs-built_in">min</span>(x2,y2);    <span class="hljs-keyword">if</span>(P&lt;Q) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(Q&lt;P) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(p&lt;q) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(q&lt;p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> x1&gt;=y1;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// freopen(&quot;data_\\ran10c.in&quot;,&quot;r&quot;,stdin);</span>    <span class="hljs-comment">// freopen(&quot;data_\\qwq.out&quot;,&quot;w&quot;,stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    lg[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>, lg[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;to[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">fc</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">dfs</span>(i);    <span class="hljs-keyword">while</span>(k --&gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(bel[root[x]]!=bel[root[y]]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>); <span class="hljs-keyword">continue</span> ; &#125;        <span class="hljs-keyword">if</span>(root[x]==root[y]) z=<span class="hljs-built_in">lca</span>(x,y), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,d[x]-d[z],d[y]-d[z]);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> p=d[x]<span class="hljs-number">-1</span>, q=d[y]<span class="hljs-number">-1</span>, d1, d2;            <span class="hljs-keyword">int</span> z=bel[root[x]], x=root[x], y=root[y];            <span class="hljs-keyword">int</span> d1=(ord[y]-ord[x]+s[z])%s[z], d2=(ord[x]-ord[y]+s[z])%s[z];            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ck</span>(p+d1,q,p,q+d2)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,p+d1,q); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,p,q+d2);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基环树</tag>
      
      <tag>最近公共祖先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1061C Multiplicity 题解</title>
    <link href="/2021/CF1061C-solution/"/>
    <url>/2021/CF1061C-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><ahref="https://codeforces.com/problemset/problem/1061/C">link</a></p><p>相信大家都能秒推这道题的方程。</p><span id="more"></span><p>状态：设 $ f(i,j)$ 为原序列中前 <spanclass="math inline">\(i\)</span> 个数选出了 <spanclass="math inline">\(j\)</span> 个的方案数。</p><p>转移是显然的。 <span class="math display">\[f(i,j)=\begin{cases}f(i-1,j)+f(i-1,j-1) \quad j \mid a_i\\f(i-1,j) \quad j \nmid a_i\end{cases}\]</span> 然而这样的复杂度过高，数组也开不下。</p><p>考虑只有 <span class="math inline">\(j \mid a_i\)</span>时状态才会被更新，否则只会将上一个 <spanclass="math inline">\(i\)</span> 的状态继承过来。</p><p>所以对于每个 <spanclass="math inline">\(a_i\)</span>，能够影响方案数的仅仅只有它的约数。</p><p>将每个 <span class="math inline">\(a_i\)</span> 分解，决策集合为<span class="math inline">\(a_i\)</span> 的约数集合。</p><p>然后用滚动数组优化掉第一维。</p><p>设 $ f(i)$ 为长度为 <span class="math inline">\(i\)</span>的序列的方案数，由于少了一维，所以转移时要累加所有状态，同时也不需要从第<span class="math inline">\(i-1\)</span> 个数继承状态了。</p><p>但是我这样的菜比无法写出优化后的转移方程。</p><p>设 <span class="math inline">\(j\)</span> 为 <spanclass="math inline">\(a_i\)</span> 的约数，将 <spanclass="math inline">\(f(j-1)\)</span> 累加到 $ f(j)$ 中。</p><p>大概就是这样。</p><p> </p><p>从「 <span class="math inline">\(a_i\)</span> 的约数 <spanclass="math inline">\(j\)</span> 对长度为 <spanclass="math inline">\(j\)</span>的序列的方案数产生的贡献」考虑的话，我很难明白转移。</p><p>所以从 <span class="math inline">\(a_i\)</span> 产生的贡献考虑。</p><p>在原来朴素的转移方程中，对于 <spanclass="math inline">\(a_i\)</span>，只会在每个 <spanclass="math inline">\(j\)</span>处更新状态，它对总方案数的贡献是更新的这一部分。</p><p>这样新状态的转移就很好理解了。</p><p> </p><p>这种直接省略一维的滚动数组要注意循环顺序，确保决策从上一轮转移而来。</p><p>最后累加答案。</p><p>这道题启示我滚动数组优化仅仅是节省了空间，求解问题仍要从原状态、决策、方程考虑。DP问题的求解要抓住并分析问题的本质。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>, mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, p, dv[N], f[N]=&#123;<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DIV</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i*i&lt;=x;++i) <span class="hljs-keyword">if</span>(!(x%i)) &#123;        dv[++y]=i;        <span class="hljs-keyword">if</span>(i*i!=x) dv[++y]=x/i;    &#125;    <span class="hljs-keyword">return</span> y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, j, x, y, z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);        y=<span class="hljs-built_in">DIV</span>(x);        <span class="hljs-keyword">for</span>(j=y;j;--j) (f[dv[j]]+=f[dv[j]<span class="hljs-number">-1</span>])%=mod;    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>,z=<span class="hljs-number">0</span>;i&lt;=n;++i) (z+=f[i])%=mod;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,z);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3288 方伯伯运椰子 题解</title>
    <link href="/2021/lg3288-solution/"/>
    <url>/2021/lg3288-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/P3288">link</a></p><p>写一篇不从网络流的角度考虑，单纯推式子的题解。</p><p>看到题目给出一张图并要求最大化 <span class="math display">\[\frac{X-Y}{k}\]</span> 就可以确定本题的大致模型：分数规划和 SPFA 判负环。</p><span id="more"></span><p>每条路满负荷，这就意味着我们可以在「理想状态」下进行推导。</p><p>设第 <span class="math inline">\(i\)</span> 条边未修改是费用为 <spanclass="math inline">\(x_i\)</span>，修改后费用为 <spanclass="math inline">\(y_i\)</span>。</p><p>题目给出 <spanclass="math inline">\(a_i,b_i,c_i,d_i\)</span>，不难想到 <spanclass="math display">\[x_i = c_i \times d_i \implies X = \sum_{i=1}^m {c_i \times d_i}\]</span> 有两种操作</p><ul><li>选择一条道路，将其进行一次压缩，这条道路的容量会下降 1 单位。</li><li>选择一条道路，将其进行一次扩容，这条道路的容量会上升 1 单位。</li></ul><p>简单推导一下式子，易得当第 <span class="math inline">\(i\)</span>条边进行压缩时 <span class="math display">\[y_i= (c_i-1) \times d_i - a_i \implies Y= \sum_{i=1}^m { (c_i-1) \timesd_i + a_i}\]</span></p><p>进行扩容时 <span class="math display">\[y_i = (c_i+1) \times d_i -b_i \implies Y= \sum_{i=1}^m { (c_i+1) \timesd_i + b_i }\]</span> 我们令 <span class="math display">\[\max{ \{ \frac{X-Y}{k} \} } = ans\]</span> 则 <span class="math display">\[\frac{X-Y}{k}  \large \le ans\]</span> <span class="math display">\[X-Y  \le  \large ans \times k\]</span></p><p><span class="math display">\[ans \times k  + Y - X \ge \large 0\]</span></p><p>而 <span class="math display">\[Y-X  =  \sum_{i=1}^m{y_i-x_i} = \sum_{i=1}^m {\left[(c_i-1) \times d_i +a_i \right]} - \sum_{i=1}^m{c_i \times d_i}\\\]</span> <span class="math display">\[= \sum_{i=1}^m { (c_i \times d_i -d_i +a_i )-c_i \times d_i} =\sum_{i=1}^m {a_i-d_i} \\\]</span></p><p><span class="math display">\[or\]</span></p><p><span class="math display">\[=\sum_{i=1}^m {\left[(c_i+1) \times d_i + b_i \right]} -\sum_{i=1}^m{c_i \times d_i} \\\]</span></p><p><span class="math display">\[=\sum_{i=1}^m{(c_i \times d_i+ d_i +b_i)-c_i \times d_i}=\sum_{i=1}^m{b_i+d_i}\]</span></p><p>若将 <span class="math inline">\(y_i-x_i\)</span>看作图上的边权，修改次数 <span class="math inline">\(k\)</span>即为某个环上的边数。</p><p>所以我们二分一个 <spanclass="math inline">\(dlt\)</span>，判断是否有负环，决定式子是否成立，则分数式又可化为<span class="math display">\[dlt \times k + Y - X   \ge  0 \\\]</span> <span class="math display">\[\sum_{i=1}^k y_i-x_i+dlt \ge  0\]</span></p><p>由于有两种情况，所以建双向边。</p><p>因为原分数式中 <span class="math inline">\(k\)</span>是分母，所以这个满足上式的 <span class="math inline">\(dlt\)</span>应尽量小。</p><p>然后 SPFA 判负环就行。</p><p>若有负环，则不满足上式，令 <spanclass="math inline">\(l=dlt\)</span>，反之则令 <spanclass="math inline">\(r=dlt\)</span>。</p><p> </p><p>code</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> c, h[N], ver[N], nxt[N];<span class="hljs-keyword">double</span> g[N], d[N];<span class="hljs-keyword">bool</span> v[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">double</span> z)</span> </span>&#123; ver[++c]=y, g[c]=z, nxt[c]=h[x], h[x]=c; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">double</span> dlt)</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, y, z;    v[x]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=h[x];i;i=nxt[i]) &#123;        y=ver[i], z=g[i];        <span class="hljs-keyword">if</span>(d[y]&gt;d[x]+z+dlt) &#123;            d[y]=d[x]+z+dlt;            <span class="hljs-keyword">if</span>(v[y]||<span class="hljs-built_in">spfa</span>(y,dlt)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> v[x]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;    <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v)), <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));    <span class="hljs-keyword">for</span>(R <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">2</span>;++i) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>(i,x)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, x, y, A, B, P, Q;    R <span class="hljs-keyword">double</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>, mid;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;A,&amp;B,&amp;P,&amp;Q);        <span class="hljs-keyword">if</span>(P) <span class="hljs-built_in">add</span>(y,x,(<span class="hljs-keyword">double</span>)(A-Q));        <span class="hljs-built_in">add</span>(x,y,(<span class="hljs-keyword">double</span>)(B+Q));        r+=A+B+(<span class="hljs-keyword">double</span>)P*Q;    &#125;    <span class="hljs-keyword">while</span>(r-l&gt;eps) &#123;        mid=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>,l);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>分数规划</tag>
      
      <tag>SPFA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>致2021的夏</title>
    <link href="/2021/to-Natsu2021/"/>
    <url>/2021/to-Natsu2021/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8f9169df9bf86021ff8e65904b0dd8d6223efb58f4f4e1fdc1b5b73ef56d0f36">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e1cf67ffd8b0c6d72a9063df66fef18331b51dcc9caab977be30dde672f0fb99778cae27635259b36b89ac6bf2e778c78ebf9395c333f901fe521bc04046e5166e9b4acc460ade6ce33e7a6d282068e7ba6d1556090a840bce29d062327bb879404800cc421213213d8dbea7379d70b47f058b171ee46f28796cf366d772a5f84bd926b3110087697a0c6129735d7ceeec308e27af7299afafe1a1bb1e4330ef02ec088cee196ca230f16d0f08bb34dcdbc17292b68773fe751131baca59c1e88c009608ebbf8a7f00978abd2d7d9029d2fdf5f4abe4e7784924191c586913b04e8d9cc15ee85def176b75ed392a86e4036f7504394ff7ede2e7b9249083da67cd4ed87e4d909afb4147bc4c0fd06bfc8c77dddbc439ec87274b98734cf11ec629a36c18dc962792507848db28b75787e07b5d7637854e7869bc659ee995d93c118b132f79491e0913cb0b1b3512a48e814aaf3310f4f6ef86d42f6f5bf41072f9f95a4196b9978cf28a26a239910ea3fddd264d012d6bd5b83b83791f97e76e2f0002e4637a536d6fb514bf5d62339c886099b693130bc48013b9e43a27b40a1ff23aaf1a6c7d86ed7e51eb0dadb21f7305c84df701dd95763d7b364d56f00717775b45c4702d64be47eb904b072b73385bd1c3bd90d439cabe4f5165a8fb2349573affaf8857539402e341b5bcce627f6b7923d85c86308cf46fa46b9113f4699c2f729401c32ca25f990c5db14e1a22313ec2ad42af082992b86556cb191ea226c129941fd98ff88d624b572c8e41262fd570bb848c4f7f143745b0c8d9333835660b24b2357ca406d6bcabf6453af4a572b0b331177e75ff0f4cc63b9a0b044fb2cdff24438dbe3c2c2b7f9467f0650d34ccab6bf650c2548aef8d4fc399933c2ca1a5ac03af4349c0e68831a74d69d3340bfe958ea7da99ddffb631be099044b8ed82bf188e4a693a1a44565795f6c11453f5ecbd5f70d4b7c4ad7c8751b2380ad644c55f58a5ee82b012ee547469120e4d24d300c52f1cba7e801eb1c989492c4684745fc0f9c59f2641671447b1f8e229ecff24422ae1831612629b9c221e19107322fd0f1f2427dac3175afda922d5c9c540b59d4f2ae2bd082fc50c12ec8af7b08ef929e51dfb72463cba4daff5da12cdab6cc1c54599da5c98378e1bfafc9671c51bc795a20f415f988a85dc6e9fd8a12d7d21fd08c663ee49920473cf6ee2827ecba52bc3fafba1db1f6f4403445a387935b93fff2a817760360f557cfc63b7d2ac24eb1511602f91f42aa4462abdd131fb26622afc28a912a79d49c0646b4522c8172d27597e34fe468c04d2489e1a4ff57cd9dfcf4afbf02e0186ff636036b3ebb8ca6518da7b6bccf064ac3d374c0c741cb691b028dc787ffddf559dd65cc828edc2b6f324323aab8658758d7ba0f8c6a62aaf8335a9bf78933f90c57c435f1f4102d7baf29ca95bf2c864efd8d8598849b338b69feda6d0aa4d13b8e258ecc948e1a861cdd2011e810f1af1d3af2038761c1b81d5080857642ca585f96218c90ef3ea506a3121c0cadd657af9e3c10d780a1c7c8a2f7ffe5fcc0500dffa48d983f6c609b9482a49c78a144ff8bd913512827986370a6364066eac313684b27bc3963eb44bd9938995a1e93c69516126d8f66ca17b73f3632c5b1fe8d4df6546767425272ab872ceda145395505631714aaccff8a7dab352adf7a31f941e3cb5fba7684411780357a9f36913d6d6e59fa25351200eeb2224a308c165358d4cc665f9bccbe0d8fc209f661e95a18fd3b7f6163c70059f3b8bec7d2b12caff6aa601c4c849d60cae958b747c3342df374a40dcc09590cc6ff24a33da331fd7ef5d2f5c92d78240f9578542e728fc48457dec75e4a88660102ad2a9786e3fe4b602eceb0f9a06533f4c165adb94b3a40ac97ab6b7ab233b74e4c2b16dd1a9696ac1e81a99c26ce14bc4d62de2bfcafcedc56fbab46a7b739a69da809e94d882cd1e435b878336fe90568565dae1935bf13f58eadfa51940041874a885c82a320c56f6170f77d52edf79fcc6ab603ca9668c40bad321e5adabe84b798dd2b5a4a27a800082d123912c55adc5843d4f6bba728901485e31b7a00358c625ee022866c2bb5f4fd594dae1bc02c204139ae923dafcf211b42ecbde3061c72cf0faa39133bc43b38ae14d92d324ecace482ff01de32880b7e9aa69e9586f82253b58db08a9fc845cdde5d72986c08a6e08d4b46004d03286343453a6a00ffb86a699c811356ac17e19abeec735c6b2d5c7855ecdbad592082acf852db12413a95792248663d088d4ba02008a956768426c6392adddcc6c0d766a2225c41197c5be5b7727310e2bb9caba83dfa5f8d668db980cc2b26634bc3870efb6fa20393ff03174fa8a89cb500163d0d01b6fd9fafa7f9fad09b99c50bd51c52b01cede07ef1ad22bc1876a09574c254ac26bfec9170159a3df9f20c2f5c85266f1e58f15b4322d8d50cf90475628e7538f229dfe7e7383ad5a1f3223b997a259754f5227c1c400491d53971b07331bde7c734bc704c9fc372546ab5ac18e708d239c8c8613236fb5c060a7a846263558f58178fe14e02639f0d7b300ea88a4a4a6f0a3de161abcadff518a3343181718357f3aea982548ebcb4768f314f42d05aea2ac71c31b16fc86ade8feda53eb81e848493b026c083315431e2bad8c89d51805138f6a563b91c7eadcafd30f2d35b653e1b9f9692bf51fc40ea8c1ea0c4155bd3393539173e8e61821dfc01949c1765a3ae8894b72e09b4739dc5287b9c5050daf4335214718d7a654a0b9117cd21952074f24780c91d7c952b4920319543135e4e2cf6587d32548b85c25eaadd7b443b4359f541644893ee4375887e67a906e53470b27bfffa77f40f314b929ff085a2e2e3665769f5b44ccd412ac036f4f425993389d62adaa4039078b8552cdccc9d45d4fb77486b68964648bf17aa3f874f7c3d7095da98d9e7b796d6bb5c5a84496b5a832886bd52e83c6dab51a5914a687f81887ffa1d6257c09d6f2d4e964cd9c1f04581fa8aec1372190d3bc472ecc1c0212dd8c698c997df9c188b3dff62db460824e2e046f55015860066f08d90956915e32b06759b28944653dc1b35fbc2e1133abe6ced4e37e5808e31f588446a634da3f11f590d70ae3d7cc4ff6b212cf6de40c71983ab365d0167291171d3f788b563afd870b2fe0f3d82d19237e36e7e731c1ada7938876f6c2104dbf8dc476940d674e43572ea5b4009b0d550dfe2dc0941754951eef50bea97590313081ff48f7f99a38364fd0e20dad5e264e593114c1008bf56b835d1596cf9da6b069879e5898a32b409a47ad621384fcf33bd75d63167adcb978f455f02ebaeab3e42ac41cd350b6e873a9101e5a1185fb0fcf9e5abfc9629f10ee7b736df5a01cc212e74b1ffdcb1cb64f7e6c905c3aae0b0e1f6455e6bd9e96a7128e04f4a3691379e23c23ba4aa9d96b225ee3fe32312d5493f06190a34525eac0788b7f9a106ad80b120e74381cfe5291f42b74335c01e32fbaf314796884f55eece42a68214daa1882c02b6d85b137fc7d1a5163d08c5e68052057ae26790cea648f0adffb821146a680b5500aabaa0631ab249d9ecec247776bfad2372d95f1097d089d56a8cc0737cda1145aaaf8782007d48ea4c1f47be3d13899203d0f96b094b024ce93bb4d645e7ba50083e5a7d92cba30009ff7b9b3077905a353c01c236f8a01d2629254992eef942c3259b64808c6126111810d13af925edbff5cc8acb55d7c16f81642e56cf8b79b5d4b29c256322e14a2e079e9ada53c4e4ca0a7bf4ed427e0fa0cefaaeca7719b12674714dcbc3566727eec08c130fff6ab27881dd0387e1b5133262e8ddd890e7989e936486b5bc5ccddac29d40c7db5439ca09d11830ad0900690f8e2f48d0b870da898234a81262377e2e79357bd93a607a4c80c7cc86a71d356e017e5c25e2d5a15e909465d3129ba090ef39b82a024e938156d17ce19bdca485736293abec255abfb00f0cd7bd30c7174c1ebcf2d66176f081067aff49c30f0fc7c2a5056ed1b34d7b4c19c6599f91a5ac0818acf4f08491975a7543a4ceb71f975e91e6fd1d80e48cef2f55dfc6d1c2300146ef7ab09d1c64e1807b73af9d7e481a0fb463a98b4100a11f4de8b7a95a2db6f01915739d46db77ab08007405e049594282ded2936c83663ceeba055d0b6f731dec6a9fad87c16f005a0962b00c9cf5e1691ad6ba2483de4e6da789a577d250db2b479499863db2968715d6729fc845d2073bc7ce3715cc79341f74d121c5b9d439fa87a135b335daa7847daa1e4546d2d520535fc6db73d85b452d05415ce2061b2569d8a460e775551ad99a5fef690829115ce12282026d7126d708dbeb5b480ae515914f66238d0d1a6ae8e4e0a749d894e1072114024479d18a49e512ca80096065aba96efa8efffaef667ca36567d6770f50f596ebe89f61de4dec7ac8234f7b97c615efbfaea13699dfe52060872b536d771f14963e5a1996d7798f96d819537d13997589c10f201f855b5091a27554daa9492753eb56f8dff01f0763707cafeaf90ada0ef843de43fb3f7ee8db074ab681d7867e33223570dd4c0f22df5495931c6376348a1fce0ac04642a7eb7c9ef4d1ed6115f4a4075ba6e93da476ba094202adf1e37ec4be150f21a06ffe8366ec9a11d8553ed67de1eb6b1d549df50b2709a9514683a0e333fec3a3defcf23bd20403fdf0b2f42b3f56bc97daf33e6841d10e0d5ee69811ffb878edf68093a4575c558a89a67fdba79d4e1d9c76f24de2a87d032c5586b827c2bacc1a328ffdfc78d000922d0e878f9253d61bfe323c7ea602bf657dc8290749e7a3a59954ab5b23641c80613bc426bb6d94cf8a7ebcbf0e86df41cd02ce3f46544e9b463549d58f91a9229a086044228a3032166d984c3a453566348c5349fa68331f488b4215f80d04b7527c2019803ea2721bde4ff824eb3d433ebe5e24d5edda6e1e9997a204ca94938af3dd300532fffc7f9c7798b6dd863a4070db56ad09c3b7fbce48e45564f328b6fd788d8aafe93f776a02ad28863232f8c9fe41f1987cf37022897fd1f8be8059419422aa3c7b1e2ba5833c4d6cba0452612c45e16303be2946dd6384b2f653c47b6cba9f9deb4e40ed36045cbc58be48b443e5b488f672458cfa0a88bfbcb7688d70eca6df65f927cc29f7883be1e31ac38180e917bba37d61033b6d24319d795e74875d134a53c1bcb254504159c8ff546fb35ca4c18d5e81ccc8d0f5bef7090254c48cdd7626ffb3ff01adf02b870247bc2cdea93e16def09e148b451d61e6c942e4854337823e3fa2e270f265e77be42b9ba4a1030afc02277be9177d8bca5c9978ce8fde8d371a264faff3612185b33ad7d0a2e6cd9d041472adeff0b110abc3257fd4707e575af89dbaa34a0b1ab7b17cb4de8ec52c8ee88e64d82eff124c2a97593b680fadf01e91e8f4ac12b869cf83959689a8788656eb6741d740399cc48c95c4b8b6167207d7a5a5aa1fd5a4f6fa664a7cc17fb586b4ac777d7bc43469130c49d9f67ebace560d110089916910d04d09f407bff4292e1848e21aaad9155f7b992d52455f29b93f7ec5c47d6df1ff565af93a4978efc67f9a0d6a7072db8b212c0345ef29e2c35400bf9863075cbab80ba1378cddc0906b772597b1b2c998d2a71b3bae8124b383771055f912c60a96470b508b654b415d07f7b421e5a57193c97748ec4b590ee38e2b94133c1d2d84536da36e08ef5d356a6a4a9eef47711dc46a2ee216724fe7d960106a3201726742f5697a321f70651128ed0ed2a68650043ac8b05aa59715da281b5d492e7c2bf536608d55cac774767c759a1e51960b27ad11a1f5da593792b847517fa83e797965ccef86932437fa3eff19808fe273e39f8669f497eea126d77a26d686387551d2d8a7e1d8478e88965e7ee527339278953c6b3feb41a81e56bbdfe3ddc2de8e6bc49c9a145bf00e1fcd1fe02de059ad7ab8675f1aec6c67fe322319aa2c1ec61c01c576658102f9cc55fe5b9e803eae51fe45774a7e4eea20fa658a04f754ac6f4a2c47cb0b5595cc61b48a3fcc08c76cbcd399dffb03d5d2570922141b9f73d89aa55382cacb004e93831364ac9c22c79ba33e20b10f8b7d578dff47cb28fee02bc5ede02c09fef7860fce1731bdf3640898728b0fd43ef586ffc8385ce1d1e937f48ba40dac6d8c156e5b2a0e6dc214ff5df00f6fd91d1f2c0ca84e452a719370ad87bfb131dca78b1ecd2608481fa45a71cb8f40709034c99cb82e8b9ddc4c2aa396fc906a38cfe95dab59481083ce13df3e2e09d49950135d0d7b0568324ffbb07bbad47512b684291a40840fa778fcd768cae99a6b6c3de8239e83c0e6aed78e61b1a94176437a22680c6cb0ee2fabbe81144443c011a8bcc23fc0a1ec03948cabf40fbb02c78264dab99c656ef08ebf55e7e39dd5f81c790d0661ec094bb571188c1808cfbdc0421453f60086178a5b319d0a80163f1ffde16fdc35651e4b4e599037ee27836a18965ab81e6cedf32377b229eb6b533ee2fd7179881f3e4caa47a626aaff78590f548bdb599f8850c96571481aad2a8d960d91d834ceae36e225d51a665a02fd448fddb12ffa43412f15c240097a3c2ff3a995ad11a92bc445c25d8f1aab31813b9e39e79608680eb6cf3261bfe765aa3ed7bc94bb952fbfff59d518c285ade560d9dbb7129c28865af8041015e3eb688beb97c4c2e4482a13fe1627ec38430c8f7bceabefa5966aeb381c8ec4e40214625687000485e7b63404a55968db55e9aaa8fda137f0d9889a0f4f932fa3925db7675cc9334a5e5fd8c0ccc89483607ad4fbeaa89d5af87399574b4f220ede5080ab26369980a9263bbb35ec2b2a105ea873e3d6df740bf5574141caf4b04ea73932ce76d71d1e679113c17db54e4b168bba83f6cbc5a6829f3d781b6c7d0f1b19ddf8e1c6baf8fc3e5dbc03c1d1e87fcc7edde3873cb4556fa4e0f093865463bbbf6a41d115812bdc4c9794264f9004e8795eedbddf073cfb089e2735215b6b2a273968cf70979c589c5cfdfbc9a59c876548017d0cd43a55e3dace516c8ff5ff22d0b027a5a728c76e6be9d68d18e8176f882023a80f0061415ecaa6d21e4193860a8aa991d7e056989fe77f48b02fa890abe8d0ed0a808ce7ae962509dbe6b46f0170f541b811096548c821d6a1e75578193f2eb7c090ce804f6b9f21672c38a28d575d492d7381444c8a6e508526bdabc67c6a2b03fa2d4f1f4df5438e88d147acde44073e8559f7b762acccdbd8a773ef5ecbae08da5909dea61557f854a1667c6fbc430240c63bfca301233c5b4b7f051d062a9aec83e60040323a9fc909b46c91d0e9cc16bbdff050833047b9527f91c991ffba44f75ba0e61ea1079e8e28d2e58f23ebf96b06fbc736993f34397c1623475f8165a33211675bd7500d3e0476774e48c97e713e844c96e7fca8dceba5e5018e286ccebcf4503bd3dfd857c9fc9861a9866924f958288a5d9eec8329b7f3baebbb544b4564484aa432d22f3ea7fe2bd7339ac6a3d98ba62a406a609d815396aecbec653781f64676a244683bcf1ee5a14d3952e9281c29bca025eeb2ff58e8dc148b037f5b897edb6b297dc4c554539548e3544a164a6f4edd022b10fc04c32737ef654cbc2a60c49f4118da921c65775e42aaa650b722c31c86fe6f6b5ea4797fb1654ccd2a9710b2530ecfa33dd1e44af1a580926de7dcfbc130a0bbc1b9cce28facbe594beff8aba62fdc3aba005332868df32abffdeca171de5d91614d952e6f6d5311abddcd2d93a8e655cbe294b84abf670febaffa5ad1a9bda9085ed737a1cbd71d8bb261393bdf6c6f50b8db19ffe647f8162baea781f187671afb693c3f833f38130ba71f34f1864e7abc62437cb66d472cd5e3eefa084e6564d32b432335cd5a67c2627b511af761cc2e210569771e099f39c1eed1d4b2c6a84e56863fe75894014811667ec814a92389bd7cdd254471058aec597da7ed484ff0a331f1eeb5f14e9501454738e0f70a9f04fe8b8c96b45d47bc9d9942666d3e8b70c626b57496397f26ccbd6da2a604736876643136f259ce935812c185682f02187eca0dfc193ed9ebd9f9c138ad79bf61c9c4ae3e475ee3abcce32aa3a87765b2d527758da231df4876eb5252fdd74ea45b2cb63edbaeb3a2423b9259446757714ffa25d01615796a6af085eed6b5d7a19ca89d3e9eb8fc796adccd1c6dfac5a57a133600c92eae6d8557f64b28da9e377ac91361c1981cb808d129647478fc93ff00d72f115b2d70c3127ef7fcb6df9f2777a197812a5df55e6ba0e5000d7cac25dc56b7eedebbbac62727ba99067c168c4ec90f9e46d5fd3d01204ac91ee45fe563a64966be8ffdff483c2f4c291108d87ee6c1f5dafad7a471ea837abd7b53f7b2241c121c4a64ae8f547073749de94c6030598204e087bde0b30e0d9bceab96a67be7d057ddab2671562009dd0312fd7ada2584ffc77a9dedcf0b6ed1be8f5974ee213c2743e4d5a885a864375b7c228dbf6e512c73d537ef6f1130ba3ef539778eb51d8155ecbbf73c7122478a3b87be0cf26d4b6043751173e78514b1953fba0a96e7e59c64a352b4be93cfc139f0cb6713d981ec0bc9fa99f62ea515784f871940b872bb1e786303c1d44f5ae948a54d9d390b26dcf0332c72fcdfcc0fb5b9183b7bfb3390e6194cd46c13f092acf709ff7fa892d444ed2ececd60b08ba9d2f443d3a69b4e262c66a7f4195d779795e5b3ebf8d05cd6a3b34bc5c01f8354cc72e68a257dd3f71728eccb24aff3cd200a81f9f7c304516f845e1ea7faf65b0ed04b002f41f0be5c31d1609fd59c7b8a1694769e161f039294d86135efe3da97226a46bb60d35ad9dce37caa348ebdf8bbacd458abe2454db1b57804c47b4437896403a372bd2b6812700da6663b7e59e32f15a79935e9e2a2d1e8022a09637dffc91a604c4f581a53f865e1852fe1301a11b11464f08dda149a8b923c111e88773d1a6ee95a17eaccd0df3545331345fbe1e37425a52a00fa4736c5e60e4eb9736c4ef3412a543ad15ddbbc428a7989784022219bce426cd042fdd9cf101063feb188604ccc95cc2550ea8635a79983e959918fe72e629e8aa055d18560c3f65c8facbd9e967b132545fb152288d878ff40d585197766ad43e7cbc41fc99194fa3646f5624eb2ca9910ffaffbc19d5ef64edd48125ea76efba2053babdf6138f3303d4ff342c31e47e29348d6fb26124d16d4d040a774e8de939d8a1a768ba36b64707c2962541c1d676c2548661c781928538a967a23c5142eb277af688d5af07a5fb73e307d528db6f0eedcc9b62d4f36a219e130e3fd2d36e302ae5f07fe45ef5f9425d692513c2a94663636e73b0087345484954f706ee9271746a07e7cc00b77fd7d12ebb2d4fad0433b27be83830b4a7419c91c4748cfdef0c937ba38d8a25eb99e4ac58465ae00d2d101e9775ef8405e442c2a0b081b13a809af0a078c904eb1a80d63177f164341b525fecb473814fef13b53200d2ac818aa6305e03775fb0b397cdda1b26ac2596b0396c71e683fe94541c6e080b54599e662d78d227af44bf1c32acff98a0a27029fa44175b9d122ec4de7fe197f195bdf23676d5c4d4df562d5d6823851b84479db20769e48329d62c48db02cb7d633a521fde11a7bce80508c80632dff2ff5edc139a3b4a28bde11e20d1ad81adbcf92d7abb41884357e48dfa0a3fcfee7c5f98574735d43897c12a6c3fc45eca8742a7cc18f21a4cb2d6e8c52effa78a33d5e547f79ccd8d30e77e099f2c537fe8897b67b320802febfdf5eae5a0bded947b2aaf8483fc2d1529a74a8212c45d0cd60583b7998fbddb7d7b3d8f9d9719b911b61aa0e50850dd4ea01a1033668a977ef6add1afc1b580b3cccf8349b6240c0741a9c05987d1f1cd5a8a2e99fe0969aba0000c20c647b4458e93252ee7cb33932079626121c2782c5fb903f441ff8cbade040f23f3a954c901707c494c9875457264ea6963983109667906cd1a4b712484e35eeae8867b50bcf8fd43f1a30945f703ebc29382920cf0ffda7c2fb3ae622858d8918e6bd024124a084e23419ac95a6fa20ec942cbc159d4d387e1f4e9f61bd94cd72f5eb1d5e1243bbbbf9a7ee832ffec282962e70820c0b3285746d7cdb092de1bf2a7e5e99456ed8ae5e351a98af69fa99890fb77b6ea595694b428c9625a9cb6cd38f4116a5578635e4813c8aac8438ad74dd3fb6959e3acee5c71da1fd4983f3e57928707f823b6814d6b4a4f0a8116e3546e771288c189b97efd5b57db4767e352eb9592c369567bb8863371dc7e095c59d944a6dff57eedee29898890dc375589e44ac8549d04a833284f3eb40fa5c400e486139dc0fdd37f5294afd085fd82b08f2d2412db2853e7fd3bf7d35787e4a54f608832a4c14d64b0be7a36993755763136ecf72af2261b2eafa4880f551cd016ac3fb729ee4acd74e82e3f25b93d7d126bbbeaa2360d7e9d9bc0efe5450895b3c3f58edf68292619f524798fb0f52bf8a3b45b15a2f8402e8c38d9ebe6cf6a4ed03e2c0e16a6e4dc3ca3580bf88d6f86b5d70f32602a0c1d42e18a6c4a88118be2476b222dfa2b6fe5dbb9a07005e789faed514d6a1f79d0dac4775b520be25683b3efff787413313fa0cdbe99b56ae139101be655478b64be7934fdd347521272a13588b987e8987606c892587fa86d22446b6c4d539d6c4dea464d80812336fe3cd5a777adc07db1a8ff199fa001c71592bf4828938ee9fd45fd4ef63f2c1d7fab2dfda43da46786ccbb2b0ef06858e818aacace83203f8ab74bd06d2a85a9cd1e3ad18c81b861cb1ba5b35a540e5ec6286c2a54af52537df9cc5b89e74ac0af1019686657324b97d52e9512526c77849be6b3a91328c20e00086b6a86a3f7a26328c2c65b1ff15f8bc6635f4d216dd02876bb38402b8562f3394259739efacca7a2f62ebb33c258dbc57bdd7b3c42d31b8b09eca54f5948e51b0a70fd5f0492aa30968335acc9db683bef9a630e954150b12e35cff8d8b09e1cbf56ec1843b685c326425375ffc2bde030e7c17beb6170312b9a043e926386cbaaeedc8c4e2c00f8594494b4dcab9cbdae083c18e4a9797ed59e477a121a7195284542c4d29da4117ef13cbd466a07271b5b9aee44b669251e23b03dbee987344858df19310b6e677e21e45d69170bc7d3f4c87124aaeadb56801c81489adb42c1f3b7a7feffa5c3c854ad3daaba5f9b210f0353b311cb06f90cd6725659a4fed0eb68c3543e2693935d67bbddfe96c09358af191eeae5426d483b5308b2e31ae3179d205e2bdd048f827bf8a9edcc76d7f790eae6406d0a036d0fa7d3c59585e7ccb06fcdb5bc288d5156aa4446cb2b4da660e4a6a580267d2d2b5dda77b3e6aa7bdf79148c9c90fa723926db60f0d593a14fb3737917480425536298f1993fde955178539bf80b9fbca1cecfcae5dd4ac8ee4ed0ff1b374369ada6f6dfaf5cd6b6eedb8692264eca44a41b1ee027fbd90e1a50ea0766a2b470f8d8bb53f9bec0acc4e59dc64b10882c2503c16cc4ce108a9324c27a426fb13781b0d1ec5e8db766a197bdb2c0fc4126f6010325c7c8390302abff6f2a8588e086bec24ab30c9e7515c168a933720664d30c1eba691856102ebbb8b1651853f4d1bb02b5b7efd6b14f8c076198eb00e1b59317bd3b2eaa86eb13afdca548c34d8f2c299dd779aea7b3877c7dfdaf5431abe65af4201a025932f14eed2064d30e73af8ddd0aef8c2cbefe3d1aed5757096d7133a02efe8d812606f6562d22fe29bb8e5865248f51666c4d6f0f73a26497c1e1643f1bae79b856ff5077a565f384616d186a640357367a8654b201eba893e7af528f20bfef9c109baddb4036cf7156747b38c75d1a7a5c9be00ee1aebcfe6580e0a24579afd9142f998b5854929cb4442809505d2090466794368dd60e88bb76dc83ec21a3c3dbd0747ac77c7e0fcb08d5e441611627a73ce5b4915b47919480151789bf1652776f41f1a4284b4d715a753cdf97fdc8bdff372140d7f21679e66e06453d459ad88468cf508738723fee76a5799fe8ab5022766edc793ac9e5c73265bab4696022737d69a9921f7436577641ba594e66fcfdc22a468f93d413fb5ac42db86748568c229592adceb3f34fa0754a97feab21440b65059fa30898a8781a8daec1a7aee8badf8c40a1bb6bbd2e7159fca552baac03097be154fcfba5e08fab6d53e46a448adb5d12aec200bbc6ad1d86698be93158ed5946cd18eedee1d3d491ec8cf8cfd3c51091bd68b32ca99ba6050be1a93f3129bf556301ce792c70cceeaa8fc9019b390fee706f5c6d1ed0bebebb0dca642308dfb51811e2caedbdb2a493b760a95feb5084d0a8c829833e521412244ccba73c8ef970c443f662017a1f42ad44812587e79b074db95b9200579a4e2e073b3b56245f50343bb6a11a33458d3d28b0dde998b8bb9713a2f4e8ccbff16e2e0bca33e7c630a0a7725886841c4a9471b9c96500e61bd652dbecd89e6dc886bc02e632992f99c08cdff0c9c09588904ead89672177dd520c4726fafc9edc676071a1042165e2bb104d7a744d071cde32151c63b288b7ac64b6563fe4e9ce251163f84811c039b26ffb7eebb2c83c265f5bdb450adc0a6aecaf26301a7eb9df894bba0e4868adc4c582006deac80e0d789b119be77ed64af07a563191aaee69b77b4908f46f004ad4d49bff4b921f6dd45704915205cfe3521a2e8fc6c2142b4b7642184452b687994d1b38699aa6a6e127d42b10d607a8e4f5d2d1c0e5855f4d2418bfd97fe43da49dcb6b9c8b98deb50e4b5aa1cd0ecd455f9cf610abb1d5389f32c377c5ee90406470274b54b01fe02e1731c4f945af246f1acde08e4e12225787aff22e7d05fd89eeaa9ce972bf8f5fcd0db91e2c4016f5d1c61cd0f310d007de4ee558e213f3a066fdc796c7d65d3870a6dfac6e09d03e49e49d7c107eeb17966153e537068b14d90839c6efcf44474115de85fdcd898702eeb5bdd8f56755b976aba8520f13d43f71a73ab8d6f2953ef620f5aed919d71009c37b18ec7d900f3e0e4e18e50687b0844ccb2e57f606ea311527a945cb1115a329b67c11a5c32c897b238c755708a55</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的夏天</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa1025 城市里的间谍 题解</title>
    <link href="/2021/UVa1025-solution/"/>
    <url>/2021/UVa1025-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><a href="https://www.luogu.com.cn/problem/UVA1025">link</a></p><h2 id="solution">solution</h2><p>显然的，这是一道线性 DP 题。</p><p>而「时间」则是计算顺序。</p><p>题目要求求出最小等待时间，而转移「时间」这一状态与当前所处车站有关。</p><p>所以我们设 <span class="math inline">\(f(i,j)\)</span> 为 <spanclass="math inline">\(i\)</span> 时刻，在第 <spanclass="math inline">\(j\)</span> 个车站的最小等待时间。</p><span id="more"></span><p>显然我们有三种转移决策。</p><ol type="1"><li>在当前车站再等待一个时刻。</li><li>乘坐向左的列车。</li><li>乘坐向右的列车。</li></ol><p>不难想到我们用一个数组 <spanclass="math inline">\(v(i,j,k=0/1)\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个时刻的第 <spanclass="math inline">\(j\)</span> 个车站有无列车向左/右行驶。</p><p>设 <span class="math inline">\(t(i)\)</span> 为车站 <spanclass="math inline">\((i \rightarrow i+1)\)</span> 和 <spanclass="math inline">\((i+1 \rightarrow i)\)</span> 的时间。</p><p>那么转移为</p><p><span class="math display">\[f(i,j)= \min\begin{cases}f(i+1,j) +1\\f(i+t(j),j+1) \}\\f(i+t(j-1),j-1) \}\end{cases}\]</span></p><p>两式对应的条件分别为 <span class="math display">\[\begin{cases}v(i,j,0)=1,j&lt;n,i+t(j) \le T\\v(i,j,1)=1,j&gt;1,i+t(j-1) \le T\end{cases}\]</span><del>我有一个优美的状态转移方程，可惜这里空太小，我写不下</del></p><p>边界 <span class="math inline">\(f(T,n)=0\)</span>, <spanclass="math inline">\(f(T,[1,n-1])= \infty\)</span>。</p><p>答案 <span class="math inline">\(f(0,1)\)</span>。</p><p>由于是「自底向上」的递推方法，要注意 <spanclass="math inline">\(i\)</span>要逆序循环，还有向左向右列车的能够转移的状态的差异。</p><p>对于无解的情况，只需要判断目标状态是否等于 <spanclass="math inline">\(\infty\)</span> 就可以。</p><p>还要注意 UVa 的奇怪输出格式。</p><h2 id="code">Code</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 0x3f3f3f3f</span><span class="hljs-keyword">int</span> n, T, t[<span class="hljs-number">55</span>], f[<span class="hljs-number">255</span>][<span class="hljs-number">55</span>];<span class="hljs-keyword">bool</span> v[<span class="hljs-number">255</span>][<span class="hljs-number">55</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">r_</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//快读  &#125;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    R <span class="hljs-keyword">int</span> i, j, m1, m2, d, k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n=<span class="hljs-built_in">r_</span>()) &#123;        T=<span class="hljs-built_in">r_</span>();        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) t[i]=<span class="hljs-built_in">r_</span>(), f[T][i]=inf;        m1=<span class="hljs-built_in">r_</span>();        <span class="hljs-keyword">while</span>(m1--) &#123;            d=<span class="hljs-built_in">r_</span>();            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i)            &#123; <span class="hljs-keyword">if</span>(d&lt;=T) v[d][i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; d+=t[i]; &#125;        &#125;        m2=<span class="hljs-built_in">r_</span>();        <span class="hljs-keyword">while</span>(m2--) &#123;            d=<span class="hljs-built_in">r_</span>();            <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i;--i)            &#123; <span class="hljs-keyword">if</span>(d&lt;=T) v[d][i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; d+=t[i]; &#125;        &#125;        f[T][n]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(i=T<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;            f[i][j]=f[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(j&lt;n&amp;&amp;v[i][j][<span class="hljs-number">0</span>]&amp;&amp;i+t[j]&lt;=T)                f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i+t[j]][j+<span class="hljs-number">1</span>]);            <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">1</span>&amp;&amp;v[i][j][<span class="hljs-number">1</span>]&amp;&amp;i+t[j<span class="hljs-number">-1</span>]&lt;=T)                f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i+t[j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case Number %d: &quot;</span>,++k);        <span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&gt;=inf) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);        <span class="hljs-built_in">memset</span>(v,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(v));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树上问题α</title>
    <link href="/2021/natsu-TRpr1/"/>
    <url>/2021/natsu-TRpr1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>树上问题可谓是老生常谈，家喻户晓了。凭着老少皆宜，童叟无欺，毒瘤遍地，常数离奇，复杂度迷等特点使NOI 系列比赛出了很多奇葩树据结构题。</p><p>那么我们就开始吧！</p><p>设 <span class="math inline">\((x \rightarrow y)\)</span>为存在由节点 <span class="math inline">\(x\)</span> 到节点 <spanclass="math inline">\(y\)</span> 的路径。</p><span id="more"></span><h2 id="从最基本的-lca-开始">从最基本的 LCA 开始</h2><p>此 LCA 非彼 lca（某候选队爷），但是相信大家都明白 LCA到底是个什么，这里不做赘述。</p><p>你说，你会 LCA，那我便考你一考。。。</p><p>LCA，究竟是甚么意思啊？</p><p>不就是最近公共祖先吗，<del>去 LOJ 看 lca 的头像啊</del>。</p><p>对呀对呀！......LCA 有四种求法，你知道吗?</p><p>编不下去了。 QwQ</p><p>LCA 有倍增、树剖、Tarjan、欧拉序 <spanclass="math inline">\(+\)</span> RMQ 四种常见求法。</p><p>那么有人会问了：向上标记法呢？</p><p>呐。。请问各位写过它吗（</p><p><del>写过当我没说</del></p><p>咳咳，实际上是因为这个算法太过返璞归真，就跟解方程时遍历集合 <spanclass="math inline">\(R\)</span> 来求解类似。</p><p>而那四种多半都是对这个算法的优化。</p><p>倍增最好写，实质上是对向上标记法的倍增优化。就是</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(d[f[y][i]]&gt;=d[x]) y=f[y][i]; <span class="hljs-comment">// 一定要写大于等于啊！！！</span></code></pre></div><p>或者写</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=dep[y]-dep[x];j;++i,j&gt;&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>) y=f[y][i];</code></pre></div><p>我在这里出错好多次了（暴露了我的菜。</p><p>倍增与树形 dp 非常相似，算法的流程简单明了。</p><p>设 <span class="math inline">\(f(x,k)\)</span> 为节点 <spanclass="math inline">\(x\)</span> 的第 <spanclass="math inline">\(2^k\)</span> 个祖先，显然转移为 <spanclass="math display">\[\large f(x,k)=f(f(x,k-1),k-1) \quad k \le log_2n\]</span> 在 DFS / BFS 预处理节点深度的时候可以顺便求出 <spanclass="math inline">\(f\)</span> 数组。</p><p>顺带一提 DFS / BFS的同时还可以求出与每个节点到根的距离，然后求两点间的最小距离。实际应用时，应根据要预处理出的信息选择两种遍历方式，<del>但还是DFS 好写，用处更多</del>。</p><p>查询的时候，对于点 <spanclass="math inline">\((x,y)\)</span>，将它们置于同一深度，然后。 <spanclass="math display">\[\text{You jump I jump!}\]</span> 通过 <span class="math inline">\(k\)</span> 递减顺序不断让<span class="math inline">\((x,y)\)</span> 往上“跳”，比较祖先就行了。</p><p>复杂度为</p><p>预处理 <span class="math inline">\(O(n \times log_2n)\)</span></p><p>单次查询 <span class="math inline">\(O(log_2n)\)</span></p><p><del>就是容易被卡</del></p><p> </p><p>Tarjan同（du）志（liu）的算法是一个离线算法，实质上是对向上标记法的并查集优化。</p><p>但是实在是不常用，最起码我没在实际做题时用过。</p><p>Tarjan 同志的算法一向思路巧妙。</p><p>此算法将「访问完毕并且回溯的节点」标记为2，「访问了且尚未回溯的节点」标记为1，其余为0。同时开始时每个节点各自为一个集合。</p><p>用并查集维护「上一个回溯的父节点」。</p><p>但是我说不清楚。。很巧妙的算法，并且这位同志证明了每次查询为 <spanclass="math inline">\(O(1)\)</span>。</p><p>预处理 <span class="math inline">\(O(n)\)</span>。</p><p>处理询问 <span class="math inline">\(O(n+m)\)</span>，<spanclass="math inline">\(m\)</span> 为询问个数。</p><p>就是常数有时比倍增还难看</p><p>在此不再赘述。</p><p>至于树剖和欧拉序 <span class="math inline">\(+\)</span>RMQ，我还没有系统地去学习，大概下一篇树上问题博客会说一下。</p><h3 id="接着经典题走一波">接着经典题走一波。</h3><p><a href="https://www.luogu.com.cn/problem/P5836">Milk Visits</a></p><p>累加每条路径的权，查询两件间距离时候大于0即可。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P3398">仓鼠找sugar</a></p><p>设 <span class="math inline">\(dis(x,y)\)</span> 为 <spanclass="math inline">\((x \rightarrow y)\)</span> 的最短路径长度。</p><p>如果 $(u v) $ 和 <span class="math inline">\((p \rightarrowq)\)</span> 的最短路径相交，那么有 <span class="math display">\[\large dis(LCA(u,v),p)+dis(LCA(u,v),q)=dis(p,q)\]</span> 或者 <span class="math display">\[\large dis(LCA(p,q),u)+dis(LCA(p,q),v)=dis(u,v)\]</span></p><p> </p><p>也就是有一条路径的 LCA 在另一条路径上。</p><p>稍加思索不难证明。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P1967">货车运输</a></p><p>题目要求不超过限重，不难想到因该最大化每条路的限重。所以在原图上求出最大生成树。</p><p>那么对于点 <span class="math inline">\((x,y)\)</span>，如果在并查集中<span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 不在同一个集合，则 <spanclass="math inline">\(x\)</span> 不能到达 <spanclass="math inline">\(y\)</span>。</p><p>接下来就是每辆车最多运送的货物，不难想到最多运送的货物就是 <spanclass="math inline">\((x \rightarrow y)\)</span>路径上权值最小的边。</p><p>如果用朴素的算法去求最小的边权，那么复杂度会上天，<spanclass="math inline">\(O(n)\)</span>。</p><p>联系我们对想上标记法的倍增优化，不难想到对求路径上最小的边权进行倍增优化。</p><p>设 <span class="math inline">\(d(x,k)\)</span> 为节点 <spanclass="math inline">\(x\)</span> 到它的 <spanclass="math inline">\(2^k\)</span> 辈祖先这条路径上最小的边权。</p><p>接着不难想到转移 <span class="math display">\[\large d(x,k)=\min{ \{ d(x,k-1),d(f(x,k-1),k-1) \} } \quad k \le log_2n\]</span> 可以在求 <span class="math inline">\(f\)</span>数组的同时求出。</p><p>所以，在求 LCA 的过程中不断维护路径上最小的 <spanclass="math inline">\(d(x,k)\)</span>。</p><p>这题毒瘤数据，给出的图不一定联通。</p><p>顺带一提，<span class="math inline">\(d\)</span>数组是什么，怎么转移，在第一页且算法相同的题解中，只有神鱼讲到了。某些人直接一笔带过甚至完全没有提到过。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P4281">紧急集合 /聚会</a></p><p>三个点两两求出 LCA，三个点的深度减去它们 LCA 的深度就是答案2。</p><p>而三个点 LCA 中必定有两个点相同，那个不同的即为答案1。</p><p>至于证明。。画图是显然的，但是论述的话感觉很多思路都不是那么有说服力，就不献丑了，自己说的自己都不能完全信。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P4427">求和</a></p><p>大概是 LCA+树上差分，但又没去差分，仅仅是用了它的思路。</p><p>由于指数范围较小，我们设 <span class="math inline">\(g(x,k)\)</span>为根节点到节点 <span class="math inline">\(x\)</span> 路径上点权的 <spanclass="math inline">\(k\)</span> 次方和，在 DFS 时维护，设 <spanclass="math inline">\(dep(x)\)</span> 为节点 <spanclass="math inline">\(x\)</span> 的深度。不难想到转移 <spanclass="math display">\[\large g(x,k)=g(y,k)+(dep(x)-1)^k \quad (y \rightarrow x)\]</span> 这是建立在点上的，可以看作点权，求路径上的点权和。</p><p>我们知道，两点之间路径的点权和可以表示为 <spanclass="math display">\[\large ty(x)+ty(y)-ty(z)-ty(f(z,0)) \quad z=LCA(x,y)\]</span> 其中 <span class="math inline">\(ty(x)\)</span> 必须是根节点到<span class="math inline">\(x\)</span> 点的点权和，画图不难证明。</p><p>所以这题就可以切了。 <span class="math display">\[\large g(x,k)+g(y,k)-g(z,k)-g(f(z,0),k) \quad z=LCA(x,y)\]</span> 注意要加上 <span class="math inline">\(mod\)</span>的两倍，不然会当场去世（</p><p>同时，借着这题说一下树上差分。</p><h2 id="树上差分">树上差分</h2><p>差分本是对序列的操作，是前缀和的逆运算。树上差分就是将树上点/边的区间操作转化为差分，用前缀和求出维护的信息。</p><p>大概就是这种思想，没啥可说的，通常与 LCA 结合。</p><p> </p><p><a href="https://loj.ac/p/10131">暗的连锁</a></p><p>经典题目，显然加入非树边 <span class="math inline">\((x \rightarrow y)\)</span> 之后会形成一个环，将树上 <span class="math inline">\((x\rightarrow y)\)</span> 的边上任意一边斩断，再斩断非树边，就可以击败Dark。</p><p>姑且称非树边 <span class="math inline">\((x \rightarrow y )\)</span>将将树上 <span class="math inline">\((x \rightarrow y)\)</span>的路径「覆盖」了一次，不难想到，如果树边 <span class="math inline">\((u\rightarrow v)\)</span>被「覆盖」了多于一次，那么无论如何都不存在合法的方式将 Dark 斩断。</p><p>同时不难想到，如果一条树边没有被「覆盖」，那么将其斩断后再任意斩断一条非树边就能达到目的。这题差分的是边权，求子树边权和，仿照上题的叙述方式，则有 <spanclass="math display">\[\large ty(x)+ty(y)-ty(z)-ty(z) \quad z=LCA(x,y)\]</span> 是不是很像求两点间的距离？</p><p>所以开一个 <span class="math inline">\(w\)</span> 数组，如果有 <spanclass="math inline">\((x \rightarrow y)\)</span>，就令 <spanclass="math display">\[w(x)+1,w(y)+1,w(z)-2 \quad z=LCA(x,y)\]</span> 通过 DFS 累加子树的 <spanclass="math inline">\(w\)</span>，最后求出方案数即可。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P3128">Max Flow</a></p><p>与上题的区别仅仅是 「差分的是点权，求最大子树边权和」，在累加差分数组<span class="math inline">\(w\)</span> 时取每颗子树的最大值即可。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P3258">松鼠的新家</a></p><p>差分的是点权，求每个点的访问次数。给出的访问顺序两两求出 LCA并且差分，与前两题基本相同。</p><p>注意最后需要将访问顺序 $ w(a_i)-1 i n $ ，因为差分时会多加一次。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P6869">Putovanje</a></p><p>稍加思索不难发现，为了最小化费用，第 <spanclass="math inline">\(i\)</span>条边只能用单程票或多程票，并且取决于经过 <spanclass="math inline">\(i\)</span> 的次数。</p><p>题目要求按照编号大小访问，不难想到两个点间的最短路径必定经过其LCA，所以在倍增求 LCA 的时候将路径差分，最后用一次 DFS求出每条边的访问次数，即<span class="math inline">\(g\)</span>数组。</p><p>然后取 $ $​​​，累加 <span class="math inline">\(ans\)</span>​​​</p><p> </p><p><a href="https://www.luogu.com.cn/problem/CF191C">Fools andRoads</a></p><p>题意很简单：有一颗 <span class="math inline">\(n\)</span>个节点的树，<span class="math inline">\(k\)</span>次旅行，问每一条边被走过的次数。</p><p>淼题，。，注意要按照边的顺序输出。</p><p> </p><p><a href="https://www.luogu.com.cn/problem/P1600">天天爱跑步</a></p><p>有名的毒瘤题。</p><p>通过简单推式子与转化为树上区间问题来解决。</p><p>lyd在他的蓝书中已经讲得很清楚了，<del>懒得讲了</del>，就不献丑了。</p><h2 id="树的直径">树的直径</h2><p>通常意义上，直径为树上的最长链，可能有多条。</p><p>证明略，因为不知道问什么在 hexo 上报错。</p><p>两次 DFS / BFS的思路都是相同的，都用到了「从一个节点出发能够到达的最远的节点一定是直径的一端」。</p><p>从任意节点出发记录最远能够到达的节点，它是直径的一端，再以它为起点记录最远能够到达的距离，显然那是另一端。</p><p>证明的话，写出的难度大于想到的难度，放个链接，<ahref="https://oi-wiki.org/graph/tree-diameter/">OI wiki</a></p><p>复杂度是显然的。</p><p>树形 dp能优美地求出直径长度，并且能处理负权的情况，缺点也很明显，即相较于纯粹的DFS，后者能维护更多的信息且更好写。但是 DFS / BFS无法处理有负权的情况。</p><p><a href="https://www.luogu.com.cn/problem/P5536">核心城市</a></p><p>题目要求 <span class="math inline">\(k\)</span>座城市建到一条链上。最小化最大距离，很容易想到是直径。</p><p>所以两次 DFS 求出直径，在第二次 DFS时标记出直径上的父子关系，然后求出直径中点。</p><p>以直径中点为起点进行DFS，求出每个从每个节点以它为根的深度和出发能够到达的最大深度。</p><p>然后将求出的最大深度与原来在树中的深度相减再+1。</p><p>最后将得到的数组排序，取第 <span class="math inline">\(k+1\)</span>大的值即可。</p><p> </p><p>删掉了一题，过不了 hexo。</p><hr /><p> </p><p>不写了，再写就猝死了 Orz</p><p>直径还有好多题，以后看情况写吧。</p><p>接下来会把做题中心转到 DP 与数学上。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树上问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3778 商旅 题解</title>
    <link href="/2021/lg3778-solution/"/>
    <url>/2021/lg3778-solution/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><blockquote><p>修改于 2022.6.27</p></blockquote><p><a href="https://www.luogu.com.cn/problem/P3778">link</a></p><p>由题意得盈利效率为一个分数，故此题为分数规划。</p><p>由于 <span class="math inline">\(N\)</span>的范围很小，所以就可以大胆地使用邻接矩阵建图，并使用 floyd 算法。</p><p>题目中的盈利效率定义为：环路中的收益/花费的时间，给出的数据是两个集市<span class="math inline">\((i,j)\)</span> 从 <spanclass="math inline">\(i\)</span> 购买和从 <spanclass="math inline">\(j\)</span> 卖出分别的价格和从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span>的时间，并不能直接用于求盈利效率，需要预处理。</p><span id="more"></span><p>设 <span class="math inline">\(g(i,j)\)</span> 为从 <spanclass="math inline">\(i\)</span> 点买入，在 <spanclass="math inline">\(j\)</span> 点卖出任意商品的最大利润。</p><p>所以，我们在读入价格时预处理出每个 <spanclass="math inline">\(g(i,j)\)</span> 。注意这里要枚举 <spanclass="math inline">\(i\)</span> 的所有入边与 <spanclass="math inline">\(j\)</span> 的所有出边，并将其差取最大值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k_;++j) &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;b[i][j],&amp;s[i][j]);    <span class="hljs-keyword">if</span>(b[i][j]==<span class="hljs-number">-1</span>) b[i][j]=inf;    <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-number">-1</span>) s[i][j]=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 对于无法购买的两个集市，将其值改为相减为-inf 的值，以免影响后面的运算</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=k_;++t)    g[i][j]=<span class="hljs-built_in">max</span>(g[i][j],s[j][t]-b[i][t]);</code></pre></div><p>设 <span class="math inline">\(d(i,j)\)</span> 为从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span>所用的最短时间，初始化为正无穷，读入所有两个点距离之后进行 floyd算法求出。 这里用<code>memset(d,0x3f,sizeof(d))</code>的话只有82pts，血的教训。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;    <span class="hljs-keyword">int</span> x, y, z; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);    d[x][y]=z;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) <span class="hljs-keyword">if</span>(!d[i][j]) d[i][j]=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)    <span class="hljs-keyword">if</span>(d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];</code></pre></div><p>设计完状态之后，就可以列出盈利效率的式子了。</p><p>不难想到，二分一个 <spanclass="math inline">\(mid\)</span>，表示盈利效率为 <spanclass="math inline">\(mid\)</span>，设 <spanclass="math inline">\(i,j\)</span> 为环路上可以相互到达的点 ，<spanclass="math inline">\(V\)</span> 为环路点集。</p><p>易得下式 <span class="math display">\[\frac{ \sum \limits_{i,j \in V} g(i,j) }{ \sum \limits_{i,j \in V}d(i,j) } \ge mid\]</span></p><p>但是如此并不能直接进行计算，要把它转化为<strong>对环的判断</strong>。</p><p>所以我们设建一张新图，设 <span class="math inline">\(f(i,j)\)</span>为新图上的权值。</p><p>不难得到 <span class="math display">\[\sum \limits_{i,j \in V} g(i,j) \ge mid \times \sum \limits_{i,j \in V}d(i,j)\]</span></p><p><span class="math display">\[\sum \limits_{i,j \in V} g(i,j) - mid \times \sum \limits_{i,j \in V}d(i,j) \ge 0\]</span></p><p>所以我们令 <span class="math display">\[\sum \limits_{i,j \in V} f(i,j)= \sum \limits_{i,j \in V} g(i,j) - mid\times \sum \limits_{i,j \in V} d(i,j)\]</span></p><p>所以 <span class="math display">\[f(i,j)=g(i,j)-mid \times d(i,j) \quad i,j \in V\]</span> 然后跑 Floyd算法，判断有无环并取最大值，再判断最大值是否大于等于 0。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> ans=-inf;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)        <span class="hljs-keyword">if</span>(i==j) f[i][j]=-inf; <span class="hljs-keyword">else</span> f[i][j]=g[i][j]-x*d[i][j];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)        f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i][k]+f[k][j]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans=<span class="hljs-built_in">max</span>(ans,f[i][i]);    <span class="hljs-comment">// i 到达 i，表示有环。</span>    <span class="hljs-comment">// 因为初始 f[i][i] 设置的是-inf 所以不影响答案</span>    <span class="hljs-keyword">return</span> ans&gt;=<span class="hljs-number">0</span>;&#125;</code></pre></div><p>二分过程。其中初始 <span class="math inline">\(l=0\)</span>，<spanclass="math inline">\(r=\max{\{ g(i,j) \}}\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-keyword">int</span> mid=(l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l=mid; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,l);</code></pre></div><p>几个细节。</p><ul><li>值域是 <spanclass="math inline">\([0,10^9]\)</span>，对题目中的“如果没有任何一条环路可以盈利，则输出0”并不需要特判。</li><li>一定要开 long long！</li><li>因为我们对权的处理，并不需要除法，因此可以完全无视题目中的向下取整。</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>分数规划</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论β</title>
    <link href="/2021/natsu-GT2/"/>
    <url>/2021/natsu-GT2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>目前我所在的地区还没有太受烟花影响，就下了点小雨</p><p>但是这一个月一点作业都没写 qwq，说要换班结果现在都没有消息</p><p>今天还要水一篇题解（</p><p>好吧 ╮(╯-╰)╭，进入正题</p><p>这是一份图论总结</p><span id="more"></span><h2 id="最短路">最短路</h2><p>老生常谈的话题了。。</p><p>我们都知道最短路常用的三种算法： Dijkstra，Bellman-Ford，Floyd 其中Dijkstra算法是「纯粹的最短路算法」，它基于一个性质，即：当边权都为非负时，全局最小值不可能被其他节点更新，所以可以不断取出全局最小值标记并扩展。这也就导致了，他只能解决广义上可以转化为最短路模型的问题。它有堆优化和桶优化，但都不是本文的重点。</p><p><a href="https://www.luogu.com.cn/problem/P3008">Roads andPlanes</a></p><p><ahref="https://www.luogu.com.cn/problem/UVA12661">有趣的赛车比赛</a></p><p>这两题都是正经的「最短路问题」。</p><p>而 Bellman-Ford就有意思得多。我们一般有用它的队列优化形式，也就是那个死掉的SPFA。它有其他很多用处，<del>可惜我不会。</del></p><p>SPFA算法的本质是对队列里的节点，用它能到达的节点对他进行「松弛」操作，使所有节点满足三角形不等式，对应到最短路问题里，就是设 <span class="math inline">\(d(i)\)</span> 为原点到 <spanclass="math inline">\(i\)</span> 的最短距离，<spanclass="math inline">\(E\)</span> 为边集，则有 <spanclass="math display">\[\large {\forall} (x,y,z) \in E \quad d(y)\le d(x)+z\]</span> 这像什么？DP！</p><p>DP 对状态空间的遍历构成一张 DAG，顺序为该 DAG的拓扑序。DP无法处理图上最短路问题的原因，是因为图不一定是一张DAG，状态之间有后效性。所以加一维，就可以求出最短路了，将其用滚动数组优化，就是Bellman-Ford 算法。</p><p>这里懒得写了，就放几张 rxz 课件的图。</p><p><img src="https://i.loli.net/2021/07/31/ktlbg3Ico1ZrmxF.png" srcset="/img/loading.gif" lazyload /></p><figure><img src="https://i.loli.net/2021/07/31/LUaA3o8Hj6lDKOJ.png" srcset="/img/loading.gif" lazyloadalt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2021/07/31/9jcRSEpkbs3VrNX.png" srcset="/img/loading.gif" lazyloadalt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>所以，SPFA的每一轮松弛操作，对应状态转移。最后，全部的状态收敛，满足三角形不等式（优化后的状态转移方程与三角形不等式不谋而合），所以就求出了答案。</p><p>我们回过头来看堆优化 Dijkstra，它实际上近似于「堆优化的SPFA」，其中也有传奇的三角形不等式。</p><p>这启发我们，对于有后效性且不便于加维的DP，我们可以使用类似最短路的方式进行状态转移。</p><p><a href="https://www.luogu.com.cn/problem/P4042">骑士游戏</a></p><p>经典的一道题，运用了上述思想。</p><p>Dijkstra和类似拓扑序的顺序也能做，而且复杂度有保证，<del>但是不够刺激</del>。</p><p>看到题解里有人把一本通用来讲述 SPFA用处的话贴了上来，顿时想起那本不仅大力推崇SPFA，还花了大量篇幅讲述何种优化方式及用法，<del>然而全部都会被卡掉。</del></p><p>在这里吐槽一下这本书，通篇宋体，码风奇怪，抄袭，漏洞百出。</p><p>就算讲解很敷衍，也坚持把全部代码贴出来。</p><p>而且抄袭的部分感觉讲解不完整，<del>没有联系上下文</del>，非抄袭的部分思维局限，舍本逐末，讲不到核心的思维。</p><p>很多人只知道去建模，只浮于表面。</p><p><a href="luogu.com.cn/problem/P1948">Telephone Lines</a></p><p>这道题有两种做法。一是用上述 DP与最短路问题的共通性，建分层图，直接跑最短路。</p><p>另一种是二分答案，将不花钱的线看作权为0的边，其余为权为1的边，判断是否可行。</p><p>这种情况又有两种做法。</p><p>像不像二叉树  (￣︶￣*))</p><p>一种是使用双端队列 BFS，另一种是在 BFS时，扩展完一个节点，将其改为未访问的状态</p><p>两种方式有细节的不同。</p><p>这启发我们，SPFA 是基于 BFS的算法，其能求解权不为1的图的最短路问题。</p><p>最短路问题与DP，类似拓扑序的奇妙结合，则需要我们自己做题去思考并体会了。</p><p><a href="https://www.luogu.com.cn/problem/P3953">逛公园</a>(这题可以看出 pair 的常数之大)</p><p><a href="luogu.com.cn/problem/P2446">大陆争霸</a></p><p><ahref="https://www.luogu.com.cn/problem/solution/P3645">雅加达的摩天楼</a>(奇怪的题，<del>我还没做</del>)</p><p>SPFA还能用来判负环，以及用在分数规划中。具体可以参考我之前的博客。</p><p>至于 floyd，我之前的两篇博客都讲得差不多了，，</p><h2 id="生成树">生成树</h2><p>相信大家对 MST 很了解，这里就不细说概念了。</p><p>有两种常用算法 Kruskal 与 Prim。</p><p>Kruskal算法基于贪心，由排序和并查集实现，每次选取权值最小的边加入最小生成树，简单好写。</p><p>Prim 算法维护最小生成树的一部分，及 MST 点集 <spanclass="math inline">\(T\)</span> 和其他点集 <spanclass="math inline">\(S\)</span>，每次找 <spanclass="math inline">\(\min{_{x \in T,y \in T} \{z\}}\)</span>这样一条边并加入 <spanclass="math inline">\(T\)</span>，具体实现不作赘述。</p><p>感觉这部分没啥好说的，也可能是因为我做题少。</p><p>最小生成树上两点的路径就是两点的最小瓶颈路，即路上最大边权最小。</p><p>呃……好像就没了。</p><p>次小生成树和 kruskal重构树都没有深入学，仅仅是知道。（<del>我连模板题都没切掉</del></p><p>随便水一个最短路径生成树吧。</p><p>在最短路算法进行的过程中，原点到每个点的最短路径是不断扩展的，而将这些路径加入一个集合，此集合就是一颗最短路径生成树，即所对于边<span class="math inline">\((x,y,z)\)</span>，有 <spanclass="math inline">\(d(y)=d(x)+z\)</span></p><p><a href="https://loj.ac/p/10064">黑暗城堡</a></p><p>对于上题，先跑一遍 Dijkstra，然后执行一个类似于 prim算法的操作。即维护最短路径生成树的一部分，每扩展一个节点，就判断当前树中有多少节点满足上述条件，并将结果累乘，最终求得答案。</p><p>纯粹的生成树问题，要么很难，要么很水，大多数是配合其他算法解决树上图上问题，这里就不放题了。</p><h2 id="差分约束系统">差分约束系统</h2><p>差分约束系统是 <span class="math inline">\(N\)</span>元一次不等式组，形如。 <span class="math display">\[\large x_i-x_j\ge c_k \quad i,j \in X\]</span> 其中 <span class="math inline">\(X\)</span> 是变量集。</p><p>当然不等式也可以变成 <span class="math inline">\(x_i-x_j \lec_k\)</span> 这样。</p><p>与三角形不等式十分相似。</p><p>所以考虑将其与最短路问题相结合。如果把构成差分的两个变量看作节点，不等式的限制看作边与权，那么最短路数组<span class="math inline">\(d(i)\)</span>就是满足当前不等式的<strong>约束 </strong>下的 <spanclass="math inline">\(i\)</span> 的最大值。</p><p>据 smy 所言，图论是在线性代数下的课程。</p><p>然而我并没有深入理解。。。</p><p>而由于这仅仅是一些点之间的关系，直接建图的话图不一定联通，所以有时候需要虚拟原点。还可能隐含一些限制，所以也要注意一些情况，如<span class="math display">\[\large d(x) \le d(x+1) \le d(x)+1\]</span> 而这样的题目多是求最大值或最小值，不难想到</p><p>对于最大值而言，要使满足形如 <span class="math inline">\(x_i-x_j \lec_k\)</span> 的式子最少，这是显然的</p><p>所以跑最短路，图中不应出现负环。</p><p>最小值则反之。</p><p><a href="https://www.luogu.com.cn/problem/P3275">糖果</a></p><p><a href="https://www.luogu.com.cn/problem/SP116">Intervals</a></p><p><a href="https://www.luogu.com.cn/problem/P4926">倍杀测量者</a></p><p>那么差分约束系统最有意思的地方在哪呢？</p><p>当然是 <strong>約束（やくそく）</strong>辣~</p><p><ahref="http://music.163.com/song?id=32235890">言葉のいらない約束</a></p><p>$ キミの背中押す、結んだ約束 $</p><p>$ 推动着你前行，我们定下的约定 $</p><h2 id="一些话">一些话</h2><p>莫名想起去年的暑假</p><p>那个没有OI，没有whk，没有被孤立，无忧无虑的暑假</p><p>那个曾经被我认为没有意义的暑假</p><p>在刷B站，玩游戏，听歌这种循环往复中感受到了夏日透出的清凉</p><p>仿佛能蒸融那些鼓吹“竞争”，支持学生内卷的噪音</p><p>我还记得那个夏天快要结束的时候</p><p>纵使滚滚乌云遮蔽了天空，耳机里的歌声仍然能把我带向更远的地方</p><p>然而开学后呢？</p><p>”成绩”所带来了虚荣也好，麻烦也罢，彻底毁了我对周围人的信任</p><p>发生了很多事，每一次都让我看清那些我曾经当作“朋友”的人的丑恶嘴脸</p><p>剩下的，也就只剩那些交情不是很深的阿宅们了……</p><p>$ 夏の夢に染まっていたいだけ $</p><p>$ 想要只做着夏日的梦$</p><p>$ お願いどうか覚めないでよ $</p><p>$ 拜托了请不要让我醒过来 $</p><p>回收初二这一年，一直在逃避，逃避学校内的压力，逃避自己的现状与未来</p><p>似乎没有做好一件事</p><p>而如今，自己确实走上了自己希望的道路吧。。。</p><p>Tommy_Keen，K神的签名大概是</p><p>be strong，小伙子，在OI上，你比半年前强了那么多</p><p>半年前，1月31日</p><p>我最没有方向的时候</p><p>一个连 dfs都不会写的菜鸡，还受到了外界的打击以及胡思乱想给自己的心理压力</p><p>前几天的夜晚</p><p>那个又迷失了方向的夜晚</p><p>“不必在意那些学了好多年的人啊！你一定能超过他们！”</p><p>“他们只是时间比我充足啊！”</p><p>如是安慰自己</p><p>可在晦暗的房间里</p><p>回应我的只有氤氲着「嵐（あらし）」气息的风裹挟着的划过眼角的游丝</p><p>远处的天空，只有单调的灰黑色</p><p>是那么孤独 那么孤独</p><p>但愿我能做到吧</p><p>耳边响彻的 <ahref="http://music.163.com/song?id=33367345">夜明けと蛍</a></p><p>夏が来ないままの空を描いたなら</p><p>/若然幻想出那片夏日仍未到來的天空</p><p>君は僕を笑うだろうか</p><p>/你大概會取笑我吧</p><p>明け方の夢</p><p>/於拂曉之夢中</p><p>浮かぶ月が見えた</p><p>/能看見那片浮月之空</p><p>朝が来ないままで</p><p>/若然能永不迎來清晨</p><p>息が出来たなら</p><p>/如此呼吸生存下去的話</p><p>遠い遠い夏の向こうへ</p><p>/那就往遙遠 遙遠的 夏日的彼方去</p><p>冷たくない君の手のひらが見えた</p><p>/我並不寒冷 因為能看見你的手心</p><p>淡い朝焼けの夜空</p><p>/遍染淡淡朝霞的夜空</p><p>夏がこないままの街を今</p><p>/此刻走於這夏日仍未到來的街道上</p><p>あぁ 藍の色 夜明けと蛍</p><p>啊啊 蒼藍之色 黎明與螢光</p><p><a href="http://music.163.com/song?id=30053338">IA 版本</a></p><p><a href="http://music.163.com/song?id=1302953072">鹿乃版本</a></p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论α_暑假day26-27-28</title>
    <link href="/2021/natsu-GT1/"/>
    <url>/2021/natsu-GT1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>今晚上出去吃了顿饭，回家就已经9点了qwq</p><h2 id="闲话">闲话</h2><p>自从夏令营结束就一直在颓废，整天摸鱼🐟，昨天终于开始卷OI了</p><div class="code-wrapper"><pre><code class="hljs markdown">消え去ってしまってよ　行ってしまうなら<span class="hljs-code">   除去掉了啊　起行了的话</span><span class="hljs-code">   僕はここで止まらないで</span><span class="hljs-code">   那我就绝不会止步于此啊</span><span class="hljs-code">                 ------- ウミユリ海底譚 </span></code></pre></div><p>这就像海底谭一样令人感动不是吗（bushi </p><p>快乐水没了，，，烟花马上登录山东！</p><p>今天中午出去吃饭，看到蜜雪冰城前堆满了人，生意红红火火恍恍惚惚哼哼嘿嘿哈哈</p><p>所以我就像在夏令营那样去了阿水</p><p>真的懒得等了，orz</p><h2 id="言归正传">言归正传</h2><span id="more"></span><hr /><p>前几天我搞了一个图论&amp;树上问题的题单，其实有一部分是我觉得不错的题目，其他的随便挑的题，具体好不好就不能保证了。。</p><p>感觉POI题目质量不错啊</p><h3 id="section">7.26</h3><p>写了一个割点的模板，没了</p><h3 id="section-1">7.27 &amp; 7.28</h3><p>通过 <a href="https://www.luogu.com.cn/problem/P2939">RevampingTrails</a> 接触了分层图的概念与简单应用</p><p>所谓分层图，即</p><p><img src="https://cdn.luogu.com.cn/upload/pic/10006.png" srcset="/img/loading.gif" lazyload /></p><p>(图片来源于 <span class="citation"data-cites="fy1234567ok">@fy1234567ok</span>，侵删)</p><p>适用于把一张图多次修改的情况</p><p>建多层图，每一层对应每一种情况（具体做法就不说了</p><p>这样的话，最终可以求出每一种情况的答案，取合适值即可</p><p>相应地，其时空复杂度也是随层数上升（常数通常上升的很离谱</p><p>然后又学习了<strong>分数规划</strong>及其在图论上的应用</p><p>经典例题</p><p><a href="https://www.luogu.com.cn/problem/P2868">SightseeingCows</a></p><p><a href="https://www.luogu.com.cn/problem/P4377">Talent Show</a></p><p>这两题式子很像</p><p>0/1分数规划模型为：</p><p>对于给定的 <span class="math inline">\(a_1,a_2,a_3,...,a_n\)</span>与 <span class="math inline">\(b_1,b_2,b_3,...,b_n\)</span>，求一组解<span class="math inline">\(x_i(1 \le i \len,x_i=0/1)\)</span>，使下式最大化</p><p>$ $</p><p>分数值必然存在单调性，所以我们二分一个 <spanclass="math inline">\(mid\)</span>，使</p><p>$ mid $</p><p>经过变形不难得到 ( $ $ 炸了的话就将就看把。。。)</p><p>$ ^n_{i=1} (a_i-mid b_i) x_i $</p><p>所以就有了t2这样的0/1背包的规划</p><p>当然这只是基本形式，本质是从两个集合中各选若干元素，是他们各自之和之商最大</p><p>实际上式子不会是这样的，但其形式无非是</p><p>$ ^n _{i=1} z_i $​</p><p>其中 <span class="math inline">\(z_i\)</span> 是某多项式</p><p>如果 <span class="math inline">\(z_i\)</span>是图上的权，你会想到什么？</p><p>负环！</p><p>如果一张图中存在负环，那么上式<strong>不会成立</strong>，并且上式成立与否是判断<span class="math inline">\(mid\)</span> 是否可行的关键！</p><p>所以对于关于图论的题(t1)，推出式子后二分答案转判定，不断使用某个已经死掉的算法判断是否有负环，最终求得答案</p><p>对于那个已经死掉的算法，可以用</p><ul><li>最短路长度不超过 <span class="math inline">\(n\)</span></li><li>每个点入队次数不超过 <span class="math inline">\(n\)</span></li><li>最快的dfs形式</li></ul><p>可在最短路问题上，它还是死了</p><p>随随便便就能卡掉，虽然有各种优化，但是正式比赛只有比阿伟还勇的勇士敢写</p><p>但是网络流、判负环、差分约束等非最短路问题上，它还活着 o((&gt;ω&lt;))o</p><p>一个最短路算法，如今基本不用在最短路问题上……</p><p>那么不是图论呢？</p><p>t2实质上是背包，那么通过dp求出最终的答案，判断是否大于等于0，实质是一样的</p><p>下面是几道题</p><p><a href="https://www.luogu.com.cn/problem/P3199">最小圈</a></p><p>双倍经验：<a href="https://www.luogu.com.cn/problem/UVA11090">Goingin Cycle!!</a></p><p><a href="https://www.luogu.com.cn/problem/P3288">方伯伯运椰子</a></p><p><a href="https://www.luogu.com.cn/problem/P3705">新生舞会</a>与网络流结合</p><p><a href="https://www.luogu.com.cn/problem/P4322">最佳团体</a> 与树形dp 结合</p><p><span class="math inline">\(updata\)</span> 2021.8.6 23:51</p><p>站外题 <ahref="https://www.acwing.com/problem/content/350/">最优比率生成树</a>（我还没做</p><p>综上，分数规划可以当作加了一个多项式的二分答案来做，不需要很强的数学推导能力，而且是相对冷门的内容。出了二分以外，还有Dinkelbach 迭代法，然而我不会</p><p> </p><p>然后是两道 Floyd 算法的题目</p><p><a href="https://www.luogu.com.cn/problem/P2419">Cow Contest</a></p><p><a href="https://www.luogu.com.cn/problem/P2047">社交网络</a></p><p>这两道题本质上是对考察对 Floyd 算法的理解</p><p>通过松弛操作解决传递闭包有关问题</p><p>$ X Y,Y Z X Z$​​</p><p>大概长这样</p><p>和通过松弛操作求出最短路数</p><p>本来今天还想学一下强连通分量，无奈时间喂给了 <spanclass="math inline">\(osu!\)</span></p><p> </p><hr /><p>好多内容还没讲</p><p>但现在是 7.28 23:10</p><p>今天就到这啦~</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>山东OI夏令营2021 游记</title>
    <link href="/2021/SDSC2021/"/>
    <url>/2021/SDSC2021/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h3 id="sd-summer-camp">SD summer camp!</h3><p>首先吐槽一句“数据结构提高班”只讲一天数据结构，“高级算法班”讲了线段树、平衡树、分块等等一堆数据结构。。。</p><span id="more"></span><p> </p><h2 id="报道">7.15 报道</h2><p>大老远坐车到日照，花了整整一上午时间QAQ。在车站坐公交车去山外，山外在最后一站，一路上一直在听歌。为了防止耳机没电就用的有线耳机。</p><p>报道时就已经有好多人了，官方没说明白路线，在学校里转了好久才找到报到处。拿到学员证（fanka）后知道了我在新8号楼，结果这是唯一没有桌子和wifi的宿舍楼、、(╬▔皿▔)╯。还有一些没什么用的信息。</p><p>在宿舍知道我市还有教练带队来的初中生，xxs，<del>没有高中的</del>。认识了来自德州的准高一学生zqr，这家伙还会网络流orz。</p><p>去超市买了可乐和阿萨姆，，，，这一晚上大概就是玩。</p><p> </p><h2 id="day01">7.16 day01</h2><p>山外的空调好冷≡(▔﹏▔)≡，开的16度但是晚上被冻醒好几次，早晨常规6点起床了，早饭吃到了山外最喜欢的豆角。。几乎每天每顿都有。</p><p>今天上午在报告厅上课，由来自莱州一中的 <del>孙名媛</del>孙铭远讲述图论相关知识。</p><p>先讲了 dijkstra以及堆优化与桶优化与次短路问题及其证明，有个大佬说可以用 A star搞。。好吧我不会 A star。</p><p>然后就讲了用 A star 的 K短路问题，很多人不那么理解估价函数，我大概明白了，然鹅我还是不会<del>实现</del>。</p><p>还有已经死掉的某算法以及 Floyd 与 johnson</p><p>接着是最长路问题，没啥好说的，然后下课了。</p><p><strong>这里有一个小插曲</strong>：报告厅在-1楼没有厕所，我们只能去楼上找了一个位置奇怪的厕所。。。然而那里只有两个位置，等着的却又很多人。有人说“这和排队接水是一样的”“你怎么知道每个人用的时间？” “估价函数！”简直笑死。。后来知道正经的厕所在六楼。</p><p>上课后讲了差分约数系统，大概就是一堆不等式的操作，，并且讲述了虚拟原点的作用。</p><p>然后是生成树相关。先介绍了两种常规MST算法与很有意思的 boruvka算法，然后讲述了最小瓶颈路/树和次小生成树。</p><p>随后详细讲了 kruskal重构树及其<strong>优美性质</strong>，今天的课程就结束了。</p><p><strong>各路大佬简直吊打我</strong></p><p>下午自己随便切了几道题目，这段时间的题目会在夏令营结束后选几题单独讲一下。吃完晚饭去机房，然而人却满了，，，有两个组的用同几间机房，白天上机时间错开，但是晚上就不行了。这一点很不满意(* ￣︿￣)</p><p>截至7.18 23:00，我晚上没有在机房抢到一个位置。</p><p>所以我和朋友在宿舍用热点切题去了~</p><p> </p><h2 id="day02">7.17 day02</h2><p>今天早上起晚了一点，，</p><p>依然是孙名媛讲述图论。</p><p>先讲了欧拉回路的定义、性质、<strong>美妙</strong>性质以及运用。</p><p>在讲 CF547D 的时候，“找到一条欧拉回路并对边定向”没有讲述过程，后面做这题的时候直接去世。</p><p>然后是树上相关问题。</p><p>括号序，欧拉序，dfs 序。</p><p>还有重链剖分。</p><p>我在十几天钱看过树上相关问题，对于这种在树上一顿dfs与bfs理解起来还是没有压力的。后面说树链剖分一般和数据结构同时出现（其实基本都是线段树），我/(ㄒoㄒ)/~~</p><p>一个多月前我还会写线段树板子，现在已经忘得差不多了。前几天k神给我一道线段树优化dp，我连读题的心都无了。。。</p><p>最后是 dsu ontree，也叫树上启发式合并。是一种基于重链剖分，合并重复扫描，从而降低复杂度的算法。也没啥复杂的，还是树上操作，实质上是一种<strong>暴力，但不完全暴力</strong> 的算法。</p><p>在最后的最后，甚至还提到了点分治。。真要讲了那真的是“数据结构提高班”了。</p><p>朋友在山外超商里买了一个耳机，花了几十元（忘了。。），同款的在某宝只要个位数就能买到（）。</p><p>认识了来自青岛平度的准高一学生官同学和与他玩mc的小朋友。他的 linux技术实在是太强了 orz。我连 wsl 都不会用 ╥﹏╥...</p><p> </p><p>下午举行了 %你赛 形式的练习</p><p>T1：次短路 T2：差分约束系统 T3：欧拉路径 T4：使用重链剖分求LCAT5：dsu on tree的课件例题 T6：dsu on tree简单习题</p><p>t1、t4我之前做过。t2是小k的农场，机房有大佬发现直接输出<code>Yes</code>可以得85分，还能下载数据。所以他们共同合作，特判数据，得到了比我快4s的速度。t3能想明白，但最后的实现上出了问题，，对边定向到底是个什么操作啊。</p><p>smy发了t5的标程（因为讲课时很多人都没听懂，就算懂了也不会实现），t6只要把t5的板子改一下就行了。</p><p>这个班是选手讲课的下界，往下的班就是教练上课了，但是没有真正意义上的%你赛，上机时还没人盯着(￣y▽,￣)╭</p><p>晚上听了yamf的讲座，讲述他羟基进pku的事情，我在下面玩游戏，大概听了半个多小时就回宿舍了。</p><p> </p><h2 id="day03">7.18 day03</h2><p>早上室内温度又低的离谱，室内比空调制冷的温度还低。</p><p>今天是yamf的数论课，但实际上讲得很少，从最基础的质数开始，最后连exgcd和欧拉函数都没有讲到。</p><p>下午的练习</p><p>T1：分解质因数</p><p>T2：线性筛质数</p><p>T3：GCD&amp;LCM</p><p>T4：进制转换</p><p>T5：同余</p><p>T6：乘法逆元</p><p>t1、t2做过了。t3是gcd和lcm一顿推，最终推出简化的式子。t5开桶统计，t6卡掉了我的费马小定理，，</p><p>唯独t4要单独说一下，<ahref="https://www.luogu.com.cn/problem/P4461">九连环</a></p><p>这道题实质上是一个递推求方案数的题（为什么写进制转换？），但是没有取模，不写高精最终只有30pts。</p><p>然而同机房的神仙发现，用python可以直接水过去，只跑了不到200ms！</p><p>所以我不要脸地去Trick了。 &lt;(＿　＿)&gt;</p><p>晚上是lyh的金牌之路，我听完了，但是大部分时间还是划水。</p><p><strong>想不到lyh也玩 <span class="math inline">\(osu!\)</span></strong></p><p>所以我一边听一边玩。</p><p>听完讲座后去超商买了零食。</p><p>还有好多琐事忘了。</p><p> </p><h2 id="day04">7.19 day04</h2><p>今日的课程可就友好太多了，基础算法，还是yamf。</p><p>yamf：今天的课程一定很轻松的~</p><p>然后他讲了鱼神出的 <ahref="https://www.luogu.com.cn/problem/P5344">【XR-1】逛森林</a></p><p>好多人都没听懂，我当时在打电动，没有听完 QwQ。</p><p>yamf：这题没什么思维难度，就是实现起来比较麻烦。</p><p><img src="https://i.loli.net/2021/07/23/XeU82IrZnlcfEVB.jpg" srcset="/img/loading.gif" lazyload /></p><p>还有二分，st表，倍增，倍增LCA，当然这些没啥好讲的，主要是讲题。</p><p>yamf说他把洛谷账号注销了，除了洛谷独占的题目，别的都是从loj之类的网站找的。</p><p>练习</p><p>T1：bfs</p><p>T2：RMQ（ST表）</p><p>T3：倍增优化数据结构</p><p>T4：使用倍增求LCA</p><p>T5：二分答案的课件例题</p><p>T6：二分答案简单习题</p><p>只有t2做过QAQ</p><p>t3是 <ahref="https://www.luogu.com.cn/problem/P3295">[SCOI2016]萌萌哒</a>，这题我自己想了好久，然而没有想到正解。正解是st表+魔改的并查集。</p><p>t6 <a href="https://www.luogu.com.cn/problem/CF1359F?">RC KaboomShow</a>是一道纯英文的CF题目，首先题面我就没看懂，还有一个类似于扫描线的过程。。。最后放弃了。但是洛谷唯一一篇题解是lyh写的诶~</p><p>晚上的讲座有变动，我没去。</p><p>高级算法班的同学们模拟赛出了三道题，分治，数学和lxl题。zqr只有50pts（</p><p>_rqy：题目太水了</p><p> </p><h2 id="day05">7.20 day05</h2><h3 id="我们最爱的-lxl-来啦">我们最爱的 <spanclass="math inline">\(lxl\)</span> 来啦！</h3><p>lxl：你们这里好热 orz</p><p>lxl讲了树状数组，线段树，单调队列，堆啥的，还有一些题（线段树讲得很浅，用的还是以前的课件，讲得和洛谷五一课几乎一样，然而这并不影响我们对lxl的热♂情）。</p><p>最后还有STL演示！</p><div class="code-wrapper"><pre><code class="hljs cpp">map &lt; string , string &gt; p1;map &lt; <span class="hljs-keyword">int</span> , <span class="hljs-keyword">int</span> &gt; p2;p1 [ <span class="hljs-string">&quot;CCF&quot;</span> ] = <span class="hljs-string">&quot;发财&quot;</span>;p1 [ <span class="hljs-string">&quot;lxl&quot;</span> ] = <span class="hljs-string">&quot;良心出题人&quot;</span>;p2 [ <span class="hljs-number">-1</span> ] = <span class="hljs-number">114514</span>;</code></pre></div><p><img src="https://i.loli.net/2021/07/23/Zpcq2zGvAMrhSeL.jpg" srcset="/img/loading.gif" lazyload /></p><p> </p><p><img src="https://i.loli.net/2021/07/23/iE9boYdGJvIyj4g.jpg" srcset="/img/loading.gif" lazyload /></p><p>lxl懒得搞练习题，所以下午自己切题了。</p><p>晚上是smy的dp讲座。</p><p> </p><p><img src="https://i.loli.net/2021/07/23/Rl8FaCMGomXdBxn.jpg" srcset="/img/loading.gif" lazyload /></p><p> </p><p>我究极绿宝石1周目通啦！</p><p>也就是在这一晚，我玩 <span class="math inline">\(OSU!\)</span>​时笔记本电脑突然卡住，关机重启之后x键就失灵了。。</p><p>在超商买了一盒某巢咖啡。</p><p>QWQ</p><p> </p><h2 id="day06">7.21 day06</h2><p>真是有意思的一天。</p><p>今天是lyh的dp课。</p><p>但是这个dp课啊，，，</p><p>从数字三角形开始讲，，，</p><p>是怕有人听不懂还是单纯的水时长啊 (#｀-_ゝ-)</p><p>线性dp，背包，区间dp，树形dp，数位dp，状压dp，单调队列优化（有人说不会单调队列，所有又讲了一遍，水了半小时）。</p><p>每一样都讲了，但是每一样都讲得不是很多，没有讲很多题。</p><p>课件一共讲40+页，但是一共有一百多张。</p><p>最想吐槽的是树形dp。</p><p>例题只有没有上司的舞会和选课，下午的练习也没什么意思。</p><p><a href="https://www.luogu.com.cn/problem/P3574">FarmCraft</a></p><p><a href="https://www.luogu.com.cn/problem/P6082">salesman</a></p><p>比较好的两道树形dp。</p><p>练习</p><p>T1 线性dp</p><p>T2 区间dp</p><p>T3/T4：背包（并不是那么显然，可能需要一些思考） T5/T6：树形dp</p><p>六道题我做过4道。。</p><p>估计某位yba神仙也是，然后直接提交上去了，瞬间400，rk1。</p><p>我直接做没做过的题了。</p><p>T4 垃圾（我）陷阱</p><p>显然地，是背包，只不过状态的设计花了我亿点时间。</p><p>T5 “访问”美术馆</p><p>背包属性dp，最难的地方在于读入和建树。</p><p>T5/T6 都是树形背包dp。</p><p>没有做状压dp的题，我不是很喜欢这种复杂度奇高，接近于暴搜的dp。</p><p>树形dp就很不错啊。</p><p>状态设计与转移都很优美，复杂度低，在各种树上问题都能用到，还有很多套路题可以水AC数和题解（</p><p><img src="https://i.loli.net/2021/07/23/yDVQbMRuHnd23xY.jpg" srcset="/img/loading.gif" lazyload /></p><p>晚上在机房切题了，<ahref="https://www.luogu.com.cn/problem/P1131">时态同步</a>和<ahref="https://www.luogu.com.cn/problem/P1453">城市环路</a></p><p>树形dp水题和基环树有点氵的题（因为我一开始的思路错了。。）</p><p>又去了超商。</p><p> </p><h2 id="day07">7.22 day07</h2><p>今天凌晨0:00，我去隔壁宿舍吃零食。</p><p>有个人让我和他们玩三国杀，我就和他们开了一把。</p><p>我的角色牌很垃圾，最后选了界吕蒙。</p><p>就没有然后了 ≡(▔﹏▔)≡</p><p>被管理员查水表了 QAQ</p><p>还做了半个小时的蹲姿 啊啊啊。</p><p>然而早上起来一点都不疼，就是特别困。</p><p>上午讲得dp优化，基本没在听。</p><p>单调队列优化，数据结构优化，斜率优化，杂题选讲。</p><p>斜率优化只听了个大概，不会推式子。</p><p><img src="https://i.loli.net/2021/07/23/baAxm4w9g5fUFlz.jpg" srcset="/img/loading.gif" lazyload /></p><p>下午一点就去练习</p><p>T1：数位dp T2/T3：状压dp T4：二分+单调队列优化 T5/T6：斜率优化</p><p>只做出了T1，T2，T4，T5</p><p>因为这些东西我之前都没有学过啊，就算懂得原理也不会实现。</p><p>所以做得很慢，而且除了T4都是看着题解做的。</p><p>被各路神仙吊打。</p><p>好吧。 ╮(╯-╰)╭</p><p>就这样结束了。</p><p>大概明天会就这段时间的题目水几篇题解。</p><hr /><p>现在想起来，，，</p><p>走出机房的那一刻，听着<ahref="http://music.163.com/song?id=454966322">ホタライズ -2015 SummerEdition-</a></p><p>斜阳抹过树叶的罅隙，划向云层的彼方。</p><p>夏日的阳炎，融化在阵阵蝉鸣中，与激动的心情一同淹没在追逐而来的风中</p><p>仅仅是七天，但我感觉真的不是孑然一身了呢</p><p>再也不是那个闷在家里自学，愤世嫉俗，自欺欺人的家伙了呢</p><p>我也想去追寻，我的那份「真物」，不管它是否存在过</p><p>对一切都失望的时候</p><p>「真物」</p><p>真的能给人力量啊</p><h3 id="update-2021.7.23"><span class="math inline">\(update\)</span>2021.7.23</h3>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的暑假</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假day12</title>
    <link href="/2021/natsu-day012/"/>
    <url>/2021/natsu-day012/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e97696fed57c2eacca15b6c277414dd667b12c7e78147ad46f35de036607ceb0">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e16a4b7e7981efd30aec051e7f88b2edb3fd47f0ebf3a93b510e2129ef7f3cd7061c2cfcf55fcb847dcde58b1105ab96fddeae6856be6abc2a7f95ac6d0f5c48e8b4ceabe2418cf77729e4048451d2fad74817d73e4b7ea951ea65b175207b0a37fef04c4195b9094d2f94fddfec5d4879b86897d65263db339b8a214d42b211bbafa3ecf88077f5820ca3cd29019abb5cdf2e9ea33b6c4cc116854b23249296fe2225b2883afd34c500b9e8e12204db469dc99805c72f6f4fab4d387332b0e7c9463138d760f7eac301aa2f73b99c1a2880d367da15173c3d8ac6ad383b2ab15455624515d4a996c518be95c3ee02540265f82e1d2dff9e7c3c1ad5c0670299800e1f122f95044fff88a8fa2465906a2676c633adcffa23edbd42c547aa446c8eaee6c4d56eb7aa79ffe28502c726b41ef36bc6f933a7da5eea4412e8e61b696b1fdd141a8ccfe2f43b0bf6709ad7eb9eed600f62ee6b3c907bb14a4dfebb5c61fdf588c270307c083819d83dbb75e5692dc34873ea80d959d42997f69517914c6e981d1383aaf430c2fac545469439d1638c56e417a75e75450d898842ddbdab6cba6e9c274a2fb3d7bc0cf25098636029bed987c0645af28f41a783f8593d9afe8103f4dac0655a932f36177efc91176427dc2d5fe3ac45aa0e0802a2454b161c317505477b43bdb8bb362637f95cb86022b49ca5a19f11987e266651493a1f59a6b90699df576f313e080e2f09cc7c83050f837ee3d612d0c0807aa503aa7834bc490dd8e3108e5953a7002a89f044677d8f0c14aaad349cdbbb1d4c49760be466cd8fecc359bcecf76adc623128c8d80cec17fd8f117f8d096c208f91f3e2d391b20eaf59b05ca7e7198bf03f54b9aafe1dee2c7bbdeef38d8e68d8e2c34cab3c9058b82a9ee91aa4c300638845c4e58fa5f3518937e2a370a8a2e9419258274624a52a41863d996683c8cfe7e9a9852c741c68c74740b2569d5c3c068ee99956f2d23ee2df160b7aa9350d6a97ca3aff716772197be6a30db5835829fee8dcb2b7ccc556770ef2ff8d40d9798014457559ff6d352e53227c33c11dd0c8e2efd6749d904421f76210f92c6e4ddffff8f96e5a6c9759872dc69e56ec83767eb007becf1e110ecbf49f798dd5d83016fb8e4f8b8a1418d6b20191dbb566d37b2661e93e5238a9ffa20f1f26f2422b2c15c369f1a296b2b399091ee499b3a9d821a1c084729b30cc64dc1b0ee59dcd24175c2eebbe06b1f1e8df39ea55fdaa139ed242126711810b523243a2a5d1b052c0eb8fcb2230055854a69ff0a339120fcd4d8c7d0116e00a175e934bac43845a381d3170eb43e5fccf2b9e54306adbd03174a5f094c28dbb3605027d4f6a1fbc9cb0e85481eba28b498d4f2d2ab52aac040c6db0153c4f2ec484f12b71f9ae8fcd0efbc94c70871c6eec2fd7c61ccaec7d1559036f15cbd6237ba5a393375368c92766f6bf8b50b6e8d6da1377f2aa40b93d23e028e79ab16b64fe3931b9f5dae51ab03c0cd3e65585bb438413f288d277947d91ec4806a908fc273dad34e8fae4fff807b00d2d818830a9be47ff474fabee4be7ad92921c50dae2acaf661f9421823ee22bbaf0b54109eb836a1f467c79ddf060abc07c599e4b298efc6da02edbafc9a8ce8cdb8194df13920dc960fd800e22667d629eeaa5e08c0030ec8aa2ef4a9006153a9783237630ebeffcaec12d11b009c2fc9dd36dce4245f04eca67b86c54e52fb0a5f545683fb9576010f5e53511a30e027544c841e22bee9def4c3d2f2a9d07c8b0a9ab2da8c52b650c85f818ee82c4b84595a56e69562456736d49765fd391782f9efa42163ef9308e23b08279f3a4fc8acdd49120caae422381c4f1dce05149615fdd9d394725c5a3fce7598d6bd57506205a517f7d1c465db911810f35202819d13842f986c4daf69739ced77932c274c944d640a75a9ca7416a81e91694adad291a0f2e158be79be015a3e2a4733d29afb1005e619ca39d87e9dbbe6e03ffa4c595781b33fb54aa49155a8ec4dc80db0abb2f727292aaddd00cc9604d867fc3f75ee86618d3da0632f38614c0cf63fcef6d2ec9fdb34870691502565d29b18cf3124b88278719cacbc61315385edaec806b4c65993a081bee7d726b08842d1ab74464d6486c18ceccdc92e42ea3852efe5350549b151d8d7585e80115d9d2b8ce09782cf54cc099b26e14a1445a5102dbd6b02c2d7cb3ad5b1a96ca9f1233696312cbc9acb2eec7f44130f0d4cec06015f5e5356daeecd4888eefd85d5eb2c7d805cdb041dcf94a69dea734ecc832b41cf474c4ee5acffe9675310e3df5b37d469ffe38d580ab4b558f80b481845af338132018977f0b13bc9b2ed4f25bf7302711eb839cccab04c06a416362d5290e23d6a92a47a12a3056f15e0209c2fe194352d72f06fbc2a8ce94304b211a4a088a03ad4178416aa171586103ce95ecc166f39bde7c589b27baecf0ae040b643246030519ad1b06ef32fa8cbe36b06d4c9edf3ce50ac468840dbe9b155dc05a5aed0aac699c329e84ccc1e1e5fc6b9ef714c9d2ede7b60bf986c6153ccfcda00981aadfacf79b3ac042284082f4c158959a4abaa797bdf3b898e600e68ff382f27ad0fc0c5a746da20a00c40454ee3ff69ea38de139d0d0a8add0d2338eb6e09cb282ecf4d6282358c7381475995a081fa52332fed0a510d8e990e7f740501b40c9359eba9b491d0844aaba518bab715b68097bf73b0139feb413ff8141e6aa5d3b670fc37ec02e4b4211582581da8e3a99e9e428570667f2b9fb3064ae54b6674e9cc311f444ac0cba153850fe62d27e1e740c882987dd958b788344b65a9fabb0f519a79d5ce31709e7c4e2eb2761d8be75598af324d999efc3e8cd902f54ea3f86ad47e957cb093dfc2a885b5e8984eb3b8d59581263552ce50b896f8d3517617addee0c903d455a55d05726c390cf86df95e535011fc838451c25a7ecdfa90d2cea75cfac7166c95293dbb5737ce62eaec7a46d10b6edd27f310e9fc28386988e73b0c1158efc35a6a18dc084dedeea2ad5c0ded2d22daa18f1876442699b69e49d1191df59770559eadf207b96a393129334e4ce3c557998af8071d03929c09313d78b05581f0abaec1f45f91b2cbadf069bd4b9afa9a2860b31a18b39759c09a52e9791b2756b7760b3d901421142f74c36e76466802f617bd90fc6bb881f29f762f18bd03afdd2bc7985b643ff5834189b887c74d517457a6c342271df92a97bac84393e1e246f1b37b06b2e3564ab7a67917a4fb5c64e5d4d837219946d98e4e45541ded23aa5651130dbde306c98f9fdf0bc3e843c2b0da669be7d56af53350577d88d940de7edbc7299079e3ced4abb9ebaa90eca0780809bc74f423c410583a1d46f02cc978b6d7fcfb412b3a5eefed35541410ffd29d50ef6aaec1465e371971253475daf219bff2baf9fc2057f31bec8e4b698db50f2cf0c91e4dabc50c1cc54d3e83efc27005a86b706cba1abe1acf5e9084576b4eca2b4c108cdd69dd2d49203449024a568f5616441d85fd08f5e52ca9236290dd55fa70bc27f509252db16258db7287162d2f3ecc136bae71e51be629f30942c7c0f166567b36a5a2029924670799eedea6d25fc3896f51ef3ee62617eaf301c528be986683550ab4c82d05b547ce9da7d2f52cbbc228567feecf5f38e754896cb6bcffbfc4e6e12c75038db21e5da42d55a4641f0701d6232e6938f3871d11c823a38706670c028e1ec96a217fd8b1c5092589e143f6ed9df2cd111b4bff467dac51b9dd760fbd77e22ec5d20bd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的暑假</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假day09/10/11</title>
    <link href="/2021/natsu-day09-10-11/"/>
    <url>/2021/natsu-day09-10-11/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password error." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="81fcc9840b87ceb6245a5cffa3c8a4cd29c6dbf7003f2f58ff1b8fd319d82676">9483d41952f129c8a6370de05915d28b579679abccadc7d8bed95ab8c0f87f8d5bbb5c2b7a38572070c01d34b38328afc3c185c512bbb7024cab3fc10a29820f3f3ae723b9952cc40cdd06cb15dd6eca178f3ada3876eb76b0d9f43dc5d3ef7bd3e2e0277fb7cd2214bd273f3c5d81c70858650ed9f484e7e50f3be6517ee3cbd1408d0d50791ab4689a7a108040941a7a519caf027d9f04c62bdce4375065f3330a59b79f9370fabb928b7ab451f03921a28404723b6f7fce59a6927d815bb14e12c49b277b9b0998b7a731534546e2c9aa13c3236bd3cdbd6798096a345f25334376c751b9cbdc4c84c496e7e363888ce29568fa3f90172c8216a18df250b3bb619438380f9fdcaf3f96031db68d9f06cf183f232e3dafcd3681542d6d2e99a232ef3decd8a7f57e3eb4f9f6ab8359cb1301a59a7ea2fb9ad7c88bcbc7254aeecc62e7c9f29b42fb2bfaeeff38ac666f63537c83e1870f051d209a0ad77b07ad7f0d39f2c4203f00d75dafbbfa8a395d23f3ee645a3dd7e2734fadf063754f1ee3b3b8ff2bc6b124ba17e654ec41e104bce80cc31816d8f9a89bb7e1609dffdd0c043aab04d493f65ad24282790e73e2d17ff41cb7aa694c0690bc09bd37cd865488455b732494f997e3a1f4a65c7fce0dd22c04a9738d31bd8d4492341516625f2a66c309af1980df2b1a179e8b032c4583909b96c25c1cc216c6c4b7256f8287bc29c611aae1e39337d76cf00047fcccec08719464dfcbebbc3f32c2b7908017543983fe5d9a814405c340e38d4a31a131788f6cb6625162e89585b247d3b0c3629cb073ceb508e22c53f0218b5ad68cab2a01c8d351d3fb7a9c5a5c3fc96351ccbcac51c3a5fd7326ef96e2c7b85b30f647e2eb3442bcab90ceeb9fe3f35a27183984b6554ebf53ab6b9548984bca18c73530815a1bfcf1b030b364fc29e85b23fcbee20ee4f86f467bce52447f697dfbfdeb1407b8395212f6d8dae3b1b405a23e6490538145ad3fc8bc4e6caea84c89bb0e34893490c2dc9a15495846a66795979f749d63095bfe1301876cd20416c0f23b81f3c5fddb68793e58397028d8333b13a91132a857a3e1986fc07ae0827820e7518ce1028e1689ebe8cbfe6410c89ec14e93af478935ef2c3a5d3f541322b3b869952f0197efe3277755fbea220a8ae714b41b25eb7ace42571a35285cc461f508225f9077e2473b522e9be1f95894d24f2aed0536fb3393b5a6e3af7e852ed4fba6ad8b2fdc9b61241507872650674c52b8f12e7ef1289c5fe61bd922e1ecd9b1d7fd9a3aee46942cdec3ced409c1997b5280819cac74c3b5a0dc977a0118a3061121e644d8d33b96246f246a59317d4f7262ac1168e98c51e07b7f68d074b7925c4de22a776f6a177d38f43b33c1fbc5c392958a942b398898d5530dcba9ac1e5dedca639d466c5ce2a85166a93ff1ed92983ff29b63c1af910ff88e658219815294c0c0a443331012e2699ca2539c1d13cb18984b03f79313563969bb1e44f78abd557bddfa66df6e1290972c079e90c752c10bad3c9ecd9be1b62c747fd248d7c328243559622036eedf2380eb51d625bbc8c7624eecfd57b719d193889e7c5ac3e58ac01f377f51059759b31e1cb4464b9fa3681395bacdebfcee755b185cc2f49fa462bdb025680a1ae42d334c1ea4b155330bbc7693eaf0db84f96e261781f04d70a352319640d8aea1210971b6cb10cd0429fff7cacf53136adb2a31cd8e156f930e7b50d3dfd06fdac13f5b7e4d40bdfed173e81ff375494f6a6989e23c4d3bfc6cf0686aed08d2f6ac2e8bb99c87efbce2fa3c70c35641c86ed583153fc5d689e3408df0f771572c1a8564e5ec574e294e8e12c119325c8c0cfeecaedf6a22dcd8039722812f3f0318f8f4013cd78bf5a3b62240253d77d447781c196dcd28531c403050cb050d07b33d7b717dacb32120b0bd330338144f4e16a40d8a246c9c2d265a67867924982b9361a1bf863c2389ed7a9746da10755a646baa8f8a1ff2d3482663b4db7bd7ba8eb4552359d8aa55cd04cf9b013ec491da650ca38325f586522a7edd2d32f69115af4fa0145b28ba958e8d2bfdf56e2a9ccd3c317e525f7b11bfb69777f085b57d715e37ee8832544401be1742c7d6f86efa43188fafc26c6d75284a7bf43c321ef48b9f559063e7f536cf8c39592dbd08d775b368efe76f83215b35be3c96bb829b3201e4cb4b290af2ceaad89ac424c4eaf25d6091e26a4297b58469078f2c060dfb908d563445ad87b4786218648ec42b9fa610926ce3c4774c47f29ade9b5c8a0c9c3acd74ddb37a647865836d39d69f434947554acd14114ea1375a729e986dd4466888d2dc9668d888b799ee0a3e82b8adeab414afa1a242f623f5b30488998dcb443f331fa8b387527fa7a999f507002e100be117b9ab64def6d93992f5a7b2da75e0a5ea4d3200341991508d4e279de9c3a3fb423d3682260564d56ca1971a6d7b1477a182d31fcc88c6a871f59db77ca4784a34345edc308af3742a931382df739c611475d965b4ce1f691ee92120d3bdb120292d94ca2fa0240f443298cbddbecdae09a95ccdd7dfc55dc39774c3bd3638f7e13ac99f08063ae569c6f6d408d1dd316077ad23c830589a184a3916db8cb556e4a13f0bd0b8bf57f642f0699c09535c87705640da4a5b08486454a8da45b9d25c625a9bf056fe8d5b2619d3b41d8208d1c02e3729d36e348fccf2ac0530a00047e430ab156b2ca4c9bc88b95489817ac2e3dc8667d5bf58f572b048a435651773d6252164f2e7d2b5e2cfe333f29b9eeaf216b07897a3a405712670b07e11af4d8dca15992ff168e86032eb1a2bccc49951e928b432916e213d3b4e18fb66eba112988f96d744f3ba0a1b5632863f758849b213063f6ab5a102fd5b81bde12b28aed0ac063fbe27ed5c372df957c1030689a741caa47263b74acc9f84adc595cd7a0b738d44aa394896a37722f9f60f456c4b657975d32a3a9f874f7a8186644ebe3fa72a34ff47f080b5b21a73f73b58ede762232f5e707c594ab72d4419b9ba8a747c2b02fd8be579097d88c4a39f7f4293896ddff59925b0fc326c112032e6b15d0768e8ba8e76f98b2179c8692d80f6e3d95b0114ca70a0bd390c67a760d863898c228463fc62b712ac58a0bd7189e36bcd81e79eb3d154d8c9358259a73c6883a2bdffaa2655eebe4bfd9220996aea6ee46de03626b683b4c6a7537360386443b091dacb73ad6fadb5df57f906be310f5fa54bbc3161312bcd99b385383b2a264be705e0afeb7510644621d97c54728027be97bb267e1fc6829d5367a1197d8bc3be0f0669588f235b570a9b3299b766ed649ca1e40c051732ab83eea35627a1c7fed214637d93db4eff8c4bf090b3489d538dcac6a9730867058d3ea2bc0cf447de6ee5d4dce817a0a16ab62eddd5a53762dc57129936f930c870e7197882e668a67c0655d3e776b67f7ac5b046a9d7a676b9709c5aa8b51e5b73331873977db853833c90b1873a3c71ca67c34e2b8fe4b7186d2d32969a5a93c7897d2f36b7cba06fc3b617b07ee17a0dce9925ef3ed5b483c976bd378cd3a9c32680fdbdeda2e589c987def293149eafb06509e985dcc858f888b0c7b292d7f287734e775e679058ee05643cb1046dee5ef2fca9b683936a1910491fe9170cc74b1d538accce5611dff14af5612f699a8f0d8bb748a4f425e1d3ceba58cbd4a8cb996d52819e3fbd1b89055cdfc0211c78fad6d41d8f8b790552f2664574783d3039d437637eb6e8593f22fdc2567faec2092483202cecd1282dced73fbddb68b583b91277d9b9dd39543d6568df870e1af7efcbb607d40cb31fbf3826556cae509c3364dc2340fc46a2e62984ed216391ace3aa0b7ffc33bbf2500ca8a4604badbc4f7c90160411a8c95ea29ffa843ae11c1abb0e675e7ea7efb8b7d03388cf83c67fc60e412d48b3de57860daa0e1f0712147d2f416b952c7b799e9a44934112c91305cfa58764dda4e6071868f0066bf3f9d366db12b85b74047434628a2ffdae5867e058aef6b628e193486af5f511f0721e173a34ff9fdd8d71ce83ea290f3561501cf0ab8a274e3cf7d7f64500599a0a47375cefdf74a1a66fda5e5048459cf5812c6784e4aaad6576d623634e2e028d3e6b1b5c7d5ddf1af3c91dec210d9d845c39470a6256f9b080381f34a4bc9384962a6b32bc26b1b5a19ecc27ddfdc92cc93881c95aeba191e4b4e601f884154ac5b1c4eead5d5ade3eba3db4fadecec98d4f8aaf03</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">This post is locked.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>简记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021的暑假</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
