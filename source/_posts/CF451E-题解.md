---
title: CF451E Devu and Flowers 题解
urls: solution-cf451e
tags: 组合数学
categories: 题解
math: true
abbrlink: 5bf5e6d
date: 2021-08-25 10:33:50
---

[link](https://www.luogu.com.cn/problem/CF451E)

根据容斥原理，得到多重集的组合数。

从 $ S={n_1 \times a_1,\cdots n_k \times a_k}$ 任取 $ r \quad (r\le \sum_{i=1}^k n_i)$ 个元素组成一个多重集的方案数为
$$
C^{k-1}_{k+r-1}-\sum_{i=1}^k{C^{k-1}_{k+r-n_i-2}}+\sum_{1\le i<j \le k}{C^{k-1}_{k+r-n_i-n_j-3}}- \cdots + (-1)^k C^{k-1}_{k+r-\sum_{i=1}^k{n_i-(k+1)}}
$$
好长啊c

<!--more-->

本题套进去就行了。

本题重点在实现。

上式一共 $2^k$ 项，我们可以将它压缩成一个整数。

题目中的 $ s$  较大，我们可以用 $ lucas$ 定理搞一下。

由于
$$
 C^{n-1}_{n+m-1}= \frac{P^{n-1}_{n+m-1}}{(n-1)!}
$$
所以可先计算上式，然后用逆元搞一下，$\large n$ 很小，可以直接递推。

实现的时候注意每一项减去的值就行了。

```cpp 
#include<cstdio>
#include<iostream>
using namespace std;
#define ll long long
const ll p=1e9+7;
ll n, m, ans, f[22], inv[22];
ll C(ll y,ll x) {
    if(y<0||x<0||y<x) return 0;
    y%=p;
    if(!y||!x) return 1;
    ll i, z=1;
    for(i=0;i<x;++i) (z*=(y-i))%=p;
    for(i=1;i<=x;++i) (z*=inv[i])%=p;
    return z;
}
int main() {
    int i, x;
    inv[0]=inv[1]=1;
    for(i=2;i<=20;++i) inv[i]=((p-p/i))*inv[p%i]%p;
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;++i) scanf("%lld",&f[i]);
    for(x=0;x<1<<n;++x) {
        if(!x) (ans+=C(n+m-1,n-1))%=p;
        else {
            ll y=n+m, z=0;
            for(i=0;i<n;++i) if((x>>i)&1) ++z, y-=f[i+1];
            y-=z+1;
            if(z&1ll) (ans-=C(y,n-1))%=p; else (ans+=C(y,n-1))%=p;
        }
    }
    printf("%lld\n",(ans+p)%p);
}
```
