---
title: 洛谷2862 Corral the Cows 题解
urls: lg2862-solution
tags: 二分答案
categories: 题解
math: true
abbrlink: 45c7a00c
date: 2021-08-22 21:59:08
---

[link](https://www.luogu.com.cn/problem/P2862)

几个月前写的题解，来水了……

<!-- more -->


最小化满足条件的正方形边长，正方形边长具有单调性，显然二分答案。

坐标范围为 $[1,10000]$，明显开不下这么大的二维数组。并且 $n$ 很小，不离散化简直是浑身难受啊。

先对读入的数据进行离散化，然后求出二维前缀和。

最后二分一个 $mid$ 表示正方形边长为 $mid$ 是否能满足条件。

判断的时候枚举目标点的横纵坐标，用二维前缀和减去不在正方形内的部分，判断是否大于等于 $c$ 即可。

一定要注意枚举正方形时的边界问题，具体细节看代码。

```cpp 
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define R register
const int N=1010;
int c, n, m, cnt, b[N], s[N][N];
struct pt { int x, y; } a[510];
int f(int x) { return lower_bound(b+1,b+m+1,x)-b; }
bool c_(int w) {
    R int i, j, t;
    for(R int x1=1,x2=1;x1<=m;++x1) {
        for(;b[x2]-b[x1]+1<=w && x2<=m;++x2);
        --x2;
        for(R int y1=1,y2=1;y1<=m;++y1) {
            for(;b[y2]-b[y1]+1<=w && y2<=m;++y2);
            --y2;
            t=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
            if(t>=c) return 1;
        }
    }
    return 0;
}
int main() {
    R int i, j, x, y;
    for(scanf("%d%d",&c,&n),i=1;i<=n;++i) {
        scanf("%d%d",&x,&y);
        a[i]=(pt){x,y}, b[++cnt]=x, b[++cnt]=y;
    }
    sort(b+1,b+cnt+1);
    m=unique(b+1,b+cnt+1)-b-1;
    for(i=1;i<=n;++i) {
        ++s[f(a[i].x)][f(a[i].y)];
    }
    for(i=1;i<=m;++i) for(j=1;j<=m;++j)
        s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];   
    R int l=1, r=1e4, h;
    while(l<r) if(c_(h=l+r>>1)) r=h; else l=h+1;
    printf("%d",l);
}
```
