---
title: luogu2986 Great Cow Gathering 题解
urls: lg2986-solution
tags:
  - DP
  - 树形DP
categories: 题解
math: true
abbrlink: de24e156
date: 2021-08-22 21:57:48
---

[link](https://www.luogu.com.cn/problem/P2986)

设 $d(x)$ 为以 $x$ 为根的子树中所有的牛到达 $x$ 的代价，设 $V_x$ 为 $x$ 的子节点集。

称 $y \in V_x$，当且仅当有 $(x \rightarrow y)$ 的路径。

不妨将每个点的奶牛总数称为点权。

设 $ct(y)$ 为以 $y$ 为根的子树的点权和，$z$ 为 $(x \rightarrow y)$ 的长度。

<!-- more -->

转移是显然的
$$
d(x)=\sum_{y \in V_x} d(y)+z \times ct(y)
$$
然后考虑换根 DP。

设 $f(x)$ 为选择 $x$ 点的最小代价，令 $f(1)=d(1)$。

设 $S$ 为整棵树的点权和。

显然有
$$
f(y)=f(x)-ct(y) \times z + (S-ct(y)) \times z
$$

$$
f(y)=f(x)-(2 \times ct(y) \times z)+S \times z
$$

最后取
$$
\min_{1 \le x \le n}{\{ f(x) \}}
$$
实现上的问题只有子树的点权和无法方便计算，可以用一个变量记录 $(x \rightarrow y)$ 的每个 $y$ 子树点权和，再用另一个变量将它们累加，最后在遍历子节点后加上自身的点权就能求出完整的 $ct$ 数组。

具体看代码。

```cpp 
#include<cstdio>
#include<iostream>
using namespace std;
#define ll long long
const int N=1e5+10;
ll n, s, c[N];
ll ans=(1ll<<60), ct[N], d[N], f[N];
ll cnt, h[N], ver[N<<1], nxt[N<<1], w[N<<1];
bool v[N];
void add(ll x,ll y,ll z) { ver[++cnt]=y, w[cnt]=z, nxt[cnt]=h[x], h[x]=cnt; }
ll dp(ll x,ll fa) {
    ll res=0;
    for(int i=h[x];i;i=nxt[i]) if(ver[i]!=fa) {
       ll y=ver[i], z=w[i];
       ll o=dp(y,x);
       d[x]+=d[y]+z*o, res+=o;
    }
    return ct[x]=res+c[x];
}
void dfs(ll x,ll fa) {
    for(int i=h[x];i;i=nxt[i]) if(ver[i]!=fa) {
        y=ver[i], z=w[i];
        f[y]=f[x]-((ct[y]*z)<<1ll)+s*z;
        dfs(y,x);
    }
}
int main() {
    // freopen("data_\\P2986_8.in","r",stdin);
    scanf("%lld",&n);
    for(int i=1;i<=n;++i) scanf("%lld",&c[i]), s+=c[i];
    for(int i=1;i<n;++i) {
        ll x, y, z; scanf("%lld%lld%lld",&x,&y,&z);
        add(x,y,z), add(y,x,z);
    }
    dp(1,0);
    f[1]=d[1];
    dfs(1,0);
    for(int i=1;i<=n;++i) ans=min(ans,f[i]);
    printf("%lld\n",ans);
}
```
