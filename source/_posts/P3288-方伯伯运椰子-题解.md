---
title: luogu3288 方伯伯运椰子 题解
urls: lg3288-solution
tags:
  - 分数规划
  - 图论
  - SPFA
categories: 题解
math: true
abbrlink: 70b88a4b
date: 2021-08-19 19:50:24
---

[link](https://www.luogu.com.cn/problem/P3288)

写一篇不从网络流的角度考虑，单纯推式子的题解。

看到题目给出一张图并要求最大化
$$
 \frac{X-Y}{k}
$$
就可以确定本题的大致模型：分数规划和 SPFA 判负环。

<!-- more -->

每条路满负荷，这就意味着我们可以在「理想状态」下进行推导。

设第 $i$ 条边未修改是费用为 $x_i$，修改后费用为 $y_i$。

题目给出 $a_i,b_i,c_i,d_i$，不难想到
$$
 x_i = c_i \times d_i \implies X = \sum_{i=1}^m {c_i \times d_i}
$$
有两种操作

- 选择一条道路，将其进行一次压缩，这条道路的容量会下降 1 单位。
- 选择一条道路，将其进行一次扩容，这条道路的容量会上升 1 单位。

简单推导一下式子，易得当第 $i$ 条边进行压缩时
$$
 y_i= (c_i-1) \times d_i - a_i \implies Y= \sum_{i=1}^m { (c_i-1) \times d_i + a_i}
$$

进行扩容时
$$
 y_i = (c_i+1) \times d_i -b_i \implies Y= \sum_{i=1}^m { (c_i+1) \times d_i + b_i }
$$
我们令
$$
 \max{ \{ \frac{X-Y}{k} \} } = ans
$$
则
$$
\frac{X-Y}{k}  \large \le ans 
$$
$$
 X-Y  \le  \large ans \times k 
$$

$$
 ans \times k  + Y - X \ge \large 0
$$



而
$$
Y-X  =  \sum_{i=1}^m{y_i-x_i} = \sum_{i=1}^m {\left[(c_i-1) \times d_i + a_i \right]} - \sum_{i=1}^m{c_i \times d_i}\\
$$
$$
= \sum_{i=1}^m { (c_i \times d_i -d_i +a_i )-c_i \times d_i} = \sum_{i=1}^m {a_i-d_i} \\
$$

$$
 or 
$$

$$
 =\sum_{i=1}^m {\left[(c_i+1) \times d_i + b_i \right]} - \sum_{i=1}^m{c_i \times d_i} \\
$$

$$
 =\sum_{i=1}^m{(c_i \times d_i+ d_i +b_i)-c_i \times d_i}= \sum_{i=1}^m{b_i+d_i}
$$



若将 $y_i-x_i$  看作图上的边权，修改次数 $k$ 即为某个环上的边数。

所以我们二分一个 $dlt$，判断是否有负环，决定式子是否成立，则分数式又可化为
$$
dlt \times k + Y - X   \ge  0 \\
$$
$$
\sum_{i=1}^k y_i-x_i+dlt \ge  0
$$



由于有两种情况，所以建双向边。

因为原分数式中 $k$ 是分母，所以这个满足上式的 $dlt$ 应尽量小。

然后 SPFA 判负环就行。

若有负环，则不满足上式，令 $l=dlt$，反之则令 $r=dlt$。

&nbsp;

code

```cpp 
#include<bits/stdc++.h>
using namespace std;
#define R register
#define ll long long
const int N=5e4+10;
const double eps=1e-4;
int n, m;
int c, h[N], ver[N], nxt[N];
double g[N], d[N];
bool v[N];
void add(int x,int y,double z) { ver[++c]=y, g[c]=z, nxt[c]=h[x], h[x]=c; }
bool spfa(int x,double dlt) {
    R int i, y, z;
    v[x]=1;
    for(i=h[x];i;i=nxt[i]) {
        y=ver[i], z=g[i];
        if(d[y]>d[x]+z+dlt) {
            d[y]=d[x]+z+dlt;
            if(v[y]||spfa(y,dlt)) return 1;
        }
    }
    return v[x]=0;
}
bool C(double x) {
    memset(v,0,sizeof(v)), memset(d,0,sizeof(d));
    for(R int i=1;i<=n+2;++i) if(spfa(i,x)) return 1;
    return 0;
}
int main() {
    R int i, x, y, A, B, P, Q;
    R double l=0, r=0, mid;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;++i) {
        scanf("%d%d%d%d%d%d",&x,&y,&A,&B,&P,&Q);
        if(P) add(y,x,(double)(A-Q));
        add(x,y,(double)(B+Q));
        r+=A+B+(double)P*Q;
    }
    while(r-l>eps) {
        mid=(l+r)/2;
        if(C(mid)) l=mid; else r=mid;
    }
    printf("%.2lf",l);
}
```
