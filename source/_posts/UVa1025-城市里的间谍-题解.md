---
title: UVa1025 城市里的间谍 题解
urls: UVa1025-solution
tags: DP
categories: 题解
math: true
abbrlink: 356f905e
date: 2021-08-09 22:40:57
---

[link](https://www.luogu.com.cn/problem/UVA1025)

## solution

显然的，这是一道线性 DP 题。

而「时间」则是计算顺序。

题目要求求出最小等待时间，而转移「时间」这一状态与当前所处车站有关。

所以我们设 $f(i,j)$ 为 $i$ 时刻，在第 $j$ 个车站的最小等待时间。

<!-- more -->

显然我们有三种转移决策。

1. 在当前车站再等待一个时刻。
2. 乘坐向左的列车。
3. 乘坐向右的列车。

不难想到我们用一个数组 $v(i,j,k=0/1)$ 表示第 $i$ 个时刻的第 $j$ 个车站有无列车向左/右行驶。

设 $t(i)$ 为车站 $(i \rightarrow i+1)$ 和 $(i+1 \rightarrow i)$ 的时间。

那么转移为


$$
f(i,j)= \min\begin{cases}
f(i+1,j) +1
\\
f(i+t(j),j+1) \} 
\\
f(i+t(j-1),j-1) \} 
\end{cases}
$$


两式对应的条件分别为
$$
\begin{cases}
 v(i,j,0)=1,j<n,i+t(j) \le T
\\
 v(i,j,1)=1,j>1,i+t(j-1) \le T
\end{cases}
$$
~~我有一个优美的状态转移方程，可惜这里空太小，我写不下~~

边界 $f(T,n)=0$, $f(T,[1,n-1])= \infty$。

答案 $f(0,1)$。

由于是「自底向上」的递推方法，要注意 $i$ 要逆序循环，还有向左向右列车的能够转移的状态的差异。

对于无解的情况，只需要判断目标状态是否等于 $\infty$ 就可以。

还要注意 UVa 的奇怪输出格式。

## Code

```cpp 
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
#define R register
#define inf 0x3f3f3f3f
int n, T, t[55], f[255][55];
bool v[255][55][2];
inline int r_() { //快读  }
int main() {
    R int i, j, m1, m2, d, k=0;
    while(n=r_()) {
        T=r_();
        for(i=1;i<n;++i) t[i]=r_(), f[T][i]=inf;
        m1=r_();
        while(m1--) {
            d=r_();
            for(i=1;i<n;++i)
            { if(d<=T) v[d][i][0]=1; d+=t[i]; }
        }
        m2=r_();
        while(m2--) {
            d=r_();
            for(i=n-1;i;--i)
            { if(d<=T) v[d][i+1][1]=1; d+=t[i]; }
        }
        f[T][n]=0;
        for(i=T-1;i>=0;--i) for(j=1;j<=n;++j) {
            f[i][j]=f[i+1][j]+1;
            if(j<n&&v[i][j][0]&&i+t[j]<=T)
                f[i][j]=min(f[i][j],f[i+t[j]][j+1]);
            if(j>1&&v[i][j][1]&&i+t[j-1]<=T)
                f[i][j]=min(f[i][j],f[i+t[j-1]][j-1]);
        }
        printf("Case Number %d: ",++k);
        if(f[0][1]>=inf) puts("impossible"); else printf("%d\n",f[0][1]);
        memset(v,0,sizeof(v));
    }
}
```
