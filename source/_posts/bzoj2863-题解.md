---
title: bzoj2863 愤怒的元首 题解
urls: bzoj2863-solution
tags:
  - DAG
  - 容斥原理
categories: 题解
math: true
abbrlink: 2a5600b9
date: 2021-08-29 20:04:40
---

[link](https://darkbzoj.tk/problem/2863)

看到题目，就想起各种空耳了，~~我到河北省来~~（

大概意思是计算节点数为 $n$ 的 DAG 数量。

<!--more-->

考虑

- DAG 有入度为 0 的点。

- 若一张图是 DAG，那么去除入度为 0 的节点后，它仍然是 DAG。

设 $f(i)$ 为有 $i$ 个节点的 DAG 的数量，$g(i,j)$ 表示为有 $i$ 个节点的 DAG，**至少**有 $j$ 个入度为 0 的节点的方案数。

为什么是「至少」?

因为准确个数的方案难以计算，且这样可以构造容斥。

 $ C_i^j$ 表示 有 $i$ 个点的 DAG，任选 $j$ 个点，令其入度数是 0 的方案数。

这 $j$ 个点又可以向剩下 $ i-j$ 个点连边。

方案数 $j \times (i-j)$。

题目描述中又有这样一句话。

>Hint：基图不连通也是合法方案

说明也可以不连边。

方案数 $2^{j \times (i-j)} $。

又因为乘法原理，所以还要乘 $ f(i-j)$。
$$
g(i,j)=C_i^j \times 2^{j \times (i-j)} \times f(i-j)
$$
将其累加就能求出 $f$ 数组了吗？

显然不行的，前面提到了「至少」构造的容斥。

不难想到，如果 $j$ 个点有不连边的情况，那么可能会增加入度为 0 节点个数，而这些是被「强行」计算了的。

即 入度为 0 节点个数大于 $ j$ 的方案数在 $g(i,j)$ 中会被重复计算 $C^j_i$ 次。

可以容斥。
$$
f(i)=\sum_{j=1}^i{(-1)^{j-1} \times g(i,j) }
$$

$$
f(i)=\sum_{j=1}^i{(-1)^{j-1} \times C_i^j \times 2^{j \times (i-j)} \times f(i-j)}
$$

实现的时候可以用  $O(n)$ 的时间预处理阶乘、逆元和 2 的整数次幂。

```cpp 
#include<cstdio>
using namespace std;
#define ll long long
const int N=3006;
const ll p=1e9+7;
ll n, i, j, f[N], fac[N], inv[N], pw[N*N];
void init() {
    fac[1]=inv[0]=inv[1]=pw[0]=1;
    for(int i=2;i<=n;++i) {
        fac[i]=fac[i-1]*i%p;
        inv[i]=(p-p/i)*inv[p%i]%p;
    }
    for(int i=2;i<=n;++i) (inv[i]*=inv[i-1])%=p;
    for(int i=1;i<=n*n;++i) pw[i]=(pw[i-1]<<1)%p;
}
ll C(int n,int m) { return fac[n]*inv[m]%p*inv[n-m]%p; }
int main() {
    scanf("%lld",&n);
    init();
    f[0]=f[1]=1;
    for(int i=2;i<=n;++i) for(j=1;j<=i;++j)
        (f[i]+=(j&1? 1ll:-1ll)*C(i,j)*pw[j*(i-j)]%p*f[i-j]%p)%=p;
    printf("%lld\n",(f[n]+p)%p);
}
```
