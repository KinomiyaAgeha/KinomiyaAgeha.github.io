---
title: LOJ2652 Zap 题解
urls: loj2652-solution
tags:
  - 数论
  - 莫比乌斯函数
categories: 题解
math: true
abbrlink: 1f78871b
date: 2021-08-25 10:34:50
---

[link](https://loj.ac/p/2652)

题目要求等价于求满足 $ x \le a/k, y \le b/k$ 并且 $\gcd(x,y)=1$ 的二元组  $(x,y)$ 的数量。

<!--more-->

设 $g(a,b,k)$ 为满足 $ x\le a, y\le b$ 且  $k \mid \gcd(x,y)$ 的二元组 $ (x,y)$ 的数量，不难想到
$$
 g(a,b,k)=(\lfloor a/k \rfloor ) \times (\lfloor b/k \rfloor)
$$
由容斥原理，得由于 $ g(a,b,1)=a \times b$，比真正的答案多了 $ \gcd(x,y)$ 是 $2,3,5 \dots$ 的倍数的个数，所以要减去它们，即 $ g(a,b,2)$ 与 $g(a,b,3)$。

而减去后多减了 $ \gcd(x,y)$ 既是 $2$ 的倍数，又是 $3$ 的倍数的个数，即 $g(a,b,6)$，又要加上。以此类推，我们发现加减的关系正是 $ k$ 的莫比乌斯函数。

$ Mobios(x)$ 记为  \mu(x)$ 。

所以答案为
$$
f(a,b) = \sum_{i=1}^{\min{(a,b)}} \mu(i) \times g(a,b,i)
$$
由于
$$
\forall i \in \left[ x, \min(a/\lfloor a/x \rfloor \rfloor ,\lfloor b/ \lfloor b/x \rfloor  \rfloor)\right]
$$

$$
 g(a,b,i)=(\lfloor a/i \rfloor ) \times (\lfloor b/i \rfloor) \text{ 都相同}
$$

所以实现的时候求出 $ \mu(x)$ 的前缀和，直接处理一个区间的信息。

```cpp 
#include<cstdio>
#include<iostream>
using namespace std;
#define ll long long
const int N=5e4+10;
int n, a, b, k, Mobius[N];
bool v[N];
int sol() {
    int x, gx, ans=0;
    a/=k, b/=k;
    if(a>b) swap(a,b);
    for(x=1;x<=a;x=gx+1) {
        gx=min(a/(a/x),b/(b/x));
        ans+=(Mobius[gx]-Mobius[x-1])*(a/x)*(b/x);
    }
    return ans;
}
int main() {
    int i, j;
    for(i=1;i<=5e4;++i) Mobius[i]=1;
    for(i=2;i<=5e4;++i) if(!v[i]) {
        Mobius[i]=-1;
        for(j=(i<<1);j<=5e4;j+=i) {
            v[j]=1;
            if(j/i%i==0) Mobius[j]=0; else Mobius[j]*=-1;
        } 
    }
    for(i=1;i<=5e4;++i) Mobius[i]+=Mobius[i-1];
    scanf("%d",&n);
    while(n --> 0) {
        scanf("%d%d%d",&a,&b,&k);
        printf("%d\n",sol());
    }
}
```
