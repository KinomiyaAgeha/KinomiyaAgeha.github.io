---
title: luogu4778 Counting swaps 题解
urls: solution-lg4778
tags:
  - 组合数学
  - 容斥原理
categories: 题解
abbrlink: 18ee8bed
date: 2021-08-25 10:35:05
---

[link](https://www.luogu.com.cn/problem/P4778)

将给定的排列 $P=\{p_1,p_2, \dots p_k\}$ 中 $i$ 与 $p_i$ 连一条边，这样就构成了由若干个环构成的图。

而要求的就是把这张图变成 $k$ 个自环最少需要的操作次数。

<!-- more -->

设 $f(n)$ 为长度为 $n$ 的环变成若干个自环的最少需要的操作次数。

设 $g(n,x,y)$ 为长度为 $n$ 的环变成长度为  $x$ 与 $y$ 的两个环的方案数。

不难发现
$$
 g(n,x,y)=
\begin{cases}
\frac{n}{2} \quad \text{$n$ 是偶数且 $x=y$} \\
 n \quad \text{ $n$ 是奇数或 $x \neq y$}
\end{cases}
$$
而
$$
 f(n)=\sum_{x+y=n}{g(n,x,y) \times f(x) \times f(y) \times \frac{(n-2)!}{(x-1)!(y-1)!}}
$$
上式实际是
$$
\large \text{累加（方案数 $\times$ 操作方法数 $\times$ 多重集全排列）}
$$
通过奇怪的手段可以发现通项公式 $ f_n=n^{n-2}$ 。

这样我们就不必计算上式了。

设排列 $P$ 由长度为 $l_1,l_2,\dots l_k$ 的 $\large k$ 个环组成，那么答案为
$$
 (\prod_{1\le i \le k} {f(l_i)}) \times \frac{(n-k)!}{\prod_{1 \le i \le k}{(l_i-1)!}}
$$
后面的东西还是多重集全排列。

然后注意实现的细节就可以了。

```cpp 
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
#define ll long long
const int N=100010, P=1e9+9;
ll n, t, p[N], fac[N]={1ll};
bool v[N];
ll fp(ll x,ll y) {
    ll z=1;
    for(;y;x=x*x%P,y>>=1ll) if(y&1ll) z=z*x%P;
    return z;
}
int main() {
    ll i, j;
    for(i=1;i<=1e5;++i) fac[i]=fac[i-1]*i%P;
    scanf("%lld",&t);
    while(t --> 0) {
        scanf("%lld",&n);
        for(i=1;i<=n;++i) scanf("%lld",&p[i]), v[i]=0;
        int k=0;
        ll ans=1;
        for(i=1;i<=n;++i) if(!v[i]) {
            v[i]=1;
            ll dlt=1;
            for(j=p[i];j!=i;j=p[j]) v[j]=1, ++dlt;
            ++k;
            (ans*=(dlt==1? 1:fp(dlt,dlt-2)))%=P;
            (ans*=fp(fac[dlt-1],P-2))%=P;
        }
        printf("%lld\n",ans*fac[n-k]%P);
    }
}
```
