---
title: 树上问题α
urls: natsu-TRpr1
tags: 树上问题
categories: OI
math: true
abbrlink: 765081c6
date: 2021-08-07 22:53:46
---


树上问题可谓是老生常谈，家喻户晓了。凭着老少皆宜，童叟无欺，毒瘤遍地，常数离奇，复杂度迷等特点使 NOI 系列比赛出了很多奇葩树据结构题。

那么我们就开始吧！

设 $(x \rightarrow y)$ 为存在由节点 $x$ 到节点 $y$ 的路径。

<!--more-->

## 从最基本的 LCA 开始

此 LCA 非彼 lca（某候选队爷），但是相信大家都明白 LCA 到底是个什么，这里不做赘述。

你说，你会 LCA，那我便考你一考。。。

LCA，究竟是甚么意思啊？

不就是最近公共祖先吗，~~去 LOJ 看 lca 的头像啊~~。

对呀对呀！......LCA 有四种求法，你知道吗?

编不下去了。 QwQ

LCA 有倍增、树剖、Tarjan、欧拉序 $+$ RMQ 四种常见求法。

那么有人会问了：向上标记法呢？

呐。。请问各位写过它吗（

~~写过当我没说~~

咳咳，实际上是因为这个算法太过返璞归真，就跟解方程时遍历集合 $R$ 来求解类似。

而那四种多半都是对这个算法的优化。

倍增最好写，实质上是对向上标记法的倍增优化。就是

```cpp 
if(d[f[y][i]]>=d[x]) y=f[y][i]; // 一定要写大于等于啊！！！
```

或者写

```cpp 
for(i=0,j=dep[y]-dep[x];j;++i,j>>=1) if(j&1) y=f[y][i];
```



我在这里出错好多次了（暴露了我的菜。

倍增与树形 dp 非常相似，算法的流程简单明了。

设 $f(x,k)$ 为节点 $x$ 的第 $2^k$ 个祖先，显然转移为
$$
\large f(x,k)=f(f(x,k-1),k-1) \quad k \le log_2n
$$
在 DFS / BFS 预处理节点深度的时候可以顺便求出 $f$ 数组。

顺带一提 DFS / BFS 的同时还可以求出与每个节点到根的距离，然后求两点间的最小距离。实际应用时，应根据要预处理出的信息选择两种遍历方式，~~但还是 DFS 好写，用处更多~~。

查询的时候，对于点 $(x,y)$，将它们置于同一深度，然后。
$$
\text{You jump I jump!}
$$
通过 $k$ 递减顺序不断让 $(x,y)$ 往上 “跳”，比较祖先就行了。

 

复杂度为 

预处理 $O(n \times log_2n)$

单次查询 $O(log_2n)$

~~就是容易被卡~~

&nbsp;

Tarjan 同（du）志（liu）的算法是一个离线算法，实质上是对向上标记法的并查集优化。

但是实在是不常用，最起码我没在实际做题时用过。

Tarjan 同志的算法一向思路巧妙。

此算法将「访问完毕并且回溯的节点」标记为2，「访问了且尚未回溯的节点」标记为1，其余为0。同时开始时每个节点各自为一个集合。

用并查集维护「上一个回溯的父节点」。

但是我说不清楚。。很巧妙的算法，并且这位同志证明了每次查询为 $O(1)$。

预处理 $O(n)$。

处理询问 $O(n+m)$，$m$ 为询问个数。

就是常数有时比倍增还难看

在此不再赘述。

至于树剖和欧拉序 $+$ RMQ，我还没有系统地去学习，大概下一篇树上问题博客会说一下。



### 接着经典题走一波。

[Milk Visits](https://www.luogu.com.cn/problem/P5836)

累加每条路径的权，查询两件间距离时候大于0即可。

&nbsp;

[仓鼠找sugar](https://www.luogu.com.cn/problem/P3398)

设 $dis(x,y)$ 为 $(x \rightarrow y)$ 的最短路径长度。

如果 $(u \rightarrow v) $ 和 $(p \rightarrow q)$ 的最短路径相交，那么有
$$
\large dis(LCA(u,v),p)+dis(LCA(u,v),q)=dis(p,q)
$$
或者
$$
\large dis(LCA(p,q),u)+dis(LCA(p,q),v)=dis(u,v)
$$

&nbsp;

也就是有一条路径的 LCA 在另一条路径上。

稍加思索不难证明。

&nbsp;

[货车运输](https://www.luogu.com.cn/problem/P1967)

题目要求不超过限重，不难想到因该最大化每条路的限重。所以在原图上求出最大生成树。

那么对于点 $(x,y)$，如果在并查集中 $x$ 与 $y$ 不在同一个集合，则 $x$ 不能到达 $y$。

接下来就是每辆车最多运送的货物，不难想到最多运送的货物就是 $(x \rightarrow y)$ 路径上权值最小的边。

如果用朴素的算法去求最小的边权，那么复杂度会上天，$O(n)$。

联系我们对想上标记法的倍增优化，不难想到对求路径上最小的边权进行倍增优化。

设 $d(x,k)$ 为节点 $x$ 到它的 $2^k$ 辈祖先这条路径上最小的边权。

接着不难想到转移
$$
\large d(x,k)=\min{ \{ d(x,k-1),d(f(x,k-1),k-1) \} } \quad k \le log_2n
$$
可以在求 $f$ 数组的同时求出。

所以，在求 LCA 的过程中不断维护路径上最小的 $d(x,k)$。

这题毒瘤数据，给出的图不一定联通。

顺带一提，$d$ 数组是什么，怎么转移，在第一页且算法相同的题解中，只有神鱼讲到了。某些人直接一笔带过甚至完全没有提到过。

&nbsp;

[紧急集合 / 聚会](https://www.luogu.com.cn/problem/P4281)

三个点两两求出 LCA，三个点的深度减去它们 LCA 的深度就是答案2。

而三个点 LCA 中必定有两个点相同，那个不同的即为答案1。

至于证明。。画图是显然的，但是论述的话感觉很多思路都不是那么有说服力，就不献丑了，自己说的自己都不能完全信。

&nbsp;

[求和](https://www.luogu.com.cn/problem/P4427)

大概是 LCA+树上差分，但又没去差分，仅仅是用了它的思路。

由于指数范围较小，我们设 $g(x,k)$ 为根节点到节点 $x$ 路径上点权的 $k$ 次方和，在 DFS 时维护，设 $dep(x)$ 为节点 $x$ 的深度。不难想到转移
$$
\large g(x,k)=g(y,k)+(dep(x)-1)^k \quad (y \rightarrow x)
$$
这是建立在点上的，可以看作点权，求路径上的点权和。

我们知道，两点之间路径的点权和可以表示为
$$
\large ty(x)+ty(y)-ty(z)-ty(f(z,0)) \quad z=LCA(x,y)
$$
其中 $ty(x)$ 必须是根节点到 $x$ 点的点权和，画图不难证明。

所以这题就可以切了。
$$
\large g(x,k)+g(y,k)-g(z,k)-g(f(z,0),k) \quad z=LCA(x,y)
$$
注意要加上 $mod$ 的两倍，不然会当场去世（

同时，借着这题说一下树上差分。



## 树上差分

差分本是对序列的操作，是前缀和的逆运算。树上差分就是将树上点/边的区间操作转化为差分，用前缀和求出维护的信息。

大概就是这种思想，没啥可说的，通常与 LCA 结合。

&nbsp;

[暗的连锁](https://loj.ac/p/10131)

经典题目，显然加入非树边 $(x \rightarrow y )$ 之后会形成一个环，将树上 $(x \rightarrow y)$ 的边上任意一边斩断，再斩断非树边，就可以击败 Dark。

姑且称非树边 $(x \rightarrow y )$ 将将树上 $(x \rightarrow y)$ 的路径「覆盖」了一次，不难想到，如果树边 $(u \rightarrow v)$ 被「覆盖」了多于一次，那么无论如何都不存在合法的方式将 Dark 斩断。

同时不难想到，如果一条树边没有被「覆盖」，那么将其斩断后再任意斩断一条非树边就能达到目的。
这题差分的是边权，求子树边权和，仿照上题的叙述方式，则有
$$
\large ty(x)+ty(y)-ty(z)-ty(z) \quad z=LCA(x,y)
$$
是不是很像求两点间的距离？

所以开一个 $w$ 数组，如果有 $(x \rightarrow y)$，就令 
$$
w(x)+1,w(y)+1,w(z)-2 \quad z=LCA(x,y)
$$
通过 DFS 累加子树的 $w$，最后求出方案数即可。

&nbsp;

[Max Flow](https://www.luogu.com.cn/problem/P3128)

与上题的区别仅仅是 「差分的是点权，求最大子树边权和」，在累加差分数组 $w$ 时取每颗子树的最大值即可。

&nbsp;

[松鼠的新家](https://www.luogu.com.cn/problem/P3258)

差分的是点权，求每个点的访问次数。给出的访问顺序两两求出 LCA 并且差分，与前两题基本相同。

注意最后需要将访问顺序 $ w(a_i)-1 \quad 1 \le i \le n $ ，因为差分时会多加一次。

&nbsp;

[Putovanje](https://www.luogu.com.cn/problem/P6869)

稍加思索不难发现，为了最小化费用，第 $i$ 条边只能用单程票或多程票，并且取决于经过 $i$ 的次数。

题目要求按照编号大小访问，不难想到两个点间的最短路径必定经过其 LCA，所以在倍增求 LCA 的时候将路径差分，最后用一次 DFS 求出每条边的访问次数，即$g$ 数组。

然后取 $\min{ ( c_{x,1} \times g(x),c_{x,2} ) } $​​​，累加 $ans$​​​

&nbsp;

[Fools and Roads](https://www.luogu.com.cn/problem/CF191C)

题意很简单：有一颗 $n$ 个节点的树，$k$ 次旅行，问每一条边被走过的次数。

淼题，。，注意要按照边的顺序输出。

&nbsp;

[天天爱跑步](https://www.luogu.com.cn/problem/P1600)

有名的毒瘤题。

通过简单推式子与转化为树上区间问题来解决。

lyd 在他的蓝书中已经讲得很清楚了，~~懒得讲了~~，就不献丑了。



## 树的直径

通常意义上，直径为树上的最长链，可能有多条。

证明略，因为不知道问什么在 hexo 上报错。

两次 DFS / BFS 的思路都是相同的，都用到了「从一个节点出发能够到达的最远的节点一定是直径的一端」。

从任意节点出发记录最远能够到达的节点，它是直径的一端，再以它为起点记录最远能够到达的距离，显然那是另一端。

证明的话，写出的难度大于想到的难度，放个链接，[OI wiki](https://oi-wiki.org/graph/tree-diameter/)

复杂度是显然的。

树形 dp 能优美地求出直径长度，并且能处理负权的情况，缺点也很明显，即相较于纯粹的 DFS，后者能维护更多的信息且更好写。但是 DFS / BFS 无法处理有负权的情况。

[核心城市](https://www.luogu.com.cn/problem/P5536)

题目要求 $k$ 座城市建到一条链上。最小化最大距离，很容易想到是直径。

所以两次 DFS 求出直径，在第二次 DFS 时标记出直径上的父子关系，然后求出直径中点。

以直径中点为起点进行 DFS，求出每个从每个节点以它为根的深度和出发能够到达的最大深度。

然后将求出的最大深度与原来在树中的深度相减再+1。

最后将得到的数组排序，取第 $k+1$ 大的值即可。

&nbsp;

删掉了一题，过不了 hexo。

----

&nbsp;

不写了，再写就猝死了 Orz

直径还有好多题，以后看情况写吧。

接下来会把做题中心转到 DP 与数学上。

